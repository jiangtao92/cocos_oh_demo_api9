console.log('pptest importing cc 1');
System.register(['./instantiated-1af0bf5b.js'], function (exports) {
    'use strict';
    var ScalableContainer, Pool, RecyclePool, GFXObject, ObjectType, DESCRIPTOR_BUFFER_TYPE, DESCRIPTOR_SAMPLER_TYPE, BufferUsageBit, MemoryUsageBit, BufferFlagBit, CommandBufferType, SurfaceTransform, DrawInfo, murmurhash2_32_gc, QueueType, GlobalBarrierInfo, TextureBarrierInfo, Status, API, Feature, Format, FormatType, Type$1, MemoryAccessBit, TextureType, TextureUsageBit, TextureFlagBit, SampleCount, VsyncMode, Filter, Address, ComparisonFunc, StencilOp, BlendFactor, BlendOp, ColorMask, ShaderStageFlagBit, LoadOp, StoreOp, AccessType, ResolveMode, PipelineBindPoint, PrimitiveMode, PolygonMode, ShadeModel, CullMode, DynamicStateFlagBit, StencilFace, DescriptorType, QueryType, ClearFlagBit, Size, DeviceCaps, Offset, Rect, Extent, TextureSubresLayers, TextureSubresRange, TextureCopy, TextureBlit, BufferTextureCopy, Viewport, Color, BindingMappingInfo, SwapchainInfo, DeviceInfo, BufferInfo, BufferViewInfo, DispatchInfo, IndirectBuffer, TextureInfo, TextureViewInfo, SamplerInfo, Uniform, UniformBlock, UniformSamplerTexture, UniformSampler, UniformTexture, UniformStorageImage, UniformStorageBuffer, UniformInputAttachment, ShaderStage, Attribute, ShaderInfo, InputAssemblerInfo, ColorAttachment, DepthStencilAttachment, SubpassInfo, SubpassDependency, RenderPassInfo, FramebufferInfo, DescriptorSetLayoutBinding, DescriptorSetLayoutInfo, DescriptorSetInfo, PipelineLayoutInfo, InputState, CommandBufferInfo, QueueInfo, QueryPoolInfo, FormatInfo, MemoryStatus, DynamicStencilStates, DynamicStates, AttributeName, FormatInfos, DESCRIPTOR_DYNAMIC_TYPE, DRAW_INFO_SIZE, IsPowerOf2, FormatSize, FormatSurfaceSize, GetTypeSize, getTypedArrayConstructor, Device, Texture, Sampler, BlendTarget$1, BlendState$2, RasterizerState$1, DepthStencilState$1, PipelineState$1, PipelineStateInfo, UniformProxyFactory, MorphWeightValueProxy, MorphWeightsValueProxy, MorphWeightsAllValueProxy, Track, TrackPath, RealTrack, VectorTrack, QuatTrack, ColorTrack, SizeTrack, ObjectTrack, isPropertyPath, isCustomPath, HierarchyPath, ComponentPath, CubicSplineVec2Value, CubicSplineVec3Value, CubicSplineVec4Value, CubicSplineQuatValue, CubicSplineNumberValue, AnimationController, VariableType, StateMachineComponent, errorID, debug, error, nextPow2, systemInfo, OS, BrowserType, WECHAT, macro, EDITOR, warnID, warn, legacyCC, readBuffer, Vec3, writeBuffer, Mesh, BufferBlob, find, mapBuffer, Model, Enum, ccclass, _applyDecoratedDescriptor, editable, type$1, executeInEditMode, disallowAnimation, serializable, Vec4, help, executionOrder, menu$1, tooltip, visible, RenderableComponent, _initializerDefineProperty, assertIsTrue, TransformBit, builtinResMgr, formerlySerializedAs, Mat4, removeProperty, js, LightType, slide, range, Component, Light$1, Color$1, property$1, DirectionalLight$1, Camera, nt2lm, SphereLight$1, toRadian, SpotLight$1, replaceProperty, Quat, AABB, TextureBufferPool, getWorldTransformUntilRoot, SkelAnimDataHub, UBOSkinningAnimation, ModelType, NativeSkinningModel, deleteTransform, getTransform, getWorldMatrix, BatchingSchemes, UBOSkinning, NativeBakedSkinningModel, UBOSkinningTexture, UNIFORM_JOINT_TEXTURE_BINDING, INST_JOINT_ANIM_INFO, Skeleton$1, Node, Material, CCString, override, Vec2, Texture2D, Filter$1, PixelFormat, AnimationState$2, Animation$3, Asset, ImageAsset, Rect$1, Size$1, createMap, _getClassId, string, extname, mixin, Pool$1, director, Director, disallowMultiple, NodeEventType, displayOrder, visibleRect, ccenum, requireComponent, displayName, NodeUIProperties, multiline, TextureBase, RenderingSubMesh, NodeEventProcessor, clamp$1, CCObject, MaterialInstance, RenderTexture, Camera$1, view, screen, markAsWarning, RenderPriority, Layers, NativeDrawBatch2D, Pass, clampf, addon, logID, input, Input, DispatcherEventType, pointerEvent2SystemEvent, InputEventType, sys, ModelLocalBindings, UBOLocal, downloader, factory, EventHandler, rangeMin, rangeMax, lerp, game, contains, screenAdapter, KeyCode, MINIGAME, OPEN_HARMONY, RUNTIME_BASED, clamp01, EventTouch, SystemEventType, Event, Scene, editorOnly, array, View, toDegree, RealCurve, AnimationCurve, constructLegacyCurveAndConvert, WrapMode, repeat$2, pseudoRandom, random, randomRange, randomRangeInt, sign$1, radian, pingPong, INT_MAX, intersect, instantiate, cylinder, applyDefaultGeometryOptions, box, plane, capsule, bt, PhysicsSystem, PhysicsGroup$1, ERigidBodyType, fastRemoveAt, EColliderType, VEC3_0, absolute, absMaxComponent, absMax, Game, selector, createCommonjsModule, commonjsGlobal, unwrapExports, remove, Eventify, CollisionMatrix, System, _decorator, preTransforms, degreesToRadians, radiansToDegrees, getError, playOnFocus, assetManager, changeBasename, EventTarget, log, mat4, easing, engineVersion, TERRAIN_BLOCK_VERTEX_SIZE, TERRAIN_BLOCK_VERTEX_COMPLEXITY, TERRAIN_BLOCK_TILE_COMPLEXITY, TerrainAsset, EffectAsset, CCBoolean, CCFloat, TERRAIN_MAX_LAYER_COUNT, isValid, TerrainLayerInfo, PipelineEventType, TERRAIN_HEIGHT_FMAX, TERRAIN_HEIGHT_FMIN, TERRAIN_HEIGHT_BASE, TERRAIN_HEIGHT_FACTORY, TERRAIN_MAX_BLEND_LAYERS, TERRAIN_DATA_VERSION5, SAXParser, CCInteger, TextAsset, CCClass, Scheduler, setClassAlias;
    return {
        setters: [function (module) {
            ScalableContainer = module.S;
            Pool = module.P;
            RecyclePool = module.R;
            GFXObject = module.G;
            ObjectType = module.O;
            DESCRIPTOR_BUFFER_TYPE = module.D;
            DESCRIPTOR_SAMPLER_TYPE = module.a;
            BufferUsageBit = module.B;
            MemoryUsageBit = module.M;
            BufferFlagBit = module.b;
            CommandBufferType = module.C;
            SurfaceTransform = module.c;
            DrawInfo = module.d;
            murmurhash2_32_gc = module.m;
            QueueType = module.Q;
            GlobalBarrierInfo = module.e;
            TextureBarrierInfo = module.T;
            Status = module.f;
            API = module.A;
            Feature = module.F;
            Format = module.g;
            FormatType = module.h;
            Type$1 = module.i;
            MemoryAccessBit = module.j;
            TextureType = module.k;
            TextureUsageBit = module.l;
            TextureFlagBit = module.n;
            SampleCount = module.o;
            VsyncMode = module.V;
            Filter = module.p;
            Address = module.q;
            ComparisonFunc = module.r;
            StencilOp = module.s;
            BlendFactor = module.t;
            BlendOp = module.u;
            ColorMask = module.v;
            ShaderStageFlagBit = module.w;
            LoadOp = module.L;
            StoreOp = module.x;
            AccessType = module.y;
            ResolveMode = module.z;
            PipelineBindPoint = module.E;
            PrimitiveMode = module.H;
            PolygonMode = module.I;
            ShadeModel = module.J;
            CullMode = module.K;
            DynamicStateFlagBit = module.N;
            StencilFace = module.U;
            DescriptorType = module.W;
            QueryType = module.X;
            ClearFlagBit = module.Y;
            Size = module.Z;
            DeviceCaps = module._;
            Offset = module.$;
            Rect = module.a0;
            Extent = module.a1;
            TextureSubresLayers = module.a2;
            TextureSubresRange = module.a3;
            TextureCopy = module.a4;
            TextureBlit = module.a5;
            BufferTextureCopy = module.a6;
            Viewport = module.a7;
            Color = module.a8;
            BindingMappingInfo = module.a9;
            SwapchainInfo = module.aa;
            DeviceInfo = module.ab;
            BufferInfo = module.ac;
            BufferViewInfo = module.ad;
            DispatchInfo = module.ae;
            IndirectBuffer = module.af;
            TextureInfo = module.ag;
            TextureViewInfo = module.ah;
            SamplerInfo = module.ai;
            Uniform = module.aj;
            UniformBlock = module.ak;
            UniformSamplerTexture = module.al;
            UniformSampler = module.am;
            UniformTexture = module.an;
            UniformStorageImage = module.ao;
            UniformStorageBuffer = module.ap;
            UniformInputAttachment = module.aq;
            ShaderStage = module.ar;
            Attribute = module.as;
            ShaderInfo = module.at;
            InputAssemblerInfo = module.au;
            ColorAttachment = module.av;
            DepthStencilAttachment = module.aw;
            SubpassInfo = module.ax;
            SubpassDependency = module.ay;
            RenderPassInfo = module.az;
            FramebufferInfo = module.aA;
            DescriptorSetLayoutBinding = module.aB;
            DescriptorSetLayoutInfo = module.aC;
            DescriptorSetInfo = module.aD;
            PipelineLayoutInfo = module.aE;
            InputState = module.aF;
            CommandBufferInfo = module.aG;
            QueueInfo = module.aH;
            QueryPoolInfo = module.aI;
            FormatInfo = module.aJ;
            MemoryStatus = module.aK;
            DynamicStencilStates = module.aL;
            DynamicStates = module.aM;
            AttributeName = module.aN;
            FormatInfos = module.aO;
            DESCRIPTOR_DYNAMIC_TYPE = module.aP;
            DRAW_INFO_SIZE = module.aQ;
            IsPowerOf2 = module.aR;
            FormatSize = module.aS;
            FormatSurfaceSize = module.aT;
            GetTypeSize = module.aU;
            getTypedArrayConstructor = module.aV;
            Device = module.aW;
            Texture = module.aX;
            Sampler = module.aY;
            BlendTarget$1 = module.aZ;
            BlendState$2 = module.a_;
            RasterizerState$1 = module.a$;
            DepthStencilState$1 = module.b0;
            PipelineState$1 = module.b1;
            PipelineStateInfo = module.b2;
            UniformProxyFactory = module.b3;
            MorphWeightValueProxy = module.b4;
            MorphWeightsValueProxy = module.b5;
            MorphWeightsAllValueProxy = module.b6;
            Track = module.b7;
            TrackPath = module.b8;
            RealTrack = module.b9;
            VectorTrack = module.ba;
            QuatTrack = module.bb;
            ColorTrack = module.bc;
            SizeTrack = module.bd;
            ObjectTrack = module.be;
            isPropertyPath = module.bf;
            isCustomPath = module.bg;
            HierarchyPath = module.bh;
            ComponentPath = module.bi;
            CubicSplineVec2Value = module.bj;
            CubicSplineVec3Value = module.bk;
            CubicSplineVec4Value = module.bl;
            CubicSplineQuatValue = module.bm;
            CubicSplineNumberValue = module.bn;
            AnimationController = module.bo;
            VariableType = module.bp;
            StateMachineComponent = module.bq;
            errorID = module.br;
            debug = module.bs;
            error = module.bt;
            nextPow2 = module.bu;
            systemInfo = module.bv;
            OS = module.bw;
            BrowserType = module.bx;
            WECHAT = module.by;
            macro = module.bz;
            EDITOR = module.bA;
            warnID = module.bB;
            warn = module.bC;
            legacyCC = module.bD;
            readBuffer = module.bE;
            Vec3 = module.bF;
            writeBuffer = module.bG;
            Mesh = module.bH;
            BufferBlob = module.bI;
            find = module.bJ;
            mapBuffer = module.bK;
            Model = module.bL;
            Enum = module.bM;
            ccclass = module.bN;
            _applyDecoratedDescriptor = module.bO;
            editable = module.bP;
            type$1 = module.bQ;
            executeInEditMode = module.bR;
            disallowAnimation = module.bS;
            serializable = module.bT;
            Vec4 = module.bU;
            help = module.bV;
            executionOrder = module.bW;
            menu$1 = module.bX;
            tooltip = module.bY;
            visible = module.bZ;
            RenderableComponent = module.b_;
            _initializerDefineProperty = module.b$;
            assertIsTrue = module.c0;
            TransformBit = module.c1;
            builtinResMgr = module.c2;
            formerlySerializedAs = module.c3;
            Mat4 = module.c4;
            removeProperty = module.c5;
            js = module.c6;
            LightType = module.c7;
            slide = module.c8;
            range = module.c9;
            Component = module.ca;
            Light$1 = module.cb;
            Color$1 = module.cc;
            property$1 = module.cd;
            DirectionalLight$1 = module.ce;
            Camera = module.cf;
            nt2lm = module.cg;
            SphereLight$1 = module.ch;
            toRadian = module.ci;
            SpotLight$1 = module.cj;
            replaceProperty = module.ck;
            Quat = module.cl;
            AABB = module.cm;
            TextureBufferPool = module.cn;
            getWorldTransformUntilRoot = module.co;
            SkelAnimDataHub = module.cp;
            UBOSkinningAnimation = module.cq;
            ModelType = module.cr;
            NativeSkinningModel = module.cs;
            deleteTransform = module.ct;
            getTransform = module.cu;
            getWorldMatrix = module.cv;
            BatchingSchemes = module.cw;
            UBOSkinning = module.cx;
            NativeBakedSkinningModel = module.cy;
            UBOSkinningTexture = module.cz;
            UNIFORM_JOINT_TEXTURE_BINDING = module.cA;
            INST_JOINT_ANIM_INFO = module.cB;
            Skeleton$1 = module.cC;
            Node = module.cD;
            Material = module.cE;
            CCString = module.cF;
            override = module.cG;
            Vec2 = module.cH;
            Texture2D = module.cI;
            Filter$1 = module.cJ;
            PixelFormat = module.cK;
            AnimationState$2 = module.cL;
            Animation$3 = module.cM;
            Asset = module.cN;
            ImageAsset = module.cO;
            Rect$1 = module.cP;
            Size$1 = module.cQ;
            createMap = module.cR;
            _getClassId = module.cS;
            string = module.cT;
            extname = module.cU;
            mixin = module.cV;
            Pool$1 = module.cW;
            director = module.cX;
            Director = module.cY;
            disallowMultiple = module.cZ;
            NodeEventType = module.c_;
            displayOrder = module.c$;
            visibleRect = module.d0;
            ccenum = module.d1;
            requireComponent = module.d2;
            displayName = module.d3;
            NodeUIProperties = module.d4;
            multiline = module.d5;
            TextureBase = module.d6;
            RenderingSubMesh = module.d7;
            NodeEventProcessor = module.d8;
            clamp$1 = module.d9;
            CCObject = module.da;
            MaterialInstance = module.db;
            RenderTexture = module.dc;
            Camera$1 = module.dd;
            view = module.de;
            screen = module.df;
            markAsWarning = module.dg;
            RenderPriority = module.dh;
            Layers = module.di;
            NativeDrawBatch2D = module.dj;
            Pass = module.dk;
            clampf = module.dl;
            addon = module.dm;
            logID = module.dn;
            input = module.dp;
            Input = module.dq;
            DispatcherEventType = module.dr;
            pointerEvent2SystemEvent = module.ds;
            InputEventType = module.dt;
            sys = module.du;
            ModelLocalBindings = module.dv;
            UBOLocal = module.dw;
            downloader = module.dx;
            factory = module.dy;
            EventHandler = module.dz;
            rangeMin = module.dA;
            rangeMax = module.dB;
            lerp = module.dC;
            game = module.dD;
            contains = module.dE;
            screenAdapter = module.dF;
            KeyCode = module.dG;
            MINIGAME = module.dH;
            OPEN_HARMONY = module.dI;
            RUNTIME_BASED = module.dJ;
            clamp01 = module.dK;
            EventTouch = module.dL;
            SystemEventType = module.dM;
            Event = module.dN;
            Scene = module.dO;
            editorOnly = module.dP;
            array = module.dQ;
            View = module.dR;
            toDegree = module.dS;
            RealCurve = module.dT;
            AnimationCurve = module.dU;
            constructLegacyCurveAndConvert = module.dV;
            WrapMode = module.dW;
            repeat$2 = module.dX;
            pseudoRandom = module.dY;
            random = module.dZ;
            randomRange = module.d_;
            randomRangeInt = module.d$;
            sign$1 = module.e0;
            radian = module.e1;
            pingPong = module.e2;
            INT_MAX = module.e3;
            intersect = module.e4;
            instantiate = module.e5;
            cylinder = module.e6;
            applyDefaultGeometryOptions = module.e7;
            box = module.e8;
            plane = module.e9;
            capsule = module.ea;
            bt = module.eb;
            PhysicsSystem = module.ec;
            PhysicsGroup$1 = module.ed;
            ERigidBodyType = module.ee;
            fastRemoveAt = module.ef;
            EColliderType = module.eg;
            VEC3_0 = module.eh;
            absolute = module.ei;
            absMaxComponent = module.ej;
            absMax = module.ek;
            Game = module.el;
            selector = module.em;
            createCommonjsModule = module.en;
            commonjsGlobal = module.eo;
            unwrapExports = module.ep;
            remove = module.eq;
            Eventify = module.er;
            CollisionMatrix = module.es;
            System = module.et;
            _decorator = module.eu;
            preTransforms = module.ev;
            degreesToRadians = module.ew;
            radiansToDegrees = module.ex;
            getError = module.ey;
            playOnFocus = module.ez;
            assetManager = module.eA;
            changeBasename = module.eB;
            EventTarget = module.eC;
            log = module.eD;
            mat4 = module.eE;
            easing = module.eF;
            engineVersion = module.eG;
            TERRAIN_BLOCK_VERTEX_SIZE = module.eH;
            TERRAIN_BLOCK_VERTEX_COMPLEXITY = module.eI;
            TERRAIN_BLOCK_TILE_COMPLEXITY = module.eJ;
            TerrainAsset = module.eK;
            EffectAsset = module.eL;
            CCBoolean = module.eM;
            CCFloat = module.eN;
            TERRAIN_MAX_LAYER_COUNT = module.eO;
            isValid = module.eP;
            TerrainLayerInfo = module.eQ;
            PipelineEventType = module.eR;
            TERRAIN_HEIGHT_FMAX = module.eS;
            TERRAIN_HEIGHT_FMIN = module.eT;
            TERRAIN_HEIGHT_BASE = module.eU;
            TERRAIN_HEIGHT_FACTORY = module.eV;
            TERRAIN_MAX_BLEND_LAYERS = module.eW;
            TERRAIN_DATA_VERSION5 = module.eX;
            SAXParser = module.eY;
            CCInteger = module.eZ;
            TextAsset = module.e_;
            CCClass = module.e$;
            Scheduler = module.f0;
            setClassAlias = module.f1;
            var _setter = {};
            _setter.Acceleration = module.gN;
            _setter.AffineTransform = module.fb;
            _setter.AnimCurve = module.gx;
            _setter.Animation = module.cM;
            _setter.AnimationClip = module.gt;
            _setter.AnimationComponent = module.cM;
            _setter.AnimationManager = module.gB;
            _setter.AnimationState = module.cL;
            _setter.Asset = module.cN;
            _setter.AssetLibrary = module.gf;
            _setter.AssetManager = module.gb;
            _setter.BaseNode = module.gh;
            _setter.BitMask = module.fp;
            _setter.BloomStage = module.g8;
            _setter.BoxCollider = module.gX;
            _setter.BoxColliderComponent = module.gX;
            _setter.BufferAsset = module.fG;
            _setter.CCBoolean = module.eM;
            _setter.CCClass = module.e$;
            _setter.CCFloat = module.eN;
            _setter.CCInteger = module.eZ;
            _setter.CCLoader = module.gd;
            _setter.CCObject = module.da;
            _setter.CCString = module.cF;
            _setter.Camera = module.dd;
            _setter.CameraComponent = module.dd;
            _setter.CapsuleCollider = module.gZ;
            _setter.CapsuleColliderComponent = module.gZ;
            _setter.Collider = module.gW;
            _setter.ColliderComponent = module.gW;
            _setter.Color = module.cc;
            _setter.CompactValueTypeArray = module.fC;
            _setter.Component = module.ca;
            _setter.ComponentModifier = module.gn;
            _setter.ConeCollider = module.h0;
            _setter.ConstantForce = module.gT;
            _setter.Constraint = module.h4;
            _setter.CubicSplineNumberValue = module.bn;
            _setter.CubicSplineQuatValue = module.bm;
            _setter.CubicSplineVec2Value = module.bj;
            _setter.CubicSplineVec3Value = module.bk;
            _setter.CubicSplineVec4Value = module.bl;
            _setter.CurveValueAdapter = module.go;
            _setter.CylinderCollider = module.g$;
            _setter.CylinderColliderComponent = module.g$;
            _setter.DebugMode = module.fS;
            _setter.DeferredPipeline = module.g4;
            _setter.Details = module.fA;
            _setter.Director = module.cY;
            _setter.EAxisDirection = module.h7;
            _setter.EPSILON = module.ff;
            _setter.ERigidBodyType = module.ee;
            _setter.EffectAsset = module.eL;
            _setter.Enum = module.bM;
            _setter.Event = module.dN;
            _setter.EventAcceleration = module.gK;
            _setter.EventHandler = module.dz;
            _setter.EventInfo = module.gy;
            _setter.EventKeyboard = module.gL;
            _setter.EventMouse = module.gM;
            _setter.EventTarget = module.eC;
            _setter.EventTouch = module.dL;
            _setter.Eventify = module.er;
            _setter.ExtrapolationMode = module.gE;
            _setter.ForwardFlow = module.f$;
            _setter.ForwardPipeline = module.f_;
            _setter.ForwardStage = module.g1;
            _setter.Game = module.el;
            _setter.GbufferStage = module.g6;
            _setter.HierachyModifier = module.gm;
            _setter.HingeConstraint = module.h5;
            _setter.ImageAsset = module.cO;
            _setter.Input = module.dq;
            _setter.InstancedBuffer = module.fX;
            _setter.JavaScript = module.fM;
            _setter.JsonAsset = module.fJ;
            _setter.KeyCode = module.dG;
            _setter.Layers = module.di;
            _setter.LightingStage = module.g7;
            _setter.MATH_FLOAT_ARRAY = module.fn;
            _setter.MainFlow = module.g5;
            _setter.Mat3 = module.fa;
            _setter.Mat4 = module.c4;
            _setter.Material = module.cE;
            _setter.MathBase = module.fo;
            _setter.Mesh = module.bH;
            _setter.MeshCollider = module.g_;
            _setter.MeshColliderComponent = module.g_;
            _setter.MissingScript = module.gk;
            _setter.Node = module.cD;
            _setter.NodeActivator = module.gi;
            _setter.NodePool = module.gJ;
            _setter.ObjectCurve = module.gI;
            _setter.PhysicMaterial = module.gU;
            _setter.PhysicsMaterial = module.gU;
            _setter.PhysicsRayResult = module.gV;
            _setter.PhysicsSystem = module.ec;
            _setter.PipelineEventProcessor = module.ga;
            _setter.PipelineEventType = module.eR;
            _setter.PipelineStateManager = module.fY;
            _setter.PlaneCollider = module.h3;
            _setter.PointToPointConstraint = module.h6;
            _setter.Pool = module.P;
            _setter.PostProcessStage = module.g9;
            _setter.Prefab = module.fH;
            _setter.PrefabLink = module.fu;
            _setter.PrivateNode = module.gj;
            _setter.Quat = module.cl;
            _setter.QuatCurve = module.gG;
            _setter.QuatInterpolationMode = module.gH;
            _setter.RatioSampler = module.gw;
            _setter.RealCurve = module.dT;
            _setter.RealInterpolationMode = module.gD;
            _setter.Rect = module.cP;
            _setter.RecyclePool = module.R;
            _setter.RenderFlow = module.fV;
            _setter.RenderPipeline = module.fU;
            _setter.RenderQueueDesc = module.g3;
            _setter.RenderStage = module.fW;
            _setter.RenderTexture = module.dc;
            _setter.RenderableComponent = module.b_;
            _setter.RenderingSubMesh = module.d7;
            _setter.ResolutionPolicy = module.fT;
            _setter.RigidBody = module.gS;
            _setter.RigidBodyComponent = module.gS;
            _setter.Scene = module.dO;
            _setter.SceneAsset = module.fI;
            _setter.Scheduler = module.f0;
            _setter.Script = module.fL;
            _setter.ShadowFlow = module.g0;
            _setter.ShadowStage = module.g2;
            _setter.SimplexCollider = module.h2;
            _setter.Size = module.cQ;
            _setter.SkelAnimDataHub = module.cp;
            _setter.Skeleton = module.cC;
            _setter.SphereCollider = module.gY;
            _setter.SphereColliderComponent = module.gY;
            _setter.System = module.et;
            _setter.SystemEvent = module.gP;
            _setter.SystemEventType = module.dM;
            _setter.TERRAIN_BLOCK_TILE_COMPLEXITY = module.eJ;
            _setter.TERRAIN_BLOCK_VERTEX_COMPLEXITY = module.eI;
            _setter.TERRAIN_BLOCK_VERTEX_SIZE = module.eH;
            _setter.TERRAIN_DATA_VERSION = module.hd;
            _setter.TERRAIN_DATA_VERSION2 = module.he;
            _setter.TERRAIN_DATA_VERSION3 = module.hf;
            _setter.TERRAIN_DATA_VERSION4 = module.hg;
            _setter.TERRAIN_DATA_VERSION5 = module.eX;
            _setter.TERRAIN_DATA_VERSION_DEFAULT = module.hh;
            _setter.TERRAIN_EAST_INDEX = module.hc;
            _setter.TERRAIN_HEIGHT_BASE = module.eU;
            _setter.TERRAIN_HEIGHT_FACTORY = module.eV;
            _setter.TERRAIN_HEIGHT_FMAX = module.eS;
            _setter.TERRAIN_HEIGHT_FMIN = module.eT;
            _setter.TERRAIN_MAX_BLEND_LAYERS = module.eW;
            _setter.TERRAIN_MAX_LAYER_COUNT = module.eO;
            _setter.TERRAIN_MAX_LEVELS = module.h8;
            _setter.TERRAIN_NORTH_INDEX = module.h9;
            _setter.TERRAIN_SOUTH_INDEX = module.ha;
            _setter.TERRAIN_WEST_INDEX = module.hb;
            _setter.TangentWeightMode = module.gF;
            _setter.TerrainAsset = module.eK;
            _setter.TerrainCollider = module.h1;
            _setter.TerrainLayerBinaryInfo = module.hi;
            _setter.TerrainLayerInfo = module.eQ;
            _setter.TextAsset = module.e_;
            _setter.Texture2D = module.cI;
            _setter.TextureCube = module.fK;
            _setter.Touch = module.gO;
            _setter.TypeScript = module.fN;
            _setter.UniformCurveValueAdapter = module.gp;
            _setter.VERSION = module.eG;
            _setter.ValueType = module.fq;
            _setter.Vec2 = module.cH;
            _setter.Vec3 = module.bF;
            _setter.Vec4 = module.bU;
            _setter.View = module.dR;
            _setter.WorldNode3DToLocalNodeUI = module.fw;
            _setter.WorldNode3DToWorldNodeUI = module.fx;
            _setter._decorator = module.eu;
            _setter.absMax = module.ek;
            _setter.absMaxComponent = module.ej;
            _setter.approx = module.fh;
            _setter.assert = module.fO;
            _setter.assertID = module.fP;
            _setter.assetManager = module.eA;
            _setter.bezier = module.gu;
            _setter.bezierByTime = module.gv;
            _setter.bits = module.f5;
            _setter.builtinResMgr = module.c2;
            _setter.ccenum = module.d1;
            _setter.cclegacy = module.bD;
            _setter.clamp = module.d9;
            _setter.clamp01 = module.dK;
            _setter.color = module.fe;
            _setter.computeRatioByType = module.gA;
            _setter.convertUtils = module.fy;
            _setter.createDefaultPipeline = module.fZ;
            _setter.debug = module.bs;
            _setter.deserialize = module.fz;
            _setter.deserializeTag = module.fE;
            _setter.director = module.cX;
            _setter.easing = module.eF;
            _setter.editorExtrasTag = module.fD;
            _setter.effects = module.gl;
            _setter.enumerableProps = module.fm;
            _setter.equals = module.fg;
            _setter.error = module.bt;
            _setter.errorID = module.br;
            _setter.find = module.bJ;
            _setter.game = module.dD;
            _setter.geometry = module.f4;
            _setter.getError = module.ey;
            _setter.getPathFromRoot = module.gC;
            _setter.getSerializationMetadata = module.fB;
            _setter.getWorldTransformUntilRoot = module.co;
            _setter.input = module.dp;
            _setter.instantiate = module.e5;
            _setter.inverseLerp = module.fl;
            _setter.isCustomTargetModifier = module.gs;
            _setter.isDisplayStats = module.fQ;
            _setter.isElementModifier = module.gr;
            _setter.isPropertyModifier = module.gq;
            _setter.isValid = module.eP;
            _setter.js = module.fr;
            _setter.lerp = module.dC;
            _setter.loader = module.ge;
            _setter.log = module.eD;
            _setter.logID = module.dn;
            _setter.macro = module.bz;
            _setter.markAsWarning = module.dg;
            _setter.mat4 = module.eE;
            _setter.math = module.f3;
            _setter.misc = module.fs;
            _setter.murmurhash2_32_gc = module.m;
            _setter.nextPow2 = module.fk;
            _setter.path = module.ft;
            _setter.physics = module.gR;
            _setter.pingPong = module.e2;
            _setter.pointerEvent2SystemEvent = module.ds;
            _setter.pseudoRandom = module.dY;
            _setter.pseudoRandomRange = module.fi;
            _setter.pseudoRandomRangeInt = module.fj;
            _setter.quat = module.f9;
            _setter.random = module.dZ;
            _setter.randomRange = module.d_;
            _setter.randomRangeInt = module.d$;
            _setter.rect = module.fd;
            _setter.removeProperty = module.c5;
            _setter.renderer = module.f2;
            _setter.repeat = module.dX;
            _setter.replaceProperty = module.ck;
            _setter.resources = module.gc;
            _setter.sampleAnimationCurve = module.gz;
            _setter.screen = module.df;
            _setter.serializeTag = module.fF;
            _setter.setDefaultLogTimes = module.fv;
            _setter.setDisplayStats = module.fR;
            _setter.size = module.fc;
            _setter.sys = module.du;
            _setter.systemEvent = module.gQ;
            _setter.toDegree = module.dS;
            _setter.toRadian = module.ci;
            _setter.url = module.gg;
            _setter.v2 = module.f6;
            _setter.v3 = module.f7;
            _setter.v4 = module.f8;
            _setter.view = module.de;
            _setter.warn = module.bC;
            _setter.warnID = module.bB;
            exports(_setter);
        }],
        execute: function () {
          console.log('pptest importing cc 2');
            exports({
                CacheMode: void 0,
                ECollider2DType: void 0,
                EJoint2DType: void 0,
                EPhysics2DDrawFlags: void 0,
                ERaycast2DType: void 0,
                ERigidBody2DType: void 0,
                HorizontalTextAlignment: void 0,
                InstanceMaterialType: void 0,
                Overflow: void 0,
                Physics2DManifoldType: void 0,
                PhysicsGroup: void 0,
                VerticalTextAlignment: void 0,
                earcut: earcut,
                fragmentText: fragmentText,
                getBaselineOffset: getBaselineOffset,
                isUnicodeCJK: isUnicodeCJK,
                isUnicodeSpace: isUnicodeSpace,
                safeMeasureText: safeMeasureText,
                tween: tween,
                tweenUtil: tweenUtil
            });

            class CachedArray extends ScalableContainer {
              constructor(length, compareFn) {
                super();
                this.array = void 0;
                this.length = 0;
                this._compareFn = void 0;
                this._initSize = 0;
                this.array = new Array(length);
                this._initSize = length;
                this.length = 0;
                this._compareFn = compareFn;
              }

              push(item) {
                this.array[this.length++] = item;
              }

              pop() {
                return this.array[--this.length];
              }

              get(idx) {
                return this.array[idx];
              }

              clear() {
                this.length = 0;
              }

              destroy() {
                this.length = 0;
                this.array.length = 0;
                super.destroy();
              }

              tryShrink() {
                if (this.array.length >> 2 > this.length) {
                  this.array.length = Math.max(this._initSize, this.array.length >> 1);
                }
              }

              sort() {
                this.array.length = this.length;
                this.array.sort(this._compareFn);
              }

              concat(array) {
                for (let i = 0; i < array.length; ++i) {
                  this.array[this.length++] = array[i];
                }
              }

              fastRemove(idx) {
                if (idx >= this.length || idx < 0) {
                  return;
                }

                const last = --this.length;
                this.array[idx] = this.array[last];
              }

              indexOf(val) {
                for (let i = 0, len = this.length; i < len; ++i) {
                  if (this.array[i] === val) {
                    return i;
                  }
                }

                return -1;
              }

            } exports('CachedArray', CachedArray);

            var index = /*#__PURE__*/Object.freeze({
                __proto__: null,
                Pool: Pool,
                RecyclePool: RecyclePool,
                CachedArray: CachedArray
            });
            exports('memop', index);

            class DescriptorSet extends GFXObject {
              get layout() {
                return this._layout;
              }

              constructor() {
                super(ObjectType.DESCRIPTOR_SET);
                this._layout = null;
                this._buffers = [];
                this._textures = [];
                this._samplers = [];
                this._isDirty = false;
              }

              bindBuffer(binding, buffer, index = 0) {
                const bindingIndex = this._layout.bindingIndices[binding];
                const info = this._layout.bindings[bindingIndex];

                if (!info) {
                  return;
                }

                if (info.descriptorType & DESCRIPTOR_BUFFER_TYPE) {
                  const descriptorIndex = this._layout.descriptorIndices[binding];

                  if (this._buffers[descriptorIndex + index] !== buffer) {
                    this._buffers[descriptorIndex + index] = buffer;
                    this._isDirty = true;
                  }
                }
              }

              bindSampler(binding, sampler, index = 0) {
                const bindingIndex = this._layout.bindingIndices[binding];
                const info = this._layout.bindings[bindingIndex];

                if (!info) {
                  return;
                }

                if (info.descriptorType & DESCRIPTOR_SAMPLER_TYPE) {
                  const descriptorIndex = this._layout.descriptorIndices[binding];

                  if (this._samplers[descriptorIndex + index] !== sampler) {
                    this._samplers[descriptorIndex + index] = sampler;
                    this._isDirty = true;
                  }
                }
              }

              bindTexture(binding, texture, index = 0) {
                const bindingIndex = this._layout.bindingIndices[binding];
                const info = this._layout.bindings[bindingIndex];

                if (!info) {
                  return;
                }

                if (info.descriptorType & DESCRIPTOR_SAMPLER_TYPE) {
                  const descriptorIndex = this._layout.descriptorIndices[binding];

                  if (this._textures[descriptorIndex + index] !== texture) {
                    this._textures[descriptorIndex + index] = texture;
                    this._isDirty = true;
                  }
                }
              }

              getBuffer(binding, index = 0) {
                const descriptorIndex = this._layout.descriptorIndices[binding];
                return this._buffers[descriptorIndex + index];
              }

              getSampler(binding, index = 0) {
                const descriptorIndex = this._layout.descriptorIndices[binding];
                return this._samplers[descriptorIndex + index];
              }

              getTexture(binding, index = 0) {
                const descriptorIndex = this._layout.descriptorIndices[binding];
                return this._textures[descriptorIndex + index];
              }

            }

            class Buffer extends GFXObject {
              get usage() {
                return this._usage;
              }

              get memUsage() {
                return this._memUsage;
              }

              get size() {
                return this._size;
              }

              get stride() {
                return this._stride;
              }

              get count() {
                return this._count;
              }

              get flags() {
                return this._flags;
              }

              constructor() {
                super(ObjectType.BUFFER);
                this._usage = BufferUsageBit.NONE;
                this._memUsage = MemoryUsageBit.NONE;
                this._size = 0;
                this._stride = 1;
                this._count = 0;
                this._flags = BufferFlagBit.NONE;
                this._isBufferView = false;
              }

            }

            class CommandBuffer extends GFXObject {
              get type() {
                return this._type;
              }

              get queue() {
                return this._queue;
              }

              get numDrawCalls() {
                return this._numDrawCalls;
              }

              get numInstances() {
                return this._numInstances;
              }

              get numTris() {
                return this._numTris;
              }

              constructor() {
                super(ObjectType.COMMAND_BUFFER);
                this._queue = null;
                this._type = CommandBufferType.PRIMARY;
                this._numDrawCalls = 0;
                this._numInstances = 0;
                this._numTris = 0;
              }

            }

            class Swapchain extends GFXObject {
              get colorTexture() {
                return this._colorTexture;
              }

              get depthStencilTexture() {
                return this._depthStencilTexture;
              }

              get surfaceTransform() {
                return this._transform;
              }

              get width() {
                return this._colorTexture.width;
              }

              get height() {
                return this._colorTexture.height;
              }

              constructor() {
                super(ObjectType.SWAPCHAIN);
                this._transform = SurfaceTransform.IDENTITY;
                this._colorTexture = null;
                this._depthStencilTexture = null;
              }

            }

            class Framebuffer extends GFXObject {
              get renderPass() {
                return this._renderPass;
              }

              get colorTextures() {
                return this._colorTextures;
              }

              get depthStencilTexture() {
                return this._depthStencilTexture;
              }

              constructor() {
                super(ObjectType.FRAMEBUFFER);
                this._renderPass = null;
                this._colorTextures = [];
                this._depthStencilTexture = null;
              }

            }

            class InputAssembler extends GFXObject {
              get attributes() {
                return this._attributes;
              }

              get vertexBuffers() {
                return this._vertexBuffers;
              }

              get indexBuffer() {
                return this._indexBuffer;
              }

              get indirectBuffer() {
                return this._indirectBuffer;
              }

              get attributesHash() {
                return this._attributesHash;
              }

              set vertexCount(count) {
                this._drawInfo.vertexCount = count;
              }

              get vertexCount() {
                return this._drawInfo.vertexCount;
              }

              set firstVertex(first) {
                this._drawInfo.firstVertex = first;
              }

              get firstVertex() {
                return this._drawInfo.firstVertex;
              }

              set indexCount(count) {
                this._drawInfo.indexCount = count;
              }

              get indexCount() {
                return this._drawInfo.indexCount;
              }

              set firstIndex(first) {
                this._drawInfo.firstIndex = first;
              }

              get firstIndex() {
                return this._drawInfo.firstIndex;
              }

              set vertexOffset(offset) {
                this._drawInfo.vertexOffset = offset;
              }

              get vertexOffset() {
                return this._drawInfo.vertexOffset;
              }

              set instanceCount(count) {
                this._drawInfo.instanceCount = count;
              }

              get instanceCount() {
                return this._drawInfo.instanceCount;
              }

              set firstInstance(first) {
                this._drawInfo.firstInstance = first;
              }

              get firstInstance() {
                return this._drawInfo.firstInstance;
              }

              get drawInfo() {
                return this._drawInfo;
              }

              constructor() {
                super(ObjectType.INPUT_ASSEMBLER);
                this._attributes = [];
                this._attributesHash = 0;
                this._vertexBuffers = [];
                this._indexBuffer = null;
                this._indirectBuffer = null;
                this._drawInfo = new DrawInfo();
              }

              getVertexBuffer(stream = 0) {
                if (stream < this._vertexBuffers.length) {
                  return this._vertexBuffers[stream];
                } else {
                  return null;
                }
              }

              computeAttributesHash() {
                let res = 'attrs';

                for (let i = 0; i < this.attributes.length; ++i) {
                  const at = this.attributes[i];
                  res += `,${at.name},${at.format},${at.isNormalized},${at.stream},${at.isInstanced}`;
                }

                return murmurhash2_32_gc(res, 666);
              }

            }

            class DescriptorSetLayout extends GFXObject {
              get bindings() {
                return this._bindings;
              }

              get bindingIndices() {
                return this._bindingIndices;
              }

              get descriptorIndices() {
                return this._descriptorIndices;
              }

              constructor() {
                super(ObjectType.DESCRIPTOR_SET_LAYOUT);
                this._bindings = [];
                this._bindingIndices = [];
                this._descriptorIndices = [];
              }

            }

            class PipelineLayout extends GFXObject {
              get setLayouts() {
                return this._setLayouts;
              }

              constructor() {
                super(ObjectType.PIPELINE_LAYOUT);
                this._setLayouts = [];
              }

            }

            class Queue extends GFXObject {
              get type() {
                return this._type;
              }

              constructor() {
                super(ObjectType.QUEUE);
                this._type = QueueType.GRAPHICS;
              }

            }

            class RenderPass extends GFXObject {
              get colorAttachments() {
                return this._colorInfos;
              }

              get depthStencilAttachment() {
                return this._depthStencilInfo;
              }

              get subPasses() {
                return this._subpasses;
              }

              get hash() {
                return this._hash;
              }

              constructor() {
                super(ObjectType.RENDER_PASS);
                this._colorInfos = [];
                this._depthStencilInfo = null;
                this._subpasses = [];
                this._hash = 0;
              }

              computeHash() {
                let res = '';

                if (this._subpasses.length) {
                  for (let i = 0; i < this._subpasses.length; ++i) {
                    const subpass = this._subpasses[i];

                    if (subpass.inputs.length) {
                      res += 'ia';

                      for (let j = 0; j < subpass.inputs.length; ++j) {
                        const ia = this._colorInfos[subpass.inputs[j]];
                        res += `,${ia.format},${ia.sampleCount}`;
                      }
                    }

                    if (subpass.colors.length) {
                      res += 'ca';

                      for (let j = 0; j < subpass.inputs.length; ++j) {
                        const ca = this._colorInfos[subpass.inputs[j]];
                        res += `,${ca.format},${ca.sampleCount}`;
                      }
                    }

                    if (subpass.depthStencil >= 0) {
                      const ds = this._colorInfos[subpass.depthStencil];
                      res += `ds,${ds.format},${ds.sampleCount}`;
                    }
                  }
                } else {
                  res += 'ca';

                  for (let i = 0; i < this._colorInfos.length; ++i) {
                    const ca = this._colorInfos[i];
                    res += `,${ca.format},${ca.sampleCount}`;
                  }

                  const ds = this._depthStencilInfo;

                  if (ds) {
                    res += `ds,${ds.format},${ds.sampleCount}`;
                  }
                }

                return murmurhash2_32_gc(res, 666);
              }

            }

            class Shader extends GFXObject {
              get name() {
                return this._name;
              }

              get attributes() {
                return this._attributes;
              }

              get blocks() {
                return this._blocks;
              }

              get samplers() {
                return this._samplers;
              }

              constructor() {
                super(ObjectType.SHADER);
                this._name = '';
                this._stages = [];
                this._attributes = [];
                this._blocks = [];
                this._samplers = [];
              }

            }

            class GlobalBarrier extends GFXObject {
              get info() {
                return this._info;
              }

              get hash() {
                return this._hash;
              }

              constructor(info, hash) {
                super(ObjectType.GLOBAL_BARRIER);
                this._info = new GlobalBarrierInfo();
                this._hash = 0;

                this._info.copy(info);

                this._hash = hash;
              }

              static computeHash(info) {
                let res = 'prev:';

                for (let i = 0; i < info.prevAccesses.length; ++i) {
                  res += ` ${info.prevAccesses[i]}`;
                }

                res += 'next:';

                for (let i = 0; i < info.nextAccesses.length; ++i) {
                  res += ` ${info.nextAccesses[i]}`;
                }

                return murmurhash2_32_gc(res, 666);
              }

            }

            class TextureBarrier extends GFXObject {
              get info() {
                return this._info;
              }

              get hash() {
                return this._hash;
              }

              constructor(info, hash) {
                super(ObjectType.TEXTURE_BARRIER);
                this._info = new TextureBarrierInfo();
                this._hash = 0;

                this._info.copy(info);

                this._hash = hash;
              }

              static computeHash(info) {
                let res = 'prev:';

                for (let i = 0; i < info.prevAccesses.length; ++i) {
                  res += ` ${info.prevAccesses[i]}`;
                }

                res += 'next:';

                for (let i = 0; i < info.nextAccesses.length; ++i) {
                  res += ` ${info.nextAccesses[i]}`;
                }

                res += info.discardContents;
                res += info.srcQueue ? info.srcQueue.type : 0;
                res += info.dstQueue ? info.dstQueue.type : 0;
                return murmurhash2_32_gc(res, 666);
              }

            }

            var index$1 = /*#__PURE__*/Object.freeze({
                __proto__: null,
                DescriptorSet: DescriptorSet,
                Buffer: Buffer,
                CommandBuffer: CommandBuffer,
                get ObjectType () { return ObjectType; },
                get Status () { return Status; },
                get API () { return API; },
                get SurfaceTransform () { return SurfaceTransform; },
                get Feature () { return Feature; },
                get Format () { return Format; },
                get FormatType () { return FormatType; },
                get Type () { return Type$1; },
                get BufferUsageBit () { return BufferUsageBit; },
                get BufferFlagBit () { return BufferFlagBit; },
                get MemoryAccessBit () { return MemoryAccessBit; },
                get MemoryUsageBit () { return MemoryUsageBit; },
                get TextureType () { return TextureType; },
                get TextureUsageBit () { return TextureUsageBit; },
                get TextureFlagBit () { return TextureFlagBit; },
                get SampleCount () { return SampleCount; },
                get VsyncMode () { return VsyncMode; },
                get Filter () { return Filter; },
                get Address () { return Address; },
                get ComparisonFunc () { return ComparisonFunc; },
                get StencilOp () { return StencilOp; },
                get BlendFactor () { return BlendFactor; },
                get BlendOp () { return BlendOp; },
                get ColorMask () { return ColorMask; },
                get ShaderStageFlagBit () { return ShaderStageFlagBit; },
                get LoadOp () { return LoadOp; },
                get StoreOp () { return StoreOp; },
                get AccessType () { return AccessType; },
                get ResolveMode () { return ResolveMode; },
                get PipelineBindPoint () { return PipelineBindPoint; },
                get PrimitiveMode () { return PrimitiveMode; },
                get PolygonMode () { return PolygonMode; },
                get ShadeModel () { return ShadeModel; },
                get CullMode () { return CullMode; },
                get DynamicStateFlagBit () { return DynamicStateFlagBit; },
                get StencilFace () { return StencilFace; },
                get DescriptorType () { return DescriptorType; },
                get QueueType () { return QueueType; },
                get QueryType () { return QueryType; },
                get CommandBufferType () { return CommandBufferType; },
                get ClearFlagBit () { return ClearFlagBit; },
                Size: Size,
                DeviceCaps: DeviceCaps,
                Offset: Offset,
                Rect: Rect,
                Extent: Extent,
                TextureSubresLayers: TextureSubresLayers,
                TextureSubresRange: TextureSubresRange,
                TextureCopy: TextureCopy,
                TextureBlit: TextureBlit,
                BufferTextureCopy: BufferTextureCopy,
                Viewport: Viewport,
                Color: Color,
                BindingMappingInfo: BindingMappingInfo,
                SwapchainInfo: SwapchainInfo,
                DeviceInfo: DeviceInfo,
                BufferInfo: BufferInfo,
                BufferViewInfo: BufferViewInfo,
                DrawInfo: DrawInfo,
                DispatchInfo: DispatchInfo,
                IndirectBuffer: IndirectBuffer,
                TextureInfo: TextureInfo,
                TextureViewInfo: TextureViewInfo,
                SamplerInfo: SamplerInfo,
                Uniform: Uniform,
                UniformBlock: UniformBlock,
                UniformSamplerTexture: UniformSamplerTexture,
                UniformSampler: UniformSampler,
                UniformTexture: UniformTexture,
                UniformStorageImage: UniformStorageImage,
                UniformStorageBuffer: UniformStorageBuffer,
                UniformInputAttachment: UniformInputAttachment,
                ShaderStage: ShaderStage,
                Attribute: Attribute,
                ShaderInfo: ShaderInfo,
                InputAssemblerInfo: InputAssemblerInfo,
                ColorAttachment: ColorAttachment,
                DepthStencilAttachment: DepthStencilAttachment,
                SubpassInfo: SubpassInfo,
                SubpassDependency: SubpassDependency,
                RenderPassInfo: RenderPassInfo,
                GlobalBarrierInfo: GlobalBarrierInfo,
                TextureBarrierInfo: TextureBarrierInfo,
                FramebufferInfo: FramebufferInfo,
                DescriptorSetLayoutBinding: DescriptorSetLayoutBinding,
                DescriptorSetLayoutInfo: DescriptorSetLayoutInfo,
                DescriptorSetInfo: DescriptorSetInfo,
                PipelineLayoutInfo: PipelineLayoutInfo,
                InputState: InputState,
                CommandBufferInfo: CommandBufferInfo,
                QueueInfo: QueueInfo,
                QueryPoolInfo: QueryPoolInfo,
                FormatInfo: FormatInfo,
                MemoryStatus: MemoryStatus,
                DynamicStencilStates: DynamicStencilStates,
                DynamicStates: DynamicStates,
                GFXObject: GFXObject,
                get AttributeName () { return AttributeName; },
                FormatInfos: FormatInfos,
                DESCRIPTOR_BUFFER_TYPE: DESCRIPTOR_BUFFER_TYPE,
                DESCRIPTOR_SAMPLER_TYPE: DESCRIPTOR_SAMPLER_TYPE,
                DESCRIPTOR_DYNAMIC_TYPE: DESCRIPTOR_DYNAMIC_TYPE,
                DRAW_INFO_SIZE: DRAW_INFO_SIZE,
                IsPowerOf2: IsPowerOf2,
                FormatSize: FormatSize,
                FormatSurfaceSize: FormatSurfaceSize,
                GetTypeSize: GetTypeSize,
                getTypedArrayConstructor: getTypedArrayConstructor,
                Device: Device,
                Swapchain: Swapchain,
                Framebuffer: Framebuffer,
                InputAssembler: InputAssembler,
                DescriptorSetLayout: DescriptorSetLayout,
                PipelineLayout: PipelineLayout,
                Queue: Queue,
                RenderPass: RenderPass,
                Shader: Shader,
                Texture: Texture,
                Sampler: Sampler,
                GlobalBarrier: GlobalBarrier,
                TextureBarrier: TextureBarrier,
                BlendTarget: BlendTarget$1,
                BlendState: BlendState$2,
                RasterizerState: RasterizerState$1,
                DepthStencilState: DepthStencilState$1,
                PipelineState: PipelineState$1,
                PipelineStateInfo: PipelineStateInfo
            });
            exports('gfx', index$1);

            var animation = /*#__PURE__*/Object.freeze({
                __proto__: null,
                UniformProxyFactory: UniformProxyFactory,
                MorphWeightValueProxy: MorphWeightValueProxy,
                MorphWeightsValueProxy: MorphWeightsValueProxy,
                MorphWeightsAllValueProxy: MorphWeightsAllValueProxy,
                Track: Track,
                TrackPath: TrackPath,
                RealTrack: RealTrack,
                VectorTrack: VectorTrack,
                QuatTrack: QuatTrack,
                ColorTrack: ColorTrack,
                SizeTrack: SizeTrack,
                ObjectTrack: ObjectTrack,
                isPropertyPath: isPropertyPath,
                isCustomPath: isCustomPath,
                HierarchyPath: HierarchyPath,
                ComponentPath: ComponentPath,
                CubicSplineVec2Value: CubicSplineVec2Value,
                CubicSplineVec3Value: CubicSplineVec3Value,
                CubicSplineVec4Value: CubicSplineVec4Value,
                CubicSplineQuatValue: CubicSplineQuatValue,
                CubicSplineNumberValue: CubicSplineNumberValue,
                AnimationController: AnimationController,
                get VariableType () { return VariableType; },
                StateMachineComponent: StateMachineComponent
            });
            exports('animation', animation);

            class WebGLDescriptorSet extends DescriptorSet {
              constructor(...args) {
                super(...args);
                this._gpuDescriptorSet = null;
              }

              get gpuDescriptorSet() {
                return this._gpuDescriptorSet;
              }

              initialize(info) {
                this._layout = info.layout;
                const {
                  bindings,
                  descriptorIndices,
                  descriptorCount
                } = info.layout.gpuDescriptorSetLayout;
                this._buffers = Array(descriptorCount).fill(null);
                this._textures = Array(descriptorCount).fill(null);
                this._samplers = Array(descriptorCount).fill(null);
                const gpuDescriptors = [];
                this._gpuDescriptorSet = {
                  gpuDescriptors,
                  descriptorIndices
                };

                for (let i = 0; i < bindings.length; ++i) {
                  const binding = bindings[i];

                  for (let j = 0; j < binding.count; j++) {
                    gpuDescriptors.push({
                      type: binding.descriptorType,
                      gpuBuffer: null,
                      gpuTexture: null,
                      gpuSampler: null
                    });
                  }
                }
              }

              destroy() {
                this._layout = null;
                this._gpuDescriptorSet = null;
              }

              update() {
                if (this._isDirty && this._gpuDescriptorSet) {
                  const descriptors = this._gpuDescriptorSet.gpuDescriptors;

                  for (let i = 0; i < descriptors.length; ++i) {
                    if (descriptors[i].type & DESCRIPTOR_BUFFER_TYPE) {
                      const buffer = this._buffers[i];

                      if (buffer) {
                        descriptors[i].gpuBuffer = buffer.gpuBuffer || buffer.gpuBufferView;
                      }
                    } else if (descriptors[i].type & DESCRIPTOR_SAMPLER_TYPE) {
                      if (this._textures[i]) {
                        descriptors[i].gpuTexture = this._textures[i].gpuTexture;
                      }

                      if (this._samplers[i]) {
                        descriptors[i].gpuSampler = this._samplers[i].gpuSampler;
                      }
                    }
                  }

                  this._isDirty = false;
                }
              }

            }

            let WebGLEXT;

            (function (WebGLEXT) {
              WebGLEXT[WebGLEXT["RGBA16F_EXT"] = 34842] = "RGBA16F_EXT";
              WebGLEXT[WebGLEXT["RGB16F_EXT"] = 34843] = "RGB16F_EXT";
              WebGLEXT[WebGLEXT["RGBA32F_EXT"] = 34836] = "RGBA32F_EXT";
              WebGLEXT[WebGLEXT["FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT"] = 33297] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT";
              WebGLEXT[WebGLEXT["UNSIGNED_NORMALIZED_EXT"] = 35863] = "UNSIGNED_NORMALIZED_EXT";
              WebGLEXT[WebGLEXT["UNSIGNED_INT_24_8_WEBGL"] = 34042] = "UNSIGNED_INT_24_8_WEBGL";
              WebGLEXT[WebGLEXT["HALF_FLOAT_OES"] = 36193] = "HALF_FLOAT_OES";
              WebGLEXT[WebGLEXT["SRGB_EXT"] = 35904] = "SRGB_EXT";
              WebGLEXT[WebGLEXT["SRGB_ALPHA_EXT"] = 35906] = "SRGB_ALPHA_EXT";
              WebGLEXT[WebGLEXT["SRGB8_ALPHA8_EXT"] = 35907] = "SRGB8_ALPHA8_EXT";
              WebGLEXT[WebGLEXT["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";
              WebGLEXT[WebGLEXT["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG";
              WebGLEXT[WebGLEXT["COMPRESSED_RGB_PVRTC_2BPPV1_IMG"] = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG";
              WebGLEXT[WebGLEXT["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL";
              WebGLEXT[WebGLEXT["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";
              WebGLEXT[WebGLEXT["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";
              WebGLEXT[WebGLEXT["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";
              WebGLEXT[WebGLEXT["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";
              WebGLEXT[WebGLEXT["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ETC2"] = 37493] = "COMPRESSED_SRGB8_ETC2";
              WebGLEXT[WebGLEXT["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA8_ETC2_EAC"] = 37496] = "COMPRESSED_RGBA8_ETC2_EAC";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_4x4_KHR"] = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_5x4_KHR"] = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_5x5_KHR"] = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_6x5_KHR"] = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_6x6_KHR"] = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_8x5_KHR"] = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_8x6_KHR"] = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_8x8_KHR"] = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_10x5_KHR"] = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_10x6_KHR"] = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_10x8_KHR"] = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_10x10_KHR"] = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_12x10_KHR"] = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_12x12_KHR"] = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR"] = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR"] = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR"] = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR"] = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR"] = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR"] = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR"] = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR"] = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR"] = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR"] = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR"] = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR"] = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR"] = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR"] = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR";
            })(WebGLEXT || (WebGLEXT = {}));

            class WebGLDeviceManager {
              static get instance() {
                return WebGLDeviceManager._instance;
              }

              static setInstance(instance) {
                WebGLDeviceManager._instance = instance;
              }

            }
            WebGLDeviceManager._instance = null;

            function GFXFormatToWebGLType(format, gl) {
              switch (format) {
                case Format.R8:
                  return gl.UNSIGNED_BYTE;

                case Format.R8SN:
                  return gl.BYTE;

                case Format.R8UI:
                  return gl.UNSIGNED_BYTE;

                case Format.R8I:
                  return gl.BYTE;

                case Format.R16F:
                  return WebGLEXT.HALF_FLOAT_OES;

                case Format.R16UI:
                  return gl.UNSIGNED_SHORT;

                case Format.R16I:
                  return gl.SHORT;

                case Format.R32F:
                  return gl.FLOAT;

                case Format.R32UI:
                  return gl.UNSIGNED_INT;

                case Format.R32I:
                  return gl.INT;

                case Format.RG8:
                  return gl.UNSIGNED_BYTE;

                case Format.RG8SN:
                  return gl.BYTE;

                case Format.RG8UI:
                  return gl.UNSIGNED_BYTE;

                case Format.RG8I:
                  return gl.BYTE;

                case Format.RG16F:
                  return WebGLEXT.HALF_FLOAT_OES;

                case Format.RG16UI:
                  return gl.UNSIGNED_SHORT;

                case Format.RG16I:
                  return gl.SHORT;

                case Format.RG32F:
                  return gl.FLOAT;

                case Format.RG32UI:
                  return gl.UNSIGNED_INT;

                case Format.RG32I:
                  return gl.INT;

                case Format.RGB8:
                  return gl.UNSIGNED_BYTE;

                case Format.SRGB8:
                  return gl.UNSIGNED_BYTE;

                case Format.RGB8SN:
                  return gl.BYTE;

                case Format.RGB8UI:
                  return gl.UNSIGNED_BYTE;

                case Format.RGB8I:
                  return gl.BYTE;

                case Format.RGB16F:
                  return WebGLEXT.HALF_FLOAT_OES;

                case Format.RGB16UI:
                  return gl.UNSIGNED_SHORT;

                case Format.RGB16I:
                  return gl.SHORT;

                case Format.RGB32F:
                  return gl.FLOAT;

                case Format.RGB32UI:
                  return gl.UNSIGNED_INT;

                case Format.RGB32I:
                  return gl.INT;

                case Format.BGRA8:
                  return gl.UNSIGNED_BYTE;

                case Format.RGBA8:
                  return gl.UNSIGNED_BYTE;

                case Format.SRGB8_A8:
                  return gl.UNSIGNED_BYTE;

                case Format.RGBA8SN:
                  return gl.BYTE;

                case Format.RGBA8UI:
                  return gl.UNSIGNED_BYTE;

                case Format.RGBA8I:
                  return gl.BYTE;

                case Format.RGBA16F:
                  return WebGLEXT.HALF_FLOAT_OES;

                case Format.RGBA16UI:
                  return gl.UNSIGNED_SHORT;

                case Format.RGBA16I:
                  return gl.SHORT;

                case Format.RGBA32F:
                  return gl.FLOAT;

                case Format.RGBA32UI:
                  return gl.UNSIGNED_INT;

                case Format.RGBA32I:
                  return gl.INT;

                case Format.R5G6B5:
                  return gl.UNSIGNED_SHORT_5_6_5;

                case Format.R11G11B10F:
                  return gl.FLOAT;

                case Format.RGB5A1:
                  return gl.UNSIGNED_SHORT_5_5_5_1;

                case Format.RGBA4:
                  return gl.UNSIGNED_SHORT_4_4_4_4;

                case Format.RGB10A2:
                  return gl.UNSIGNED_BYTE;

                case Format.RGB10A2UI:
                  return gl.UNSIGNED_INT;

                case Format.RGB9E5:
                  return gl.UNSIGNED_BYTE;

                case Format.DEPTH:
                  return gl.UNSIGNED_INT;

                case Format.DEPTH_STENCIL:
                  return WebGLEXT.UNSIGNED_INT_24_8_WEBGL;

                case Format.BC1:
                  return gl.UNSIGNED_BYTE;

                case Format.BC1_SRGB:
                  return gl.UNSIGNED_BYTE;

                case Format.BC2:
                  return gl.UNSIGNED_BYTE;

                case Format.BC2_SRGB:
                  return gl.UNSIGNED_BYTE;

                case Format.BC3:
                  return gl.UNSIGNED_BYTE;

                case Format.BC3_SRGB:
                  return gl.UNSIGNED_BYTE;

                case Format.BC4:
                  return gl.UNSIGNED_BYTE;

                case Format.BC4_SNORM:
                  return gl.BYTE;

                case Format.BC5:
                  return gl.UNSIGNED_BYTE;

                case Format.BC5_SNORM:
                  return gl.BYTE;

                case Format.BC6H_SF16:
                  return gl.FLOAT;

                case Format.BC6H_UF16:
                  return gl.FLOAT;

                case Format.BC7:
                  return gl.UNSIGNED_BYTE;

                case Format.BC7_SRGB:
                  return gl.UNSIGNED_BYTE;

                case Format.ETC_RGB8:
                  return gl.UNSIGNED_BYTE;

                case Format.ETC2_RGB8:
                  return gl.UNSIGNED_BYTE;

                case Format.ETC2_SRGB8:
                  return gl.UNSIGNED_BYTE;

                case Format.ETC2_RGB8_A1:
                  return gl.UNSIGNED_BYTE;

                case Format.ETC2_SRGB8_A1:
                  return gl.UNSIGNED_BYTE;

                case Format.EAC_R11:
                  return gl.UNSIGNED_BYTE;

                case Format.EAC_R11SN:
                  return gl.BYTE;

                case Format.EAC_RG11:
                  return gl.UNSIGNED_BYTE;

                case Format.EAC_RG11SN:
                  return gl.BYTE;

                case Format.PVRTC_RGB2:
                  return gl.UNSIGNED_BYTE;

                case Format.PVRTC_RGBA2:
                  return gl.UNSIGNED_BYTE;

                case Format.PVRTC_RGB4:
                  return gl.UNSIGNED_BYTE;

                case Format.PVRTC_RGBA4:
                  return gl.UNSIGNED_BYTE;

                case Format.PVRTC2_2BPP:
                  return gl.UNSIGNED_BYTE;

                case Format.PVRTC2_4BPP:
                  return gl.UNSIGNED_BYTE;

                case Format.ASTC_RGBA_4X4:
                case Format.ASTC_RGBA_5X4:
                case Format.ASTC_RGBA_5X5:
                case Format.ASTC_RGBA_6X5:
                case Format.ASTC_RGBA_6X6:
                case Format.ASTC_RGBA_8X5:
                case Format.ASTC_RGBA_8X6:
                case Format.ASTC_RGBA_8X8:
                case Format.ASTC_RGBA_10X5:
                case Format.ASTC_RGBA_10X6:
                case Format.ASTC_RGBA_10X8:
                case Format.ASTC_RGBA_10X10:
                case Format.ASTC_RGBA_12X10:
                case Format.ASTC_RGBA_12X12:
                case Format.ASTC_SRGBA_4X4:
                case Format.ASTC_SRGBA_5X4:
                case Format.ASTC_SRGBA_5X5:
                case Format.ASTC_SRGBA_6X5:
                case Format.ASTC_SRGBA_6X6:
                case Format.ASTC_SRGBA_8X5:
                case Format.ASTC_SRGBA_8X6:
                case Format.ASTC_SRGBA_8X8:
                case Format.ASTC_SRGBA_10X5:
                case Format.ASTC_SRGBA_10X6:
                case Format.ASTC_SRGBA_10X8:
                case Format.ASTC_SRGBA_10X10:
                case Format.ASTC_SRGBA_12X10:
                case Format.ASTC_SRGBA_12X12:
                  return gl.UNSIGNED_BYTE;

                default:
                  {
                    return gl.UNSIGNED_BYTE;
                  }
              }
            }
            function GFXFormatToWebGLInternalFormat(format, gl) {
              switch (format) {
                case Format.R5G6B5:
                  return gl.RGB565;

                case Format.RGB5A1:
                  return gl.RGB5_A1;

                case Format.RGBA4:
                  return gl.RGBA4;

                case Format.RGBA16F:
                  return WebGLEXT.RGBA16F_EXT;

                case Format.RGBA32F:
                  return WebGLEXT.RGBA32F_EXT;

                case Format.SRGB8_A8:
                  return WebGLEXT.SRGB8_ALPHA8_EXT;

                case Format.DEPTH:
                  return gl.DEPTH_COMPONENT16;

                case Format.DEPTH_STENCIL:
                  return gl.DEPTH_STENCIL;

                default:
                  {
                    console.error('Unsupported Format, convert to WebGL internal format failed.');
                    return gl.RGBA;
                  }
              }
            }
            function GFXFormatToWebGLFormat(format, gl) {
              switch (format) {
                case Format.A8:
                  return gl.ALPHA;

                case Format.L8:
                  return gl.LUMINANCE;

                case Format.LA8:
                  return gl.LUMINANCE_ALPHA;

                case Format.RGB8:
                  return gl.RGB;

                case Format.RGB16F:
                  return gl.RGB;

                case Format.RGB32F:
                  return gl.RGB;

                case Format.BGRA8:
                  return gl.RGBA;

                case Format.RGBA8:
                  return gl.RGBA;

                case Format.SRGB8_A8:
                  return gl.RGBA;

                case Format.RGBA16F:
                  return gl.RGBA;

                case Format.RGBA32F:
                  return gl.RGBA;

                case Format.R5G6B5:
                  return gl.RGB;

                case Format.RGB5A1:
                  return gl.RGBA;

                case Format.RGBA4:
                  return gl.RGBA;

                case Format.DEPTH:
                  return gl.DEPTH_COMPONENT;

                case Format.DEPTH_STENCIL:
                  return gl.DEPTH_STENCIL;

                case Format.BC1:
                  return WebGLEXT.COMPRESSED_RGB_S3TC_DXT1_EXT;

                case Format.BC1_ALPHA:
                  return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT1_EXT;

                case Format.BC1_SRGB:
                  return WebGLEXT.COMPRESSED_SRGB_S3TC_DXT1_EXT;

                case Format.BC1_SRGB_ALPHA:
                  return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;

                case Format.BC2:
                  return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT3_EXT;

                case Format.BC2_SRGB:
                  return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;

                case Format.BC3:
                  return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT5_EXT;

                case Format.BC3_SRGB:
                  return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

                case Format.ETC_RGB8:
                  return WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL;

                case Format.ETC2_RGB8:
                  return WebGLEXT.COMPRESSED_RGB8_ETC2;

                case Format.ETC2_SRGB8:
                  return WebGLEXT.COMPRESSED_SRGB8_ETC2;

                case Format.ETC2_RGB8_A1:
                  return WebGLEXT.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;

                case Format.ETC2_SRGB8_A1:
                  return WebGLEXT.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2;

                case Format.ETC2_RGBA8:
                  return WebGLEXT.COMPRESSED_RGBA8_ETC2_EAC;

                case Format.ETC2_SRGB8_A8:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;

                case Format.EAC_R11:
                  return WebGLEXT.COMPRESSED_R11_EAC;

                case Format.EAC_R11SN:
                  return WebGLEXT.COMPRESSED_SIGNED_R11_EAC;

                case Format.EAC_RG11:
                  return WebGLEXT.COMPRESSED_RG11_EAC;

                case Format.EAC_RG11SN:
                  return WebGLEXT.COMPRESSED_SIGNED_RG11_EAC;

                case Format.PVRTC_RGB2:
                  return WebGLEXT.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;

                case Format.PVRTC_RGBA2:
                  return WebGLEXT.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

                case Format.PVRTC_RGB4:
                  return WebGLEXT.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;

                case Format.PVRTC_RGBA4:
                  return WebGLEXT.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;

                case Format.ASTC_RGBA_4X4:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_4x4_KHR;

                case Format.ASTC_RGBA_5X4:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_5x4_KHR;

                case Format.ASTC_RGBA_5X5:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_5x5_KHR;

                case Format.ASTC_RGBA_6X5:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_6x5_KHR;

                case Format.ASTC_RGBA_6X6:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_6x6_KHR;

                case Format.ASTC_RGBA_8X5:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_8x5_KHR;

                case Format.ASTC_RGBA_8X6:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_8x6_KHR;

                case Format.ASTC_RGBA_8X8:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_8x8_KHR;

                case Format.ASTC_RGBA_10X5:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_10x5_KHR;

                case Format.ASTC_RGBA_10X6:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_10x6_KHR;

                case Format.ASTC_RGBA_10X8:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_10x8_KHR;

                case Format.ASTC_RGBA_10X10:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_10x10_KHR;

                case Format.ASTC_RGBA_12X10:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_12x10_KHR;

                case Format.ASTC_RGBA_12X12:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_12x12_KHR;

                case Format.ASTC_SRGBA_4X4:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;

                case Format.ASTC_SRGBA_5X4:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR;

                case Format.ASTC_SRGBA_5X5:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR;

                case Format.ASTC_SRGBA_6X5:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR;

                case Format.ASTC_SRGBA_6X6:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR;

                case Format.ASTC_SRGBA_8X5:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR;

                case Format.ASTC_SRGBA_8X6:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR;

                case Format.ASTC_SRGBA_8X8:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR;

                case Format.ASTC_SRGBA_10X5:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR;

                case Format.ASTC_SRGBA_10X6:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR;

                case Format.ASTC_SRGBA_10X8:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR;

                case Format.ASTC_SRGBA_10X10:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR;

                case Format.ASTC_SRGBA_12X10:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR;

                case Format.ASTC_SRGBA_12X12:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR;

                default:
                  {
                    console.error('Unsupported Format, convert to WebGL format failed.');
                    return gl.RGBA;
                  }
              }
            }

            function GFXTypeToWebGLType(type, gl) {
              switch (type) {
                case Type$1.BOOL:
                  return gl.BOOL;

                case Type$1.BOOL2:
                  return gl.BOOL_VEC2;

                case Type$1.BOOL3:
                  return gl.BOOL_VEC3;

                case Type$1.BOOL4:
                  return gl.BOOL_VEC4;

                case Type$1.INT:
                  return gl.INT;

                case Type$1.INT2:
                  return gl.INT_VEC2;

                case Type$1.INT3:
                  return gl.INT_VEC3;

                case Type$1.INT4:
                  return gl.INT_VEC4;

                case Type$1.UINT:
                  return gl.UNSIGNED_INT;

                case Type$1.FLOAT:
                  return gl.FLOAT;

                case Type$1.FLOAT2:
                  return gl.FLOAT_VEC2;

                case Type$1.FLOAT3:
                  return gl.FLOAT_VEC3;

                case Type$1.FLOAT4:
                  return gl.FLOAT_VEC4;

                case Type$1.MAT2:
                  return gl.FLOAT_MAT2;

                case Type$1.MAT3:
                  return gl.FLOAT_MAT3;

                case Type$1.MAT4:
                  return gl.FLOAT_MAT4;

                case Type$1.SAMPLER2D:
                  return gl.SAMPLER_2D;

                case Type$1.SAMPLER_CUBE:
                  return gl.SAMPLER_CUBE;

                default:
                  {
                    console.error('Unsupported GLType, convert to GL type failed.');
                    return Type$1.UNKNOWN;
                  }
              }
            }

            function GFXTypeToTypedArrayCtor(type) {
              switch (type) {
                case Type$1.BOOL:
                case Type$1.BOOL2:
                case Type$1.BOOL3:
                case Type$1.BOOL4:
                case Type$1.INT:
                case Type$1.INT2:
                case Type$1.INT3:
                case Type$1.INT4:
                case Type$1.UINT:
                  return Int32Array;

                case Type$1.FLOAT:
                case Type$1.FLOAT2:
                case Type$1.FLOAT3:
                case Type$1.FLOAT4:
                case Type$1.MAT2:
                case Type$1.MAT3:
                case Type$1.MAT4:
                  return Float32Array;

                default:
                  {
                    console.error('Unsupported GLType, convert to TypedArrayConstructor failed.');
                    return Float32Array;
                  }
              }
            }

            function WebGLTypeToGFXType(glType, gl) {
              switch (glType) {
                case gl.BOOL:
                  return Type$1.BOOL;

                case gl.BOOL_VEC2:
                  return Type$1.BOOL2;

                case gl.BOOL_VEC3:
                  return Type$1.BOOL3;

                case gl.BOOL_VEC4:
                  return Type$1.BOOL4;

                case gl.INT:
                  return Type$1.INT;

                case gl.INT_VEC2:
                  return Type$1.INT2;

                case gl.INT_VEC3:
                  return Type$1.INT3;

                case gl.INT_VEC4:
                  return Type$1.INT4;

                case gl.UNSIGNED_INT:
                  return Type$1.UINT;

                case gl.FLOAT:
                  return Type$1.FLOAT;

                case gl.FLOAT_VEC2:
                  return Type$1.FLOAT2;

                case gl.FLOAT_VEC3:
                  return Type$1.FLOAT3;

                case gl.FLOAT_VEC4:
                  return Type$1.FLOAT4;

                case gl.FLOAT_MAT2:
                  return Type$1.MAT2;

                case gl.FLOAT_MAT3:
                  return Type$1.MAT3;

                case gl.FLOAT_MAT4:
                  return Type$1.MAT4;

                case gl.SAMPLER_2D:
                  return Type$1.SAMPLER2D;

                case gl.SAMPLER_CUBE:
                  return Type$1.SAMPLER_CUBE;

                default:
                  {
                    console.error('Unsupported GLType, convert to Type failed.');
                    return Type$1.UNKNOWN;
                  }
              }
            }

            function WebGLGetTypeSize(glType, gl) {
              switch (glType) {
                case gl.BOOL:
                  return 4;

                case gl.BOOL_VEC2:
                  return 8;

                case gl.BOOL_VEC3:
                  return 12;

                case gl.BOOL_VEC4:
                  return 16;

                case gl.INT:
                  return 4;

                case gl.INT_VEC2:
                  return 8;

                case gl.INT_VEC3:
                  return 12;

                case gl.INT_VEC4:
                  return 16;

                case gl.UNSIGNED_INT:
                  return 4;

                case gl.FLOAT:
                  return 4;

                case gl.FLOAT_VEC2:
                  return 8;

                case gl.FLOAT_VEC3:
                  return 12;

                case gl.FLOAT_VEC4:
                  return 16;

                case gl.FLOAT_MAT2:
                  return 16;

                case gl.FLOAT_MAT3:
                  return 36;

                case gl.FLOAT_MAT4:
                  return 64;

                case gl.SAMPLER_2D:
                  return 4;

                case gl.SAMPLER_CUBE:
                  return 4;

                default:
                  {
                    console.error('Unsupported GLType, get type failed.');
                    return 0;
                  }
              }
            }

            function WebGLGetComponentCount(glType, gl) {
              switch (glType) {
                case gl.FLOAT_MAT2:
                  return 2;

                case gl.FLOAT_MAT3:
                  return 3;

                case gl.FLOAT_MAT4:
                  return 4;

                default:
                  {
                    return 1;
                  }
              }
            }

            const WebGLCmpFuncs = [0x0200, 0x0201, 0x0202, 0x0203, 0x0204, 0x0205, 0x0206, 0x0207];
            const WebGLStencilOps = [0x0000, 0x1E00, 0x1E01, 0x1E02, 0x1E03, 0x150A, 0x8507, 0x8508];
            const WebGLBlendOps = [0x8006, 0x800A, 0x800B, 0x8007, 0x8008];
            const WebGLBlendFactors = [0x0000, 0x0001, 0x0302, 0x0304, 0x0303, 0x0305, 0x0300, 0x0306, 0x0301, 0x0307, 0x0308, 0x8001, 0x8002, 0x8003, 0x8004];
            let WebGLCmd;

            (function (WebGLCmd) {
              WebGLCmd[WebGLCmd["BEGIN_RENDER_PASS"] = 0] = "BEGIN_RENDER_PASS";
              WebGLCmd[WebGLCmd["END_RENDER_PASS"] = 1] = "END_RENDER_PASS";
              WebGLCmd[WebGLCmd["BIND_STATES"] = 2] = "BIND_STATES";
              WebGLCmd[WebGLCmd["DRAW"] = 3] = "DRAW";
              WebGLCmd[WebGLCmd["UPDATE_BUFFER"] = 4] = "UPDATE_BUFFER";
              WebGLCmd[WebGLCmd["COPY_BUFFER_TO_TEXTURE"] = 5] = "COPY_BUFFER_TO_TEXTURE";
              WebGLCmd[WebGLCmd["COUNT"] = 6] = "COUNT";
            })(WebGLCmd || (WebGLCmd = {}));

            class WebGLCmdObject {
              constructor(type) {
                this.cmdType = void 0;
                this.refCount = 0;
                this.cmdType = type;
              }

            }
            class WebGLCmdBeginRenderPass extends WebGLCmdObject {
              constructor() {
                super(WebGLCmd.BEGIN_RENDER_PASS);
                this.gpuRenderPass = null;
                this.gpuFramebuffer = null;
                this.renderArea = new Rect();
                this.clearFlag = ClearFlagBit.NONE;
                this.clearColors = [];
                this.clearDepth = 1.0;
                this.clearStencil = 0;
              }

              clear() {
                this.gpuFramebuffer = null;
                this.clearColors.length = 0;
              }

            }
            class WebGLCmdBindStates extends WebGLCmdObject {
              constructor() {
                super(WebGLCmd.BIND_STATES);
                this.gpuPipelineState = null;
                this.gpuInputAssembler = null;
                this.gpuDescriptorSets = [];
                this.dynamicOffsets = [];
                this.dynamicStates = new DynamicStates();
              }

              clear() {
                this.gpuPipelineState = null;
                this.gpuDescriptorSets.length = 0;
                this.gpuInputAssembler = null;
                this.dynamicOffsets.length = 0;
              }

            }
            class WebGLCmdDraw extends WebGLCmdObject {
              constructor() {
                super(WebGLCmd.DRAW);
                this.drawInfo = new DrawInfo();
              }

              clear() {}

            }
            class WebGLCmdUpdateBuffer extends WebGLCmdObject {
              constructor() {
                super(WebGLCmd.UPDATE_BUFFER);
                this.gpuBuffer = null;
                this.buffer = null;
                this.offset = 0;
                this.size = 0;
              }

              clear() {
                this.gpuBuffer = null;
                this.buffer = null;
              }

            }
            class WebGLCmdCopyBufferToTexture extends WebGLCmdObject {
              constructor() {
                super(WebGLCmd.COPY_BUFFER_TO_TEXTURE);
                this.gpuTexture = null;
                this.buffers = [];
                this.regions = [];
              }

              clear() {
                this.gpuTexture = null;
                this.buffers.length = 0;
                this.regions.length = 0;
              }

            }
            class WebGLCmdPackage {
              constructor() {
                this.cmds = new CachedArray(1);
                this.beginRenderPassCmds = new CachedArray(1);
                this.bindStatesCmds = new CachedArray(1);
                this.drawCmds = new CachedArray(1);
                this.updateBufferCmds = new CachedArray(1);
                this.copyBufferToTextureCmds = new CachedArray(1);
              }

              clearCmds(allocator) {
                if (this.beginRenderPassCmds.length) {
                  allocator.beginRenderPassCmdPool.freeCmds(this.beginRenderPassCmds);
                  this.beginRenderPassCmds.clear();
                }

                if (this.bindStatesCmds.length) {
                  allocator.bindStatesCmdPool.freeCmds(this.bindStatesCmds);
                  this.bindStatesCmds.clear();
                }

                if (this.drawCmds.length) {
                  allocator.drawCmdPool.freeCmds(this.drawCmds);
                  this.drawCmds.clear();
                }

                if (this.updateBufferCmds.length) {
                  allocator.updateBufferCmdPool.freeCmds(this.updateBufferCmds);
                  this.updateBufferCmds.clear();
                }

                if (this.copyBufferToTextureCmds.length) {
                  allocator.copyBufferToTextureCmdPool.freeCmds(this.copyBufferToTextureCmds);
                  this.copyBufferToTextureCmds.clear();
                }

                this.cmds.clear();
              }

            }
            function WebGLCmdFuncCreateBuffer(device, gpuBuffer) {
              const {
                gl
              } = device;
              const cache = device.stateCache;
              const glUsage = gpuBuffer.memUsage & MemoryUsageBit.HOST ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

              if (gpuBuffer.usage & BufferUsageBit.VERTEX) {
                gpuBuffer.glTarget = gl.ARRAY_BUFFER;
                const glBuffer = gl.createBuffer();

                if (glBuffer) {
                  gpuBuffer.glBuffer = glBuffer;

                  if (gpuBuffer.size > 0) {
                    if (device.extensions.useVAO) {
                      if (cache.glVAO) {
                        device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
                        cache.glVAO = null;
                      }
                    }

                    gfxStateCache.gpuInputAssembler = null;

                    if (device.stateCache.glArrayBuffer !== gpuBuffer.glBuffer) {
                      gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer);
                      device.stateCache.glArrayBuffer = gpuBuffer.glBuffer;
                    }

                    gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.size, glUsage);
                    gl.bindBuffer(gl.ARRAY_BUFFER, null);
                    device.stateCache.glArrayBuffer = null;
                  }
                }
              } else if (gpuBuffer.usage & BufferUsageBit.INDEX) {
                gpuBuffer.glTarget = gl.ELEMENT_ARRAY_BUFFER;
                const glBuffer = gl.createBuffer();

                if (glBuffer) {
                  gpuBuffer.glBuffer = glBuffer;

                  if (gpuBuffer.size > 0) {
                    if (device.extensions.useVAO) {
                      if (cache.glVAO) {
                        device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
                        cache.glVAO = null;
                      }
                    }

                    gfxStateCache.gpuInputAssembler = null;

                    if (device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer) {
                      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
                      device.stateCache.glElementArrayBuffer = gpuBuffer.glBuffer;
                    }

                    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.size, glUsage);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                    device.stateCache.glElementArrayBuffer = null;
                  }
                }
              } else if (gpuBuffer.usage & BufferUsageBit.UNIFORM) {
                gpuBuffer.glTarget = gl.NONE;

                if (gpuBuffer.buffer) {
                  gpuBuffer.vf32 = new Float32Array(gpuBuffer.buffer.buffer);
                }
              } else if (gpuBuffer.usage & BufferUsageBit.INDIRECT) {
                gpuBuffer.glTarget = gl.NONE;
              } else if (gpuBuffer.usage & BufferUsageBit.TRANSFER_DST) {
                gpuBuffer.glTarget = gl.NONE;
              } else if (gpuBuffer.usage & BufferUsageBit.TRANSFER_SRC) {
                gpuBuffer.glTarget = gl.NONE;
              } else {
                console.error('Unsupported BufferType, create buffer failed.');
                gpuBuffer.glTarget = gl.NONE;
              }
            }
            function WebGLCmdFuncDestroyBuffer(device, gpuBuffer) {
              const {
                gl
              } = device;
              const cache = device.stateCache;

              if (gpuBuffer.glBuffer) {
                switch (gpuBuffer.glTarget) {
                  case gl.ARRAY_BUFFER:
                    if (device.extensions.useVAO) {
                      if (cache.glVAO) {
                        device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
                        device.stateCache.glVAO = null;
                      }
                    }

                    gfxStateCache.gpuInputAssembler = null;
                    gl.bindBuffer(gl.ARRAY_BUFFER, null);
                    device.stateCache.glArrayBuffer = null;
                    break;

                  case gl.ELEMENT_ARRAY_BUFFER:
                    if (device.extensions.useVAO) {
                      if (cache.glVAO) {
                        device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
                        device.stateCache.glVAO = null;
                      }
                    }

                    gfxStateCache.gpuInputAssembler = null;
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                    device.stateCache.glElementArrayBuffer = null;
                    break;
                }

                gl.deleteBuffer(gpuBuffer.glBuffer);
                gpuBuffer.glBuffer = null;
              }
            }
            function WebGLCmdFuncResizeBuffer(device, gpuBuffer) {
              const {
                gl
              } = device;
              const cache = device.stateCache;
              const glUsage = gpuBuffer.memUsage & MemoryUsageBit.HOST ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

              if (gpuBuffer.usage & BufferUsageBit.VERTEX) {
                if (device.extensions.useVAO) {
                  if (cache.glVAO) {
                    device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
                    cache.glVAO = null;
                  }
                }

                gfxStateCache.gpuInputAssembler = null;

                if (device.stateCache.glArrayBuffer !== gpuBuffer.glBuffer) {
                  gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer);
                }

                if (gpuBuffer.buffer) {
                  gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.buffer, glUsage);
                } else {
                  gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.size, glUsage);
                }

                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                device.stateCache.glArrayBuffer = null;
              } else if (gpuBuffer.usage & BufferUsageBit.INDEX) {
                if (device.extensions.useVAO) {
                  if (cache.glVAO) {
                    device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
                    cache.glVAO = null;
                  }
                }

                gfxStateCache.gpuInputAssembler = null;

                if (device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer) {
                  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
                }

                if (gpuBuffer.buffer) {
                  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.buffer, glUsage);
                } else {
                  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.size, glUsage);
                }

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                device.stateCache.glElementArrayBuffer = null;
              } else if (gpuBuffer.usage & BufferUsageBit.UNIFORM) {
                if (gpuBuffer.buffer) {
                  gpuBuffer.vf32 = new Float32Array(gpuBuffer.buffer.buffer);
                }
              } else if (gpuBuffer.usage & BufferUsageBit.INDIRECT || gpuBuffer.usage & BufferUsageBit.TRANSFER_DST || gpuBuffer.usage & BufferUsageBit.TRANSFER_SRC) {
                gpuBuffer.glTarget = gl.NONE;
              } else {
                console.error('Unsupported BufferType, create buffer failed.');
                gpuBuffer.glTarget = gl.NONE;
              }
            }
            function WebGLCmdFuncUpdateBuffer(device, gpuBuffer, buffer, offset, size) {
              if (gpuBuffer.usage & BufferUsageBit.UNIFORM) {
                if (ArrayBuffer.isView(buffer)) {
                  gpuBuffer.vf32.set(buffer, offset / Float32Array.BYTES_PER_ELEMENT);
                } else {
                  gpuBuffer.vf32.set(new Float32Array(buffer), offset / Float32Array.BYTES_PER_ELEMENT);
                }
              } else if (gpuBuffer.usage & BufferUsageBit.INDIRECT) {
                gpuBuffer.indirects.clearDraws();
                const drawInfos = buffer.drawInfos;

                for (let i = 0; i < drawInfos.length; ++i) {
                  gpuBuffer.indirects.setDrawInfo(offset + i, drawInfos[i]);
                }
              } else {
                const buff = buffer;
                const {
                  gl
                } = device;
                const cache = device.stateCache;

                switch (gpuBuffer.glTarget) {
                  case gl.ARRAY_BUFFER:
                    {
                      if (device.extensions.useVAO) {
                        if (cache.glVAO) {
                          device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
                          cache.glVAO = null;
                        }
                      }

                      gfxStateCache.gpuInputAssembler = null;

                      if (device.stateCache.glArrayBuffer !== gpuBuffer.glBuffer) {
                        gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer);
                        device.stateCache.glArrayBuffer = gpuBuffer.glBuffer;
                      }

                      break;
                    }

                  case gl.ELEMENT_ARRAY_BUFFER:
                    {
                      if (device.extensions.useVAO) {
                        if (cache.glVAO) {
                          device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
                          cache.glVAO = null;
                        }
                      }

                      gfxStateCache.gpuInputAssembler = null;

                      if (device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer) {
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
                        device.stateCache.glElementArrayBuffer = gpuBuffer.glBuffer;
                      }

                      break;
                    }

                  default:
                    {
                      console.error('Unsupported BufferType, update buffer failed.');
                      return;
                    }
                }

                if (size === buff.byteLength) {
                  gl.bufferSubData(gpuBuffer.glTarget, offset, buff);
                } else {
                  gl.bufferSubData(gpuBuffer.glTarget, offset, buff.slice(0, size));
                }
              }
            }
            function WebGLCmdFuncCreateTexture(device, gpuTexture) {
              const {
                gl
              } = device;
              gpuTexture.glFormat = gpuTexture.glInternalFmt = GFXFormatToWebGLFormat(gpuTexture.format, gl);
              gpuTexture.glType = GFXFormatToWebGLType(gpuTexture.format, gl);
              let w = gpuTexture.width;
              let h = gpuTexture.height;

              switch (gpuTexture.type) {
                case TextureType.TEX2D:
                  {
                    gpuTexture.glTarget = gl.TEXTURE_2D;
                    if (gpuTexture.isSwapchainTexture) break;
                    const maxSize = Math.max(w, h);

                    if (maxSize > device.capabilities.maxTextureSize) {
                      errorID(9100, maxSize, device.capabilities.maxTextureSize);
                    }

                    if (!device.extensions.WEBGL_depth_texture && FormatInfos[gpuTexture.format].hasDepth) {
                      gpuTexture.glInternalFmt = GFXFormatToWebGLInternalFormat(gpuTexture.format, gl);
                      gpuTexture.glRenderbuffer = gl.createRenderbuffer();

                      if (gpuTexture.size > 0) {
                        if (device.stateCache.glRenderbuffer !== gpuTexture.glRenderbuffer) {
                          gl.bindRenderbuffer(gl.RENDERBUFFER, gpuTexture.glRenderbuffer);
                          device.stateCache.glRenderbuffer = gpuTexture.glRenderbuffer;
                        }

                        gl.renderbufferStorage(gl.RENDERBUFFER, gpuTexture.glInternalFmt, w, h);
                      }
                    } else {
                      gpuTexture.glTexture = gl.createTexture();

                      if (gpuTexture.size > 0) {
                        const glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

                        if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                          gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture);
                          glTexUnit.glTexture = gpuTexture.glTexture;
                        }

                        if (FormatInfos[gpuTexture.format].isCompressed) {
                          for (let i = 0; i < gpuTexture.mipLevel; ++i) {
                            const imgSize = FormatSize(gpuTexture.format, w, h, 1);
                            const view = new Uint8Array(imgSize);
                            gl.compressedTexImage2D(gl.TEXTURE_2D, i, gpuTexture.glInternalFmt, w, h, 0, view);
                            w = Math.max(1, w >> 1);
                            h = Math.max(1, h >> 1);
                          }
                        } else {
                          for (let i = 0; i < gpuTexture.mipLevel; ++i) {
                            gl.texImage2D(gl.TEXTURE_2D, i, gpuTexture.glInternalFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null);
                            w = Math.max(1, w >> 1);
                            h = Math.max(1, h >> 1);
                          }
                        }

                        if (gpuTexture.isPowerOf2) {
                          gpuTexture.glWrapS = gl.REPEAT;
                          gpuTexture.glWrapT = gl.REPEAT;
                        } else {
                          gpuTexture.glWrapS = gl.CLAMP_TO_EDGE;
                          gpuTexture.glWrapT = gl.CLAMP_TO_EDGE;
                        }

                        gpuTexture.glMinFilter = gl.LINEAR;
                        gpuTexture.glMagFilter = gl.LINEAR;
                        gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_S, gpuTexture.glWrapS);
                        gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_T, gpuTexture.glWrapT);
                        gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MIN_FILTER, gpuTexture.glMinFilter);
                        gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MAG_FILTER, gpuTexture.glMagFilter);
                      }
                    }

                    break;
                  }

                case TextureType.CUBE:
                  {
                    gpuTexture.glTarget = gl.TEXTURE_CUBE_MAP;
                    const maxSize = Math.max(w, h);

                    if (maxSize > device.capabilities.maxCubeMapTextureSize) {
                      errorID(9100, maxSize, device.capabilities.maxTextureSize);
                    }

                    gpuTexture.glTexture = gl.createTexture();

                    if (gpuTexture.size > 0) {
                      const glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

                      if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                        gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture);
                        glTexUnit.glTexture = gpuTexture.glTexture;
                      }

                      if (FormatInfos[gpuTexture.format].isCompressed) {
                        for (let f = 0; f < 6; ++f) {
                          w = gpuTexture.width;
                          h = gpuTexture.height;

                          for (let i = 0; i < gpuTexture.mipLevel; ++i) {
                            const imgSize = FormatSize(gpuTexture.format, w, h, 1);
                            const view = new Uint8Array(imgSize);
                            gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, i, gpuTexture.glInternalFmt, w, h, 0, view);
                            w = Math.max(1, w >> 1);
                            h = Math.max(1, h >> 1);
                          }
                        }
                      } else {
                        for (let f = 0; f < 6; ++f) {
                          w = gpuTexture.width;
                          h = gpuTexture.height;

                          for (let i = 0; i < gpuTexture.mipLevel; ++i) {
                            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, i, gpuTexture.glInternalFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null);
                            w = Math.max(1, w >> 1);
                            h = Math.max(1, h >> 1);
                          }
                        }
                      }

                      if (gpuTexture.isPowerOf2) {
                        gpuTexture.glWrapS = gl.REPEAT;
                        gpuTexture.glWrapT = gl.REPEAT;
                      } else {
                        gpuTexture.glWrapS = gl.CLAMP_TO_EDGE;
                        gpuTexture.glWrapT = gl.CLAMP_TO_EDGE;
                      }

                      gpuTexture.glMinFilter = gl.LINEAR;
                      gpuTexture.glMagFilter = gl.LINEAR;
                      gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_S, gpuTexture.glWrapS);
                      gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_T, gpuTexture.glWrapT);
                      gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MIN_FILTER, gpuTexture.glMinFilter);
                      gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MAG_FILTER, gpuTexture.glMagFilter);
                    }

                    break;
                  }

                default:
                  {
                    console.error('Unsupported TextureType, create texture failed.');
                    gpuTexture.type = TextureType.TEX2D;
                    gpuTexture.glTarget = gl.TEXTURE_2D;
                  }
              }
            }
            function WebGLCmdFuncDestroyTexture(device, gpuTexture) {
              const {
                gl
              } = device;

              if (gpuTexture.glTexture) {
                const glTexUnits = device.stateCache.glTexUnits;
                let texUnit = device.stateCache.texUnit;
                gl.deleteTexture(gpuTexture.glTexture);

                for (let i = 0; i < glTexUnits.length; i++) {
                  if (glTexUnits[i].glTexture === gpuTexture.glTexture) {
                    gl.activeTexture(gl.TEXTURE0 + i);
                    texUnit = i;
                    gl.bindTexture(gpuTexture.glTarget, null);
                    glTexUnits[i].glTexture = null;
                  }
                }

                device.stateCache.texUnit = texUnit;
                gpuTexture.glTexture = null;
              }

              if (gpuTexture.glRenderbuffer) {
                let glRenderbuffer = device.stateCache.glRenderbuffer;
                gl.deleteRenderbuffer(gpuTexture.glRenderbuffer);

                if (glRenderbuffer === gpuTexture.glRenderbuffer) {
                  gl.bindRenderbuffer(gl.RENDERBUFFER, null);
                  glRenderbuffer = null;
                }

                gpuTexture.glRenderbuffer = null;
              }
            }
            function WebGLCmdFuncResizeTexture(device, gpuTexture) {
              if (!gpuTexture.size) return;
              const {
                gl
              } = device;
              let w = gpuTexture.width;
              let h = gpuTexture.height;

              switch (gpuTexture.type) {
                case TextureType.TEX2D:
                  {
                    gpuTexture.glTarget = gl.TEXTURE_2D;
                    const maxSize = Math.max(w, h);

                    if (maxSize > device.capabilities.maxTextureSize) {
                      errorID(9100, maxSize, device.capabilities.maxTextureSize);
                    }

                    if (gpuTexture.glRenderbuffer) {
                      if (device.stateCache.glRenderbuffer !== gpuTexture.glRenderbuffer) {
                        gl.bindRenderbuffer(gl.RENDERBUFFER, gpuTexture.glRenderbuffer);
                        device.stateCache.glRenderbuffer = gpuTexture.glRenderbuffer;
                      }

                      gl.renderbufferStorage(gl.RENDERBUFFER, gpuTexture.glInternalFmt, w, h);
                    } else if (gpuTexture.glTexture) {
                      const glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

                      if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                        gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture);
                        glTexUnit.glTexture = gpuTexture.glTexture;
                      }

                      if (FormatInfos[gpuTexture.format].isCompressed) {
                        for (let i = 0; i < gpuTexture.mipLevel; ++i) {
                          const imgSize = FormatSize(gpuTexture.format, w, h, 1);
                          const view = new Uint8Array(imgSize);
                          gl.compressedTexImage2D(gl.TEXTURE_2D, i, gpuTexture.glInternalFmt, w, h, 0, view);
                          w = Math.max(1, w >> 1);
                          h = Math.max(1, h >> 1);
                        }
                      } else {
                        for (let i = 0; i < gpuTexture.mipLevel; ++i) {
                          gl.texImage2D(gl.TEXTURE_2D, i, gpuTexture.glInternalFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null);
                          w = Math.max(1, w >> 1);
                          h = Math.max(1, h >> 1);
                        }
                      }
                    }

                    break;
                  }

                case TextureType.CUBE:
                  {
                    gpuTexture.glTarget = gl.TEXTURE_CUBE_MAP;
                    const maxSize = Math.max(w, h);

                    if (maxSize > device.capabilities.maxCubeMapTextureSize) {
                      errorID(9100, maxSize, device.capabilities.maxTextureSize);
                    }

                    const glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

                    if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                      gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture);
                      glTexUnit.glTexture = gpuTexture.glTexture;
                    }

                    if (FormatInfos[gpuTexture.format].isCompressed) {
                      for (let f = 0; f < 6; ++f) {
                        w = gpuTexture.width;
                        h = gpuTexture.height;

                        for (let i = 0; i < gpuTexture.mipLevel; ++i) {
                          const imgSize = FormatSize(gpuTexture.format, w, h, 1);
                          const view = new Uint8Array(imgSize);
                          gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, i, gpuTexture.glInternalFmt, w, h, 0, view);
                          w = Math.max(1, w >> 1);
                          h = Math.max(1, h >> 1);
                        }
                      }
                    } else {
                      for (let f = 0; f < 6; ++f) {
                        w = gpuTexture.width;
                        h = gpuTexture.height;

                        for (let i = 0; i < gpuTexture.mipLevel; ++i) {
                          gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, i, gpuTexture.glInternalFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null);
                          w = Math.max(1, w >> 1);
                          h = Math.max(1, h >> 1);
                        }
                      }
                    }

                    break;
                  }

                default:
                  {
                    console.error('Unsupported TextureType, create texture failed.');
                    gpuTexture.type = TextureType.TEX2D;
                    gpuTexture.glTarget = gl.TEXTURE_2D;
                  }
              }
            }
            function WebGLCmdFuncCreateFramebuffer(device, gpuFramebuffer) {
              for (let i = 0; i < gpuFramebuffer.gpuColorTextures.length; ++i) {
                const tex = gpuFramebuffer.gpuColorTextures[i];

                if (tex.isSwapchainTexture) {
                  gpuFramebuffer.isOffscreen = false;
                  return;
                }
              }

              const {
                gl
              } = device;
              const attachments = [];
              const glFramebuffer = gl.createFramebuffer();

              if (glFramebuffer) {
                gpuFramebuffer.glFramebuffer = glFramebuffer;

                if (device.stateCache.glFramebuffer !== gpuFramebuffer.glFramebuffer) {
                  gl.bindFramebuffer(gl.FRAMEBUFFER, gpuFramebuffer.glFramebuffer);
                }

                for (let i = 0; i < gpuFramebuffer.gpuColorTextures.length; ++i) {
                  const gpuTexture = gpuFramebuffer.gpuColorTextures[i];

                  if (gpuTexture) {
                    if (gpuTexture.glTexture) {
                      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gpuTexture.glTarget, gpuTexture.glTexture, 0);
                    } else {
                      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, gpuTexture.glRenderbuffer);
                    }

                    attachments.push(gl.COLOR_ATTACHMENT0 + i);
                    gpuFramebuffer.width = Math.min(gpuFramebuffer.width, gpuTexture.width);
                    gpuFramebuffer.height = Math.min(gpuFramebuffer.height, gpuTexture.height);
                  }
                }

                const dst = gpuFramebuffer.gpuDepthStencilTexture;

                if (dst) {
                  const glAttachment = FormatInfos[dst.format].hasStencil ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;

                  if (dst.glTexture) {
                    gl.framebufferTexture2D(gl.FRAMEBUFFER, glAttachment, dst.glTarget, dst.glTexture, 0);
                  } else {
                    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, glAttachment, gl.RENDERBUFFER, dst.glRenderbuffer);
                  }

                  gpuFramebuffer.width = Math.min(gpuFramebuffer.width, dst.width);
                  gpuFramebuffer.height = Math.min(gpuFramebuffer.height, dst.height);
                }

                if (device.extensions.WEBGL_draw_buffers) {
                  device.extensions.WEBGL_draw_buffers.drawBuffersWEBGL(attachments);
                }

                const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

                if (status !== gl.FRAMEBUFFER_COMPLETE) {
                  switch (status) {
                    case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                      {
                        console.error('glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_ATTACHMENT');
                        break;
                      }

                    case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                      {
                        console.error('glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT');
                        break;
                      }

                    case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                      {
                        console.error('glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_DIMENSIONS');
                        break;
                      }

                    case gl.FRAMEBUFFER_UNSUPPORTED:
                      {
                        console.error('glCheckFramebufferStatus() - FRAMEBUFFER_UNSUPPORTED');
                        break;
                      }
                  }
                }

                if (device.stateCache.glFramebuffer !== gpuFramebuffer.glFramebuffer) {
                  gl.bindFramebuffer(gl.FRAMEBUFFER, device.stateCache.glFramebuffer);
                }
              }
            }
            function WebGLCmdFuncDestroyFramebuffer(device, gpuFramebuffer) {
              if (gpuFramebuffer.glFramebuffer) {
                device.gl.deleteFramebuffer(gpuFramebuffer.glFramebuffer);

                if (device.stateCache.glFramebuffer === gpuFramebuffer.glFramebuffer) {
                  device.gl.bindFramebuffer(device.gl.FRAMEBUFFER, null);
                  device.stateCache.glFramebuffer = null;
                }

                gpuFramebuffer.glFramebuffer = null;
              }
            }
            function WebGLCmdFuncCreateShader(device, gpuShader) {
              const {
                gl
              } = device;

              for (let k = 0; k < gpuShader.gpuStages.length; k++) {
                const gpuStage = gpuShader.gpuStages[k];
                let glShaderType = 0;
                let shaderTypeStr = '';
                let lineNumber = 1;

                switch (gpuStage.type) {
                  case ShaderStageFlagBit.VERTEX:
                    {
                      shaderTypeStr = 'VertexShader';
                      glShaderType = gl.VERTEX_SHADER;
                      break;
                    }

                  case ShaderStageFlagBit.FRAGMENT:
                    {
                      shaderTypeStr = 'FragmentShader';
                      glShaderType = gl.FRAGMENT_SHADER;
                      break;
                    }

                  default:
                    {
                      console.error('Unsupported ShaderType.');
                      return;
                    }
                }

                const glShader = gl.createShader(glShaderType);

                if (glShader) {
                  gpuStage.glShader = glShader;
                  gl.shaderSource(gpuStage.glShader, gpuStage.source);
                  gl.compileShader(gpuStage.glShader);

                  if (!gl.getShaderParameter(gpuStage.glShader, gl.COMPILE_STATUS)) {
                    console.error(`${shaderTypeStr} in '${gpuShader.name}' compilation failed.`);
                    console.error('Shader source dump:', gpuStage.source.replace(/^|\n/g, () => `\n${lineNumber++} `));
                    console.error(gl.getShaderInfoLog(gpuStage.glShader));

                    for (let l = 0; l < gpuShader.gpuStages.length; l++) {
                      const stage = gpuShader.gpuStages[k];

                      if (stage.glShader) {
                        gl.deleteShader(stage.glShader);
                        stage.glShader = null;
                      }
                    }

                    return;
                  }
                }
              }

              const glProgram = gl.createProgram();

              if (!glProgram) {
                return;
              }

              gpuShader.glProgram = glProgram;

              for (let k = 0; k < gpuShader.gpuStages.length; k++) {
                const gpuStage = gpuShader.gpuStages[k];
                gl.attachShader(gpuShader.glProgram, gpuStage.glShader);
              }

              gl.linkProgram(gpuShader.glProgram);

              if (device.extensions.destroyShadersImmediately) {
                for (let k = 0; k < gpuShader.gpuStages.length; k++) {
                  const gpuStage = gpuShader.gpuStages[k];

                  if (gpuStage.glShader) {
                    gl.detachShader(gpuShader.glProgram, gpuStage.glShader);
                    gl.deleteShader(gpuStage.glShader);
                    gpuStage.glShader = null;
                  }
                }
              }

              if (gl.getProgramParameter(gpuShader.glProgram, gl.LINK_STATUS)) {
                debug(`Shader '${gpuShader.name}' compilation succeeded.`);
              } else {
                console.error(`Failed to link shader '${gpuShader.name}'.`);
                console.error(gl.getProgramInfoLog(gpuShader.glProgram));
                return;
              }

              const activeAttribCount = gl.getProgramParameter(gpuShader.glProgram, gl.ACTIVE_ATTRIBUTES);
              gpuShader.glInputs = new Array(activeAttribCount);

              for (let i = 0; i < activeAttribCount; ++i) {
                const attribInfo = gl.getActiveAttrib(gpuShader.glProgram, i);

                if (attribInfo) {
                  let varName;
                  const nameOffset = attribInfo.name.indexOf('[');

                  if (nameOffset !== -1) {
                    varName = attribInfo.name.substr(0, nameOffset);
                  } else {
                    varName = attribInfo.name;
                  }

                  const glLoc = gl.getAttribLocation(gpuShader.glProgram, varName);
                  const type = WebGLTypeToGFXType(attribInfo.type, gl);
                  const stride = WebGLGetTypeSize(attribInfo.type, gl);
                  gpuShader.glInputs[i] = {
                    binding: glLoc,
                    name: varName,
                    type,
                    stride,
                    count: attribInfo.size,
                    size: stride * attribInfo.size,
                    glType: attribInfo.type,
                    glLoc
                  };
                }
              }

              if (gpuShader.blocks.length > 0) {
                gpuShader.glBlocks = new Array(gpuShader.blocks.length);

                for (let i = 0; i < gpuShader.blocks.length; ++i) {
                  const block = gpuShader.blocks[i];
                  const glBlock = {
                    set: block.set,
                    binding: block.binding,
                    name: block.name,
                    size: 0,
                    glUniforms: new Array(block.members.length),
                    glActiveUniforms: []
                  };
                  gpuShader.glBlocks[i] = glBlock;

                  for (let u = 0; u < block.members.length; ++u) {
                    const uniform = block.members[u];
                    const glType = GFXTypeToWebGLType(uniform.type, gl);
                    const stride = WebGLGetTypeSize(glType, gl);
                    const size = stride * uniform.count;
                    glBlock.glUniforms[u] = {
                      binding: -1,
                      name: uniform.name,
                      type: uniform.type,
                      stride,
                      count: uniform.count,
                      size,
                      offset: 0,
                      glType,
                      glLoc: null,
                      array: null
                    };
                  }
                }
              }

              for (let i = 0; i < gpuShader.subpassInputs.length; ++i) {
                const subpassInput = gpuShader.subpassInputs[i];
                gpuShader.samplerTextures.push(new UniformSamplerTexture(subpassInput.set, subpassInput.binding, subpassInput.name, Type$1.SAMPLER2D, subpassInput.count));
              }

              if (gpuShader.samplerTextures.length > 0) {
                gpuShader.glSamplerTextures = new Array(gpuShader.samplerTextures.length);

                for (let i = 0; i < gpuShader.samplerTextures.length; ++i) {
                  const sampler = gpuShader.samplerTextures[i];
                  gpuShader.glSamplerTextures[i] = {
                    set: sampler.set,
                    binding: sampler.binding,
                    name: sampler.name,
                    type: sampler.type,
                    count: sampler.count,
                    units: [],
                    glUnits: null,
                    glType: GFXTypeToWebGLType(sampler.type, gl),
                    glLoc: null
                  };
                }
              }

              const activeUniformCount = gl.getProgramParameter(gpuShader.glProgram, gl.ACTIVE_UNIFORMS);

              for (let i = 0; i < activeUniformCount; ++i) {
                const uniformInfo = gl.getActiveUniform(gpuShader.glProgram, i);

                if (uniformInfo) {
                  const isSampler = uniformInfo.type === gl.SAMPLER_2D || uniformInfo.type === gl.SAMPLER_CUBE;

                  if (!isSampler) {
                    const glLoc = gl.getUniformLocation(gpuShader.glProgram, uniformInfo.name);

                    if (device.extensions.isLocationActive(glLoc)) {
                      let varName;
                      const nameOffset = uniformInfo.name.indexOf('[');

                      if (nameOffset !== -1) {
                        varName = uniformInfo.name.substr(0, nameOffset);
                      } else {
                        varName = uniformInfo.name;
                      }

                      for (let j = 0; j < gpuShader.glBlocks.length; j++) {
                        const glBlock = gpuShader.glBlocks[j];

                        for (let k = 0; k < glBlock.glUniforms.length; k++) {
                          const glUniform = glBlock.glUniforms[k];

                          if (glUniform.name === varName) {
                            glUniform.glLoc = glLoc;
                            glUniform.count = uniformInfo.size;
                            glUniform.size = glUniform.stride * glUniform.count;
                            glUniform.array = new (GFXTypeToTypedArrayCtor(glUniform.type))(glUniform.size / 4);
                            glBlock.glActiveUniforms.push(glUniform);
                            break;
                          }
                        }
                      }
                    }
                  }
                }
              }

              for (let j = 0; j < gpuShader.glBlocks.length; j++) {
                const glBlock = gpuShader.glBlocks[j];

                for (let k = 0; k < glBlock.glUniforms.length; k++) {
                  const glUniform = glBlock.glUniforms[k];
                  glUniform.offset = glBlock.size / 4;
                  glBlock.size += glUniform.size;
                }
              }

              const glActiveSamplers = [];
              const glActiveSamplerLocations = [];
              const {
                bindingMappingInfo
              } = device;
              const {
                texUnitCacheMap
              } = device.stateCache;
              let flexibleSetBaseOffset = 0;

              for (let i = 0; i < gpuShader.blocks.length; ++i) {
                if (gpuShader.blocks[i].set === bindingMappingInfo.flexibleSet) {
                  flexibleSetBaseOffset++;
                }
              }

              let arrayOffset = 0;

              for (let i = 0; i < gpuShader.samplerTextures.length; ++i) {
                const sampler = gpuShader.samplerTextures[i];
                const glLoc = gl.getUniformLocation(gpuShader.glProgram, sampler.name);

                if (device.extensions.isLocationActive(glLoc)) {
                  glActiveSamplers.push(gpuShader.glSamplerTextures[i]);
                  glActiveSamplerLocations.push(glLoc);
                }

                if (texUnitCacheMap[sampler.name] === undefined) {
                  let binding = sampler.binding + bindingMappingInfo.samplerOffsets[sampler.set] + arrayOffset;

                  if (sampler.set === bindingMappingInfo.flexibleSet) {
                    binding -= flexibleSetBaseOffset;
                  }

                  texUnitCacheMap[sampler.name] = binding % device.capabilities.maxTextureUnits;
                  arrayOffset += sampler.count - 1;
                }
              }

              if (glActiveSamplers.length) {
                const usedTexUnits = [];

                for (let i = 0; i < glActiveSamplers.length; ++i) {
                  const glSampler = glActiveSamplers[i];
                  let cachedUnit = texUnitCacheMap[glSampler.name];

                  if (cachedUnit !== undefined) {
                    glSampler.glLoc = glActiveSamplerLocations[i];

                    for (let t = 0; t < glSampler.count; ++t) {
                      while (usedTexUnits[cachedUnit]) {
                        cachedUnit = (cachedUnit + 1) % device.capabilities.maxTextureUnits;
                      }

                      glSampler.units.push(cachedUnit);
                      usedTexUnits[cachedUnit] = true;
                    }
                  }
                }

                let unitIdx = 0;

                for (let i = 0; i < glActiveSamplers.length; ++i) {
                  const glSampler = glActiveSamplers[i];

                  if (!device.extensions.isLocationActive(glSampler.glLoc)) {
                    glSampler.glLoc = glActiveSamplerLocations[i];

                    for (let t = 0; t < glSampler.count; ++t) {
                      while (usedTexUnits[unitIdx]) {
                        unitIdx = (unitIdx + 1) % device.capabilities.maxTextureUnits;
                      }

                      if (texUnitCacheMap[glSampler.name] === undefined) {
                        texUnitCacheMap[glSampler.name] = unitIdx;
                      }

                      glSampler.units.push(unitIdx);
                      usedTexUnits[unitIdx] = true;
                    }
                  }
                }

                if (device.stateCache.glProgram !== gpuShader.glProgram) {
                  gl.useProgram(gpuShader.glProgram);
                }

                for (let i = 0; i < glActiveSamplers.length; i++) {
                  const glSampler = glActiveSamplers[i];
                  glSampler.glUnits = new Int32Array(glSampler.units);
                  gl.uniform1iv(glSampler.glLoc, glSampler.glUnits);
                }

                if (device.stateCache.glProgram !== gpuShader.glProgram) {
                  gl.useProgram(device.stateCache.glProgram);
                }
              }

              for (let i = 0; i < gpuShader.glBlocks.length;) {
                if (gpuShader.glBlocks[i].glActiveUniforms.length) {
                  i++;
                } else {
                  gpuShader.glBlocks[i] = gpuShader.glBlocks[gpuShader.glBlocks.length - 1];
                  gpuShader.glBlocks.length--;
                }
              }

              gpuShader.glSamplerTextures = glActiveSamplers;
            }
            function WebGLCmdFuncDestroyShader(device, gpuShader) {
              if (gpuShader.glProgram) {
                const {
                  gl
                } = device;

                if (!device.extensions.destroyShadersImmediately) {
                  for (let k = 0; k < gpuShader.gpuStages.length; k++) {
                    const gpuStage = gpuShader.gpuStages[k];

                    if (gpuStage.glShader) {
                      gl.detachShader(gpuShader.glProgram, gpuStage.glShader);
                      gl.deleteShader(gpuStage.glShader);
                      gpuStage.glShader = null;
                    }
                  }
                }

                gl.deleteProgram(gpuShader.glProgram);

                if (device.stateCache.glProgram === gpuShader.glProgram) {
                  device.gl.useProgram(null);
                  device.stateCache.glProgram = null;
                }

                gpuShader.glProgram = null;
              }
            }
            function WebGLCmdFuncCreateInputAssember(device, gpuInputAssembler) {
              const {
                gl
              } = device;
              gpuInputAssembler.glAttribs = new Array(gpuInputAssembler.attributes.length);
              const offsets = [0, 0, 0, 0, 0, 0, 0, 0];

              for (let i = 0; i < gpuInputAssembler.attributes.length; ++i) {
                const attrib = gpuInputAssembler.attributes[i];
                const stream = attrib.stream !== undefined ? attrib.stream : 0;
                const gpuBuffer = gpuInputAssembler.gpuVertexBuffers[stream];
                const glType = GFXFormatToWebGLType(attrib.format, gl);
                const {
                  size
                } = FormatInfos[attrib.format];
                gpuInputAssembler.glAttribs[i] = {
                  name: attrib.name,
                  glBuffer: gpuBuffer.glBuffer,
                  glType,
                  size,
                  count: FormatInfos[attrib.format].count,
                  stride: gpuBuffer.stride,
                  componentCount: WebGLGetComponentCount(glType, gl),
                  isNormalized: attrib.isNormalized !== undefined ? attrib.isNormalized : false,
                  isInstanced: attrib.isInstanced !== undefined ? attrib.isInstanced : false,
                  offset: offsets[stream]
                };
                offsets[stream] += size;
              }
            }
            function WebGLCmdFuncDestroyInputAssembler(device, gpuInputAssembler) {
              const it = gpuInputAssembler.glVAOs.values();
              let res = it.next();
              const OES_vertex_array_object = device.extensions.OES_vertex_array_object;
              let glVAO = device.stateCache.glVAO;

              while (!res.done) {
                OES_vertex_array_object.deleteVertexArrayOES(res.value);

                if (glVAO === res.value) {
                  OES_vertex_array_object.bindVertexArrayOES(null);
                  glVAO = null;
                }

                res = it.next();
              }

              device.stateCache.glVAO = glVAO;
              gpuInputAssembler.glVAOs.clear();
            }
            const gfxStateCache = {
              gpuPipelineState: null,
              gpuInputAssembler: null,
              glPrimitive: 0
            };
            function WebGLCmdFuncBeginRenderPass(device, gpuRenderPass, gpuFramebuffer, renderArea, clearColors, clearDepth, clearStencil) {
              const {
                gl
              } = device;
              const cache = device.stateCache;
              let clears = 0;

              if (gpuFramebuffer && gpuRenderPass) {
                if (cache.glFramebuffer !== gpuFramebuffer.glFramebuffer) {
                  gl.bindFramebuffer(gl.FRAMEBUFFER, gpuFramebuffer.glFramebuffer);
                  cache.glFramebuffer = gpuFramebuffer.glFramebuffer;
                }

                if (cache.viewport.left !== renderArea.x || cache.viewport.top !== renderArea.y || cache.viewport.width !== renderArea.width || cache.viewport.height !== renderArea.height) {
                  gl.viewport(renderArea.x, renderArea.y, renderArea.width, renderArea.height);
                  cache.viewport.left = renderArea.x;
                  cache.viewport.top = renderArea.y;
                  cache.viewport.width = renderArea.width;
                  cache.viewport.height = renderArea.height;
                }

                if (cache.scissorRect.x !== renderArea.x || cache.scissorRect.y !== renderArea.y || cache.scissorRect.width !== renderArea.width || cache.scissorRect.height !== renderArea.height) {
                  gl.scissor(renderArea.x, renderArea.y, renderArea.width, renderArea.height);
                  cache.scissorRect.x = renderArea.x;
                  cache.scissorRect.y = renderArea.y;
                  cache.scissorRect.width = renderArea.width;
                  cache.scissorRect.height = renderArea.height;
                }

                let clearCount = clearColors.length;

                if (!device.extensions.WEBGL_draw_buffers) {
                  clearCount = 1;
                }

                for (let j = 0; j < clearCount; ++j) {
                  const colorAttachment = gpuRenderPass.colorAttachments[j];

                  if (colorAttachment.format !== Format.UNKNOWN) {
                    switch (colorAttachment.loadOp) {
                      case LoadOp.LOAD:
                        break;

                      case LoadOp.CLEAR:
                        {
                          if (cache.bs.targets[0].blendColorMask !== ColorMask.ALL) {
                            gl.colorMask(true, true, true, true);
                          }

                          const clearColor = clearColors[0];
                          gl.clearColor(clearColor.x, clearColor.y, clearColor.z, clearColor.w);
                          clears |= gl.COLOR_BUFFER_BIT;
                          break;
                        }

                      case LoadOp.DISCARD:
                        {
                          break;
                        }
                    }
                  }
                }

                if (gpuRenderPass.depthStencilAttachment) {
                  if (gpuRenderPass.depthStencilAttachment.format !== Format.UNKNOWN) {
                    switch (gpuRenderPass.depthStencilAttachment.depthLoadOp) {
                      case LoadOp.LOAD:
                        break;

                      case LoadOp.CLEAR:
                        {
                          if (!cache.dss.depthWrite) {
                            gl.depthMask(true);
                          }

                          gl.clearDepth(clearDepth);
                          clears |= gl.DEPTH_BUFFER_BIT;
                          break;
                        }

                      case LoadOp.DISCARD:
                        {
                          break;
                        }
                    }

                    if (FormatInfos[gpuRenderPass.depthStencilAttachment.format].hasStencil) {
                      switch (gpuRenderPass.depthStencilAttachment.stencilLoadOp) {
                        case LoadOp.LOAD:
                          break;

                        case LoadOp.CLEAR:
                          {
                            if (!cache.dss.stencilWriteMaskFront) {
                              gl.stencilMaskSeparate(gl.FRONT, 0xffff);
                            }

                            if (!cache.dss.stencilWriteMaskBack) {
                              gl.stencilMaskSeparate(gl.BACK, 0xffff);
                            }

                            gl.clearStencil(clearStencil);
                            clears |= gl.STENCIL_BUFFER_BIT;
                            break;
                          }

                        case LoadOp.DISCARD:
                          {
                            break;
                          }
                      }
                    }
                  }
                }

                if (clears) {
                  gl.clear(clears);
                }

                if (clears & gl.COLOR_BUFFER_BIT) {
                  const colorMask = cache.bs.targets[0].blendColorMask;

                  if (colorMask !== ColorMask.ALL) {
                    const r = (colorMask & ColorMask.R) !== ColorMask.NONE;
                    const g = (colorMask & ColorMask.G) !== ColorMask.NONE;
                    const b = (colorMask & ColorMask.B) !== ColorMask.NONE;
                    const a = (colorMask & ColorMask.A) !== ColorMask.NONE;
                    gl.colorMask(r, g, b, a);
                  }
                }

                if (clears & gl.DEPTH_BUFFER_BIT && !cache.dss.depthWrite) {
                  gl.depthMask(false);
                }

                if (clears & gl.STENCIL_BUFFER_BIT) {
                  if (!cache.dss.stencilWriteMaskFront) {
                    gl.stencilMaskSeparate(gl.FRONT, 0);
                  }

                  if (!cache.dss.stencilWriteMaskBack) {
                    gl.stencilMaskSeparate(gl.BACK, 0);
                  }
                }
              }
            }
            function WebGLCmdFuncBindStates(device, gpuPipelineState, gpuInputAssembler, gpuDescriptorSets, dynamicOffsets, dynamicStates) {
              const {
                gl
              } = device;
              const cache = device.stateCache;
              const gpuShader = gpuPipelineState && gpuPipelineState.gpuShader;
              let isShaderChanged = false;
              let glWrapS;
              let glWrapT;
              let glMinFilter;

              if (gpuPipelineState && gfxStateCache.gpuPipelineState !== gpuPipelineState) {
                gfxStateCache.gpuPipelineState = gpuPipelineState;
                gfxStateCache.glPrimitive = gpuPipelineState.glPrimitive;

                if (gpuPipelineState.gpuShader) {
                  const {
                    glProgram
                  } = gpuPipelineState.gpuShader;

                  if (cache.glProgram !== glProgram) {
                    gl.useProgram(glProgram);
                    cache.glProgram = glProgram;
                    isShaderChanged = true;
                  }
                }

                const {
                  rs
                } = gpuPipelineState;

                if (rs) {
                  if (cache.rs.cullMode !== rs.cullMode) {
                    switch (rs.cullMode) {
                      case CullMode.NONE:
                        {
                          gl.disable(gl.CULL_FACE);
                          break;
                        }

                      case CullMode.FRONT:
                        {
                          gl.enable(gl.CULL_FACE);
                          gl.cullFace(gl.FRONT);
                          break;
                        }

                      case CullMode.BACK:
                        {
                          gl.enable(gl.CULL_FACE);
                          gl.cullFace(gl.BACK);
                          break;
                        }
                    }

                    cache.rs.cullMode = rs.cullMode;
                  }

                  const isFrontFaceCCW = rs.isFrontFaceCCW;

                  if (cache.rs.isFrontFaceCCW !== isFrontFaceCCW) {
                    gl.frontFace(isFrontFaceCCW ? gl.CCW : gl.CW);
                    cache.rs.isFrontFaceCCW = isFrontFaceCCW;
                  }

                  if (cache.rs.depthBias !== rs.depthBias || cache.rs.depthBiasSlop !== rs.depthBiasSlop) {
                    gl.polygonOffset(rs.depthBias, rs.depthBiasSlop);
                    cache.rs.depthBias = rs.depthBias;
                    cache.rs.depthBiasSlop = rs.depthBiasSlop;
                  }

                  if (cache.rs.lineWidth !== rs.lineWidth) {
                    gl.lineWidth(rs.lineWidth);
                    cache.rs.lineWidth = rs.lineWidth;
                  }
                }

                const {
                  dss
                } = gpuPipelineState;

                if (dss) {
                  if (cache.dss.depthTest !== dss.depthTest) {
                    if (dss.depthTest) {
                      gl.enable(gl.DEPTH_TEST);
                    } else {
                      gl.disable(gl.DEPTH_TEST);
                    }

                    cache.dss.depthTest = dss.depthTest;
                  }

                  if (cache.dss.depthWrite !== dss.depthWrite) {
                    gl.depthMask(dss.depthWrite);
                    cache.dss.depthWrite = dss.depthWrite;
                  }

                  if (cache.dss.depthFunc !== dss.depthFunc) {
                    gl.depthFunc(WebGLCmpFuncs[dss.depthFunc]);
                    cache.dss.depthFunc = dss.depthFunc;
                  }

                  if (cache.dss.stencilTestFront !== dss.stencilTestFront || cache.dss.stencilTestBack !== dss.stencilTestBack) {
                    if (dss.stencilTestFront || dss.stencilTestBack) {
                      gl.enable(gl.STENCIL_TEST);
                    } else {
                      gl.disable(gl.STENCIL_TEST);
                    }

                    cache.dss.stencilTestFront = dss.stencilTestFront;
                    cache.dss.stencilTestBack = dss.stencilTestBack;
                  }

                  if (cache.dss.stencilFuncFront !== dss.stencilFuncFront || cache.dss.stencilRefFront !== dss.stencilRefFront || cache.dss.stencilReadMaskFront !== dss.stencilReadMaskFront) {
                    gl.stencilFuncSeparate(gl.FRONT, WebGLCmpFuncs[dss.stencilFuncFront], dss.stencilRefFront, dss.stencilReadMaskFront);
                    cache.dss.stencilFuncFront = dss.stencilFuncFront;
                    cache.dss.stencilRefFront = dss.stencilRefFront;
                    cache.dss.stencilReadMaskFront = dss.stencilReadMaskFront;
                  }

                  if (cache.dss.stencilFailOpFront !== dss.stencilFailOpFront || cache.dss.stencilZFailOpFront !== dss.stencilZFailOpFront || cache.dss.stencilPassOpFront !== dss.stencilPassOpFront) {
                    gl.stencilOpSeparate(gl.FRONT, WebGLStencilOps[dss.stencilFailOpFront], WebGLStencilOps[dss.stencilZFailOpFront], WebGLStencilOps[dss.stencilPassOpFront]);
                    cache.dss.stencilFailOpFront = dss.stencilFailOpFront;
                    cache.dss.stencilZFailOpFront = dss.stencilZFailOpFront;
                    cache.dss.stencilPassOpFront = dss.stencilPassOpFront;
                  }

                  if (cache.dss.stencilWriteMaskFront !== dss.stencilWriteMaskFront) {
                    gl.stencilMaskSeparate(gl.FRONT, dss.stencilWriteMaskFront);
                    cache.dss.stencilWriteMaskFront = dss.stencilWriteMaskFront;
                  }

                  if (cache.dss.stencilFuncBack !== dss.stencilFuncBack || cache.dss.stencilRefBack !== dss.stencilRefBack || cache.dss.stencilReadMaskBack !== dss.stencilReadMaskBack) {
                    gl.stencilFuncSeparate(gl.BACK, WebGLCmpFuncs[dss.stencilFuncBack], dss.stencilRefBack, dss.stencilReadMaskBack);
                    cache.dss.stencilFuncBack = dss.stencilFuncBack;
                    cache.dss.stencilRefBack = dss.stencilRefBack;
                    cache.dss.stencilReadMaskBack = dss.stencilReadMaskBack;
                  }

                  if (cache.dss.stencilFailOpBack !== dss.stencilFailOpBack || cache.dss.stencilZFailOpBack !== dss.stencilZFailOpBack || cache.dss.stencilPassOpBack !== dss.stencilPassOpBack) {
                    gl.stencilOpSeparate(gl.BACK, WebGLStencilOps[dss.stencilFailOpBack], WebGLStencilOps[dss.stencilZFailOpBack], WebGLStencilOps[dss.stencilPassOpBack]);
                    cache.dss.stencilFailOpBack = dss.stencilFailOpBack;
                    cache.dss.stencilZFailOpBack = dss.stencilZFailOpBack;
                    cache.dss.stencilPassOpBack = dss.stencilPassOpBack;
                  }

                  if (cache.dss.stencilWriteMaskBack !== dss.stencilWriteMaskBack) {
                    gl.stencilMaskSeparate(gl.BACK, dss.stencilWriteMaskBack);
                    cache.dss.stencilWriteMaskBack = dss.stencilWriteMaskBack;
                  }
                }

                const {
                  bs
                } = gpuPipelineState;

                if (bs) {
                  if (cache.bs.isA2C !== bs.isA2C) {
                    if (bs.isA2C) {
                      gl.enable(gl.SAMPLE_ALPHA_TO_COVERAGE);
                    } else {
                      gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
                    }

                    cache.bs.isA2C = bs.isA2C;
                  }

                  if (cache.bs.blendColor.x !== bs.blendColor.x || cache.bs.blendColor.y !== bs.blendColor.y || cache.bs.blendColor.z !== bs.blendColor.z || cache.bs.blendColor.w !== bs.blendColor.w) {
                    gl.blendColor(bs.blendColor.x, bs.blendColor.y, bs.blendColor.z, bs.blendColor.w);
                    cache.bs.blendColor.x = bs.blendColor.x;
                    cache.bs.blendColor.y = bs.blendColor.y;
                    cache.bs.blendColor.z = bs.blendColor.z;
                    cache.bs.blendColor.w = bs.blendColor.w;
                  }

                  const target0 = bs.targets[0];
                  const target0Cache = cache.bs.targets[0];

                  if (target0Cache.blend !== target0.blend) {
                    if (target0.blend) {
                      gl.enable(gl.BLEND);
                    } else {
                      gl.disable(gl.BLEND);
                    }

                    target0Cache.blend = target0.blend;
                  }

                  if (target0Cache.blendEq !== target0.blendEq || target0Cache.blendAlphaEq !== target0.blendAlphaEq) {
                    gl.blendEquationSeparate(WebGLBlendOps[target0.blendEq], WebGLBlendOps[target0.blendAlphaEq]);
                    target0Cache.blendEq = target0.blendEq;
                    target0Cache.blendAlphaEq = target0.blendAlphaEq;
                  }

                  if (target0Cache.blendSrc !== target0.blendSrc || target0Cache.blendDst !== target0.blendDst || target0Cache.blendSrcAlpha !== target0.blendSrcAlpha || target0Cache.blendDstAlpha !== target0.blendDstAlpha) {
                    gl.blendFuncSeparate(WebGLBlendFactors[target0.blendSrc], WebGLBlendFactors[target0.blendDst], WebGLBlendFactors[target0.blendSrcAlpha], WebGLBlendFactors[target0.blendDstAlpha]);
                    target0Cache.blendSrc = target0.blendSrc;
                    target0Cache.blendDst = target0.blendDst;
                    target0Cache.blendSrcAlpha = target0.blendSrcAlpha;
                    target0Cache.blendDstAlpha = target0.blendDstAlpha;
                  }

                  if (target0Cache.blendColorMask !== target0.blendColorMask) {
                    gl.colorMask((target0.blendColorMask & ColorMask.R) !== ColorMask.NONE, (target0.blendColorMask & ColorMask.G) !== ColorMask.NONE, (target0.blendColorMask & ColorMask.B) !== ColorMask.NONE, (target0.blendColorMask & ColorMask.A) !== ColorMask.NONE);
                    target0Cache.blendColorMask = target0.blendColorMask;
                  }
                }
              }

              if (gpuPipelineState && gpuPipelineState.gpuPipelineLayout && gpuShader) {
                const blockLen = gpuShader.glBlocks.length;
                const {
                  dynamicOffsetIndices
                } = gpuPipelineState.gpuPipelineLayout;

                for (let j = 0; j < blockLen; j++) {
                  const glBlock = gpuShader.glBlocks[j];
                  const gpuDescriptorSet = gpuDescriptorSets[glBlock.set];
                  const descriptorIdx = gpuDescriptorSet && gpuDescriptorSet.descriptorIndices[glBlock.binding];
                  const gpuDescriptor = descriptorIdx >= 0 && gpuDescriptorSet.gpuDescriptors[descriptorIdx];
                  let vf32 = null;
                  let offset = 0;

                  if (gpuDescriptor && gpuDescriptor.gpuBuffer) {
                    const {
                      gpuBuffer
                    } = gpuDescriptor;
                    const dynamicOffsetIndexSet = dynamicOffsetIndices[glBlock.set];
                    const dynamicOffsetIndex = dynamicOffsetIndexSet && dynamicOffsetIndexSet[glBlock.binding];

                    if (dynamicOffsetIndex >= 0) {
                      offset = dynamicOffsets[dynamicOffsetIndex];
                    }

                    if ('vf32' in gpuBuffer) {
                      vf32 = gpuBuffer.vf32;
                    } else {
                      offset += gpuBuffer.offset;
                      vf32 = gpuBuffer.gpuBuffer.vf32;
                    }

                    offset >>= 2;
                  }

                  if (!vf32) {
                    error(`Buffer binding '${glBlock.name}' at set ${glBlock.set} binding ${glBlock.binding} is not bounded`);
                    continue;
                  }

                  const uniformLen = glBlock.glActiveUniforms.length;

                  for (let l = 0; l < uniformLen; l++) {
                    const glUniform = glBlock.glActiveUniforms[l];

                    switch (glUniform.glType) {
                      case gl.BOOL:
                      case gl.INT:
                        {
                          for (let u = 0; u < glUniform.array.length; ++u) {
                            const idx = glUniform.offset + offset + u;

                            if (vf32[idx] !== glUniform.array[u]) {
                              for (let n = u, m = idx; n < glUniform.array.length; ++n, ++m) {
                                glUniform.array[n] = vf32[m];
                              }

                              gl.uniform1iv(glUniform.glLoc, glUniform.array);
                              break;
                            }
                          }

                          break;
                        }

                      case gl.BOOL_VEC2:
                      case gl.INT_VEC2:
                        {
                          for (let u = 0; u < glUniform.array.length; ++u) {
                            const idx = glUniform.offset + offset + u;

                            if (vf32[idx] !== glUniform.array[u]) {
                              for (let n = u, m = idx; n < glUniform.array.length; ++n, ++m) {
                                glUniform.array[n] = vf32[m];
                              }

                              gl.uniform2iv(glUniform.glLoc, glUniform.array);
                              break;
                            }
                          }

                          break;
                        }

                      case gl.BOOL_VEC3:
                      case gl.INT_VEC3:
                        {
                          for (let u = 0; u < glUniform.array.length; ++u) {
                            const idx = glUniform.offset + offset + u;

                            if (vf32[idx] !== glUniform.array[u]) {
                              for (let n = u, m = idx; n < glUniform.array.length; ++n, ++m) {
                                glUniform.array[n] = vf32[m];
                              }

                              gl.uniform3iv(glUniform.glLoc, glUniform.array);
                              break;
                            }
                          }

                          break;
                        }

                      case gl.BOOL_VEC4:
                      case gl.INT_VEC4:
                        {
                          for (let u = 0; u < glUniform.array.length; ++u) {
                            const idx = glUniform.offset + offset + u;

                            if (vf32[idx] !== glUniform.array[u]) {
                              for (let n = u, m = idx; n < glUniform.array.length; ++n, ++m) {
                                glUniform.array[n] = vf32[m];
                              }

                              gl.uniform4iv(glUniform.glLoc, glUniform.array);
                              break;
                            }
                          }

                          break;
                        }

                      case gl.FLOAT:
                        {
                          for (let u = 0; u < glUniform.array.length; ++u) {
                            const idx = glUniform.offset + offset + u;

                            if (vf32[idx] !== glUniform.array[u]) {
                              for (let n = u, m = idx; n < glUniform.array.length; ++n, ++m) {
                                glUniform.array[n] = vf32[m];
                              }

                              gl.uniform1fv(glUniform.glLoc, glUniform.array);
                              break;
                            }
                          }

                          break;
                        }

                      case gl.FLOAT_VEC2:
                        {
                          for (let u = 0; u < glUniform.array.length; ++u) {
                            const idx = glUniform.offset + offset + u;

                            if (vf32[idx] !== glUniform.array[u]) {
                              for (let n = u, m = idx; n < glUniform.array.length; ++n, ++m) {
                                glUniform.array[n] = vf32[m];
                              }

                              gl.uniform2fv(glUniform.glLoc, glUniform.array);
                              break;
                            }
                          }

                          break;
                        }

                      case gl.FLOAT_VEC3:
                        {
                          for (let u = 0; u < glUniform.array.length; ++u) {
                            const idx = glUniform.offset + offset + u;

                            if (vf32[idx] !== glUniform.array[u]) {
                              for (let n = u, m = idx; n < glUniform.array.length; ++n, ++m) {
                                glUniform.array[n] = vf32[m];
                              }

                              gl.uniform3fv(glUniform.glLoc, glUniform.array);
                              break;
                            }
                          }

                          break;
                        }

                      case gl.FLOAT_VEC4:
                        {
                          for (let u = 0; u < glUniform.array.length; ++u) {
                            const idx = glUniform.offset + offset + u;

                            if (vf32[idx] !== glUniform.array[u]) {
                              for (let n = u, m = idx; n < glUniform.array.length; ++n, ++m) {
                                glUniform.array[n] = vf32[m];
                              }

                              gl.uniform4fv(glUniform.glLoc, glUniform.array);
                              break;
                            }
                          }

                          break;
                        }

                      case gl.FLOAT_MAT2:
                        {
                          for (let u = 0; u < glUniform.array.length; ++u) {
                            const idx = glUniform.offset + offset + u;

                            if (vf32[idx] !== glUniform.array[u]) {
                              for (let n = u, m = idx; n < glUniform.array.length; ++n, ++m) {
                                glUniform.array[n] = vf32[m];
                              }

                              gl.uniformMatrix2fv(glUniform.glLoc, false, glUniform.array);
                              break;
                            }
                          }

                          break;
                        }

                      case gl.FLOAT_MAT3:
                        {
                          for (let u = 0; u < glUniform.array.length; ++u) {
                            const idx = glUniform.offset + offset + u;

                            if (vf32[idx] !== glUniform.array[u]) {
                              for (let n = u, m = idx; n < glUniform.array.length; ++n, ++m) {
                                glUniform.array[n] = vf32[m];
                              }

                              gl.uniformMatrix3fv(glUniform.glLoc, false, glUniform.array);
                              break;
                            }
                          }

                          break;
                        }

                      case gl.FLOAT_MAT4:
                        {
                          for (let u = 0; u < glUniform.array.length; ++u) {
                            const idx = glUniform.offset + offset + u;

                            if (vf32[idx] !== glUniform.array[u]) {
                              for (let n = u, m = idx; n < glUniform.array.length; ++n, ++m) {
                                glUniform.array[n] = vf32[m];
                              }

                              gl.uniformMatrix4fv(glUniform.glLoc, false, glUniform.array);
                              break;
                            }
                          }

                          break;
                        }
                    }
                  }

                  continue;
                }

                const samplerLen = gpuShader.glSamplerTextures.length;

                for (let i = 0; i < samplerLen; i++) {
                  const glSampler = gpuShader.glSamplerTextures[i];
                  const gpuDescriptorSet = gpuDescriptorSets[glSampler.set];
                  let descriptorIndex = gpuDescriptorSet && gpuDescriptorSet.descriptorIndices[glSampler.binding];
                  let gpuDescriptor = descriptorIndex >= 0 && gpuDescriptorSet.gpuDescriptors[descriptorIndex];
                  const texUnitLen = glSampler.units.length;

                  for (let l = 0; l < texUnitLen; l++) {
                    const texUnit = glSampler.units[l];

                    if (!gpuDescriptor || !gpuDescriptor.gpuSampler) {
                      error(`Sampler binding '${glSampler.name}' at set ${glSampler.set} binding ${glSampler.binding} index ${l} is not bounded`);
                      continue;
                    }

                    if (gpuDescriptor.gpuTexture && gpuDescriptor.gpuTexture.size > 0) {
                      const {
                        gpuTexture
                      } = gpuDescriptor;
                      const glTexUnit = cache.glTexUnits[texUnit];

                      if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                        if (cache.texUnit !== texUnit) {
                          gl.activeTexture(gl.TEXTURE0 + texUnit);
                          cache.texUnit = texUnit;
                        }

                        if (gpuTexture.glTexture) {
                          gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture);
                        } else {
                          gl.bindTexture(gpuTexture.glTarget, device.nullTex2D.gpuTexture.glTexture);
                        }

                        glTexUnit.glTexture = gpuTexture.glTexture;
                      }

                      const {
                        gpuSampler
                      } = gpuDescriptor;

                      if (gpuTexture.isPowerOf2) {
                        glWrapS = gpuSampler.glWrapS;
                        glWrapT = gpuSampler.glWrapT;
                      } else {
                        glWrapS = gl.CLAMP_TO_EDGE;
                        glWrapT = gl.CLAMP_TO_EDGE;
                      }

                      if (gpuTexture.isPowerOf2) {
                        if (gpuTexture.mipLevel <= 1 && (gpuSampler.glMinFilter === gl.LINEAR_MIPMAP_NEAREST || gpuSampler.glMinFilter === gl.LINEAR_MIPMAP_LINEAR)) {
                          glMinFilter = gl.LINEAR;
                        } else {
                          glMinFilter = gpuSampler.glMinFilter;
                        }
                      } else if (gpuSampler.glMinFilter === gl.LINEAR || gpuSampler.glMinFilter === gl.LINEAR_MIPMAP_NEAREST || gpuSampler.glMinFilter === gl.LINEAR_MIPMAP_LINEAR) {
                        glMinFilter = gl.LINEAR;
                      } else {
                        glMinFilter = gl.NEAREST;
                      }

                      if (gpuTexture.glWrapS !== glWrapS) {
                        if (cache.texUnit !== texUnit) {
                          gl.activeTexture(gl.TEXTURE0 + texUnit);
                          cache.texUnit = texUnit;
                        }

                        gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_S, glWrapS);
                        gpuTexture.glWrapS = glWrapS;
                      }

                      if (gpuTexture.glWrapT !== glWrapT) {
                        if (cache.texUnit !== texUnit) {
                          gl.activeTexture(gl.TEXTURE0 + texUnit);
                          cache.texUnit = texUnit;
                        }

                        gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_T, glWrapT);
                        gpuTexture.glWrapT = glWrapT;
                      }

                      if (gpuTexture.glMinFilter !== glMinFilter) {
                        if (cache.texUnit !== texUnit) {
                          gl.activeTexture(gl.TEXTURE0 + texUnit);
                          cache.texUnit = texUnit;
                        }

                        gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MIN_FILTER, glMinFilter);
                        gpuTexture.glMinFilter = glMinFilter;
                      }

                      if (gpuTexture.glMagFilter !== gpuSampler.glMagFilter) {
                        if (cache.texUnit !== texUnit) {
                          gl.activeTexture(gl.TEXTURE0 + texUnit);
                          cache.texUnit = texUnit;
                        }

                        gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MAG_FILTER, gpuSampler.glMagFilter);
                        gpuTexture.glMagFilter = gpuSampler.glMagFilter;
                      }
                    }

                    gpuDescriptor = gpuDescriptorSet.gpuDescriptors[++descriptorIndex];
                  }
                }
              }

              if (gpuInputAssembler && gpuShader && (isShaderChanged || gfxStateCache.gpuInputAssembler !== gpuInputAssembler)) {
                gfxStateCache.gpuInputAssembler = gpuInputAssembler;
                const ia = device.extensions.ANGLE_instanced_arrays;

                if (device.extensions.useVAO) {
                  const vao = device.extensions.OES_vertex_array_object;
                  let glVAO = gpuInputAssembler.glVAOs.get(gpuShader.glProgram);

                  if (!glVAO) {
                    glVAO = vao.createVertexArrayOES();
                    gpuInputAssembler.glVAOs.set(gpuShader.glProgram, glVAO);
                    vao.bindVertexArrayOES(glVAO);
                    gl.bindBuffer(gl.ARRAY_BUFFER, null);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                    cache.glArrayBuffer = null;
                    cache.glElementArrayBuffer = null;
                    let glAttrib;
                    const inputLen = gpuShader.glInputs.length;

                    for (let j = 0; j < inputLen; j++) {
                      const glInput = gpuShader.glInputs[j];
                      glAttrib = null;
                      const attribLen = gpuInputAssembler.glAttribs.length;

                      for (let k = 0; k < attribLen; k++) {
                        const attrib = gpuInputAssembler.glAttribs[k];

                        if (attrib.name === glInput.name) {
                          glAttrib = attrib;
                          break;
                        }
                      }

                      if (glAttrib) {
                        if (cache.glArrayBuffer !== glAttrib.glBuffer) {
                          gl.bindBuffer(gl.ARRAY_BUFFER, glAttrib.glBuffer);
                          cache.glArrayBuffer = glAttrib.glBuffer;
                        }

                        for (let c = 0; c < glAttrib.componentCount; ++c) {
                          const glLoc = glInput.glLoc + c;
                          const attribOffset = glAttrib.offset + glAttrib.size * c;
                          gl.enableVertexAttribArray(glLoc);
                          cache.glCurrentAttribLocs[glLoc] = true;
                          gl.vertexAttribPointer(glLoc, glAttrib.count, glAttrib.glType, glAttrib.isNormalized, glAttrib.stride, attribOffset);

                          if (ia) {
                            ia.vertexAttribDivisorANGLE(glLoc, glAttrib.isInstanced ? 1 : 0);
                          }
                        }
                      }
                    }

                    const gpuBuffer = gpuInputAssembler.gpuIndexBuffer;

                    if (gpuBuffer) {
                      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
                    }

                    vao.bindVertexArrayOES(null);
                    gl.bindBuffer(gl.ARRAY_BUFFER, null);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                    cache.glArrayBuffer = null;
                    cache.glElementArrayBuffer = null;
                  }

                  if (cache.glVAO !== glVAO) {
                    vao.bindVertexArrayOES(glVAO);
                    cache.glVAO = glVAO;
                  }
                } else {
                  for (let a = 0; a < device.capabilities.maxVertexAttributes; ++a) {
                    cache.glCurrentAttribLocs[a] = false;
                  }

                  const inputLen = gpuShader.glInputs.length;

                  for (let j = 0; j < inputLen; j++) {
                    const glInput = gpuShader.glInputs[j];
                    let glAttrib = null;
                    const attribLen = gpuInputAssembler.glAttribs.length;

                    for (let k = 0; k < attribLen; k++) {
                      const attrib = gpuInputAssembler.glAttribs[k];

                      if (attrib.name === glInput.name) {
                        glAttrib = attrib;
                        break;
                      }
                    }

                    if (glAttrib) {
                      if (cache.glArrayBuffer !== glAttrib.glBuffer) {
                        gl.bindBuffer(gl.ARRAY_BUFFER, glAttrib.glBuffer);
                        cache.glArrayBuffer = glAttrib.glBuffer;
                      }

                      for (let c = 0; c < glAttrib.componentCount; ++c) {
                        const glLoc = glInput.glLoc + c;
                        const attribOffset = glAttrib.offset + glAttrib.size * c;

                        if (!cache.glEnabledAttribLocs[glLoc] && glLoc >= 0) {
                          gl.enableVertexAttribArray(glLoc);
                          cache.glEnabledAttribLocs[glLoc] = true;
                        }

                        cache.glCurrentAttribLocs[glLoc] = true;
                        gl.vertexAttribPointer(glLoc, glAttrib.count, glAttrib.glType, glAttrib.isNormalized, glAttrib.stride, attribOffset);

                        if (ia) {
                          ia.vertexAttribDivisorANGLE(glLoc, glAttrib.isInstanced ? 1 : 0);
                        }
                      }
                    }
                  }

                  const gpuBuffer = gpuInputAssembler.gpuIndexBuffer;

                  if (gpuBuffer) {
                    if (cache.glElementArrayBuffer !== gpuBuffer.glBuffer) {
                      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
                      cache.glElementArrayBuffer = gpuBuffer.glBuffer;
                    }
                  }

                  for (let a = 0; a < device.capabilities.maxVertexAttributes; ++a) {
                    if (cache.glEnabledAttribLocs[a] !== cache.glCurrentAttribLocs[a]) {
                      gl.disableVertexAttribArray(a);
                      cache.glEnabledAttribLocs[a] = false;
                    }
                  }
                }
              }

              if (gpuPipelineState && gpuPipelineState.dynamicStates.length) {
                const dsLen = gpuPipelineState.dynamicStates.length;

                for (let j = 0; j < dsLen; j++) {
                  const dynamicState = gpuPipelineState.dynamicStates[j];

                  switch (dynamicState) {
                    case DynamicStateFlagBit.LINE_WIDTH:
                      {
                        if (cache.rs.lineWidth !== dynamicStates.lineWidth) {
                          gl.lineWidth(dynamicStates.lineWidth);
                          cache.rs.lineWidth = dynamicStates.lineWidth;
                        }

                        break;
                      }

                    case DynamicStateFlagBit.DEPTH_BIAS:
                      {
                        if (cache.rs.depthBias !== dynamicStates.depthBiasConstant || cache.rs.depthBiasSlop !== dynamicStates.depthBiasSlope) {
                          gl.polygonOffset(dynamicStates.depthBiasConstant, dynamicStates.depthBiasSlope);
                          cache.rs.depthBias = dynamicStates.depthBiasConstant;
                          cache.rs.depthBiasSlop = dynamicStates.depthBiasSlope;
                        }

                        break;
                      }

                    case DynamicStateFlagBit.BLEND_CONSTANTS:
                      {
                        const blendConstant = dynamicStates.blendConstant;

                        if (cache.bs.blendColor.x !== blendConstant.x || cache.bs.blendColor.y !== blendConstant.y || cache.bs.blendColor.z !== blendConstant.z || cache.bs.blendColor.w !== blendConstant.w) {
                          gl.blendColor(blendConstant.x, blendConstant.y, blendConstant.z, blendConstant.w);
                          cache.bs.blendColor.copy(blendConstant);
                        }

                        break;
                      }

                    case DynamicStateFlagBit.STENCIL_WRITE_MASK:
                      {
                        const front = dynamicStates.stencilStatesFront;
                        const back = dynamicStates.stencilStatesBack;

                        if (cache.dss.stencilWriteMaskFront !== front.writeMask) {
                          gl.stencilMaskSeparate(gl.FRONT, front.writeMask);
                          cache.dss.stencilWriteMaskFront = front.writeMask;
                        }

                        if (cache.dss.stencilWriteMaskBack !== back.writeMask) {
                          gl.stencilMaskSeparate(gl.BACK, back.writeMask);
                          cache.dss.stencilWriteMaskBack = back.writeMask;
                        }

                        break;
                      }

                    case DynamicStateFlagBit.STENCIL_COMPARE_MASK:
                      {
                        const front = dynamicStates.stencilStatesFront;
                        const back = dynamicStates.stencilStatesBack;

                        if (cache.dss.stencilRefFront !== front.reference || cache.dss.stencilReadMaskFront !== front.compareMask) {
                          gl.stencilFuncSeparate(gl.FRONT, WebGLCmpFuncs[cache.dss.stencilFuncFront], front.reference, front.compareMask);
                          cache.dss.stencilRefFront = front.reference;
                          cache.dss.stencilReadMaskFront = front.compareMask;
                        }

                        if (cache.dss.stencilRefBack !== back.reference || cache.dss.stencilReadMaskBack !== back.compareMask) {
                          gl.stencilFuncSeparate(gl.BACK, WebGLCmpFuncs[cache.dss.stencilFuncBack], back.reference, back.compareMask);
                          cache.dss.stencilRefBack = back.reference;
                          cache.dss.stencilReadMaskBack = back.compareMask;
                        }

                        break;
                      }
                  }
                }
              }
            }
            function WebGLCmdFuncDraw(device, drawInfo) {
              const {
                gl
              } = device;
              const {
                ANGLE_instanced_arrays: ia,
                WEBGL_multi_draw: md
              } = device.extensions;
              const {
                gpuInputAssembler,
                glPrimitive
              } = gfxStateCache;

              if (gpuInputAssembler) {
                const indexBuffer = gpuInputAssembler.gpuIndexBuffer;

                if (gpuInputAssembler.gpuIndirectBuffer) {
                  const indirects = gpuInputAssembler.gpuIndirectBuffer.indirects;

                  if (indirects.drawByIndex) {
                    for (let j = 0; j < indirects.drawCount; j++) {
                      indirects.byteOffsets[j] = indirects.offsets[j] * indexBuffer.stride;
                    }

                    if (md) {
                      if (indirects.instancedDraw) {
                        md.multiDrawElementsInstancedWEBGL(glPrimitive, indirects.counts, 0, gpuInputAssembler.glIndexType, indirects.byteOffsets, 0, indirects.instances, 0, indirects.drawCount);
                      } else {
                        md.multiDrawElementsWEBGL(glPrimitive, indirects.counts, 0, gpuInputAssembler.glIndexType, indirects.byteOffsets, 0, indirects.drawCount);
                      }
                    } else {
                      for (let j = 0; j < indirects.drawCount; j++) {
                        if (indirects.instances[j] && ia) {
                          ia.drawElementsInstancedANGLE(glPrimitive, indirects.counts[j], gpuInputAssembler.glIndexType, indirects.byteOffsets[j], indirects.instances[j]);
                        } else {
                          gl.drawElements(glPrimitive, indirects.counts[j], gpuInputAssembler.glIndexType, indirects.byteOffsets[j]);
                        }
                      }
                    }
                  } else if (md) {
                    if (indirects.instancedDraw) {
                      md.multiDrawArraysInstancedWEBGL(glPrimitive, indirects.offsets, 0, indirects.counts, 0, indirects.instances, 0, indirects.drawCount);
                    } else {
                      md.multiDrawArraysWEBGL(glPrimitive, indirects.offsets, 0, indirects.counts, 0, indirects.drawCount);
                    }
                  } else {
                    for (let j = 0; j < indirects.drawCount; j++) {
                      if (indirects.instances[j] && ia) {
                        ia.drawArraysInstancedANGLE(glPrimitive, indirects.offsets[j], indirects.counts[j], indirects.instances[j]);
                      } else {
                        gl.drawArrays(glPrimitive, indirects.offsets[j], indirects.counts[j]);
                      }
                    }
                  }
                } else if (drawInfo.instanceCount && ia) {
                  if (indexBuffer) {
                    if (drawInfo.indexCount > 0) {
                      const offset = drawInfo.firstIndex * indexBuffer.stride;
                      ia.drawElementsInstancedANGLE(glPrimitive, drawInfo.indexCount, gpuInputAssembler.glIndexType, offset, drawInfo.instanceCount);
                    }
                  } else if (drawInfo.vertexCount > 0) {
                    ia.drawArraysInstancedANGLE(glPrimitive, drawInfo.firstVertex, drawInfo.vertexCount, drawInfo.instanceCount);
                  }
                } else if (indexBuffer) {
                  if (drawInfo.indexCount > 0) {
                    const offset = drawInfo.firstIndex * indexBuffer.stride;
                    gl.drawElements(glPrimitive, drawInfo.indexCount, gpuInputAssembler.glIndexType, offset);
                  }
                } else if (drawInfo.vertexCount > 0) {
                  gl.drawArrays(glPrimitive, drawInfo.firstVertex, drawInfo.vertexCount);
                }
              }
            }
            const cmdIds = new Array(WebGLCmd.COUNT);
            function WebGLCmdFuncExecuteCmds(device, cmdPackage) {
              cmdIds.fill(0);

              for (let i = 0; i < cmdPackage.cmds.length; ++i) {
                const cmd = cmdPackage.cmds.array[i];
                const cmdId = cmdIds[cmd]++;

                switch (cmd) {
                  case WebGLCmd.BEGIN_RENDER_PASS:
                    {
                      const cmd0 = cmdPackage.beginRenderPassCmds.array[cmdId];
                      WebGLCmdFuncBeginRenderPass(device, cmd0.gpuRenderPass, cmd0.gpuFramebuffer, cmd0.renderArea, cmd0.clearColors, cmd0.clearDepth, cmd0.clearStencil);
                      break;
                    }

                  case WebGLCmd.BIND_STATES:
                    {
                      const cmd2 = cmdPackage.bindStatesCmds.array[cmdId];
                      WebGLCmdFuncBindStates(device, cmd2.gpuPipelineState, cmd2.gpuInputAssembler, cmd2.gpuDescriptorSets, cmd2.dynamicOffsets, cmd2.dynamicStates);
                      break;
                    }

                  case WebGLCmd.DRAW:
                    {
                      const cmd3 = cmdPackage.drawCmds.array[cmdId];
                      WebGLCmdFuncDraw(device, cmd3.drawInfo);
                      break;
                    }

                  case WebGLCmd.UPDATE_BUFFER:
                    {
                      const cmd4 = cmdPackage.updateBufferCmds.array[cmdId];
                      WebGLCmdFuncUpdateBuffer(device, cmd4.gpuBuffer, cmd4.buffer, cmd4.offset, cmd4.size);
                      break;
                    }

                  case WebGLCmd.COPY_BUFFER_TO_TEXTURE:
                    {
                      const cmd5 = cmdPackage.copyBufferToTextureCmds.array[cmdId];
                      WebGLCmdFuncCopyBuffersToTexture(device, cmd5.buffers, cmd5.gpuTexture, cmd5.regions);
                      break;
                    }
                }
              }
            }
            function WebGLCmdFuncCopyTexImagesToTexture(device, texImages, gpuTexture, regions) {
              const {
                gl
              } = device;
              const glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

              if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture);
                glTexUnit.glTexture = gpuTexture.glTexture;
              }

              let n = 0;
              let f = 0;

              switch (gpuTexture.glTarget) {
                case gl.TEXTURE_2D:
                  {
                    for (let i = 0; i < regions.length; i++) {
                      const region = regions[i];
                      gl.texSubImage2D(gl.TEXTURE_2D, region.texSubres.mipLevel, region.texOffset.x, region.texOffset.y, gpuTexture.glFormat, gpuTexture.glType, texImages[n++]);
                    }

                    break;
                  }

                case gl.TEXTURE_CUBE_MAP:
                  {
                    for (let i = 0; i < regions.length; i++) {
                      const region = regions[i];
                      const fcount = region.texSubres.baseArrayLayer + region.texSubres.layerCount;

                      for (f = region.texSubres.baseArrayLayer; f < fcount; ++f) {
                        gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, region.texSubres.mipLevel, region.texOffset.x, region.texOffset.y, gpuTexture.glFormat, gpuTexture.glType, texImages[n++]);
                      }
                    }

                    break;
                  }

                default:
                  {
                    console.error('Unsupported GL texture type, copy buffer to texture failed.');
                  }
              }

              if (gpuTexture.flags & TextureFlagBit.GEN_MIPMAP && gpuTexture.isPowerOf2) {
                gl.generateMipmap(gpuTexture.glTarget);
              }
            }
            function WebGLCmdFuncCopyBuffersToTexture(device, buffers, gpuTexture, regions) {
              const {
                gl
              } = device;
              const glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

              if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture);
                glTexUnit.glTexture = gpuTexture.glTexture;
              }

              let n = 0;
              let w = 1;
              let h = 1;
              let f = 0;
              const fmtInfo = FormatInfos[gpuTexture.format];
              const {
                isCompressed
              } = fmtInfo;

              switch (gpuTexture.glTarget) {
                case gl.TEXTURE_2D:
                  {
                    for (let i = 0; i < regions.length; i++) {
                      const region = regions[i];
                      w = region.texExtent.width;
                      h = region.texExtent.height;
                      const pixels = buffers[n++];

                      if (!isCompressed) {
                        gl.texSubImage2D(gl.TEXTURE_2D, region.texSubres.mipLevel, region.texOffset.x, region.texOffset.y, w, h, gpuTexture.glFormat, gpuTexture.glType, pixels);
                      } else if (gpuTexture.glInternalFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL && !device.extensions.noCompressedTexSubImage2D) {
                        gl.compressedTexSubImage2D(gl.TEXTURE_2D, region.texSubres.mipLevel, region.texOffset.x, region.texOffset.y, w, h, gpuTexture.glFormat, pixels);
                      } else {
                        gl.compressedTexImage2D(gl.TEXTURE_2D, region.texSubres.mipLevel, gpuTexture.glInternalFmt, w, h, 0, pixels);
                      }
                    }

                    break;
                  }

                case gl.TEXTURE_CUBE_MAP:
                  {
                    for (let i = 0; i < regions.length; i++) {
                      const region = regions[i];
                      const fcount = region.texSubres.baseArrayLayer + region.texSubres.layerCount;

                      for (f = region.texSubres.baseArrayLayer; f < fcount; ++f) {
                        w = region.texExtent.width;
                        h = region.texExtent.height;
                        const pixels = buffers[n++];

                        if (!isCompressed) {
                          gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, region.texSubres.mipLevel, region.texOffset.x, region.texOffset.y, w, h, gpuTexture.glFormat, gpuTexture.glType, pixels);
                        } else if (gpuTexture.glInternalFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL && !device.extensions.noCompressedTexSubImage2D) {
                          gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, region.texSubres.mipLevel, region.texOffset.x, region.texOffset.y, w, h, gpuTexture.glFormat, pixels);
                        } else {
                          gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, region.texSubres.mipLevel, gpuTexture.glInternalFmt, w, h, 0, pixels);
                        }
                      }
                    }

                    break;
                  }

                default:
                  {
                    console.error('Unsupported GL texture type, copy buffer to texture failed.');
                  }
              }

              if (gpuTexture.flags & TextureFlagBit.GEN_MIPMAP) {
                gl.generateMipmap(gpuTexture.glTarget);
              }
            }
            function WebGLCmdFuncCopyTextureToBuffers(device, gpuTexture, buffers, regions) {
              const {
                gl
              } = device;
              const cache = device.stateCache;
              const framebuffer = gl.createFramebuffer();
              gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
              let x = 0;
              let y = 0;
              let w = 1;
              let h = 1;

              switch (gpuTexture.glTarget) {
                case gl.TEXTURE_2D:
                  {
                    for (let k = 0; k < regions.length; k++) {
                      const region = regions[k];
                      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gpuTexture.glTarget, gpuTexture.glTexture, region.texSubres.mipLevel);
                      x = region.texOffset.x;
                      y = region.texOffset.y;
                      w = region.texExtent.width;
                      h = region.texExtent.height;
                      gl.readPixels(x, y, w, h, gpuTexture.glFormat, gpuTexture.glType, buffers[k]);
                    }

                    break;
                  }

                default:
                  {
                    console.error('Unsupported GL texture type, copy texture to buffers failed.');
                  }
              }

              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
              cache.glFramebuffer = null;
              gl.deleteFramebuffer(framebuffer);
            }

            class WebGLIndirectDrawInfos {
              constructor() {
                this.counts = void 0;
                this.offsets = void 0;
                this.instances = void 0;
                this.drawCount = 0;
                this.drawByIndex = false;
                this.instancedDraw = false;
                this.byteOffsets = void 0;
                this._capacity = 4;
                this.counts = new Int32Array(this._capacity);
                this.offsets = new Int32Array(this._capacity);
                this.instances = new Int32Array(this._capacity);
                this.byteOffsets = new Int32Array(this._capacity);
              }

              clearDraws() {
                this.drawCount = 0;
                this.drawByIndex = false;
                this.instancedDraw = false;
              }

              setDrawInfo(idx, info) {
                this._ensureCapacity(idx);

                this.drawByIndex = info.indexCount > 0;
                this.instancedDraw = !!info.instanceCount;
                this.drawCount = Math.max(idx + 1, this.drawCount);

                if (this.drawByIndex) {
                  this.counts[idx] = info.indexCount;
                  this.offsets[idx] = info.firstIndex;
                } else {
                  this.counts[idx] = info.vertexCount;
                  this.offsets[idx] = info.firstVertex;
                }

                this.instances[idx] = Math.max(1, info.instanceCount);
              }

              _ensureCapacity(target) {
                if (this._capacity > target) return;
                this._capacity = nextPow2(target);
                const counts = new Int32Array(this._capacity);
                const offsets = new Int32Array(this._capacity);
                const instances = new Int32Array(this._capacity);
                this.byteOffsets = new Int32Array(this._capacity);
                counts.set(this.counts);
                offsets.set(this.offsets);
                instances.set(this.instances);
                this.counts = counts;
                this.offsets = offsets;
                this.instances = instances;
              }

            }

            class WebGLBuffer extends Buffer {
              constructor(...args) {
                super(...args);
                this._gpuBuffer = null;
                this._gpuBufferView = null;
                this._uniformBuffer = null;
              }

              get gpuBuffer() {
                return this._gpuBuffer;
              }

              get gpuBufferView() {
                return this._gpuBufferView;
              }

              initialize(info) {
                if ('buffer' in info) {
                  this._isBufferView = true;
                  const buffer = info.buffer;
                  this._usage = buffer.usage;
                  this._memUsage = buffer.memUsage;
                  this._size = this._stride = info.range;
                  this._count = 1;
                  this._flags = buffer.flags;
                  this._gpuBufferView = {
                    gpuBuffer: buffer.gpuBuffer,
                    offset: info.offset,
                    range: info.range
                  };
                } else {
                  this._usage = info.usage;
                  this._memUsage = info.memUsage;
                  this._size = info.size;
                  this._stride = Math.max(info.stride || this._size, 1);
                  this._count = this._size / this._stride;
                  this._flags = info.flags;

                  if (this._usage & BufferUsageBit.UNIFORM && this._size > 0) {
                    this._uniformBuffer = new Uint8Array(this._size);
                  }

                  this._gpuBuffer = {
                    usage: this._usage,
                    memUsage: this._memUsage,
                    size: this._size,
                    stride: this._stride,
                    buffer: null,
                    vf32: null,
                    indirects: new WebGLIndirectDrawInfos(),
                    glTarget: 0,
                    glBuffer: null
                  };

                  if (this._usage & BufferUsageBit.UNIFORM) {
                    this._gpuBuffer.buffer = this._uniformBuffer;
                  }

                  WebGLCmdFuncCreateBuffer(WebGLDeviceManager.instance, this._gpuBuffer);
                  WebGLDeviceManager.instance.memoryStatus.bufferSize += this._size;
                }
              }

              destroy() {
                if (this._gpuBuffer) {
                  WebGLCmdFuncDestroyBuffer(WebGLDeviceManager.instance, this._gpuBuffer);
                  WebGLDeviceManager.instance.memoryStatus.bufferSize -= this._size;
                  this._gpuBuffer = null;
                }

                if (this._gpuBufferView) {
                  this._gpuBufferView = null;
                }
              }

              resize(size) {
                if (this._isBufferView) {
                  console.warn('cannot resize buffer views!');
                  return;
                }

                const oldSize = this._size;

                if (oldSize === size) {
                  return;
                }

                this._size = size;
                this._count = this._size / this._stride;

                if (this._uniformBuffer) {
                  this._uniformBuffer = new Uint8Array(size);
                }

                if (this._gpuBuffer) {
                  if (this._uniformBuffer) {
                    this._gpuBuffer.buffer = this._uniformBuffer;
                  }

                  this._gpuBuffer.size = size;

                  if (size > 0) {
                    WebGLCmdFuncResizeBuffer(WebGLDeviceManager.instance, this._gpuBuffer);
                    WebGLDeviceManager.instance.memoryStatus.bufferSize -= oldSize;
                    WebGLDeviceManager.instance.memoryStatus.bufferSize += size;
                  }
                }
              }

              update(buffer, size) {
                if (this._isBufferView) {
                  console.warn('cannot update through buffer views!');
                  return;
                }

                let buffSize;

                if (size !== undefined) {
                  buffSize = size;
                } else if (this._usage & BufferUsageBit.INDIRECT) {
                  buffSize = 0;
                } else {
                  buffSize = buffer.byteLength;
                }

                WebGLCmdFuncUpdateBuffer(WebGLDeviceManager.instance, this._gpuBuffer, buffer, 0, buffSize);
              }

            }

            class WebGLCommandPool {
              constructor(Clazz, count) {
                this._frees = void 0;
                this._freeIdx = 0;
                this._freeCmds = void 0;
                this._frees = new Array(count);
                this._freeCmds = new CachedArray(count);

                for (let i = 0; i < count; ++i) {
                  this._frees[i] = new Clazz();
                }

                this._freeIdx = count - 1;
              }

              alloc(Clazz) {
                if (this._freeIdx < 0) {
                  const size = this._frees.length * 2;
                  const temp = this._frees;
                  this._frees = new Array(size);
                  const increase = size - temp.length;

                  for (let i = 0; i < increase; ++i) {
                    this._frees[i] = new Clazz();
                  }

                  for (let i = increase, j = 0; i < size; ++i, ++j) {
                    this._frees[i] = temp[j];
                  }

                  this._freeIdx += increase;
                }

                const cmd = this._frees[this._freeIdx];
                this._frees[this._freeIdx--] = null;
                ++cmd.refCount;
                return cmd;
              }

              free(cmd) {
                if (--cmd.refCount === 0) {
                  this._freeCmds.push(cmd);
                }
              }

              freeCmds(cmds) {
                for (let i = 0; i < cmds.length; ++i) {
                  if (--cmds.array[i].refCount === 0) {
                    this._freeCmds.push(cmds.array[i]);
                  }
                }
              }

              release() {
                for (let i = 0; i < this._freeCmds.length; ++i) {
                  const cmd = this._freeCmds.array[i];
                  cmd.clear();
                  this._frees[++this._freeIdx] = cmd;
                }

                this._freeCmds.clear();
              }

            }
            class WebGLCommandAllocator {
              constructor() {
                this.beginRenderPassCmdPool = void 0;
                this.bindStatesCmdPool = void 0;
                this.drawCmdPool = void 0;
                this.updateBufferCmdPool = void 0;
                this.copyBufferToTextureCmdPool = void 0;
                this.beginRenderPassCmdPool = new WebGLCommandPool(WebGLCmdBeginRenderPass, 1);
                this.bindStatesCmdPool = new WebGLCommandPool(WebGLCmdBindStates, 1);
                this.drawCmdPool = new WebGLCommandPool(WebGLCmdDraw, 1);
                this.updateBufferCmdPool = new WebGLCommandPool(WebGLCmdUpdateBuffer, 1);
                this.copyBufferToTextureCmdPool = new WebGLCommandPool(WebGLCmdCopyBufferToTexture, 1);
              }

              clearCmds(cmdPackage) {
                if (cmdPackage.beginRenderPassCmds.length) {
                  this.beginRenderPassCmdPool.freeCmds(cmdPackage.beginRenderPassCmds);
                  cmdPackage.beginRenderPassCmds.clear();
                }

                if (cmdPackage.bindStatesCmds.length) {
                  this.bindStatesCmdPool.freeCmds(cmdPackage.bindStatesCmds);
                  cmdPackage.bindStatesCmds.clear();
                }

                if (cmdPackage.drawCmds.length) {
                  this.drawCmdPool.freeCmds(cmdPackage.drawCmds);
                  cmdPackage.drawCmds.clear();
                }

                if (cmdPackage.updateBufferCmds.length) {
                  this.updateBufferCmdPool.freeCmds(cmdPackage.updateBufferCmds);
                  cmdPackage.updateBufferCmds.clear();
                }

                if (cmdPackage.copyBufferToTextureCmds.length) {
                  this.copyBufferToTextureCmdPool.freeCmds(cmdPackage.copyBufferToTextureCmds);
                  cmdPackage.copyBufferToTextureCmds.clear();
                }

                cmdPackage.cmds.clear();
              }

              releaseCmds() {
                this.beginRenderPassCmdPool.release();
                this.bindStatesCmdPool.release();
                this.drawCmdPool.release();
                this.updateBufferCmdPool.release();
                this.copyBufferToTextureCmdPool.release();
              }

            }

            class WebGLCommandBuffer extends CommandBuffer {
              constructor(...args) {
                super(...args);
                this.cmdPackage = new WebGLCmdPackage();
                this._cmdAllocator = new WebGLCommandAllocator();
                this._isInRenderPass = false;
                this._curGPUPipelineState = null;
                this._curGPUInputAssembler = null;
                this._curGPUDescriptorSets = [];
                this._curDynamicOffsets = Array(8).fill(0);
                this._curDynamicStates = new DynamicStates();
                this._isStateInvalied = false;
              }

              initialize(info) {
                this._type = info.type;
                this._queue = info.queue;
                const setCount = WebGLDeviceManager.instance.bindingMappingInfo.bufferOffsets.length;

                for (let i = 0; i < setCount; i++) {
                  this._curGPUDescriptorSets.push(null);
                }
              }

              destroy() {
                this._cmdAllocator.clearCmds(this.cmdPackage);
              }

              begin(renderPass, subpass = 0, frameBuffer) {
                this._cmdAllocator.clearCmds(this.cmdPackage);

                this._curGPUPipelineState = null;
                this._curGPUInputAssembler = null;
                this._curGPUDescriptorSets.length = 0;
                this._numDrawCalls = 0;
                this._numInstances = 0;
                this._numTris = 0;
              }

              end() {
                if (this._isStateInvalied) {
                  this.bindStates();
                }

                this._isInRenderPass = false;
              }

              beginRenderPass(renderPass, framebuffer, renderArea, clearColors, clearDepth, clearStencil) {
                const cmd = this._cmdAllocator.beginRenderPassCmdPool.alloc(WebGLCmdBeginRenderPass);

                cmd.gpuRenderPass = renderPass.gpuRenderPass;
                cmd.gpuFramebuffer = framebuffer.gpuFramebuffer;
                cmd.renderArea = renderArea;
                cmd.clearColors.length = clearColors.length;

                for (let i = 0; i < clearColors.length; ++i) {
                  cmd.clearColors[i] = clearColors[i];
                }

                cmd.clearDepth = clearDepth;
                cmd.clearStencil = clearStencil;
                this.cmdPackage.beginRenderPassCmds.push(cmd);
                this.cmdPackage.cmds.push(WebGLCmd.BEGIN_RENDER_PASS);
                this._isInRenderPass = true;
              }

              endRenderPass() {
                this._isInRenderPass = false;
              }

              bindPipelineState(pipelineState) {
                const gpuPipelineState = pipelineState.gpuPipelineState;

                if (gpuPipelineState !== this._curGPUPipelineState) {
                  this._curGPUPipelineState = gpuPipelineState;
                  this._isStateInvalied = true;
                }
              }

              bindDescriptorSet(set, descriptorSet, dynamicOffsets) {
                const gpuDescriptorSet = descriptorSet.gpuDescriptorSet;

                if (gpuDescriptorSet !== this._curGPUDescriptorSets[set]) {
                  this._curGPUDescriptorSets[set] = gpuDescriptorSet;
                  this._isStateInvalied = true;
                }

                if (dynamicOffsets) {
                  var _this$_curGPUPipeline;

                  const gpuPipelineLayout = (_this$_curGPUPipeline = this._curGPUPipelineState) === null || _this$_curGPUPipeline === void 0 ? void 0 : _this$_curGPUPipeline.gpuPipelineLayout;

                  if (gpuPipelineLayout) {
                    const offsets = this._curDynamicOffsets;
                    const idx = gpuPipelineLayout.dynamicOffsetOffsets[set];

                    for (let i = 0; i < dynamicOffsets.length; i++) offsets[idx + i] = dynamicOffsets[i];

                    this._isStateInvalied = true;
                  }
                }
              }

              bindInputAssembler(inputAssembler) {
                const gpuInputAssembler = inputAssembler.gpuInputAssembler;
                this._curGPUInputAssembler = gpuInputAssembler;
                this._isStateInvalied = true;
              }

              setViewport(viewport) {
                const cache = this._curDynamicStates.viewport;

                if (cache.left !== viewport.left || cache.top !== viewport.top || cache.width !== viewport.width || cache.height !== viewport.height || cache.minDepth !== viewport.minDepth || cache.maxDepth !== viewport.maxDepth) {
                  cache.left = viewport.left;
                  cache.top = viewport.top;
                  cache.width = viewport.width;
                  cache.height = viewport.height;
                  cache.minDepth = viewport.minDepth;
                  cache.maxDepth = viewport.maxDepth;
                  this._isStateInvalied = true;
                }
              }

              setScissor(scissor) {
                const cache = this._curDynamicStates.scissor;

                if (cache.x !== scissor.x || cache.y !== scissor.y || cache.width !== scissor.width || cache.height !== scissor.height) {
                  cache.x = scissor.x;
                  cache.y = scissor.y;
                  cache.width = scissor.width;
                  cache.height = scissor.height;
                  this._isStateInvalied = true;
                }
              }

              setLineWidth(lineWidth) {
                if (this._curDynamicStates.lineWidth !== lineWidth) {
                  this._curDynamicStates.lineWidth = lineWidth;
                  this._isStateInvalied = true;
                }
              }

              setDepthBias(depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor) {
                const cache = this._curDynamicStates;

                if (cache.depthBiasConstant !== depthBiasConstantFactor || cache.depthBiasClamp !== depthBiasClamp || cache.depthBiasSlope !== depthBiasSlopeFactor) {
                  cache.depthBiasConstant = depthBiasConstantFactor;
                  cache.depthBiasClamp = depthBiasClamp;
                  cache.depthBiasSlope = depthBiasSlopeFactor;
                  this._isStateInvalied = true;
                }
              }

              setBlendConstants(blendConstants) {
                const cache = this._curDynamicStates.blendConstant;

                if (cache.x !== blendConstants.x || cache.y !== blendConstants.y || cache.z !== blendConstants.z || cache.w !== blendConstants.w) {
                  cache.copy(blendConstants);
                  this._isStateInvalied = true;
                }
              }

              setDepthBound(minDepthBounds, maxDepthBounds) {
                const cache = this._curDynamicStates;

                if (cache.depthMinBounds !== minDepthBounds || cache.depthMaxBounds !== maxDepthBounds) {
                  cache.depthMinBounds = minDepthBounds;
                  cache.depthMaxBounds = maxDepthBounds;
                  this._isStateInvalied = true;
                }
              }

              setStencilWriteMask(face, writeMask) {
                const front = this._curDynamicStates.stencilStatesFront;
                const back = this._curDynamicStates.stencilStatesBack;

                if (face & StencilFace.FRONT) {
                  if (front.writeMask !== writeMask) {
                    front.writeMask = writeMask;
                    this._isStateInvalied = true;
                  }
                }

                if (face & StencilFace.BACK) {
                  if (back.writeMask !== writeMask) {
                    back.writeMask = writeMask;
                    this._isStateInvalied = true;
                  }
                }
              }

              setStencilCompareMask(face, reference, compareMask) {
                const front = this._curDynamicStates.stencilStatesFront;
                const back = this._curDynamicStates.stencilStatesBack;

                if (face & StencilFace.FRONT) {
                  if (front.compareMask !== compareMask || front.reference !== reference) {
                    front.reference = reference;
                    front.compareMask = compareMask;
                    this._isStateInvalied = true;
                  }
                }

                if (face & StencilFace.BACK) {
                  if (back.compareMask !== compareMask || back.reference !== reference) {
                    back.reference = reference;
                    back.compareMask = compareMask;
                    this._isStateInvalied = true;
                  }
                }
              }

              draw(infoOrAssembler) {
                if (this._type === CommandBufferType.PRIMARY && this._isInRenderPass || this._type === CommandBufferType.SECONDARY) {
                  if (this._isStateInvalied) {
                    this.bindStates();
                  }

                  const info = 'drawInfo' in infoOrAssembler ? infoOrAssembler.drawInfo : infoOrAssembler;

                  const cmd = this._cmdAllocator.drawCmdPool.alloc(WebGLCmdDraw);

                  cmd.drawInfo.copy(info);
                  this.cmdPackage.drawCmds.push(cmd);
                  this.cmdPackage.cmds.push(WebGLCmd.DRAW);
                  ++this._numDrawCalls;
                  this._numInstances += info.instanceCount;
                  const indexCount = info.indexCount || info.vertexCount;

                  if (this._curGPUPipelineState) {
                    const glPrimitive = this._curGPUPipelineState.glPrimitive;

                    switch (glPrimitive) {
                      case 0x0004:
                        {
                          this._numTris += indexCount / 3 * Math.max(info.instanceCount, 1);
                          break;
                        }

                      case 0x0005:
                      case 0x0006:
                        {
                          this._numTris += (indexCount - 2) * Math.max(info.instanceCount, 1);
                          break;
                        }
                    }
                  }
                } else {
                  console.error('Command \'draw\' must be recorded inside a render pass.');
                }
              }

              updateBuffer(buffer, data, size) {
                if (this._type === CommandBufferType.PRIMARY && !this._isInRenderPass || this._type === CommandBufferType.SECONDARY) {
                  const gpuBuffer = buffer.gpuBuffer;

                  if (gpuBuffer) {
                    const cmd = this._cmdAllocator.updateBufferCmdPool.alloc(WebGLCmdUpdateBuffer);

                    let buffSize = 0;
                    let buff = null;

                    if (buffer.usage & BufferUsageBit.INDIRECT) {
                      buff = data;
                    } else {
                      if (size !== undefined) {
                        buffSize = size;
                      } else {
                        buffSize = data.byteLength;
                      }

                      buff = data;
                    }

                    cmd.gpuBuffer = gpuBuffer;
                    cmd.buffer = buff;
                    cmd.offset = 0;
                    cmd.size = buffSize;
                    this.cmdPackage.updateBufferCmds.push(cmd);
                    this.cmdPackage.cmds.push(WebGLCmd.UPDATE_BUFFER);
                  }
                } else {
                  console.error('Command \'updateBuffer\' must be recorded outside a render pass.');
                }
              }

              copyBuffersToTexture(buffers, texture, regions) {
                if (this._type === CommandBufferType.PRIMARY && !this._isInRenderPass || this._type === CommandBufferType.SECONDARY) {
                  const gpuTexture = texture.gpuTexture;

                  if (gpuTexture) {
                    const cmd = this._cmdAllocator.copyBufferToTextureCmdPool.alloc(WebGLCmdCopyBufferToTexture);

                    if (cmd) {
                      cmd.gpuTexture = gpuTexture;
                      cmd.regions = regions;
                      cmd.buffers = buffers;
                      this.cmdPackage.copyBufferToTextureCmds.push(cmd);
                      this.cmdPackage.cmds.push(WebGLCmd.COPY_BUFFER_TO_TEXTURE);
                    }
                  }
                } else {
                  console.error('Command \'copyBufferToTexture\' must be recorded outside a render pass.');
                }
              }

              execute(cmdBuffs, count) {
                for (let i = 0; i < count; ++i) {
                  const webGLCmdBuff = cmdBuffs[i];

                  for (let c = 0; c < webGLCmdBuff.cmdPackage.beginRenderPassCmds.length; ++c) {
                    const cmd = webGLCmdBuff.cmdPackage.beginRenderPassCmds.array[c];
                    ++cmd.refCount;
                    this.cmdPackage.beginRenderPassCmds.push(cmd);
                  }

                  for (let c = 0; c < webGLCmdBuff.cmdPackage.bindStatesCmds.length; ++c) {
                    const cmd = webGLCmdBuff.cmdPackage.bindStatesCmds.array[c];
                    ++cmd.refCount;
                    this.cmdPackage.bindStatesCmds.push(cmd);
                  }

                  for (let c = 0; c < webGLCmdBuff.cmdPackage.drawCmds.length; ++c) {
                    const cmd = webGLCmdBuff.cmdPackage.drawCmds.array[c];
                    ++cmd.refCount;
                    this.cmdPackage.drawCmds.push(cmd);
                  }

                  for (let c = 0; c < webGLCmdBuff.cmdPackage.updateBufferCmds.length; ++c) {
                    const cmd = webGLCmdBuff.cmdPackage.updateBufferCmds.array[c];
                    ++cmd.refCount;
                    this.cmdPackage.updateBufferCmds.push(cmd);
                  }

                  for (let c = 0; c < webGLCmdBuff.cmdPackage.copyBufferToTextureCmds.length; ++c) {
                    const cmd = webGLCmdBuff.cmdPackage.copyBufferToTextureCmds.array[c];
                    ++cmd.refCount;
                    this.cmdPackage.copyBufferToTextureCmds.push(cmd);
                  }

                  this.cmdPackage.cmds.concat(webGLCmdBuff.cmdPackage.cmds.array);
                  this._numDrawCalls += webGLCmdBuff._numDrawCalls;
                  this._numInstances += webGLCmdBuff._numInstances;
                  this._numTris += webGLCmdBuff._numTris;
                }
              }

              pipelineBarrier(globalBarrier, textureBarriers, textures) {}

              bindStates() {
                const bindStatesCmd = this._cmdAllocator.bindStatesCmdPool.alloc(WebGLCmdBindStates);

                if (bindStatesCmd) {
                  bindStatesCmd.gpuPipelineState = this._curGPUPipelineState;
                  Array.prototype.push.apply(bindStatesCmd.gpuDescriptorSets, this._curGPUDescriptorSets);
                  Array.prototype.push.apply(bindStatesCmd.dynamicOffsets, this._curDynamicOffsets);
                  bindStatesCmd.gpuInputAssembler = this._curGPUInputAssembler;
                  bindStatesCmd.dynamicStates.copy(this._curDynamicStates);
                  this.cmdPackage.bindStatesCmds.push(bindStatesCmd);
                  this.cmdPackage.cmds.push(WebGLCmd.BIND_STATES);
                  this._isStateInvalied = false;
                }
              }

            }

            class WebGLFramebuffer extends Framebuffer {
              constructor(...args) {
                super(...args);
                this._gpuFramebuffer = null;
              }

              get gpuFramebuffer() {
                return this._gpuFramebuffer;
              }

              initialize(info) {
                this._renderPass = info.renderPass;
                this._colorTextures = info.colorTextures || [];
                this._depthStencilTexture = info.depthStencilTexture || null;
                const gpuColorTextures = [];

                for (let i = 0; i < info.colorTextures.length; ++i) {
                  const colorTexture = info.colorTextures[i];

                  if (colorTexture) {
                    gpuColorTextures.push(colorTexture.gpuTexture);
                  }
                }

                let gpuDepthStencilTexture = null;

                if (info.depthStencilTexture) {
                  gpuDepthStencilTexture = info.depthStencilTexture.gpuTexture;
                }

                let width = Number.MAX_SAFE_INTEGER;
                let height = Number.MAX_SAFE_INTEGER;
                this._gpuFramebuffer = {
                  gpuRenderPass: info.renderPass.gpuRenderPass,
                  gpuColorTextures,
                  gpuDepthStencilTexture,
                  glFramebuffer: null,
                  isOffscreen: true,

                  get width() {
                    return this.isOffscreen ? width : this.gpuColorTextures[0].width;
                  },

                  set width(val) {
                    width = val;
                  },

                  get height() {
                    return this.isOffscreen ? height : this.gpuColorTextures[0].height;
                  },

                  set height(val) {
                    height = val;
                  }

                };
                WebGLCmdFuncCreateFramebuffer(WebGLDeviceManager.instance, this._gpuFramebuffer);
              }

              destroy() {
                if (this._gpuFramebuffer) {
                  WebGLCmdFuncDestroyFramebuffer(WebGLDeviceManager.instance, this._gpuFramebuffer);
                  this._gpuFramebuffer = null;
                }
              }

            }

            class WebGLInputAssembler extends InputAssembler {
              constructor(...args) {
                super(...args);
                this._gpuInputAssembler = null;
              }

              get gpuInputAssembler() {
                return this._gpuInputAssembler;
              }

              initialize(info) {
                if (info.vertexBuffers.length === 0) {
                  console.error('InputAssemblerInfo.vertexBuffers is null.');
                  return;
                }

                this._attributes = info.attributes;
                this._attributesHash = this.computeAttributesHash();
                this._vertexBuffers = info.vertexBuffers;

                if (info.indexBuffer) {
                  this._indexBuffer = info.indexBuffer;
                  this._drawInfo.indexCount = this._indexBuffer.size / this._indexBuffer.stride;
                  this._drawInfo.firstIndex = 0;
                } else {
                  const vertBuff = this._vertexBuffers[0];
                  this._drawInfo.vertexCount = vertBuff.size / vertBuff.stride;
                  this._drawInfo.firstVertex = 0;
                  this._drawInfo.vertexOffset = 0;
                }

                this._drawInfo.instanceCount = 0;
                this._drawInfo.firstInstance = 0;
                this._indirectBuffer = info.indirectBuffer || null;
                const gpuVertexBuffers = new Array(info.vertexBuffers.length);

                for (let i = 0; i < info.vertexBuffers.length; ++i) {
                  const vb = info.vertexBuffers[i];

                  if (vb.gpuBuffer) {
                    gpuVertexBuffers[i] = vb.gpuBuffer;
                  }
                }

                let gpuIndexBuffer = null;
                let glIndexType = 0;

                if (info.indexBuffer) {
                  gpuIndexBuffer = info.indexBuffer.gpuBuffer;

                  if (gpuIndexBuffer) {
                    switch (gpuIndexBuffer.stride) {
                      case 1:
                        glIndexType = 0x1401;
                        break;

                      case 2:
                        glIndexType = 0x1403;
                        break;

                      case 4:
                        glIndexType = 0x1405;
                        break;

                      default:
                        {
                          console.error('Error index buffer stride.');
                        }
                    }
                  }
                }

                let gpuIndirectBuffer = null;

                if (info.indirectBuffer) {
                  gpuIndirectBuffer = info.indirectBuffer.gpuBuffer;
                }

                this._gpuInputAssembler = {
                  attributes: info.attributes,
                  gpuVertexBuffers,
                  gpuIndexBuffer,
                  gpuIndirectBuffer,
                  glAttribs: [],
                  glIndexType,
                  glVAOs: new Map()
                };
                WebGLCmdFuncCreateInputAssember(WebGLDeviceManager.instance, this._gpuInputAssembler);
              }

              destroy() {
                const device = WebGLDeviceManager.instance;

                if (this._gpuInputAssembler && device.extensions.useVAO) {
                  WebGLCmdFuncDestroyInputAssembler(device, this._gpuInputAssembler);
                }

                this._gpuInputAssembler = null;
              }

            }

            class WebGLDescriptorSetLayout extends DescriptorSetLayout {
              constructor(...args) {
                super(...args);
                this._gpuDescriptorSetLayout = null;
              }

              get gpuDescriptorSetLayout() {
                return this._gpuDescriptorSetLayout;
              }

              initialize(info) {
                Array.prototype.push.apply(this._bindings, info.bindings);
                let descriptorCount = 0;
                let maxBinding = -1;
                const flattenedIndices = [];

                for (let i = 0; i < this._bindings.length; i++) {
                  const binding = this._bindings[i];
                  flattenedIndices.push(descriptorCount);
                  descriptorCount += binding.count;
                  if (binding.binding > maxBinding) maxBinding = binding.binding;
                }

                this._bindingIndices = Array(maxBinding + 1).fill(-1);
                const descriptorIndices = this._descriptorIndices = Array(maxBinding + 1).fill(-1);

                for (let i = 0; i < this._bindings.length; i++) {
                  const binding = this._bindings[i];
                  this._bindingIndices[binding.binding] = i;
                  descriptorIndices[binding.binding] = flattenedIndices[i];
                }

                const dynamicBindings = [];

                for (let i = 0; i < this._bindings.length; i++) {
                  const binding = this._bindings[i];

                  if (binding.descriptorType & DESCRIPTOR_DYNAMIC_TYPE) {
                    for (let j = 0; j < binding.count; j++) {
                      dynamicBindings.push(binding.binding);
                    }
                  }
                }

                this._gpuDescriptorSetLayout = {
                  bindings: this._bindings,
                  dynamicBindings,
                  descriptorIndices,
                  descriptorCount
                };
              }

              destroy() {
                this._bindings.length = 0;
              }

            }

            class WebGLPipelineLayout extends PipelineLayout {
              constructor(...args) {
                super(...args);
                this._gpuPipelineLayout = null;
              }

              get gpuPipelineLayout() {
                return this._gpuPipelineLayout;
              }

              initialize(info) {
                Array.prototype.push.apply(this._setLayouts, info.setLayouts);
                const dynamicOffsetIndices = [];
                const gpuSetLayouts = [];
                let dynamicOffsetCount = 0;
                const dynamicOffsetOffsets = [];

                for (let i = 0; i < this._setLayouts.length; i++) {
                  const setLayout = this._setLayouts[i];
                  const dynamicBindings = setLayout.gpuDescriptorSetLayout.dynamicBindings;
                  const indices = Array(setLayout.bindingIndices.length).fill(-1);

                  for (let j = 0; j < dynamicBindings.length; j++) {
                    const binding = dynamicBindings[j];
                    if (indices[binding] < 0) indices[binding] = dynamicOffsetCount + j;
                  }

                  gpuSetLayouts.push(setLayout.gpuDescriptorSetLayout);
                  dynamicOffsetIndices.push(indices);
                  dynamicOffsetOffsets.push(dynamicOffsetCount);
                  dynamicOffsetCount += dynamicBindings.length;
                }

                this._gpuPipelineLayout = {
                  gpuSetLayouts,
                  dynamicOffsetIndices,
                  dynamicOffsetCount,
                  dynamicOffsetOffsets
                };
              }

              destroy() {
                this._setLayouts.length = 0;
              }

            }

            class RasterizerState {
              get native() {
                return this;
              }

              constructor(isDiscard = false, polygonMode = PolygonMode.FILL, shadeModel = ShadeModel.GOURAND, cullMode = CullMode.BACK, isFrontFaceCCW = true, depthBiasEnabled = false, depthBias = 0, depthBiasClamp = 0.0, depthBiasSlop = 0.0, isDepthClip = true, isMultisample = false, lineWidth = 1.0) {
                this.isDiscard = isDiscard;
                this.polygonMode = polygonMode;
                this.shadeModel = shadeModel;
                this.cullMode = cullMode;
                this.isFrontFaceCCW = isFrontFaceCCW;
                this.depthBiasEnabled = depthBiasEnabled;
                this.depthBias = depthBias;
                this.depthBiasClamp = depthBiasClamp;
                this.depthBiasSlop = depthBiasSlop;
                this.isDepthClip = isDepthClip;
                this.isMultisample = isMultisample;
                this.lineWidth = lineWidth;
              }

              reset() {
                this.isDiscard = false;
                this.polygonMode = PolygonMode.FILL;
                this.shadeModel = ShadeModel.GOURAND;
                this.cullMode = CullMode.BACK;
                this.isFrontFaceCCW = true;
                this.depthBiasEnabled = false;
                this.depthBias = 0;
                this.depthBiasClamp = 0.0;
                this.depthBiasSlop = 0.0;
                this.isDepthClip = true;
                this.isMultisample = false;
                this.lineWidth = 1.0;
              }

              assign(rs) {
                Object.assign(this, rs);
              }

              destroy() {}

            }
            class DepthStencilState {
              get native() {
                return this;
              }

              constructor(depthTest = true, depthWrite = true, depthFunc = ComparisonFunc.LESS, stencilTestFront = false, stencilFuncFront = ComparisonFunc.ALWAYS, stencilReadMaskFront = 0xffff, stencilWriteMaskFront = 0xffff, stencilFailOpFront = StencilOp.KEEP, stencilZFailOpFront = StencilOp.KEEP, stencilPassOpFront = StencilOp.KEEP, stencilRefFront = 1, stencilTestBack = false, stencilFuncBack = ComparisonFunc.ALWAYS, stencilReadMaskBack = 0xffff, stencilWriteMaskBack = 0xffff, stencilFailOpBack = StencilOp.KEEP, stencilZFailOpBack = StencilOp.KEEP, stencilPassOpBack = StencilOp.KEEP, stencilRefBack = 1) {
                this.depthTest = depthTest;
                this.depthWrite = depthWrite;
                this.depthFunc = depthFunc;
                this.stencilTestFront = stencilTestFront;
                this.stencilFuncFront = stencilFuncFront;
                this.stencilReadMaskFront = stencilReadMaskFront;
                this.stencilWriteMaskFront = stencilWriteMaskFront;
                this.stencilFailOpFront = stencilFailOpFront;
                this.stencilZFailOpFront = stencilZFailOpFront;
                this.stencilPassOpFront = stencilPassOpFront;
                this.stencilRefFront = stencilRefFront;
                this.stencilTestBack = stencilTestBack;
                this.stencilFuncBack = stencilFuncBack;
                this.stencilReadMaskBack = stencilReadMaskBack;
                this.stencilWriteMaskBack = stencilWriteMaskBack;
                this.stencilFailOpBack = stencilFailOpBack;
                this.stencilZFailOpBack = stencilZFailOpBack;
                this.stencilPassOpBack = stencilPassOpBack;
                this.stencilRefBack = stencilRefBack;
              }

              reset() {
                this.depthTest = true;
                this.depthWrite = true;
                this.depthFunc = ComparisonFunc.LESS;
                this.stencilTestFront = false;
                this.stencilFuncFront = ComparisonFunc.ALWAYS;
                this.stencilReadMaskFront = 0xffff;
                this.stencilWriteMaskFront = 0xffff;
                this.stencilFailOpFront = StencilOp.KEEP;
                this.stencilZFailOpFront = StencilOp.KEEP;
                this.stencilPassOpFront = StencilOp.KEEP;
                this.stencilRefFront = 1;
                this.stencilTestBack = false;
                this.stencilFuncBack = ComparisonFunc.ALWAYS;
                this.stencilReadMaskBack = 0xffff;
                this.stencilWriteMaskBack = 0xffff;
                this.stencilFailOpBack = StencilOp.KEEP;
                this.stencilZFailOpBack = StencilOp.KEEP;
                this.stencilPassOpBack = StencilOp.KEEP;
                this.stencilRefBack = 1;
              }

              assign(dss) {
                Object.assign(this, dss);
              }

              destroy() {}

            }
            class BlendTarget {
              constructor(blend = false, blendSrc = BlendFactor.ONE, blendDst = BlendFactor.ZERO, blendEq = BlendOp.ADD, blendSrcAlpha = BlendFactor.ONE, blendDstAlpha = BlendFactor.ZERO, blendAlphaEq = BlendOp.ADD, blendColorMask = ColorMask.ALL) {
                this.blend = blend;
                this.blendSrc = blendSrc;
                this.blendDst = blendDst;
                this.blendEq = blendEq;
                this.blendSrcAlpha = blendSrcAlpha;
                this.blendDstAlpha = blendDstAlpha;
                this.blendAlphaEq = blendAlphaEq;
                this.blendColorMask = blendColorMask;
              }

              reset() {
                this.blend = false;
                this.blendSrc = BlendFactor.ONE;
                this.blendDst = BlendFactor.ZERO;
                this.blendEq = BlendOp.ADD;
                this.blendSrcAlpha = BlendFactor.ONE;
                this.blendDstAlpha = BlendFactor.ZERO;
                this.blendAlphaEq = BlendOp.ADD;
                this.blendColorMask = ColorMask.ALL;
              }

              assign(target) {
                Object.assign(this, target);
              }

              destroy() {}

            }
            class BlendState {
              get native() {
                return this;
              }

              constructor(isA2C = false, isIndepend = false, blendColor = new Color(), targets = [new BlendTarget()]) {
                this.isA2C = isA2C;
                this.isIndepend = isIndepend;
                this.blendColor = blendColor;
                this.targets = targets;
              }

              setTarget(index, target) {
                let tg = this.targets[index];

                if (!tg) {
                  tg = this.targets[index] = new BlendTarget();
                }

                Object.assign(tg, target);
              }

              reset() {
                this.isA2C = false;
                this.isIndepend = false;
                this.blendColor.x = 0;
                this.blendColor.y = 0;
                this.blendColor.z = 0;
                this.blendColor.w = 0;
                this.targets.length = 1;
                this.targets[0].reset();
              }

              destroy() {}

            }
            class PipelineState extends GFXObject {
              get shader() {
                return this._shader;
              }

              get pipelineLayout() {
                return this._pipelineLayout;
              }

              get primitive() {
                return this._primitive;
              }

              get rasterizerState() {
                return this._rs;
              }

              get depthStencilState() {
                return this._dss;
              }

              get blendState() {
                return this._bs;
              }

              get inputState() {
                return this._is;
              }

              get dynamicStates() {
                return this._dynamicStates;
              }

              get renderPass() {
                return this._renderPass;
              }

              constructor() {
                super(ObjectType.PIPELINE_STATE);
                this._shader = null;
                this._pipelineLayout = null;
                this._primitive = PrimitiveMode.TRIANGLE_LIST;
                this._is = null;
                this._rs = new RasterizerState();
                this._dss = new DepthStencilState();
                this._bs = new BlendState();
                this._dynamicStates = DynamicStateFlagBit.NONE;
                this._renderPass = null;
              }

            }

            const WebGLPrimitives = [0x0000, 0x0001, 0x0003, 0x0002, 0x0000, 0x0000, 0x0000, 0x0004, 0x0005, 0x0006, 0x0000, 0x0000, 0x0000, 0x0000];
            class WebGLPipelineState extends PipelineState {
              constructor(...args) {
                super(...args);
                this._gpuPipelineState = null;
              }

              get gpuPipelineState() {
                return this._gpuPipelineState;
              }

              initialize(info) {
                this._primitive = info.primitive;
                this._shader = info.shader;
                this._pipelineLayout = info.pipelineLayout;
                const bs = this._bs;

                if (info.blendState) {
                  const bsInfo = info.blendState;
                  const {
                    targets
                  } = bsInfo;

                  if (targets) {
                    targets.forEach((t, i) => {
                      bs.setTarget(i, t);
                    });
                  }

                  if (bsInfo.isA2C !== undefined) {
                    bs.isA2C = bsInfo.isA2C;
                  }

                  if (bsInfo.isIndepend !== undefined) {
                    bs.isIndepend = bsInfo.isIndepend;
                  }

                  if (bsInfo.blendColor !== undefined) {
                    bs.blendColor = bsInfo.blendColor;
                  }
                }

                Object.assign(this._rs, info.rasterizerState);
                Object.assign(this._dss, info.depthStencilState);
                this._is = info.inputState;
                this._renderPass = info.renderPass;
                this._dynamicStates = info.dynamicStates;
                const dynamicStates = [];

                for (let i = 0; i < 31; i++) {
                  if (this._dynamicStates & 1 << i) {
                    dynamicStates.push(1 << i);
                  }
                }

                this._gpuPipelineState = {
                  glPrimitive: WebGLPrimitives[info.primitive],
                  gpuShader: info.shader.gpuShader,
                  gpuPipelineLayout: info.pipelineLayout.gpuPipelineLayout,
                  rs: info.rasterizerState,
                  dss: info.depthStencilState,
                  bs: info.blendState,
                  gpuRenderPass: info.renderPass.gpuRenderPass,
                  dynamicStates
                };
              }

              destroy() {
                this._gpuPipelineState = null;
              }

            }

            class WebGLPrimaryCommandBuffer extends WebGLCommandBuffer {
              beginRenderPass(renderPass, framebuffer, renderArea, clearColors, clearDepth, clearStencil) {
                WebGLCmdFuncBeginRenderPass(WebGLDeviceManager.instance, renderPass.gpuRenderPass, framebuffer.gpuFramebuffer, renderArea, clearColors, clearDepth, clearStencil);
                this._isInRenderPass = true;
              }

              draw(infoOrAssembler) {
                if (this._isInRenderPass) {
                  if (this._isStateInvalied) {
                    this.bindStates();
                  }

                  const info = 'drawInfo' in infoOrAssembler ? infoOrAssembler.drawInfo : infoOrAssembler;
                  WebGLCmdFuncDraw(WebGLDeviceManager.instance, info);
                  ++this._numDrawCalls;
                  this._numInstances += info.instanceCount;
                  const indexCount = info.indexCount || info.vertexCount;

                  if (this._curGPUPipelineState) {
                    const glPrimitive = this._curGPUPipelineState.glPrimitive;

                    switch (glPrimitive) {
                      case 0x0004:
                        {
                          this._numTris += indexCount / 3 * Math.max(info.instanceCount, 1);
                          break;
                        }

                      case 0x0005:
                      case 0x0006:
                        {
                          this._numTris += (indexCount - 2) * Math.max(info.instanceCount, 1);
                          break;
                        }
                    }
                  }
                } else {
                  console.error('Command \'draw\' must be recorded inside a render pass.');
                }
              }

              setViewport(viewport) {
                const {
                  stateCache: cache,
                  gl
                } = WebGLDeviceManager.instance;

                if (cache.viewport.left !== viewport.left || cache.viewport.top !== viewport.top || cache.viewport.width !== viewport.width || cache.viewport.height !== viewport.height) {
                  gl.viewport(viewport.left, viewport.top, viewport.width, viewport.height);
                  cache.viewport.left = viewport.left;
                  cache.viewport.top = viewport.top;
                  cache.viewport.width = viewport.width;
                  cache.viewport.height = viewport.height;
                }
              }

              setScissor(scissor) {
                const {
                  stateCache: cache,
                  gl
                } = WebGLDeviceManager.instance;

                if (cache.scissorRect.x !== scissor.x || cache.scissorRect.y !== scissor.y || cache.scissorRect.width !== scissor.width || cache.scissorRect.height !== scissor.height) {
                  gl.scissor(scissor.x, scissor.y, scissor.width, scissor.height);
                  cache.scissorRect.x = scissor.x;
                  cache.scissorRect.y = scissor.y;
                  cache.scissorRect.width = scissor.width;
                  cache.scissorRect.height = scissor.height;
                }
              }

              updateBuffer(buffer, data, size) {
                if (!this._isInRenderPass) {
                  const gpuBuffer = buffer.gpuBuffer;

                  if (gpuBuffer) {
                    let buffSize;

                    if (size !== undefined) {
                      buffSize = size;
                    } else if (buffer.usage & BufferUsageBit.INDIRECT) {
                      buffSize = 0;
                    } else {
                      buffSize = data.byteLength;
                    }

                    WebGLCmdFuncUpdateBuffer(WebGLDeviceManager.instance, gpuBuffer, data, 0, buffSize);
                  }
                } else {
                  console.error('Command \'updateBuffer\' must be recorded outside a render pass.');
                }
              }

              copyBuffersToTexture(buffers, texture, regions) {
                if (!this._isInRenderPass) {
                  const gpuTexture = texture.gpuTexture;

                  if (gpuTexture) {
                    WebGLCmdFuncCopyBuffersToTexture(WebGLDeviceManager.instance, buffers, gpuTexture, regions);
                  }
                } else {
                  console.error('Command \'copyBufferToTexture\' must be recorded outside a render pass.');
                }
              }

              execute(cmdBuffs, count) {
                for (let i = 0; i < count; ++i) {
                  const webGLCmdBuff = cmdBuffs[i];
                  WebGLCmdFuncExecuteCmds(WebGLDeviceManager.instance, webGLCmdBuff.cmdPackage);
                  this._numDrawCalls += webGLCmdBuff._numDrawCalls;
                  this._numInstances += webGLCmdBuff._numInstances;
                  this._numTris += webGLCmdBuff._numTris;
                }
              }

              bindStates() {
                WebGLCmdFuncBindStates(WebGLDeviceManager.instance, this._curGPUPipelineState, this._curGPUInputAssembler, this._curGPUDescriptorSets, this._curDynamicOffsets, this._curDynamicStates);
                this._isStateInvalied = false;
              }

            }

            class WebGLQueue extends Queue {
              constructor(...args) {
                super(...args);
                this.numDrawCalls = 0;
                this.numInstances = 0;
                this.numTris = 0;
              }

              initialize(info) {
                this._type = info.type;
              }

              destroy() {}

              submit(cmdBuffs) {
                const len = cmdBuffs.length;

                for (let i = 0; i < len; i++) {
                  const cmdBuff = cmdBuffs[i];
                  this.numDrawCalls += cmdBuff.numDrawCalls;
                  this.numInstances += cmdBuff.numInstances;
                  this.numTris += cmdBuff.numTris;
                }
              }

              clear() {
                this.numDrawCalls = 0;
                this.numInstances = 0;
                this.numTris = 0;
              }

            }

            class WebGLRenderPass extends RenderPass {
              constructor(...args) {
                super(...args);
                this._gpuRenderPass = null;
              }

              get gpuRenderPass() {
                return this._gpuRenderPass;
              }

              initialize(info) {
                this._colorInfos = info.colorAttachments;
                this._depthStencilInfo = info.depthStencilAttachment;
                this._subpasses = info.subpasses;
                this._gpuRenderPass = {
                  colorAttachments: this._colorInfos,
                  depthStencilAttachment: this._depthStencilInfo
                };
                this._hash = this.computeHash();
              }

              destroy() {
                this._gpuRenderPass = null;
              }

            }

            const WebGLWraps = [0x2901, 0x8370, 0x812F, 0x812F];
            class WebGLSampler extends Sampler {
              get gpuSampler() {
                return this._gpuSampler;
              }

              constructor(info, hash) {
                super(info, hash);
                this._gpuSampler = null;
                let glMinFilter = 0;
                let glMagFilter = 0;
                const minFilter = this._info.minFilter;
                const magFilter = this._info.magFilter;
                const mipFilter = this._info.mipFilter;

                if (minFilter === Filter.LINEAR || minFilter === Filter.ANISOTROPIC) {
                  if (mipFilter === Filter.LINEAR || mipFilter === Filter.ANISOTROPIC) {
                    glMinFilter = 0x2703;
                  } else if (mipFilter === Filter.POINT) {
                    glMinFilter = 0x2701;
                  } else {
                    glMinFilter = 0x2601;
                  }
                } else if (mipFilter === Filter.LINEAR || mipFilter === Filter.ANISOTROPIC) {
                  glMinFilter = 0x2702;
                } else if (mipFilter === Filter.POINT) {
                  glMinFilter = 0x2700;
                } else {
                  glMinFilter = 0x2600;
                }

                if (magFilter === Filter.LINEAR || magFilter === Filter.ANISOTROPIC) {
                  glMagFilter = 0x2601;
                } else {
                  glMagFilter = 0x2600;
                }

                const glWrapS = WebGLWraps[this._info.addressU];
                const glWrapT = WebGLWraps[this._info.addressV];
                const glWrapR = WebGLWraps[this._info.addressW];
                this._gpuSampler = {
                  glMinFilter,
                  glMagFilter,
                  glWrapS,
                  glWrapT,
                  glWrapR
                };
              }

            }

            class WebGLShader extends Shader {
              constructor(...args) {
                super(...args);
                this._gpuShader = null;
              }

              get gpuShader() {
                return this._gpuShader;
              }

              initialize(info) {
                this._name = info.name;
                this._stages = info.stages;
                this._attributes = info.attributes;
                this._blocks = info.blocks;
                this._samplers = info.samplers;
                this._gpuShader = {
                  name: info.name,
                  blocks: info.blocks.slice(),
                  samplerTextures: info.samplerTextures.slice(),
                  subpassInputs: info.subpassInputs.slice(),
                  gpuStages: new Array(info.stages.length),
                  glProgram: null,
                  glInputs: [],
                  glUniforms: [],
                  glBlocks: [],
                  glSamplerTextures: []
                };

                for (let i = 0; i < info.stages.length; ++i) {
                  const stage = info.stages[i];
                  this._gpuShader.gpuStages[i] = {
                    type: stage.stage,
                    source: stage.source,
                    glShader: null
                  };
                }

                WebGLCmdFuncCreateShader(WebGLDeviceManager.instance, this._gpuShader);
              }

              destroy() {
                if (this._gpuShader) {
                  WebGLCmdFuncDestroyShader(WebGLDeviceManager.instance, this._gpuShader);
                  this._gpuShader = null;
                }
              }

            }

            class WebGLStateCache {
              constructor() {
                this.glArrayBuffer = null;
                this.glElementArrayBuffer = null;
                this.glVAO = null;
                this.texUnit = 0;
                this.glTexUnits = [];
                this.glRenderbuffer = null;
                this.glFramebuffer = null;
                this.viewport = new Viewport();
                this.scissorRect = new Rect(0, 0, 0, 0);
                this.rs = new RasterizerState();
                this.dss = new DepthStencilState();
                this.bs = new BlendState();
                this.glProgram = null;
                this.glEnabledAttribLocs = [];
                this.glCurrentAttribLocs = [];
                this.texUnitCacheMap = {};
              }

              initialize(texUnit, vertexAttributes) {
                for (let i = 0; i < texUnit; ++i) this.glTexUnits.push({
                  glTexture: null
                });

                this.glEnabledAttribLocs.length = vertexAttributes;
                this.glEnabledAttribLocs.fill(false);
                this.glCurrentAttribLocs.length = vertexAttributes;
                this.glCurrentAttribLocs.fill(false);
              }

            }

            class WebGLTexture extends Texture {
              constructor(...args) {
                super(...args);
                this._gpuTexture = null;
              }

              get gpuTexture() {
                return this._gpuTexture;
              }

              initialize(info, isSwapchainTexture) {
                if ('texture' in info) {
                  console.log('WebGL does not support texture view.');
                  return;
                }

                this._type = info.type;
                this._usage = info.usage;
                this._format = info.format;
                this._width = info.width;
                this._height = info.height;
                this._depth = info.depth;
                this._layerCount = info.layerCount;
                this._levelCount = info.levelCount;
                this._samples = info.samples;
                this._flags = info.flags;
                this._isPowerOf2 = IsPowerOf2(this._width) && IsPowerOf2(this._height);
                this._size = FormatSurfaceSize(this._format, this.width, this.height, this.depth, this._levelCount) * this._layerCount;
                this._gpuTexture = {
                  type: this._type,
                  format: this._format,
                  usage: this._usage,
                  width: this._width,
                  height: this._height,
                  depth: this._depth,
                  size: this._size,
                  arrayLayer: this._layerCount,
                  mipLevel: this._levelCount,
                  samples: this._samples,
                  flags: this._flags,
                  isPowerOf2: this._isPowerOf2,
                  glTarget: 0,
                  glInternalFmt: 0,
                  glFormat: 0,
                  glType: 0,
                  glUsage: 0,
                  glTexture: null,
                  glRenderbuffer: null,
                  glWrapS: 0,
                  glWrapT: 0,
                  glMinFilter: 0,
                  glMagFilter: 0,
                  isSwapchainTexture: isSwapchainTexture || false
                };
                WebGLCmdFuncCreateTexture(WebGLDeviceManager.instance, this._gpuTexture);
                WebGLDeviceManager.instance.memoryStatus.textureSize += this._size;
              }

              destroy() {
                if (this._gpuTexture) {
                  WebGLCmdFuncDestroyTexture(WebGLDeviceManager.instance, this._gpuTexture);
                  WebGLDeviceManager.instance.memoryStatus.textureSize -= this._size;
                  this._gpuTexture = null;
                }
              }

              resize(width, height) {
                const oldSize = this._size;
                this._width = width;
                this._height = height;
                this._size = FormatSurfaceSize(this._format, this.width, this.height, this.depth, this._levelCount) * this._layerCount;

                if (this._gpuTexture) {
                  this._gpuTexture.width = width;
                  this._gpuTexture.height = height;
                  this._gpuTexture.size = this._size;
                  WebGLCmdFuncResizeTexture(WebGLDeviceManager.instance, this._gpuTexture);
                  WebGLDeviceManager.instance.memoryStatus.textureSize -= oldSize;
                  WebGLDeviceManager.instance.memoryStatus.textureSize += this._size;
                }
              }

              initAsSwapchainTexture(info) {
                const texInfo = new TextureInfo();
                texInfo.format = info.format;
                texInfo.usage = FormatInfos[info.format].hasDepth ? TextureUsageBit.DEPTH_STENCIL_ATTACHMENT : TextureUsageBit.COLOR_ATTACHMENT;
                texInfo.width = info.width;
                texInfo.height = info.height;
                this.initialize(texInfo, true);
              }

            }

            const eventWebGLContextLost = 'webglcontextlost';

            function initStates(gl) {
              gl.activeTexture(gl.TEXTURE0);
              gl.pixelStorei(gl.PACK_ALIGNMENT, 1);
              gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
              gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
              gl.enable(gl.SCISSOR_TEST);
              gl.enable(gl.CULL_FACE);
              gl.cullFace(gl.BACK);
              gl.frontFace(gl.CCW);
              gl.disable(gl.POLYGON_OFFSET_FILL);
              gl.polygonOffset(0.0, 0.0);
              gl.enable(gl.DEPTH_TEST);
              gl.depthMask(true);
              gl.depthFunc(gl.LESS);
              gl.depthRange(0.0, 1.0);
              gl.stencilFuncSeparate(gl.FRONT, gl.ALWAYS, 1, 0xffff);
              gl.stencilOpSeparate(gl.FRONT, gl.KEEP, gl.KEEP, gl.KEEP);
              gl.stencilMaskSeparate(gl.FRONT, 0xffff);
              gl.stencilFuncSeparate(gl.BACK, gl.ALWAYS, 1, 0xffff);
              gl.stencilOpSeparate(gl.BACK, gl.KEEP, gl.KEEP, gl.KEEP);
              gl.stencilMaskSeparate(gl.BACK, 0xffff);
              gl.disable(gl.STENCIL_TEST);
              gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
              gl.disable(gl.BLEND);
              gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
              gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
              gl.colorMask(true, true, true, true);
              gl.blendColor(0.0, 0.0, 0.0, 0.0);
            }

            function getExtension(gl, ext) {
              const prefixes = ['', 'WEBKIT_', 'MOZ_'];

              for (let i = 0; i < prefixes.length; ++i) {
                const _ext = gl.getExtension(prefixes[i] + ext);

                if (_ext) {
                  return _ext;
                }
              }

              return null;
            }

            function getExtensions(gl) {
              const res = {
                EXT_texture_filter_anisotropic: getExtension(gl, 'EXT_texture_filter_anisotropic'),
                EXT_blend_minmax: getExtension(gl, 'EXT_blend_minmax'),
                EXT_frag_depth: getExtension(gl, 'EXT_frag_depth'),
                EXT_shader_texture_lod: getExtension(gl, 'EXT_shader_texture_lod'),
                EXT_sRGB: getExtension(gl, 'EXT_sRGB'),
                OES_vertex_array_object: getExtension(gl, 'OES_vertex_array_object'),
                EXT_color_buffer_half_float: getExtension(gl, 'EXT_color_buffer_half_float'),
                WEBGL_color_buffer_float: getExtension(gl, 'WEBGL_color_buffer_float'),
                WEBGL_compressed_texture_etc1: getExtension(gl, 'WEBGL_compressed_texture_etc1'),
                WEBGL_compressed_texture_etc: getExtension(gl, 'WEBGL_compressed_texture_etc'),
                WEBGL_compressed_texture_pvrtc: getExtension(gl, 'WEBGL_compressed_texture_pvrtc'),
                WEBGL_compressed_texture_s3tc: getExtension(gl, 'WEBGL_compressed_texture_s3tc'),
                WEBGL_compressed_texture_s3tc_srgb: getExtension(gl, 'WEBGL_compressed_texture_s3tc_srgb'),
                WEBGL_debug_shaders: getExtension(gl, 'WEBGL_debug_shaders'),
                WEBGL_draw_buffers: getExtension(gl, 'WEBGL_draw_buffers'),
                WEBGL_lose_context: getExtension(gl, 'WEBGL_lose_context'),
                WEBGL_depth_texture: getExtension(gl, 'WEBGL_depth_texture'),
                OES_texture_half_float: getExtension(gl, 'OES_texture_half_float'),
                OES_texture_half_float_linear: getExtension(gl, 'OES_texture_half_float_linear'),
                OES_texture_float: getExtension(gl, 'OES_texture_float'),
                OES_texture_float_linear: getExtension(gl, 'OES_texture_float_linear'),
                OES_standard_derivatives: getExtension(gl, 'OES_standard_derivatives'),
                OES_element_index_uint: getExtension(gl, 'OES_element_index_uint'),
                ANGLE_instanced_arrays: getExtension(gl, 'ANGLE_instanced_arrays'),
                WEBGL_debug_renderer_info: getExtension(gl, 'WEBGL_debug_renderer_info'),
                WEBGL_multi_draw: null,
                WEBGL_compressed_texture_astc: null,
                destroyShadersImmediately: true,
                noCompressedTexSubImage2D: false,
                isLocationActive: glLoc => !!glLoc,
                useVAO: false
              };
              {
                if (systemInfo.os !== OS.IOS || systemInfo.osMainVersion !== 14 || !systemInfo.isBrowser) {
                  res.WEBGL_compressed_texture_astc = getExtension(gl, 'WEBGL_compressed_texture_astc');
                }

                if (systemInfo.os !== OS.ANDROID && systemInfo.os !== OS.IOS) {
                  res.WEBGL_multi_draw = getExtension(gl, 'WEBGL_multi_draw');
                }

                if (systemInfo.browserType === BrowserType.UC) {
                  res.ANGLE_instanced_arrays = null;
                }

                if (systemInfo.os === OS.IOS && systemInfo.osMainVersion <= 10 || WECHAT ) {
                  res.destroyShadersImmediately = false;
                }
              }

              if (res.OES_vertex_array_object) {
                res.useVAO = true;
              }

              return res;
            }
            function getContext(canvas) {
              let context = null;

              try {
                const webGLCtxAttribs = {
                  alpha: macro.ENABLE_TRANSPARENT_CANVAS,
                  antialias: EDITOR || macro.ENABLE_WEBGL_ANTIALIAS,
                  depth: true,
                  stencil: true,
                  premultipliedAlpha: false,
                  preserveDrawingBuffer: false,
                  powerPreference: 'default',
                  failIfMajorPerformanceCaveat: false
                };
                context = canvas.getContext('webgl', webGLCtxAttribs);
              } catch (err) {
                return null;
              }

              return context;
            }
            class WebGLSwapchain extends Swapchain {
              constructor(...args) {
                super(...args);
                this.stateCache = new WebGLStateCache();
                this.cmdAllocator = new WebGLCommandAllocator();
                this.nullTex2D = null;
                this.nullTexCube = null;
                this._canvas = null;
                this._webGLContextLostHandler = null;
                this._extensions = null;
              }

              get extensions() {
                return this._extensions;
              }

              initialize(info) {
                this._canvas = info.windowHandle;
                this._webGLContextLostHandler = this._onWebGLContextLost.bind(this);

                this._canvas.addEventListener(eventWebGLContextLost, this._onWebGLContextLost);

                const gl = WebGLDeviceManager.instance.gl;
                this.stateCache.initialize(WebGLDeviceManager.instance.capabilities.maxTextureUnits, WebGLDeviceManager.instance.capabilities.maxVertexAttributes);
                this._extensions = getExtensions(gl);
                initStates(gl);
                const colorFmt = Format.RGBA8;
                let depthStencilFmt = Format.DEPTH_STENCIL;
                let depthBits = gl.getParameter(gl.DEPTH_BITS);
                const stencilBits = gl.getParameter(gl.STENCIL_BITS);

                if (depthBits && stencilBits) depthStencilFmt = Format.DEPTH_STENCIL;else if (depthBits) depthStencilFmt = Format.DEPTH;
                this._colorTexture = new WebGLTexture();

                this._colorTexture.initAsSwapchainTexture({
                  swapchain: this,
                  format: colorFmt,
                  width: info.width,
                  height: info.height
                });

                this._depthStencilTexture = new WebGLTexture();

                this._depthStencilTexture.initAsSwapchainTexture({
                  swapchain: this,
                  format: depthStencilFmt,
                  width: info.width,
                  height: info.height
                });

                this.nullTex2D = WebGLDeviceManager.instance.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.SAMPLED, Format.RGBA8, 2, 2, TextureFlagBit.GEN_MIPMAP));
                this.nullTexCube = WebGLDeviceManager.instance.createTexture(new TextureInfo(TextureType.CUBE, TextureUsageBit.SAMPLED, Format.RGBA8, 2, 2, TextureFlagBit.GEN_MIPMAP, 6));
                const nullTexRegion = new BufferTextureCopy();
                nullTexRegion.texExtent.width = 2;
                nullTexRegion.texExtent.height = 2;
                const nullTexBuff = new Uint8Array(this.nullTex2D.size);
                nullTexBuff.fill(0);
                WebGLDeviceManager.instance.copyBuffersToTexture([nullTexBuff], this.nullTex2D, [nullTexRegion]);
                nullTexRegion.texSubres.layerCount = 6;
                WebGLDeviceManager.instance.copyBuffersToTexture([nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff], this.nullTexCube, [nullTexRegion]);
              }

              destroy() {
                if (this._canvas && this._webGLContextLostHandler) {
                  this._canvas.removeEventListener(eventWebGLContextLost, this._webGLContextLostHandler);

                  this._webGLContextLostHandler = null;
                }

                if (this.nullTex2D) {
                  this.nullTex2D.destroy();
                  this.nullTex2D = null;
                }

                if (this.nullTexCube) {
                  this.nullTexCube.destroy();
                  this.nullTexCube = null;
                }

                this._extensions = null;
                this._canvas = null;
              }

              resize(width, height, surfaceTransform) {
                if (this._colorTexture.width !== width || this._colorTexture.height !== height) {
                  debug(`Resizing swapchain: ${width}x${height}`);
                  this._canvas.width = width;
                  this._canvas.height = height;

                  this._colorTexture.resize(width, height);

                  this._depthStencilTexture.resize(width, height);
                }
              }

              _onWebGLContextLost(event) {
                warnID(11000);
                warn(event);
              }

            }

            class WebGLDevice extends Device {
              constructor(...args) {
                super(...args);
                this._swapchain = null;
                this._context = null;
              }

              get gl() {
                return this._context;
              }

              get extensions() {
                return this._swapchain.extensions;
              }

              get stateCache() {
                return this._swapchain.stateCache;
              }

              get nullTex2D() {
                return this._swapchain.nullTex2D;
              }

              get nullTexCube() {
                return this._swapchain.nullTexCube;
              }

              initialize(info) {
                WebGLDeviceManager.setInstance(this);
                this._gfxAPI = API.WEBGL;
                this._bindingMappingInfo = info.bindingMappingInfo;
                if (!this._bindingMappingInfo.bufferOffsets.length) this._bindingMappingInfo.bufferOffsets.push(0);
                if (!this._bindingMappingInfo.samplerOffsets.length) this._bindingMappingInfo.samplerOffsets.push(0);
                const gl = this._context = getContext(Device.canvas);

                if (!gl) {
                  console.error('This device does not support WebGL.');
                  return false;
                }

                this._queue = this.createQueue(new QueueInfo(QueueType.GRAPHICS));
                this._cmdBuff = this.createCommandBuffer(new CommandBufferInfo(this._queue));
                this._caps.maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
                this._caps.maxVertexUniformVectors = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
                this._caps.maxFragmentUniformVectors = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
                this._caps.maxTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
                this._caps.maxVertexTextureUnits = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
                this._caps.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
                this._caps.maxCubeMapTextureSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
                this._caps.maxUniformBufferBindings = 16;
                const extensions = gl.getSupportedExtensions();
                let extStr = '';

                if (extensions) {
                  for (const ext of extensions) {
                    extStr += `${ext} `;
                  }
                }

                const exts = getExtensions(gl);

                if (exts.WEBGL_debug_renderer_info) {
                  this._renderer = gl.getParameter(exts.WEBGL_debug_renderer_info.UNMASKED_RENDERER_WEBGL);
                  this._vendor = gl.getParameter(exts.WEBGL_debug_renderer_info.UNMASKED_VENDOR_WEBGL);
                } else {
                  this._renderer = gl.getParameter(gl.RENDERER);
                  this._vendor = gl.getParameter(gl.VENDOR);
                }

                const version = gl.getParameter(gl.VERSION);

                this._features.fill(false);

                if (exts.EXT_sRGB) {
                  this._features[Feature.FORMAT_SRGB] = true;
                }

                if (exts.EXT_blend_minmax) {
                  this._features[Feature.BLEND_MINMAX] = true;
                }

                if (exts.WEBGL_color_buffer_float) {
                  this._features[Feature.COLOR_FLOAT] = true;
                }

                if (exts.EXT_color_buffer_half_float) {
                  this._features[Feature.COLOR_HALF_FLOAT] = true;
                }

                if (exts.OES_texture_float) {
                  this._features[Feature.TEXTURE_FLOAT] = true;
                }

                if (exts.OES_texture_half_float) {
                  this._features[Feature.TEXTURE_HALF_FLOAT] = true;
                }

                if (exts.OES_texture_float_linear) {
                  this._features[Feature.TEXTURE_FLOAT_LINEAR] = true;
                }

                if (exts.OES_texture_half_float_linear) {
                  this._features[Feature.TEXTURE_HALF_FLOAT_LINEAR] = true;
                }

                this._features[Feature.FORMAT_RGB8] = true;

                if (exts.OES_element_index_uint) {
                  this._features[Feature.ELEMENT_INDEX_UINT] = true;
                }

                if (exts.ANGLE_instanced_arrays) {
                  this._features[Feature.INSTANCED_ARRAYS] = true;
                }

                if (exts.WEBGL_draw_buffers) {
                  this._features[Feature.MULTIPLE_RENDER_TARGETS] = true;
                }

                let compressedFormat = '';

                if (exts.WEBGL_compressed_texture_etc1) {
                  this._features[Feature.FORMAT_ETC1] = true;
                  compressedFormat += 'etc1 ';
                }

                if (exts.WEBGL_compressed_texture_etc) {
                  this._features[Feature.FORMAT_ETC2] = true;
                  compressedFormat += 'etc2 ';
                }

                if (exts.WEBGL_compressed_texture_s3tc) {
                  this._features[Feature.FORMAT_DXT] = true;
                  compressedFormat += 'dxt ';
                }

                if (exts.WEBGL_compressed_texture_pvrtc) {
                  this._features[Feature.FORMAT_PVRTC] = true;
                  compressedFormat += 'pvrtc ';
                }

                if (exts.WEBGL_compressed_texture_astc) {
                  this._features[Feature.FORMAT_ASTC] = true;
                  compressedFormat += 'astc ';
                }

                debug('WebGL device initialized.');
                debug(`RENDERER: ${this._renderer}`);
                debug(`VENDOR: ${this._vendor}`);
                debug(`VERSION: ${version}`);
                debug(`COMPRESSED_FORMAT: ${compressedFormat}`);
                debug(`EXTENSIONS: ${extStr}`);
                return true;
              }

              destroy() {
                if (this._queue) {
                  this._queue.destroy();

                  this._queue = null;
                }

                if (this._cmdBuff) {
                  this._cmdBuff.destroy();

                  this._cmdBuff = null;
                }
              }

              flushCommands(cmdBuffs) {}

              acquire(swapchains) {}

              present() {
                const queue = this._queue;
                this._numDrawCalls = queue.numDrawCalls;
                this._numInstances = queue.numInstances;
                this._numTris = queue.numTris;
                queue.clear();
              }

              createCommandBuffer(info) {
                const Ctor = info.type === CommandBufferType.PRIMARY ? WebGLPrimaryCommandBuffer : WebGLCommandBuffer;
                const cmdBuff = new Ctor();
                cmdBuff.initialize(info);
                return cmdBuff;
              }

              createSwapchain(info) {
                const swapchain = new WebGLSwapchain();
                this._swapchain = swapchain;
                swapchain.initialize(info);
                return swapchain;
              }

              createBuffer(info) {
                const buffer = new WebGLBuffer();
                buffer.initialize(info);
                return buffer;
              }

              createTexture(info) {
                const texture = new WebGLTexture();
                texture.initialize(info);
                return texture;
              }

              createDescriptorSet(info) {
                const descriptorSet = new WebGLDescriptorSet();
                descriptorSet.initialize(info);
                return descriptorSet;
              }

              createShader(info) {
                const shader = new WebGLShader();
                shader.initialize(info);
                return shader;
              }

              createInputAssembler(info) {
                const inputAssembler = new WebGLInputAssembler();
                inputAssembler.initialize(info);
                return inputAssembler;
              }

              createRenderPass(info) {
                const renderPass = new WebGLRenderPass();
                renderPass.initialize(info);
                return renderPass;
              }

              createFramebuffer(info) {
                const framebuffer = new WebGLFramebuffer();
                framebuffer.initialize(info);
                return framebuffer;
              }

              createDescriptorSetLayout(info) {
                const descriptorSetLayout = new WebGLDescriptorSetLayout();
                descriptorSetLayout.initialize(info);
                return descriptorSetLayout;
              }

              createPipelineLayout(info) {
                const pipelineLayout = new WebGLPipelineLayout();
                pipelineLayout.initialize(info);
                return pipelineLayout;
              }

              createPipelineState(info) {
                const pipelineState = new WebGLPipelineState();
                pipelineState.initialize(info);
                return pipelineState;
              }

              createQueue(info) {
                const queue = new WebGLQueue();
                queue.initialize(info);
                return queue;
              }

              getSampler(info) {
                const hash = Sampler.computeHash(info);

                if (!this._samplers.has(hash)) {
                  this._samplers.set(hash, new WebGLSampler(info, hash));
                }

                return this._samplers.get(hash);
              }

              getGlobalBarrier(info) {
                const hash = GlobalBarrier.computeHash(info);

                if (!this._globalBarriers.has(hash)) {
                  this._globalBarriers.set(hash, new GlobalBarrier(info, hash));
                }

                return this._globalBarriers.get(hash);
              }

              getTextureBarrier(info) {
                const hash = TextureBarrier.computeHash(info);

                if (!this._textureBarriers.has(hash)) {
                  this._textureBarriers.set(hash, new TextureBarrier(info, hash));
                }

                return this._textureBarriers.get(hash);
              }

              copyBuffersToTexture(buffers, texture, regions) {
                WebGLCmdFuncCopyBuffersToTexture(this, buffers, texture.gpuTexture, regions);
              }

              copyTextureToBuffers(texture, buffers, regions) {
                WebGLCmdFuncCopyTextureToBuffers(this, texture.gpuTexture, buffers, regions);
              }

              copyTexImagesToTexture(texImages, texture, regions) {
                WebGLCmdFuncCopyTexImagesToTexture(this, texImages, texture.gpuTexture, regions);
              }

            } exports('WebGLDevice', WebGLDevice);

            legacyCC.WebGLDevice = WebGLDevice;

            class WebGL2DescriptorSet extends DescriptorSet {
              constructor(...args) {
                super(...args);
                this._gpuDescriptorSet = null;
              }

              get gpuDescriptorSet() {
                return this._gpuDescriptorSet;
              }

              initialize(info) {
                this._layout = info.layout;
                const {
                  bindings,
                  descriptorIndices,
                  descriptorCount
                } = info.layout.gpuDescriptorSetLayout;
                this._buffers = Array(descriptorCount).fill(null);
                this._textures = Array(descriptorCount).fill(null);
                this._samplers = Array(descriptorCount).fill(null);
                const gpuDescriptors = [];
                this._gpuDescriptorSet = {
                  gpuDescriptors,
                  descriptorIndices
                };

                for (let i = 0; i < bindings.length; ++i) {
                  const binding = bindings[i];

                  for (let j = 0; j < binding.count; j++) {
                    gpuDescriptors.push({
                      type: binding.descriptorType,
                      gpuBuffer: null,
                      gpuTexture: null,
                      gpuSampler: null
                    });
                  }
                }
              }

              destroy() {
                this._layout = null;
                this._gpuDescriptorSet = null;
              }

              update() {
                if (this._isDirty && this._gpuDescriptorSet) {
                  const descriptors = this._gpuDescriptorSet.gpuDescriptors;

                  for (let i = 0; i < descriptors.length; ++i) {
                    if (descriptors[i].type & DESCRIPTOR_BUFFER_TYPE) {
                      if (this._buffers[i]) {
                        descriptors[i].gpuBuffer = this._buffers[i].gpuBuffer;
                      }
                    } else if (descriptors[i].type & DESCRIPTOR_SAMPLER_TYPE) {
                      if (this._textures[i]) {
                        descriptors[i].gpuTexture = this._textures[i].gpuTexture;
                      }

                      if (this._samplers[i]) {
                        descriptors[i].gpuSampler = this._samplers[i].gpuSampler;
                      }
                    }
                  }

                  this._isDirty = false;
                }
              }

            }

            let WebGL2EXT;

            (function (WebGL2EXT) {
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGB_PVRTC_2BPPV1_IMG"] = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL";
              WebGL2EXT[WebGL2EXT["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ETC2"] = 37493] = "COMPRESSED_SRGB8_ETC2";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA8_ETC2_EAC"] = 37496] = "COMPRESSED_RGBA8_ETC2_EAC";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_4x4_KHR"] = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_5x4_KHR"] = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_5x5_KHR"] = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_6x5_KHR"] = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_6x6_KHR"] = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_8x5_KHR"] = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_8x6_KHR"] = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_8x8_KHR"] = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_10x5_KHR"] = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_10x6_KHR"] = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_10x8_KHR"] = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_10x10_KHR"] = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_12x10_KHR"] = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_RGBA_ASTC_12x12_KHR"] = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR"] = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR"] = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR"] = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR"] = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR"] = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR"] = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR"] = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR"] = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR"] = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR"] = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR"] = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR"] = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR"] = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR";
              WebGL2EXT[WebGL2EXT["COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR"] = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR";
            })(WebGL2EXT || (WebGL2EXT = {}));

            class WebGL2DeviceManager {
              static get instance() {
                return WebGL2DeviceManager._instance;
              }

              static setInstance(instance) {
                WebGL2DeviceManager._instance = instance;
              }

            }
            WebGL2DeviceManager._instance = null;

            const WebGLWraps$1 = [0x2901, 0x8370, 0x812F, 0x812F];

            const _f32v4 = new Float32Array(4);

            function GFXFormatToWebGLType$1(format, gl) {
              switch (format) {
                case Format.R8:
                  return gl.UNSIGNED_BYTE;

                case Format.R8SN:
                  return gl.BYTE;

                case Format.R8UI:
                  return gl.UNSIGNED_BYTE;

                case Format.R8I:
                  return gl.BYTE;

                case Format.R16F:
                  return gl.HALF_FLOAT;

                case Format.R16UI:
                  return gl.UNSIGNED_SHORT;

                case Format.R16I:
                  return gl.SHORT;

                case Format.R32F:
                  return gl.FLOAT;

                case Format.R32UI:
                  return gl.UNSIGNED_INT;

                case Format.R32I:
                  return gl.INT;

                case Format.RG8:
                  return gl.UNSIGNED_BYTE;

                case Format.RG8SN:
                  return gl.BYTE;

                case Format.RG8UI:
                  return gl.UNSIGNED_BYTE;

                case Format.RG8I:
                  return gl.BYTE;

                case Format.RG16F:
                  return gl.HALF_FLOAT;

                case Format.RG16UI:
                  return gl.UNSIGNED_SHORT;

                case Format.RG16I:
                  return gl.SHORT;

                case Format.RG32F:
                  return gl.FLOAT;

                case Format.RG32UI:
                  return gl.UNSIGNED_INT;

                case Format.RG32I:
                  return gl.INT;

                case Format.RGB8:
                  return gl.UNSIGNED_BYTE;

                case Format.SRGB8:
                  return gl.UNSIGNED_BYTE;

                case Format.RGB8SN:
                  return gl.BYTE;

                case Format.RGB8UI:
                  return gl.UNSIGNED_BYTE;

                case Format.RGB8I:
                  return gl.BYTE;

                case Format.RGB16F:
                  return gl.HALF_FLOAT;

                case Format.RGB16UI:
                  return gl.UNSIGNED_SHORT;

                case Format.RGB16I:
                  return gl.SHORT;

                case Format.RGB32F:
                  return gl.FLOAT;

                case Format.RGB32UI:
                  return gl.UNSIGNED_INT;

                case Format.RGB32I:
                  return gl.INT;

                case Format.BGRA8:
                  return gl.UNSIGNED_BYTE;

                case Format.RGBA8:
                  return gl.UNSIGNED_BYTE;

                case Format.SRGB8_A8:
                  return gl.UNSIGNED_BYTE;

                case Format.RGBA8SN:
                  return gl.BYTE;

                case Format.RGBA8UI:
                  return gl.UNSIGNED_BYTE;

                case Format.RGBA8I:
                  return gl.BYTE;

                case Format.RGBA16F:
                  return gl.HALF_FLOAT;

                case Format.RGBA16UI:
                  return gl.UNSIGNED_SHORT;

                case Format.RGBA16I:
                  return gl.SHORT;

                case Format.RGBA32F:
                  return gl.FLOAT;

                case Format.RGBA32UI:
                  return gl.UNSIGNED_INT;

                case Format.RGBA32I:
                  return gl.INT;

                case Format.R5G6B5:
                  return gl.UNSIGNED_SHORT_5_6_5;

                case Format.R11G11B10F:
                  return gl.UNSIGNED_INT_10F_11F_11F_REV;

                case Format.RGB5A1:
                  return gl.UNSIGNED_SHORT_5_5_5_1;

                case Format.RGBA4:
                  return gl.UNSIGNED_SHORT_4_4_4_4;

                case Format.RGB10A2:
                  return gl.UNSIGNED_INT_2_10_10_10_REV;

                case Format.RGB10A2UI:
                  return gl.UNSIGNED_INT_2_10_10_10_REV;

                case Format.RGB9E5:
                  return gl.FLOAT;

                case Format.DEPTH:
                  return gl.FLOAT;

                case Format.DEPTH_STENCIL:
                  return gl.UNSIGNED_INT_24_8;

                case Format.BC1:
                  return gl.UNSIGNED_BYTE;

                case Format.BC1_SRGB:
                  return gl.UNSIGNED_BYTE;

                case Format.BC2:
                  return gl.UNSIGNED_BYTE;

                case Format.BC2_SRGB:
                  return gl.UNSIGNED_BYTE;

                case Format.BC3:
                  return gl.UNSIGNED_BYTE;

                case Format.BC3_SRGB:
                  return gl.UNSIGNED_BYTE;

                case Format.BC4:
                  return gl.UNSIGNED_BYTE;

                case Format.BC4_SNORM:
                  return gl.BYTE;

                case Format.BC5:
                  return gl.UNSIGNED_BYTE;

                case Format.BC5_SNORM:
                  return gl.BYTE;

                case Format.BC6H_SF16:
                  return gl.FLOAT;

                case Format.BC6H_UF16:
                  return gl.FLOAT;

                case Format.BC7:
                  return gl.UNSIGNED_BYTE;

                case Format.BC7_SRGB:
                  return gl.UNSIGNED_BYTE;

                case Format.ETC_RGB8:
                  return gl.UNSIGNED_BYTE;

                case Format.ETC2_RGB8:
                  return gl.UNSIGNED_BYTE;

                case Format.ETC2_SRGB8:
                  return gl.UNSIGNED_BYTE;

                case Format.ETC2_RGB8_A1:
                  return gl.UNSIGNED_BYTE;

                case Format.ETC2_SRGB8_A1:
                  return gl.UNSIGNED_BYTE;

                case Format.EAC_R11:
                  return gl.UNSIGNED_BYTE;

                case Format.EAC_R11SN:
                  return gl.BYTE;

                case Format.EAC_RG11:
                  return gl.UNSIGNED_BYTE;

                case Format.EAC_RG11SN:
                  return gl.BYTE;

                case Format.PVRTC_RGB2:
                  return gl.UNSIGNED_BYTE;

                case Format.PVRTC_RGBA2:
                  return gl.UNSIGNED_BYTE;

                case Format.PVRTC_RGB4:
                  return gl.UNSIGNED_BYTE;

                case Format.PVRTC_RGBA4:
                  return gl.UNSIGNED_BYTE;

                case Format.PVRTC2_2BPP:
                  return gl.UNSIGNED_BYTE;

                case Format.PVRTC2_4BPP:
                  return gl.UNSIGNED_BYTE;

                case Format.ASTC_RGBA_4X4:
                case Format.ASTC_RGBA_5X4:
                case Format.ASTC_RGBA_5X5:
                case Format.ASTC_RGBA_6X5:
                case Format.ASTC_RGBA_6X6:
                case Format.ASTC_RGBA_8X5:
                case Format.ASTC_RGBA_8X6:
                case Format.ASTC_RGBA_8X8:
                case Format.ASTC_RGBA_10X5:
                case Format.ASTC_RGBA_10X6:
                case Format.ASTC_RGBA_10X8:
                case Format.ASTC_RGBA_10X10:
                case Format.ASTC_RGBA_12X10:
                case Format.ASTC_RGBA_12X12:
                case Format.ASTC_SRGBA_4X4:
                case Format.ASTC_SRGBA_5X4:
                case Format.ASTC_SRGBA_5X5:
                case Format.ASTC_SRGBA_6X5:
                case Format.ASTC_SRGBA_6X6:
                case Format.ASTC_SRGBA_8X5:
                case Format.ASTC_SRGBA_8X6:
                case Format.ASTC_SRGBA_8X8:
                case Format.ASTC_SRGBA_10X5:
                case Format.ASTC_SRGBA_10X6:
                case Format.ASTC_SRGBA_10X8:
                case Format.ASTC_SRGBA_10X10:
                case Format.ASTC_SRGBA_12X10:
                case Format.ASTC_SRGBA_12X12:
                  return gl.UNSIGNED_BYTE;

                default:
                  {
                    return gl.UNSIGNED_BYTE;
                  }
              }
            }
            function GFXFormatToWebGLInternalFormat$1(format, gl) {
              switch (format) {
                case Format.A8:
                  return gl.ALPHA;

                case Format.L8:
                  return gl.LUMINANCE;

                case Format.LA8:
                  return gl.LUMINANCE_ALPHA;

                case Format.R8:
                  return gl.R8;

                case Format.R8SN:
                  return gl.R8_SNORM;

                case Format.R8UI:
                  return gl.R8UI;

                case Format.R8I:
                  return gl.R8I;

                case Format.RG8:
                  return gl.RG8;

                case Format.RG8SN:
                  return gl.RG8_SNORM;

                case Format.RG8UI:
                  return gl.RG8UI;

                case Format.RG8I:
                  return gl.RG8I;

                case Format.RGB8:
                  return gl.RGB8;

                case Format.RGB8SN:
                  return gl.RGB8_SNORM;

                case Format.RGB8UI:
                  return gl.RGB8UI;

                case Format.RGB8I:
                  return gl.RGB8I;

                case Format.BGRA8:
                  return gl.RGBA8;

                case Format.RGBA8:
                  return gl.RGBA8;

                case Format.RGBA8SN:
                  return gl.RGBA8_SNORM;

                case Format.RGBA8UI:
                  return gl.RGBA8UI;

                case Format.RGBA8I:
                  return gl.RGBA8I;

                case Format.R16I:
                  return gl.R16I;

                case Format.R16UI:
                  return gl.R16UI;

                case Format.R16F:
                  return gl.R16F;

                case Format.RG16I:
                  return gl.RG16I;

                case Format.RG16UI:
                  return gl.RG16UI;

                case Format.RG16F:
                  return gl.RG16F;

                case Format.RGB16I:
                  return gl.RGB16I;

                case Format.RGB16UI:
                  return gl.RGB16UI;

                case Format.RGB16F:
                  return gl.RGB16F;

                case Format.RGBA16I:
                  return gl.RGBA16I;

                case Format.RGBA16UI:
                  return gl.RGBA16UI;

                case Format.RGBA16F:
                  return gl.RGBA16F;

                case Format.R32I:
                  return gl.R32I;

                case Format.R32UI:
                  return gl.R32UI;

                case Format.R32F:
                  return gl.R32F;

                case Format.RG32I:
                  return gl.RG32I;

                case Format.RG32UI:
                  return gl.RG32UI;

                case Format.RG32F:
                  return gl.RG32F;

                case Format.RGB32I:
                  return gl.RGB32I;

                case Format.RGB32UI:
                  return gl.RGB32UI;

                case Format.RGB32F:
                  return gl.RGB32F;

                case Format.RGBA32I:
                  return gl.RGBA32I;

                case Format.RGBA32UI:
                  return gl.RGBA32UI;

                case Format.RGBA32F:
                  return gl.RGBA32F;

                case Format.R5G6B5:
                  return gl.RGB565;

                case Format.RGB5A1:
                  return gl.RGB5_A1;

                case Format.RGBA4:
                  return gl.RGBA4;

                case Format.SRGB8:
                  return gl.SRGB8;

                case Format.SRGB8_A8:
                  return gl.SRGB8_ALPHA8;

                case Format.RGB10A2:
                  return gl.RGB10_A2;

                case Format.RGB10A2UI:
                  return gl.RGB10_A2UI;

                case Format.R11G11B10F:
                  return gl.R11F_G11F_B10F;

                case Format.DEPTH:
                  return gl.DEPTH_COMPONENT32F;

                case Format.DEPTH_STENCIL:
                  return gl.DEPTH24_STENCIL8;

                case Format.BC1:
                  return WebGL2EXT.COMPRESSED_RGB_S3TC_DXT1_EXT;

                case Format.BC1_ALPHA:
                  return WebGL2EXT.COMPRESSED_RGBA_S3TC_DXT1_EXT;

                case Format.BC1_SRGB:
                  return WebGL2EXT.COMPRESSED_SRGB_S3TC_DXT1_EXT;

                case Format.BC1_SRGB_ALPHA:
                  return WebGL2EXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;

                case Format.BC2:
                  return WebGL2EXT.COMPRESSED_RGBA_S3TC_DXT3_EXT;

                case Format.BC2_SRGB:
                  return WebGL2EXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;

                case Format.BC3:
                  return WebGL2EXT.COMPRESSED_RGBA_S3TC_DXT5_EXT;

                case Format.BC3_SRGB:
                  return WebGL2EXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

                case Format.ETC_RGB8:
                  return WebGL2EXT.COMPRESSED_RGB_ETC1_WEBGL;

                case Format.ETC2_RGB8:
                  return WebGL2EXT.COMPRESSED_RGB8_ETC2;

                case Format.ETC2_SRGB8:
                  return WebGL2EXT.COMPRESSED_SRGB8_ETC2;

                case Format.ETC2_RGB8_A1:
                  return WebGL2EXT.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;

                case Format.ETC2_SRGB8_A1:
                  return WebGL2EXT.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2;

                case Format.ETC2_RGBA8:
                  return WebGL2EXT.COMPRESSED_RGBA8_ETC2_EAC;

                case Format.ETC2_SRGB8_A8:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;

                case Format.EAC_R11:
                  return WebGL2EXT.COMPRESSED_R11_EAC;

                case Format.EAC_R11SN:
                  return WebGL2EXT.COMPRESSED_SIGNED_R11_EAC;

                case Format.EAC_RG11:
                  return WebGL2EXT.COMPRESSED_RG11_EAC;

                case Format.EAC_RG11SN:
                  return WebGL2EXT.COMPRESSED_SIGNED_RG11_EAC;

                case Format.PVRTC_RGB2:
                  return WebGL2EXT.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;

                case Format.PVRTC_RGBA2:
                  return WebGL2EXT.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

                case Format.PVRTC_RGB4:
                  return WebGL2EXT.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;

                case Format.PVRTC_RGBA4:
                  return WebGL2EXT.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;

                case Format.ASTC_RGBA_4X4:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_4x4_KHR;

                case Format.ASTC_RGBA_5X4:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_5x4_KHR;

                case Format.ASTC_RGBA_5X5:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_5x5_KHR;

                case Format.ASTC_RGBA_6X5:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_6x5_KHR;

                case Format.ASTC_RGBA_6X6:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_6x6_KHR;

                case Format.ASTC_RGBA_8X5:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_8x5_KHR;

                case Format.ASTC_RGBA_8X6:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_8x6_KHR;

                case Format.ASTC_RGBA_8X8:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_8x8_KHR;

                case Format.ASTC_RGBA_10X5:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_10x5_KHR;

                case Format.ASTC_RGBA_10X6:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_10x6_KHR;

                case Format.ASTC_RGBA_10X8:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_10x8_KHR;

                case Format.ASTC_RGBA_10X10:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_10x10_KHR;

                case Format.ASTC_RGBA_12X10:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_12x10_KHR;

                case Format.ASTC_RGBA_12X12:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_12x12_KHR;

                case Format.ASTC_SRGBA_4X4:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;

                case Format.ASTC_SRGBA_5X4:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR;

                case Format.ASTC_SRGBA_5X5:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR;

                case Format.ASTC_SRGBA_6X5:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR;

                case Format.ASTC_SRGBA_6X6:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR;

                case Format.ASTC_SRGBA_8X5:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR;

                case Format.ASTC_SRGBA_8X6:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR;

                case Format.ASTC_SRGBA_8X8:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR;

                case Format.ASTC_SRGBA_10X5:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR;

                case Format.ASTC_SRGBA_10X6:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR;

                case Format.ASTC_SRGBA_10X8:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR;

                case Format.ASTC_SRGBA_10X10:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR;

                case Format.ASTC_SRGBA_12X10:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR;

                case Format.ASTC_SRGBA_12X12:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR;

                default:
                  {
                    console.error('Unsupported Format, convert to WebGL internal format failed.');
                    return gl.RGBA;
                  }
              }
            }
            function GFXFormatToWebGLFormat$1(format, gl) {
              switch (format) {
                case Format.A8:
                  return gl.ALPHA;

                case Format.L8:
                  return gl.LUMINANCE;

                case Format.LA8:
                  return gl.LUMINANCE_ALPHA;

                case Format.R8:
                case Format.R8SN:
                  return gl.RED;

                case Format.R8UI:
                case Format.R8I:
                  return gl.RED;

                case Format.RG8:
                case Format.RG8SN:
                case Format.RG8UI:
                case Format.RG8I:
                  return gl.RG;

                case Format.RGB8:
                case Format.RGB8SN:
                case Format.RGB8UI:
                case Format.RGB8I:
                  return gl.RGB;

                case Format.BGRA8:
                case Format.RGBA8:
                case Format.RGBA8SN:
                case Format.RGBA8UI:
                case Format.RGBA8I:
                  return gl.RGBA;

                case Format.R16UI:
                case Format.R16I:
                case Format.R16F:
                  return gl.RED;

                case Format.RG16UI:
                case Format.RG16I:
                case Format.RG16F:
                  return gl.RG;

                case Format.RGB16UI:
                case Format.RGB16I:
                case Format.RGB16F:
                  return gl.RGB;

                case Format.RGBA16UI:
                case Format.RGBA16I:
                case Format.RGBA16F:
                  return gl.RGBA;

                case Format.R32UI:
                case Format.R32I:
                case Format.R32F:
                  return gl.RED;

                case Format.RG32UI:
                case Format.RG32I:
                case Format.RG32F:
                  return gl.RG;

                case Format.RGB32UI:
                case Format.RGB32I:
                case Format.RGB32F:
                  return gl.RGB;

                case Format.RGBA32UI:
                case Format.RGBA32I:
                case Format.RGBA32F:
                  return gl.RGBA;

                case Format.RGB10A2:
                  return gl.RGBA;

                case Format.R11G11B10F:
                  return gl.RGB;

                case Format.R5G6B5:
                  return gl.RGB;

                case Format.RGB5A1:
                  return gl.RGBA;

                case Format.RGBA4:
                  return gl.RGBA;

                case Format.SRGB8:
                  return gl.RGB;

                case Format.SRGB8_A8:
                  return gl.RGBA;

                case Format.DEPTH:
                  return gl.DEPTH_COMPONENT;

                case Format.DEPTH_STENCIL:
                  return gl.DEPTH_STENCIL;

                case Format.BC1:
                  return WebGL2EXT.COMPRESSED_RGB_S3TC_DXT1_EXT;

                case Format.BC1_ALPHA:
                  return WebGL2EXT.COMPRESSED_RGBA_S3TC_DXT1_EXT;

                case Format.BC1_SRGB:
                  return WebGL2EXT.COMPRESSED_SRGB_S3TC_DXT1_EXT;

                case Format.BC1_SRGB_ALPHA:
                  return WebGL2EXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;

                case Format.BC2:
                  return WebGL2EXT.COMPRESSED_RGBA_S3TC_DXT3_EXT;

                case Format.BC2_SRGB:
                  return WebGL2EXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;

                case Format.BC3:
                  return WebGL2EXT.COMPRESSED_RGBA_S3TC_DXT5_EXT;

                case Format.BC3_SRGB:
                  return WebGL2EXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

                case Format.ETC_RGB8:
                  return WebGL2EXT.COMPRESSED_RGB_ETC1_WEBGL;

                case Format.ETC2_RGB8:
                  return WebGL2EXT.COMPRESSED_RGB8_ETC2;

                case Format.ETC2_SRGB8:
                  return WebGL2EXT.COMPRESSED_SRGB8_ETC2;

                case Format.ETC2_RGB8_A1:
                  return WebGL2EXT.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;

                case Format.ETC2_SRGB8_A1:
                  return WebGL2EXT.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2;

                case Format.ETC2_RGBA8:
                  return WebGL2EXT.COMPRESSED_RGBA8_ETC2_EAC;

                case Format.ETC2_SRGB8_A8:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;

                case Format.EAC_R11:
                  return WebGL2EXT.COMPRESSED_R11_EAC;

                case Format.EAC_R11SN:
                  return WebGL2EXT.COMPRESSED_SIGNED_R11_EAC;

                case Format.EAC_RG11:
                  return WebGL2EXT.COMPRESSED_RG11_EAC;

                case Format.EAC_RG11SN:
                  return WebGL2EXT.COMPRESSED_SIGNED_RG11_EAC;

                case Format.PVRTC_RGB2:
                  return WebGL2EXT.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;

                case Format.PVRTC_RGBA2:
                  return WebGL2EXT.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

                case Format.PVRTC_RGB4:
                  return WebGL2EXT.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;

                case Format.PVRTC_RGBA4:
                  return WebGL2EXT.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;

                case Format.ASTC_RGBA_4X4:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_4x4_KHR;

                case Format.ASTC_RGBA_5X4:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_5x4_KHR;

                case Format.ASTC_RGBA_5X5:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_5x5_KHR;

                case Format.ASTC_RGBA_6X5:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_6x5_KHR;

                case Format.ASTC_RGBA_6X6:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_6x6_KHR;

                case Format.ASTC_RGBA_8X5:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_8x5_KHR;

                case Format.ASTC_RGBA_8X6:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_8x6_KHR;

                case Format.ASTC_RGBA_8X8:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_8x8_KHR;

                case Format.ASTC_RGBA_10X5:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_10x5_KHR;

                case Format.ASTC_RGBA_10X6:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_10x6_KHR;

                case Format.ASTC_RGBA_10X8:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_10x8_KHR;

                case Format.ASTC_RGBA_10X10:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_10x10_KHR;

                case Format.ASTC_RGBA_12X10:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_12x10_KHR;

                case Format.ASTC_RGBA_12X12:
                  return WebGL2EXT.COMPRESSED_RGBA_ASTC_12x12_KHR;

                case Format.ASTC_SRGBA_4X4:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;

                case Format.ASTC_SRGBA_5X4:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR;

                case Format.ASTC_SRGBA_5X5:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR;

                case Format.ASTC_SRGBA_6X5:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR;

                case Format.ASTC_SRGBA_6X6:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR;

                case Format.ASTC_SRGBA_8X5:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR;

                case Format.ASTC_SRGBA_8X6:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR;

                case Format.ASTC_SRGBA_8X8:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR;

                case Format.ASTC_SRGBA_10X5:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR;

                case Format.ASTC_SRGBA_10X6:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR;

                case Format.ASTC_SRGBA_10X8:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR;

                case Format.ASTC_SRGBA_10X10:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR;

                case Format.ASTC_SRGBA_12X10:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR;

                case Format.ASTC_SRGBA_12X12:
                  return WebGL2EXT.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR;

                default:
                  {
                    console.error('Unsupported Format, convert to WebGL format failed.');
                    return gl.RGBA;
                  }
              }
            }

            function GFXTypeToWebGLType$1(type, gl) {
              switch (type) {
                case Type$1.BOOL:
                  return gl.BOOL;

                case Type$1.BOOL2:
                  return gl.BOOL_VEC2;

                case Type$1.BOOL3:
                  return gl.BOOL_VEC3;

                case Type$1.BOOL4:
                  return gl.BOOL_VEC4;

                case Type$1.INT:
                  return gl.INT;

                case Type$1.INT2:
                  return gl.INT_VEC2;

                case Type$1.INT3:
                  return gl.INT_VEC3;

                case Type$1.INT4:
                  return gl.INT_VEC4;

                case Type$1.UINT:
                  return gl.UNSIGNED_INT;

                case Type$1.FLOAT:
                  return gl.FLOAT;

                case Type$1.FLOAT2:
                  return gl.FLOAT_VEC2;

                case Type$1.FLOAT3:
                  return gl.FLOAT_VEC3;

                case Type$1.FLOAT4:
                  return gl.FLOAT_VEC4;

                case Type$1.MAT2:
                  return gl.FLOAT_MAT2;

                case Type$1.MAT2X3:
                  return gl.FLOAT_MAT2x3;

                case Type$1.MAT2X4:
                  return gl.FLOAT_MAT2x4;

                case Type$1.MAT3X2:
                  return gl.FLOAT_MAT3x2;

                case Type$1.MAT3:
                  return gl.FLOAT_MAT3;

                case Type$1.MAT3X4:
                  return gl.FLOAT_MAT3x4;

                case Type$1.MAT4X2:
                  return gl.FLOAT_MAT4x2;

                case Type$1.MAT4X3:
                  return gl.FLOAT_MAT4x3;

                case Type$1.MAT4:
                  return gl.FLOAT_MAT4;

                case Type$1.SAMPLER2D:
                  return gl.SAMPLER_2D;

                case Type$1.SAMPLER2D_ARRAY:
                  return gl.SAMPLER_2D_ARRAY;

                case Type$1.SAMPLER3D:
                  return gl.SAMPLER_3D;

                case Type$1.SAMPLER_CUBE:
                  return gl.SAMPLER_CUBE;

                default:
                  {
                    console.error('Unsupported GLType, convert to GL type failed.');
                    return Type$1.UNKNOWN;
                  }
              }
            }

            function WebGLTypeToGFXType$1(glType, gl) {
              switch (glType) {
                case gl.BOOL:
                  return Type$1.BOOL;

                case gl.BOOL_VEC2:
                  return Type$1.BOOL2;

                case gl.BOOL_VEC3:
                  return Type$1.BOOL3;

                case gl.BOOL_VEC4:
                  return Type$1.BOOL4;

                case gl.INT:
                  return Type$1.INT;

                case gl.INT_VEC2:
                  return Type$1.INT2;

                case gl.INT_VEC3:
                  return Type$1.INT3;

                case gl.INT_VEC4:
                  return Type$1.INT4;

                case gl.UNSIGNED_INT:
                  return Type$1.UINT;

                case gl.UNSIGNED_INT_VEC2:
                  return Type$1.UINT2;

                case gl.UNSIGNED_INT_VEC3:
                  return Type$1.UINT3;

                case gl.UNSIGNED_INT_VEC4:
                  return Type$1.UINT4;

                case gl.FLOAT:
                  return Type$1.FLOAT;

                case gl.FLOAT_VEC2:
                  return Type$1.FLOAT2;

                case gl.FLOAT_VEC3:
                  return Type$1.FLOAT3;

                case gl.FLOAT_VEC4:
                  return Type$1.FLOAT4;

                case gl.FLOAT_MAT2:
                  return Type$1.MAT2;

                case gl.FLOAT_MAT2x3:
                  return Type$1.MAT2X3;

                case gl.FLOAT_MAT2x4:
                  return Type$1.MAT2X4;

                case gl.FLOAT_MAT3x2:
                  return Type$1.MAT3X2;

                case gl.FLOAT_MAT3:
                  return Type$1.MAT3;

                case gl.FLOAT_MAT3x4:
                  return Type$1.MAT3X4;

                case gl.FLOAT_MAT4x2:
                  return Type$1.MAT4X2;

                case gl.FLOAT_MAT4x3:
                  return Type$1.MAT4X3;

                case gl.FLOAT_MAT4:
                  return Type$1.MAT4;

                case gl.SAMPLER_2D:
                  return Type$1.SAMPLER2D;

                case gl.SAMPLER_2D_ARRAY:
                  return Type$1.SAMPLER2D_ARRAY;

                case gl.SAMPLER_3D:
                  return Type$1.SAMPLER3D;

                case gl.SAMPLER_CUBE:
                  return Type$1.SAMPLER_CUBE;

                default:
                  {
                    console.error('Unsupported GLType, convert to Type failed.');
                    return Type$1.UNKNOWN;
                  }
              }
            }

            function WebGLGetTypeSize$1(glType, gl) {
              switch (glType) {
                case gl.BOOL:
                  return 4;

                case gl.BOOL_VEC2:
                  return 8;

                case gl.BOOL_VEC3:
                  return 12;

                case gl.BOOL_VEC4:
                  return 16;

                case gl.INT:
                  return 4;

                case gl.INT_VEC2:
                  return 8;

                case gl.INT_VEC3:
                  return 12;

                case gl.INT_VEC4:
                  return 16;

                case gl.UNSIGNED_INT:
                  return 4;

                case gl.UNSIGNED_INT_VEC2:
                  return 8;

                case gl.UNSIGNED_INT_VEC3:
                  return 12;

                case gl.UNSIGNED_INT_VEC4:
                  return 16;

                case gl.FLOAT:
                  return 4;

                case gl.FLOAT_VEC2:
                  return 8;

                case gl.FLOAT_VEC3:
                  return 12;

                case gl.FLOAT_VEC4:
                  return 16;

                case gl.FLOAT_MAT2:
                  return 16;

                case gl.FLOAT_MAT2x3:
                  return 24;

                case gl.FLOAT_MAT2x4:
                  return 32;

                case gl.FLOAT_MAT3x2:
                  return 24;

                case gl.FLOAT_MAT3:
                  return 36;

                case gl.FLOAT_MAT3x4:
                  return 48;

                case gl.FLOAT_MAT4x2:
                  return 32;

                case gl.FLOAT_MAT4x3:
                  return 48;

                case gl.FLOAT_MAT4:
                  return 64;

                case gl.SAMPLER_2D:
                  return 4;

                case gl.SAMPLER_2D_ARRAY:
                  return 4;

                case gl.SAMPLER_2D_ARRAY_SHADOW:
                  return 4;

                case gl.SAMPLER_3D:
                  return 4;

                case gl.SAMPLER_CUBE:
                  return 4;

                case gl.INT_SAMPLER_2D:
                  return 4;

                case gl.INT_SAMPLER_2D_ARRAY:
                  return 4;

                case gl.INT_SAMPLER_3D:
                  return 4;

                case gl.INT_SAMPLER_CUBE:
                  return 4;

                case gl.UNSIGNED_INT_SAMPLER_2D:
                  return 4;

                case gl.UNSIGNED_INT_SAMPLER_2D_ARRAY:
                  return 4;

                case gl.UNSIGNED_INT_SAMPLER_3D:
                  return 4;

                case gl.UNSIGNED_INT_SAMPLER_CUBE:
                  return 4;

                default:
                  {
                    console.error('Unsupported GLType, get type failed.');
                    return 0;
                  }
              }
            }

            function WebGLGetComponentCount$1(glType, gl) {
              switch (glType) {
                case gl.FLOAT_MAT2:
                  return 2;

                case gl.FLOAT_MAT2x3:
                  return 2;

                case gl.FLOAT_MAT2x4:
                  return 2;

                case gl.FLOAT_MAT3x2:
                  return 3;

                case gl.FLOAT_MAT3:
                  return 3;

                case gl.FLOAT_MAT3x4:
                  return 3;

                case gl.FLOAT_MAT4x2:
                  return 4;

                case gl.FLOAT_MAT4x3:
                  return 4;

                case gl.FLOAT_MAT4:
                  return 4;

                default:
                  {
                    return 1;
                  }
              }
            }

            const WebGLCmpFuncs$1 = [0x0200, 0x0201, 0x0202, 0x0203, 0x0204, 0x0205, 0x0206, 0x0207];
            const WebGLStencilOps$1 = [0x0000, 0x1E00, 0x1E01, 0x1E02, 0x1E03, 0x150A, 0x8507, 0x8508];
            const WebGLBlendOps$1 = [0x8006, 0x800A, 0x800B, 0x8007, 0x8008];
            const WebGLBlendFactors$1 = [0x0000, 0x0001, 0x0302, 0x0304, 0x0303, 0x0305, 0x0300, 0x0306, 0x0301, 0x0307, 0x0308, 0x8001, 0x8002, 0x8003, 0x8004];
            let WebGL2Cmd;

            (function (WebGL2Cmd) {
              WebGL2Cmd[WebGL2Cmd["BEGIN_RENDER_PASS"] = 0] = "BEGIN_RENDER_PASS";
              WebGL2Cmd[WebGL2Cmd["END_RENDER_PASS"] = 1] = "END_RENDER_PASS";
              WebGL2Cmd[WebGL2Cmd["BIND_STATES"] = 2] = "BIND_STATES";
              WebGL2Cmd[WebGL2Cmd["DRAW"] = 3] = "DRAW";
              WebGL2Cmd[WebGL2Cmd["UPDATE_BUFFER"] = 4] = "UPDATE_BUFFER";
              WebGL2Cmd[WebGL2Cmd["COPY_BUFFER_TO_TEXTURE"] = 5] = "COPY_BUFFER_TO_TEXTURE";
              WebGL2Cmd[WebGL2Cmd["COUNT"] = 6] = "COUNT";
            })(WebGL2Cmd || (WebGL2Cmd = {}));

            class WebGL2CmdObject {
              constructor(type) {
                this.cmdType = void 0;
                this.refCount = 0;
                this.cmdType = type;
              }

            }
            class WebGL2CmdBeginRenderPass extends WebGL2CmdObject {
              constructor() {
                super(WebGL2Cmd.BEGIN_RENDER_PASS);
                this.gpuRenderPass = null;
                this.gpuFramebuffer = null;
                this.renderArea = new Rect();
                this.clearColors = [];
                this.clearDepth = 1.0;
                this.clearStencil = 0;
              }

              clear() {
                this.gpuFramebuffer = null;
                this.clearColors.length = 0;
              }

            }
            class WebGL2CmdBindStates extends WebGL2CmdObject {
              constructor() {
                super(WebGL2Cmd.BIND_STATES);
                this.gpuPipelineState = null;
                this.gpuInputAssembler = null;
                this.gpuDescriptorSets = [];
                this.dynamicOffsets = [];
                this.dynamicStates = new DynamicStates();
              }

              clear() {
                this.gpuPipelineState = null;
                this.gpuInputAssembler = null;
                this.gpuDescriptorSets.length = 0;
                this.dynamicOffsets.length = 0;
              }

            }
            class WebGL2CmdDraw extends WebGL2CmdObject {
              constructor() {
                super(WebGL2Cmd.DRAW);
                this.drawInfo = new DrawInfo();
              }

              clear() {}

            }
            class WebGL2CmdUpdateBuffer extends WebGL2CmdObject {
              constructor() {
                super(WebGL2Cmd.UPDATE_BUFFER);
                this.gpuBuffer = null;
                this.buffer = null;
                this.offset = 0;
                this.size = 0;
              }

              clear() {
                this.gpuBuffer = null;
                this.buffer = null;
              }

            }
            class WebGL2CmdCopyBufferToTexture extends WebGL2CmdObject {
              constructor() {
                super(WebGL2Cmd.COPY_BUFFER_TO_TEXTURE);
                this.gpuTexture = null;
                this.buffers = [];
                this.regions = [];
              }

              clear() {
                this.gpuTexture = null;
                this.buffers.length = 0;
                this.regions.length = 0;
              }

            }
            class WebGL2CmdPackage {
              constructor() {
                this.cmds = new CachedArray(1);
                this.beginRenderPassCmds = new CachedArray(1);
                this.bindStatesCmds = new CachedArray(1);
                this.drawCmds = new CachedArray(1);
                this.updateBufferCmds = new CachedArray(1);
                this.copyBufferToTextureCmds = new CachedArray(1);
              }

              clearCmds(allocator) {
                if (this.beginRenderPassCmds.length) {
                  allocator.beginRenderPassCmdPool.freeCmds(this.beginRenderPassCmds);
                  this.beginRenderPassCmds.clear();
                }

                if (this.bindStatesCmds.length) {
                  allocator.bindStatesCmdPool.freeCmds(this.bindStatesCmds);
                  this.bindStatesCmds.clear();
                }

                if (this.drawCmds.length) {
                  allocator.drawCmdPool.freeCmds(this.drawCmds);
                  this.drawCmds.clear();
                }

                if (this.updateBufferCmds.length) {
                  allocator.updateBufferCmdPool.freeCmds(this.updateBufferCmds);
                  this.updateBufferCmds.clear();
                }

                if (this.copyBufferToTextureCmds.length) {
                  allocator.copyBufferToTextureCmdPool.freeCmds(this.copyBufferToTextureCmds);
                  this.copyBufferToTextureCmds.clear();
                }

                this.cmds.clear();
              }

            }
            function WebGL2CmdFuncCreateBuffer(device, gpuBuffer) {
              const {
                gl
              } = device;
              const cache = device.stateCache;
              const glUsage = gpuBuffer.memUsage & MemoryUsageBit.HOST ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

              if (gpuBuffer.usage & BufferUsageBit.VERTEX) {
                gpuBuffer.glTarget = gl.ARRAY_BUFFER;
                const glBuffer = gl.createBuffer();

                if (glBuffer) {
                  gpuBuffer.glBuffer = glBuffer;

                  if (gpuBuffer.size > 0) {
                    if (device.extensions.useVAO) {
                      if (cache.glVAO) {
                        gl.bindVertexArray(null);
                        cache.glVAO = null;
                      }
                    }

                    gfxStateCache$1.gpuInputAssembler = null;

                    if (device.stateCache.glArrayBuffer !== gpuBuffer.glBuffer) {
                      gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer);
                      device.stateCache.glArrayBuffer = gpuBuffer.glBuffer;
                    }

                    gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.size, glUsage);
                    gl.bindBuffer(gl.ARRAY_BUFFER, null);
                    device.stateCache.glArrayBuffer = null;
                  }
                }
              } else if (gpuBuffer.usage & BufferUsageBit.INDEX) {
                gpuBuffer.glTarget = gl.ELEMENT_ARRAY_BUFFER;
                const glBuffer = gl.createBuffer();

                if (glBuffer) {
                  gpuBuffer.glBuffer = glBuffer;

                  if (gpuBuffer.size > 0) {
                    if (device.extensions.useVAO) {
                      if (cache.glVAO) {
                        gl.bindVertexArray(null);
                        cache.glVAO = null;
                      }
                    }

                    gfxStateCache$1.gpuInputAssembler = null;

                    if (device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer) {
                      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
                      device.stateCache.glElementArrayBuffer = gpuBuffer.glBuffer;
                    }

                    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.size, glUsage);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                    device.stateCache.glElementArrayBuffer = null;
                  }
                }
              } else if (gpuBuffer.usage & BufferUsageBit.UNIFORM) {
                gpuBuffer.glTarget = gl.UNIFORM_BUFFER;
                const glBuffer = gl.createBuffer();

                if (glBuffer && gpuBuffer.size > 0) {
                  gpuBuffer.glBuffer = glBuffer;

                  if (device.stateCache.glUniformBuffer !== gpuBuffer.glBuffer) {
                    gl.bindBuffer(gl.UNIFORM_BUFFER, gpuBuffer.glBuffer);
                    device.stateCache.glUniformBuffer = gpuBuffer.glBuffer;
                  }

                  gl.bufferData(gl.UNIFORM_BUFFER, gpuBuffer.size, glUsage);
                  gl.bindBuffer(gl.UNIFORM_BUFFER, null);
                  device.stateCache.glUniformBuffer = null;
                }
              } else if (gpuBuffer.usage & BufferUsageBit.INDIRECT) {
                gpuBuffer.glTarget = gl.NONE;
              } else if (gpuBuffer.usage & BufferUsageBit.TRANSFER_DST) {
                gpuBuffer.glTarget = gl.NONE;
              } else if (gpuBuffer.usage & BufferUsageBit.TRANSFER_SRC) {
                gpuBuffer.glTarget = gl.NONE;
              } else {
                console.error('Unsupported BufferType, create buffer failed.');
                gpuBuffer.glTarget = gl.NONE;
              }
            }
            function WebGL2CmdFuncDestroyBuffer(device, gpuBuffer) {
              const {
                gl
              } = device;
              const cache = device.stateCache;

              if (gpuBuffer.glBuffer) {
                switch (gpuBuffer.glTarget) {
                  case gl.ARRAY_BUFFER:
                    if (device.extensions.useVAO) {
                      if (cache.glVAO) {
                        gl.bindVertexArray(null);
                        device.stateCache.glVAO = null;
                      }
                    }

                    gfxStateCache$1.gpuInputAssembler = null;
                    gl.bindBuffer(gl.ARRAY_BUFFER, null);
                    device.stateCache.glArrayBuffer = null;
                    break;

                  case gl.ELEMENT_ARRAY_BUFFER:
                    if (device.extensions.useVAO) {
                      if (cache.glVAO) {
                        gl.bindVertexArray(null);
                        device.stateCache.glVAO = null;
                      }
                    }

                    gfxStateCache$1.gpuInputAssembler = null;
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                    device.stateCache.glElementArrayBuffer = null;
                    break;

                  case gl.UNIFORM_BUFFER:
                    gl.bindBuffer(gl.UNIFORM_BUFFER, null);
                    device.stateCache.glUniformBuffer = null;
                    break;
                }

                gl.deleteBuffer(gpuBuffer.glBuffer);
                gpuBuffer.glBuffer = null;
              }
            }
            function WebGL2CmdFuncResizeBuffer(device, gpuBuffer) {
              const {
                gl
              } = device;
              const cache = device.stateCache;
              const glUsage = gpuBuffer.memUsage & MemoryUsageBit.HOST ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

              if (gpuBuffer.usage & BufferUsageBit.VERTEX) {
                if (device.extensions.useVAO) {
                  if (cache.glVAO) {
                    gl.bindVertexArray(null);
                    cache.glVAO = null;
                  }
                }

                gfxStateCache$1.gpuInputAssembler = null;

                if (cache.glArrayBuffer !== gpuBuffer.glBuffer) {
                  gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer);
                }

                if (gpuBuffer.buffer) {
                  gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.buffer, glUsage);
                } else {
                  gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.size, glUsage);
                }

                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                cache.glArrayBuffer = null;
              } else if (gpuBuffer.usage & BufferUsageBit.INDEX) {
                if (device.extensions.useVAO) {
                  if (cache.glVAO) {
                    gl.bindVertexArray(null);
                    cache.glVAO = null;
                  }
                }

                gfxStateCache$1.gpuInputAssembler = null;

                if (device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer) {
                  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
                }

                if (gpuBuffer.buffer) {
                  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.buffer, glUsage);
                } else {
                  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.size, glUsage);
                }

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                device.stateCache.glElementArrayBuffer = null;
              } else if (gpuBuffer.usage & BufferUsageBit.UNIFORM) {
                if (device.stateCache.glUniformBuffer !== gpuBuffer.glBuffer) {
                  gl.bindBuffer(gl.UNIFORM_BUFFER, gpuBuffer.glBuffer);
                }

                gl.bufferData(gl.UNIFORM_BUFFER, gpuBuffer.size, glUsage);
                gl.bindBuffer(gl.UNIFORM_BUFFER, null);
                device.stateCache.glUniformBuffer = null;
              } else if (gpuBuffer.usage & BufferUsageBit.INDIRECT || gpuBuffer.usage & BufferUsageBit.TRANSFER_DST || gpuBuffer.usage & BufferUsageBit.TRANSFER_SRC) {
                gpuBuffer.glTarget = gl.NONE;
              } else {
                console.error('Unsupported BufferType, create buffer failed.');
                gpuBuffer.glTarget = gl.NONE;
              }
            }
            function WebGL2CmdFuncUpdateBuffer(device, gpuBuffer, buffer, offset, size) {
              if (gpuBuffer.usage & BufferUsageBit.INDIRECT) {
                gpuBuffer.indirects.clearDraws();
                const drawInfos = buffer.drawInfos;

                for (let i = 0; i < drawInfos.length; ++i) {
                  gpuBuffer.indirects.setDrawInfo(offset + i, drawInfos[i]);
                }
              } else {
                const buff = buffer;
                const {
                  gl
                } = device;
                const cache = device.stateCache;

                switch (gpuBuffer.glTarget) {
                  case gl.ARRAY_BUFFER:
                    {
                      if (device.extensions.useVAO) {
                        if (cache.glVAO) {
                          gl.bindVertexArray(null);
                          cache.glVAO = null;
                        }
                      }

                      gfxStateCache$1.gpuInputAssembler = null;

                      if (cache.glArrayBuffer !== gpuBuffer.glBuffer) {
                        gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer);
                        cache.glArrayBuffer = gpuBuffer.glBuffer;
                      }

                      if (size === buff.byteLength) {
                        gl.bufferSubData(gpuBuffer.glTarget, offset, buff);
                      } else {
                        gl.bufferSubData(gpuBuffer.glTarget, offset, buff.slice(0, size));
                      }

                      break;
                    }

                  case gl.ELEMENT_ARRAY_BUFFER:
                    {
                      if (device.extensions.useVAO) {
                        if (cache.glVAO) {
                          gl.bindVertexArray(null);
                          cache.glVAO = null;
                        }
                      }

                      gfxStateCache$1.gpuInputAssembler = null;

                      if (cache.glElementArrayBuffer !== gpuBuffer.glBuffer) {
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
                        cache.glElementArrayBuffer = gpuBuffer.glBuffer;
                      }

                      if (size === buff.byteLength) {
                        gl.bufferSubData(gpuBuffer.glTarget, offset, buff);
                      } else {
                        gl.bufferSubData(gpuBuffer.glTarget, offset, buff.slice(0, size));
                      }

                      break;
                    }

                  case gl.UNIFORM_BUFFER:
                    {
                      if (cache.glUniformBuffer !== gpuBuffer.glBuffer) {
                        gl.bindBuffer(gl.UNIFORM_BUFFER, gpuBuffer.glBuffer);
                        cache.glUniformBuffer = gpuBuffer.glBuffer;
                      }

                      if (size === buff.byteLength) {
                        gl.bufferSubData(gpuBuffer.glTarget, offset, buff);
                      } else {
                        gl.bufferSubData(gpuBuffer.glTarget, offset, new Float32Array(buff, 0, size / 4));
                      }

                      break;
                    }

                  default:
                    {
                      console.error('Unsupported BufferType, update buffer failed.');
                    }
                }
              }
            }
            function WebGL2CmdFuncCreateTexture(device, gpuTexture) {
              const {
                gl
              } = device;
              gpuTexture.glInternalFmt = GFXFormatToWebGLInternalFormat$1(gpuTexture.format, gl);
              gpuTexture.glFormat = GFXFormatToWebGLFormat$1(gpuTexture.format, gl);
              gpuTexture.glType = GFXFormatToWebGLType$1(gpuTexture.format, gl);
              let w = gpuTexture.width;
              let h = gpuTexture.height;

              switch (gpuTexture.type) {
                case TextureType.TEX2D:
                  {
                    gpuTexture.glTarget = gl.TEXTURE_2D;
                    if (gpuTexture.isSwapchainTexture) break;
                    const maxSize = Math.max(w, h);

                    if (maxSize > device.capabilities.maxTextureSize) {
                      errorID(9100, maxSize, device.capabilities.maxTextureSize);
                    }

                    if (gpuTexture.samples === SampleCount.ONE) {
                      gpuTexture.glTexture = gl.createTexture();

                      if (gpuTexture.size > 0) {
                        const glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

                        if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                          gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture);
                          glTexUnit.glTexture = gpuTexture.glTexture;
                        }

                        if (FormatInfos[gpuTexture.format].isCompressed) {
                          for (let i = 0; i < gpuTexture.mipLevel; ++i) {
                            const imgSize = FormatSize(gpuTexture.format, w, h, 1);
                            const view = new Uint8Array(imgSize);
                            gl.compressedTexImage2D(gl.TEXTURE_2D, i, gpuTexture.glInternalFmt, w, h, 0, view);
                            w = Math.max(1, w >> 1);
                            h = Math.max(1, h >> 1);
                          }
                        } else {
                          gl.texStorage2D(gl.TEXTURE_2D, gpuTexture.mipLevel, gpuTexture.glInternalFmt, w, h);
                        }
                      }
                    } else {
                      gpuTexture.glRenderbuffer = gl.createRenderbuffer();

                      if (gpuTexture.size > 0) {
                        if (device.stateCache.glRenderbuffer !== gpuTexture.glRenderbuffer) {
                          gl.bindRenderbuffer(gl.RENDERBUFFER, gpuTexture.glRenderbuffer);
                          device.stateCache.glRenderbuffer = gpuTexture.glRenderbuffer;
                        }

                        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, gpuTexture.samples, gpuTexture.glInternalFmt, gpuTexture.width, gpuTexture.height);
                      }
                    }

                    break;
                  }

                case TextureType.CUBE:
                  {
                    gpuTexture.glTarget = gl.TEXTURE_CUBE_MAP;
                    const maxSize = Math.max(w, h);

                    if (maxSize > device.capabilities.maxCubeMapTextureSize) {
                      errorID(9100, maxSize, device.capabilities.maxTextureSize);
                    }

                    gpuTexture.glTexture = gl.createTexture();

                    if (gpuTexture.size > 0) {
                      const glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

                      if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                        gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture);
                        glTexUnit.glTexture = gpuTexture.glTexture;
                      }

                      if (FormatInfos[gpuTexture.format].isCompressed) {
                        for (let i = 0; i < gpuTexture.mipLevel; ++i) {
                          const imgSize = FormatSize(gpuTexture.format, w, h, 1);
                          const view = new Uint8Array(imgSize);

                          for (let f = 0; f < 6; ++f) {
                            gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, i, gpuTexture.glInternalFmt, w, h, 0, view);
                          }

                          w = Math.max(1, w >> 1);
                          h = Math.max(1, h >> 1);
                        }
                      } else {
                        gl.texStorage2D(gl.TEXTURE_CUBE_MAP, gpuTexture.mipLevel, gpuTexture.glInternalFmt, w, h);
                      }
                    }

                    break;
                  }

                default:
                  {
                    console.error('Unsupported TextureType, create texture failed.');
                    gpuTexture.type = TextureType.TEX2D;
                    gpuTexture.glTarget = gl.TEXTURE_2D;
                  }
              }
            }
            function WebGL2CmdFuncDestroyTexture(device, gpuTexture) {
              const {
                gl
              } = device;

              if (gpuTexture.glTexture) {
                const glTexUnits = device.stateCache.glTexUnits;
                let texUnit = device.stateCache.texUnit;
                gl.deleteTexture(gpuTexture.glTexture);

                for (let i = 0; i < glTexUnits.length; ++i) {
                  if (glTexUnits[i].glTexture === gpuTexture.glTexture) {
                    gl.activeTexture(gl.TEXTURE0 + i);
                    texUnit = i;
                    gl.bindTexture(gpuTexture.glTarget, null);
                    glTexUnits[i].glTexture = null;
                  }
                }

                device.stateCache.texUnit = texUnit;
                gpuTexture.glTexture = null;
              }

              if (gpuTexture.glRenderbuffer) {
                let glRenderbuffer = device.stateCache.glRenderbuffer;
                gl.deleteRenderbuffer(gpuTexture.glRenderbuffer);

                if (glRenderbuffer === gpuTexture.glRenderbuffer) {
                  gl.bindRenderbuffer(gl.RENDERBUFFER, null);
                  glRenderbuffer = null;
                }

                gpuTexture.glRenderbuffer = null;
              }
            }
            function WebGL2CmdFuncResizeTexture(device, gpuTexture) {
              if (!gpuTexture.size) return;
              const {
                gl
              } = device;
              let w = gpuTexture.width;
              let h = gpuTexture.height;

              switch (gpuTexture.type) {
                case TextureType.TEX2D:
                  {
                    gpuTexture.glTarget = gl.TEXTURE_2D;
                    const maxSize = Math.max(w, h);

                    if (maxSize > device.capabilities.maxTextureSize) {
                      errorID(9100, maxSize, device.capabilities.maxTextureSize);
                    }

                    if (gpuTexture.samples === SampleCount.ONE) {
                      const glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

                      if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                        gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture);
                        glTexUnit.glTexture = gpuTexture.glTexture;
                      }

                      if (FormatInfos[gpuTexture.format].isCompressed) {
                        for (let i = 0; i < gpuTexture.mipLevel; ++i) {
                          const imgSize = FormatSize(gpuTexture.format, w, h, 1);
                          const view = new Uint8Array(imgSize);
                          gl.compressedTexImage2D(gl.TEXTURE_2D, i, gpuTexture.glInternalFmt, w, h, 0, view);
                          w = Math.max(1, w >> 1);
                          h = Math.max(1, h >> 1);
                        }
                      } else {
                        WebGL2CmdFuncDestroyTexture(device, gpuTexture);
                        WebGL2CmdFuncCreateTexture(device, gpuTexture);
                      }
                    } else if (gpuTexture.glRenderbuffer) {
                      if (device.stateCache.glRenderbuffer !== gpuTexture.glRenderbuffer) {
                        gl.bindRenderbuffer(gl.RENDERBUFFER, gpuTexture.glRenderbuffer);
                        device.stateCache.glRenderbuffer = gpuTexture.glRenderbuffer;
                      }

                      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, gpuTexture.samples, gpuTexture.glInternalFmt, gpuTexture.width, gpuTexture.height);
                    }

                    break;
                  }

                case TextureType.CUBE:
                  {
                    gpuTexture.type = TextureType.CUBE;
                    gpuTexture.glTarget = gl.TEXTURE_CUBE_MAP;
                    const maxSize = Math.max(w, h);

                    if (maxSize > device.capabilities.maxCubeMapTextureSize) {
                      errorID(9100, maxSize, device.capabilities.maxTextureSize);
                    }

                    const glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

                    if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                      gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture);
                      glTexUnit.glTexture = gpuTexture.glTexture;
                    }

                    if (FormatInfos[gpuTexture.format].isCompressed) {
                      for (let f = 0; f < 6; ++f) {
                        w = gpuTexture.width;
                        h = gpuTexture.height;

                        for (let i = 0; i < gpuTexture.mipLevel; ++i) {
                          const imgSize = FormatSize(gpuTexture.format, w, h, 1);
                          const view = new Uint8Array(imgSize);
                          gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, i, gpuTexture.glInternalFmt, w, h, 0, view);
                          w = Math.max(1, w >> 1);
                          h = Math.max(1, h >> 1);
                        }
                      }
                    } else {
                      WebGL2CmdFuncDestroyTexture(device, gpuTexture);
                      WebGL2CmdFuncCreateTexture(device, gpuTexture);
                    }

                    break;
                  }

                default:
                  {
                    console.error('Unsupported TextureType, create texture failed.');
                    gpuTexture.type = TextureType.TEX2D;
                    gpuTexture.glTarget = gl.TEXTURE_2D;
                  }
              }
            }
            function WebGL2CmdFuncCreateSampler(device, gpuSampler) {
              const {
                gl
              } = device;
              const glSampler = gl.createSampler();

              if (glSampler) {
                if (gpuSampler.minFilter === Filter.LINEAR || gpuSampler.minFilter === Filter.ANISOTROPIC) {
                  if (gpuSampler.mipFilter === Filter.LINEAR || gpuSampler.mipFilter === Filter.ANISOTROPIC) {
                    gpuSampler.glMinFilter = gl.LINEAR_MIPMAP_LINEAR;
                  } else if (gpuSampler.mipFilter === Filter.POINT) {
                    gpuSampler.glMinFilter = gl.LINEAR_MIPMAP_NEAREST;
                  } else {
                    gpuSampler.glMinFilter = gl.LINEAR;
                  }
                } else if (gpuSampler.mipFilter === Filter.LINEAR || gpuSampler.mipFilter === Filter.ANISOTROPIC) {
                  gpuSampler.glMinFilter = gl.NEAREST_MIPMAP_LINEAR;
                } else if (gpuSampler.mipFilter === Filter.POINT) {
                  gpuSampler.glMinFilter = gl.NEAREST_MIPMAP_NEAREST;
                } else {
                  gpuSampler.glMinFilter = gl.NEAREST;
                }

                if (gpuSampler.magFilter === Filter.LINEAR || gpuSampler.magFilter === Filter.ANISOTROPIC) {
                  gpuSampler.glMagFilter = gl.LINEAR;
                } else {
                  gpuSampler.glMagFilter = gl.NEAREST;
                }

                gpuSampler.glWrapS = WebGLWraps$1[gpuSampler.addressU];
                gpuSampler.glWrapT = WebGLWraps$1[gpuSampler.addressV];
                gpuSampler.glWrapR = WebGLWraps$1[gpuSampler.addressW];
                gpuSampler.glSampler = glSampler;
                gl.samplerParameteri(glSampler, gl.TEXTURE_MIN_FILTER, gpuSampler.glMinFilter);
                gl.samplerParameteri(glSampler, gl.TEXTURE_MAG_FILTER, gpuSampler.glMagFilter);
                gl.samplerParameteri(glSampler, gl.TEXTURE_WRAP_S, gpuSampler.glWrapS);
                gl.samplerParameteri(glSampler, gl.TEXTURE_WRAP_T, gpuSampler.glWrapT);
                gl.samplerParameteri(glSampler, gl.TEXTURE_WRAP_R, gpuSampler.glWrapR);
                gl.samplerParameterf(glSampler, gl.TEXTURE_MIN_LOD, 0);
                gl.samplerParameterf(glSampler, gl.TEXTURE_MAX_LOD, 1000);
              }
            }
            function WebGL2CmdFuncDestroySampler(device, gpuSampler) {
              const {
                gl
              } = device;

              if (gpuSampler.glSampler) {
                gl.deleteSampler(gpuSampler.glSampler);
                const glSamplerUnits = device.stateCache.glSamplerUnits;

                for (let i = 0; i < glSamplerUnits.length; ++i) {
                  if (glSamplerUnits[i] === gpuSampler.glSampler) {
                    gl.bindSampler(i, null);
                    glSamplerUnits[i] = null;
                  }
                }

                gpuSampler.glSampler = null;
              }
            }
            function WebGL2CmdFuncCreateFramebuffer(device, gpuFramebuffer) {
              for (let i = 0; i < gpuFramebuffer.gpuColorTextures.length; ++i) {
                const tex = gpuFramebuffer.gpuColorTextures[i];

                if (tex.isSwapchainTexture) {
                  gpuFramebuffer.isOffscreen = false;
                  return;
                }
              }

              const {
                gl
              } = device;
              const attachments = [];
              const glFramebuffer = gl.createFramebuffer();

              if (glFramebuffer) {
                gpuFramebuffer.glFramebuffer = glFramebuffer;

                if (device.stateCache.glFramebuffer !== gpuFramebuffer.glFramebuffer) {
                  gl.bindFramebuffer(gl.FRAMEBUFFER, gpuFramebuffer.glFramebuffer);
                }

                for (let i = 0; i < gpuFramebuffer.gpuColorTextures.length; ++i) {
                  const colorTexture = gpuFramebuffer.gpuColorTextures[i];

                  if (colorTexture) {
                    if (colorTexture.glTexture) {
                      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, colorTexture.glTarget, colorTexture.glTexture, 0);
                    } else {
                      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, colorTexture.glRenderbuffer);
                    }

                    attachments.push(gl.COLOR_ATTACHMENT0 + i);
                    gpuFramebuffer.width = Math.min(gpuFramebuffer.width, colorTexture.width);
                    gpuFramebuffer.height = Math.min(gpuFramebuffer.height, colorTexture.height);
                  }
                }

                const dst = gpuFramebuffer.gpuDepthStencilTexture;

                if (dst) {
                  const glAttachment = FormatInfos[dst.format].hasStencil ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;

                  if (dst.glTexture) {
                    gl.framebufferTexture2D(gl.FRAMEBUFFER, glAttachment, dst.glTarget, dst.glTexture, 0);
                  } else {
                    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, glAttachment, gl.RENDERBUFFER, dst.glRenderbuffer);
                  }

                  gpuFramebuffer.width = Math.min(gpuFramebuffer.width, dst.width);
                  gpuFramebuffer.height = Math.min(gpuFramebuffer.height, dst.height);
                }

                gl.drawBuffers(attachments);
                const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

                if (status !== gl.FRAMEBUFFER_COMPLETE) {
                  switch (status) {
                    case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                      {
                        console.error('glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_ATTACHMENT');
                        break;
                      }

                    case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                      {
                        console.error('glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT');
                        break;
                      }

                    case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                      {
                        console.error('glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_DIMENSIONS');
                        break;
                      }

                    case gl.FRAMEBUFFER_UNSUPPORTED:
                      {
                        console.error('glCheckFramebufferStatus() - FRAMEBUFFER_UNSUPPORTED');
                        break;
                      }
                  }
                }

                if (device.stateCache.glFramebuffer !== gpuFramebuffer.glFramebuffer) {
                  gl.bindFramebuffer(gl.FRAMEBUFFER, device.stateCache.glFramebuffer);
                }
              }
            }
            function WebGL2CmdFuncDestroyFramebuffer(device, gpuFramebuffer) {
              if (gpuFramebuffer.glFramebuffer) {
                device.gl.deleteFramebuffer(gpuFramebuffer.glFramebuffer);

                if (device.stateCache.glFramebuffer === gpuFramebuffer.glFramebuffer) {
                  device.gl.bindFramebuffer(device.gl.FRAMEBUFFER, null);
                  device.stateCache.glFramebuffer = null;
                }

                gpuFramebuffer.glFramebuffer = null;
              }
            }
            function WebGL2CmdFuncCreateShader(device, gpuShader) {
              const {
                gl
              } = device;

              for (let k = 0; k < gpuShader.gpuStages.length; k++) {
                const gpuStage = gpuShader.gpuStages[k];
                let glShaderType = 0;
                let shaderTypeStr = '';
                let lineNumber = 1;

                switch (gpuStage.type) {
                  case ShaderStageFlagBit.VERTEX:
                    {
                      shaderTypeStr = 'VertexShader';
                      glShaderType = gl.VERTEX_SHADER;
                      break;
                    }

                  case ShaderStageFlagBit.FRAGMENT:
                    {
                      shaderTypeStr = 'FragmentShader';
                      glShaderType = gl.FRAGMENT_SHADER;
                      break;
                    }

                  default:
                    {
                      console.error('Unsupported ShaderType.');
                      return;
                    }
                }

                const glShader = gl.createShader(glShaderType);

                if (glShader) {
                  gpuStage.glShader = glShader;
                  gl.shaderSource(gpuStage.glShader, `#version 300 es\n${gpuStage.source}`);
                  gl.compileShader(gpuStage.glShader);

                  if (!gl.getShaderParameter(gpuStage.glShader, gl.COMPILE_STATUS)) {
                    console.error(`${shaderTypeStr} in '${gpuShader.name}' compilation failed.`);
                    console.error('Shader source dump:', gpuStage.source.replace(/^|\n/g, () => `\n${lineNumber++} `));
                    console.error(gl.getShaderInfoLog(gpuStage.glShader));

                    for (let l = 0; l < gpuShader.gpuStages.length; l++) {
                      const stage = gpuShader.gpuStages[k];

                      if (stage.glShader) {
                        gl.deleteShader(stage.glShader);
                        stage.glShader = null;
                      }
                    }

                    return;
                  }
                }
              }

              const glProgram = gl.createProgram();

              if (!glProgram) {
                return;
              }

              gpuShader.glProgram = glProgram;

              for (let k = 0; k < gpuShader.gpuStages.length; k++) {
                const gpuStage = gpuShader.gpuStages[k];
                gl.attachShader(gpuShader.glProgram, gpuStage.glShader);
              }

              gl.linkProgram(gpuShader.glProgram);

              for (let k = 0; k < gpuShader.gpuStages.length; k++) {
                const gpuStage = gpuShader.gpuStages[k];

                if (gpuStage.glShader) {
                  gl.detachShader(gpuShader.glProgram, gpuStage.glShader);
                  gl.deleteShader(gpuStage.glShader);
                  gpuStage.glShader = null;
                }
              }

              if (gl.getProgramParameter(gpuShader.glProgram, gl.LINK_STATUS)) {
                debug(`Shader '${gpuShader.name}' compilation succeeded.`);
              } else {
                console.error(`Failed to link shader '${gpuShader.name}'.`);
                console.error(gl.getProgramInfoLog(gpuShader.glProgram));
                return;
              }

              const activeAttribCount = gl.getProgramParameter(gpuShader.glProgram, gl.ACTIVE_ATTRIBUTES);
              gpuShader.glInputs = new Array(activeAttribCount);

              for (let i = 0; i < activeAttribCount; ++i) {
                const attribInfo = gl.getActiveAttrib(gpuShader.glProgram, i);

                if (attribInfo) {
                  let varName;
                  const nameOffset = attribInfo.name.indexOf('[');

                  if (nameOffset !== -1) {
                    varName = attribInfo.name.substr(0, nameOffset);
                  } else {
                    varName = attribInfo.name;
                  }

                  const glLoc = gl.getAttribLocation(gpuShader.glProgram, varName);
                  const type = WebGLTypeToGFXType$1(attribInfo.type, gl);
                  const stride = WebGLGetTypeSize$1(attribInfo.type, gl);
                  gpuShader.glInputs[i] = {
                    name: varName,
                    type,
                    stride,
                    count: attribInfo.size,
                    size: stride * attribInfo.size,
                    glType: attribInfo.type,
                    glLoc
                  };
                }
              }

              const activeBlockCount = gl.getProgramParameter(gpuShader.glProgram, gl.ACTIVE_UNIFORM_BLOCKS);
              let blockName;
              let blockIdx;
              let blockSize;
              let block;

              if (activeBlockCount) {
                gpuShader.glBlocks = new Array(activeBlockCount);

                for (let b = 0; b < activeBlockCount; ++b) {
                  blockName = gl.getActiveUniformBlockName(gpuShader.glProgram, b);
                  const nameOffset = blockName.indexOf('[');

                  if (nameOffset !== -1) {
                    blockName = blockName.substr(0, nameOffset);
                  }

                  block = null;

                  for (let k = 0; k < gpuShader.blocks.length; k++) {
                    if (gpuShader.blocks[k].name === blockName) {
                      block = gpuShader.blocks[k];
                      break;
                    }
                  }

                  if (!block) {
                    error(`Block '${blockName}' does not bound`);
                  } else {
                    blockIdx = b;
                    blockSize = gl.getActiveUniformBlockParameter(gpuShader.glProgram, blockIdx, gl.UNIFORM_BLOCK_DATA_SIZE);
                    const glBinding = block.binding + (device.bindingMappingInfo.bufferOffsets[block.set] || 0);
                    gl.uniformBlockBinding(gpuShader.glProgram, blockIdx, glBinding);
                    gpuShader.glBlocks[b] = {
                      set: block.set,
                      binding: block.binding,
                      idx: blockIdx,
                      name: blockName,
                      size: blockSize,
                      glBinding
                    };
                  }
                }
              }

              for (let i = 0; i < gpuShader.subpassInputs.length; ++i) {
                const subpassInput = gpuShader.subpassInputs[i];
                gpuShader.samplerTextures.push(new UniformSamplerTexture(subpassInput.set, subpassInput.binding, subpassInput.name, Type$1.SAMPLER2D, subpassInput.count));
              }

              if (gpuShader.samplerTextures.length > 0) {
                gpuShader.glSamplerTextures = new Array(gpuShader.samplerTextures.length);

                for (let i = 0; i < gpuShader.samplerTextures.length; ++i) {
                  const sampler = gpuShader.samplerTextures[i];
                  gpuShader.glSamplerTextures[i] = {
                    set: sampler.set,
                    binding: sampler.binding,
                    name: sampler.name,
                    type: sampler.type,
                    count: sampler.count,
                    units: [],
                    glUnits: null,
                    glType: GFXTypeToWebGLType$1(sampler.type, gl),
                    glLoc: null
                  };
                }
              }

              const glActiveSamplers = [];
              const glActiveSamplerLocations = [];
              const texUnitCacheMap = device.stateCache.texUnitCacheMap;
              let flexibleSetBaseOffset = 0;

              for (let i = 0; i < gpuShader.blocks.length; ++i) {
                if (gpuShader.blocks[i].set === device.bindingMappingInfo.flexibleSet) {
                  flexibleSetBaseOffset++;
                }
              }

              let arrayOffset = 0;

              for (let i = 0; i < gpuShader.samplerTextures.length; ++i) {
                const sampler = gpuShader.samplerTextures[i];
                const glLoc = gl.getUniformLocation(gpuShader.glProgram, sampler.name);

                if (glLoc && glLoc.id !== -1) {
                  glActiveSamplers.push(gpuShader.glSamplerTextures[i]);
                  glActiveSamplerLocations.push(glLoc);
                }

                if (texUnitCacheMap[sampler.name] === undefined) {
                  let binding = sampler.binding + device.bindingMappingInfo.samplerOffsets[sampler.set] + arrayOffset;

                  if (sampler.set === device.bindingMappingInfo.flexibleSet) {
                    binding -= flexibleSetBaseOffset;
                  }

                  texUnitCacheMap[sampler.name] = binding % device.capabilities.maxTextureUnits;
                  arrayOffset += sampler.count - 1;
                }
              }

              if (glActiveSamplers.length) {
                const usedTexUnits = [];

                for (let i = 0; i < glActiveSamplers.length; ++i) {
                  const glSampler = glActiveSamplers[i];
                  let cachedUnit = texUnitCacheMap[glSampler.name];

                  if (cachedUnit !== undefined) {
                    glSampler.glLoc = glActiveSamplerLocations[i];

                    for (let t = 0; t < glSampler.count; ++t) {
                      while (usedTexUnits[cachedUnit]) {
                        cachedUnit = (cachedUnit + 1) % device.capabilities.maxTextureUnits;
                      }

                      glSampler.units.push(cachedUnit);
                      usedTexUnits[cachedUnit] = true;
                    }
                  }
                }

                let unitIdx = 0;

                for (let i = 0; i < glActiveSamplers.length; ++i) {
                  const glSampler = glActiveSamplers[i];

                  if (!glSampler.glLoc) {
                    glSampler.glLoc = glActiveSamplerLocations[i];

                    while (usedTexUnits[unitIdx]) {
                      unitIdx++;
                    }

                    for (let t = 0; t < glSampler.count; ++t) {
                      while (usedTexUnits[unitIdx]) {
                        unitIdx = (unitIdx + 1) % device.capabilities.maxTextureUnits;
                      }

                      if (texUnitCacheMap[glSampler.name] === undefined) {
                        texUnitCacheMap[glSampler.name] = unitIdx;
                      }

                      glSampler.units.push(unitIdx);
                      usedTexUnits[unitIdx] = true;
                    }
                  }
                }

                if (device.stateCache.glProgram !== gpuShader.glProgram) {
                  gl.useProgram(gpuShader.glProgram);
                }

                for (let k = 0; k < glActiveSamplers.length; k++) {
                  const glSampler = glActiveSamplers[k];
                  glSampler.glUnits = new Int32Array(glSampler.units);
                  gl.uniform1iv(glSampler.glLoc, glSampler.glUnits);
                }

                if (device.stateCache.glProgram !== gpuShader.glProgram) {
                  gl.useProgram(device.stateCache.glProgram);
                }
              }

              gpuShader.glSamplerTextures = glActiveSamplers;
            }
            function WebGL2CmdFuncDestroyShader(device, gpuShader) {
              if (gpuShader.glProgram) {
                device.gl.deleteProgram(gpuShader.glProgram);

                if (device.stateCache.glProgram === gpuShader.glProgram) {
                  device.gl.useProgram(null);
                  device.stateCache.glProgram = null;
                }

                gpuShader.glProgram = null;
              }
            }
            function WebGL2CmdFuncCreateInputAssember(device, gpuInputAssembler) {
              const {
                gl
              } = device;
              gpuInputAssembler.glAttribs = new Array(gpuInputAssembler.attributes.length);
              const offsets = [0, 0, 0, 0, 0, 0, 0, 0];

              for (let i = 0; i < gpuInputAssembler.attributes.length; ++i) {
                const attrib = gpuInputAssembler.attributes[i];
                const stream = attrib.stream !== undefined ? attrib.stream : 0;
                const gpuBuffer = gpuInputAssembler.gpuVertexBuffers[stream];
                const glType = GFXFormatToWebGLType$1(attrib.format, gl);
                const {
                  size
                } = FormatInfos[attrib.format];
                gpuInputAssembler.glAttribs[i] = {
                  name: attrib.name,
                  glBuffer: gpuBuffer.glBuffer,
                  glType,
                  size,
                  count: FormatInfos[attrib.format].count,
                  stride: gpuBuffer.stride,
                  componentCount: WebGLGetComponentCount$1(glType, gl),
                  isNormalized: attrib.isNormalized !== undefined ? attrib.isNormalized : false,
                  isInstanced: attrib.isInstanced !== undefined ? attrib.isInstanced : false,
                  offset: offsets[stream]
                };
                offsets[stream] += size;
              }
            }
            function WebGL2CmdFuncDestroyInputAssembler(device, gpuInputAssembler) {
              const it = gpuInputAssembler.glVAOs.values();
              let res = it.next();
              const {
                gl
              } = device;
              let glVAO = device.stateCache.glVAO;

              while (!res.done) {
                gl.deleteVertexArray(res.value);

                if (glVAO === res.value) {
                  gl.bindVertexArray(null);
                  glVAO = null;
                }

                res = it.next();
              }

              device.stateCache.glVAO = glVAO;
              gpuInputAssembler.glVAOs.clear();
            }
            const gfxStateCache$1 = {
              gpuPipelineState: null,
              gpuInputAssembler: null,
              glPrimitive: 0,
              invalidateAttachments: []
            };
            function WebGL2CmdFuncBeginRenderPass(device, gpuRenderPass, gpuFramebuffer, renderArea, clearColors, clearDepth, clearStencil) {
              const {
                gl
              } = device;
              const cache = device.stateCache;
              let clears = 0;

              if (gpuFramebuffer && gpuRenderPass) {
                if (cache.glFramebuffer !== gpuFramebuffer.glFramebuffer) {
                  gl.bindFramebuffer(gl.FRAMEBUFFER, gpuFramebuffer.glFramebuffer);
                  cache.glFramebuffer = gpuFramebuffer.glFramebuffer;
                }

                if (cache.viewport.left !== renderArea.x || cache.viewport.top !== renderArea.y || cache.viewport.width !== renderArea.width || cache.viewport.height !== renderArea.height) {
                  gl.viewport(renderArea.x, renderArea.y, renderArea.width, renderArea.height);
                  cache.viewport.left = renderArea.x;
                  cache.viewport.top = renderArea.y;
                  cache.viewport.width = renderArea.width;
                  cache.viewport.height = renderArea.height;
                }

                if (cache.scissorRect.x !== renderArea.x || cache.scissorRect.y !== renderArea.y || cache.scissorRect.width !== renderArea.width || cache.scissorRect.height !== renderArea.height) {
                  gl.scissor(renderArea.x, renderArea.y, renderArea.width, renderArea.height);
                  cache.scissorRect.x = renderArea.x;
                  cache.scissorRect.y = renderArea.y;
                  cache.scissorRect.width = renderArea.width;
                  cache.scissorRect.height = renderArea.height;
                }

                gfxStateCache$1.invalidateAttachments.length = 0;

                for (let j = 0; j < clearColors.length; ++j) {
                  const colorAttachment = gpuRenderPass.colorAttachments[j];

                  if (colorAttachment.format !== Format.UNKNOWN) {
                    switch (colorAttachment.loadOp) {
                      case LoadOp.LOAD:
                        break;

                      case LoadOp.CLEAR:
                        {
                          if (cache.bs.targets[0].blendColorMask !== ColorMask.ALL) {
                            gl.colorMask(true, true, true, true);
                          }

                          if (!gpuFramebuffer.isOffscreen) {
                            const clearColor = clearColors[0];
                            gl.clearColor(clearColor.x, clearColor.y, clearColor.z, clearColor.w);
                            clears |= gl.COLOR_BUFFER_BIT;
                          } else {
                            _f32v4[0] = clearColors[j].x;
                            _f32v4[1] = clearColors[j].y;
                            _f32v4[2] = clearColors[j].z;
                            _f32v4[3] = clearColors[j].w;
                            gl.clearBufferfv(gl.COLOR, j, _f32v4);
                          }

                          break;
                        }

                      case LoadOp.DISCARD:
                        {
                          gfxStateCache$1.invalidateAttachments.push(gl.COLOR_ATTACHMENT0 + j);
                          break;
                        }
                    }
                  }
                }

                if (gpuRenderPass.depthStencilAttachment) {
                  if (gpuRenderPass.depthStencilAttachment.format !== Format.UNKNOWN) {
                    switch (gpuRenderPass.depthStencilAttachment.depthLoadOp) {
                      case LoadOp.LOAD:
                        break;

                      case LoadOp.CLEAR:
                        {
                          if (!cache.dss.depthWrite) {
                            gl.depthMask(true);
                          }

                          gl.clearDepth(clearDepth);
                          clears |= gl.DEPTH_BUFFER_BIT;
                          break;
                        }

                      case LoadOp.DISCARD:
                        {
                          gfxStateCache$1.invalidateAttachments.push(gl.DEPTH_ATTACHMENT);
                          break;
                        }
                    }

                    if (FormatInfos[gpuRenderPass.depthStencilAttachment.format].hasStencil) {
                      switch (gpuRenderPass.depthStencilAttachment.stencilLoadOp) {
                        case LoadOp.LOAD:
                          break;

                        case LoadOp.CLEAR:
                          {
                            if (!cache.dss.stencilWriteMaskFront) {
                              gl.stencilMaskSeparate(gl.FRONT, 0xffff);
                            }

                            if (!cache.dss.stencilWriteMaskBack) {
                              gl.stencilMaskSeparate(gl.BACK, 0xffff);
                            }

                            gl.clearStencil(clearStencil);
                            clears |= gl.STENCIL_BUFFER_BIT;
                            break;
                          }

                        case LoadOp.DISCARD:
                          {
                            gfxStateCache$1.invalidateAttachments.push(gl.STENCIL_ATTACHMENT);
                            break;
                          }
                      }
                    }
                  }
                }

                if (gpuFramebuffer.glFramebuffer && gfxStateCache$1.invalidateAttachments.length) {
                  gl.invalidateFramebuffer(gl.FRAMEBUFFER, gfxStateCache$1.invalidateAttachments);
                }

                if (clears) {
                  gl.clear(clears);
                }

                if (clears & gl.COLOR_BUFFER_BIT) {
                  const colorMask = cache.bs.targets[0].blendColorMask;

                  if (colorMask !== ColorMask.ALL) {
                    const r = (colorMask & ColorMask.R) !== ColorMask.NONE;
                    const g = (colorMask & ColorMask.G) !== ColorMask.NONE;
                    const b = (colorMask & ColorMask.B) !== ColorMask.NONE;
                    const a = (colorMask & ColorMask.A) !== ColorMask.NONE;
                    gl.colorMask(r, g, b, a);
                  }
                }

                if (clears & gl.DEPTH_BUFFER_BIT && !cache.dss.depthWrite) {
                  gl.depthMask(false);
                }

                if (clears & gl.STENCIL_BUFFER_BIT) {
                  if (!cache.dss.stencilWriteMaskFront) {
                    gl.stencilMaskSeparate(gl.FRONT, 0);
                  }

                  if (!cache.dss.stencilWriteMaskBack) {
                    gl.stencilMaskSeparate(gl.BACK, 0);
                  }
                }
              }
            }
            function WebGL2CmdFuncBindStates(device, gpuPipelineState, gpuInputAssembler, gpuDescriptorSets, dynamicOffsets, dynamicStates) {
              const {
                gl
              } = device;
              const cache = device.stateCache;
              const gpuShader = gpuPipelineState && gpuPipelineState.gpuShader;
              let isShaderChanged = false;

              if (gpuPipelineState && gfxStateCache$1.gpuPipelineState !== gpuPipelineState) {
                gfxStateCache$1.gpuPipelineState = gpuPipelineState;
                gfxStateCache$1.glPrimitive = gpuPipelineState.glPrimitive;

                if (gpuShader) {
                  const {
                    glProgram
                  } = gpuShader;

                  if (cache.glProgram !== glProgram) {
                    gl.useProgram(glProgram);
                    cache.glProgram = glProgram;
                    isShaderChanged = true;
                  }
                }

                const {
                  rs
                } = gpuPipelineState;

                if (rs) {
                  if (cache.rs.cullMode !== rs.cullMode) {
                    switch (rs.cullMode) {
                      case CullMode.NONE:
                        {
                          gl.disable(gl.CULL_FACE);
                          break;
                        }

                      case CullMode.FRONT:
                        {
                          gl.enable(gl.CULL_FACE);
                          gl.cullFace(gl.FRONT);
                          break;
                        }

                      case CullMode.BACK:
                        {
                          gl.enable(gl.CULL_FACE);
                          gl.cullFace(gl.BACK);
                          break;
                        }
                    }

                    device.stateCache.rs.cullMode = rs.cullMode;
                  }

                  const isFrontFaceCCW = rs.isFrontFaceCCW;

                  if (device.stateCache.rs.isFrontFaceCCW !== isFrontFaceCCW) {
                    gl.frontFace(isFrontFaceCCW ? gl.CCW : gl.CW);
                    device.stateCache.rs.isFrontFaceCCW = isFrontFaceCCW;
                  }

                  if (device.stateCache.rs.depthBias !== rs.depthBias || device.stateCache.rs.depthBiasSlop !== rs.depthBiasSlop) {
                    gl.polygonOffset(rs.depthBias, rs.depthBiasSlop);
                    device.stateCache.rs.depthBias = rs.depthBias;
                    device.stateCache.rs.depthBiasSlop = rs.depthBiasSlop;
                  }

                  if (device.stateCache.rs.lineWidth !== rs.lineWidth) {
                    gl.lineWidth(rs.lineWidth);
                    device.stateCache.rs.lineWidth = rs.lineWidth;
                  }
                }

                const {
                  dss
                } = gpuPipelineState;

                if (dss) {
                  if (cache.dss.depthTest !== dss.depthTest) {
                    if (dss.depthTest) {
                      gl.enable(gl.DEPTH_TEST);
                    } else {
                      gl.disable(gl.DEPTH_TEST);
                    }

                    cache.dss.depthTest = dss.depthTest;
                  }

                  if (cache.dss.depthWrite !== dss.depthWrite) {
                    gl.depthMask(dss.depthWrite);
                    cache.dss.depthWrite = dss.depthWrite;
                  }

                  if (cache.dss.depthFunc !== dss.depthFunc) {
                    gl.depthFunc(WebGLCmpFuncs$1[dss.depthFunc]);
                    cache.dss.depthFunc = dss.depthFunc;
                  }

                  if (cache.dss.stencilTestFront !== dss.stencilTestFront || cache.dss.stencilTestBack !== dss.stencilTestBack) {
                    if (dss.stencilTestFront || dss.stencilTestBack) {
                      gl.enable(gl.STENCIL_TEST);
                    } else {
                      gl.disable(gl.STENCIL_TEST);
                    }

                    cache.dss.stencilTestFront = dss.stencilTestFront;
                    cache.dss.stencilTestBack = dss.stencilTestBack;
                  }

                  if (cache.dss.stencilFuncFront !== dss.stencilFuncFront || cache.dss.stencilRefFront !== dss.stencilRefFront || cache.dss.stencilReadMaskFront !== dss.stencilReadMaskFront) {
                    gl.stencilFuncSeparate(gl.FRONT, WebGLCmpFuncs$1[dss.stencilFuncFront], dss.stencilRefFront, dss.stencilReadMaskFront);
                    cache.dss.stencilFuncFront = dss.stencilFuncFront;
                    cache.dss.stencilRefFront = dss.stencilRefFront;
                    cache.dss.stencilReadMaskFront = dss.stencilReadMaskFront;
                  }

                  if (cache.dss.stencilFailOpFront !== dss.stencilFailOpFront || cache.dss.stencilZFailOpFront !== dss.stencilZFailOpFront || cache.dss.stencilPassOpFront !== dss.stencilPassOpFront) {
                    gl.stencilOpSeparate(gl.FRONT, WebGLStencilOps$1[dss.stencilFailOpFront], WebGLStencilOps$1[dss.stencilZFailOpFront], WebGLStencilOps$1[dss.stencilPassOpFront]);
                    cache.dss.stencilFailOpFront = dss.stencilFailOpFront;
                    cache.dss.stencilZFailOpFront = dss.stencilZFailOpFront;
                    cache.dss.stencilPassOpFront = dss.stencilPassOpFront;
                  }

                  if (cache.dss.stencilWriteMaskFront !== dss.stencilWriteMaskFront) {
                    gl.stencilMaskSeparate(gl.FRONT, dss.stencilWriteMaskFront);
                    cache.dss.stencilWriteMaskFront = dss.stencilWriteMaskFront;
                  }

                  if (cache.dss.stencilFuncBack !== dss.stencilFuncBack || cache.dss.stencilRefBack !== dss.stencilRefBack || cache.dss.stencilReadMaskBack !== dss.stencilReadMaskBack) {
                    gl.stencilFuncSeparate(gl.BACK, WebGLCmpFuncs$1[dss.stencilFuncBack], dss.stencilRefBack, dss.stencilReadMaskBack);
                    cache.dss.stencilFuncBack = dss.stencilFuncBack;
                    cache.dss.stencilRefBack = dss.stencilRefBack;
                    cache.dss.stencilReadMaskBack = dss.stencilReadMaskBack;
                  }

                  if (cache.dss.stencilFailOpBack !== dss.stencilFailOpBack || cache.dss.stencilZFailOpBack !== dss.stencilZFailOpBack || cache.dss.stencilPassOpBack !== dss.stencilPassOpBack) {
                    gl.stencilOpSeparate(gl.BACK, WebGLStencilOps$1[dss.stencilFailOpBack], WebGLStencilOps$1[dss.stencilZFailOpBack], WebGLStencilOps$1[dss.stencilPassOpBack]);
                    cache.dss.stencilFailOpBack = dss.stencilFailOpBack;
                    cache.dss.stencilZFailOpBack = dss.stencilZFailOpBack;
                    cache.dss.stencilPassOpBack = dss.stencilPassOpBack;
                  }

                  if (cache.dss.stencilWriteMaskBack !== dss.stencilWriteMaskBack) {
                    gl.stencilMaskSeparate(gl.BACK, dss.stencilWriteMaskBack);
                    cache.dss.stencilWriteMaskBack = dss.stencilWriteMaskBack;
                  }
                }

                const {
                  bs
                } = gpuPipelineState;

                if (bs) {
                  if (cache.bs.isA2C !== bs.isA2C) {
                    if (bs.isA2C) {
                      gl.enable(gl.SAMPLE_ALPHA_TO_COVERAGE);
                    } else {
                      gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
                    }

                    cache.bs.isA2C = bs.isA2C;
                  }

                  if (cache.bs.blendColor.x !== bs.blendColor.x || cache.bs.blendColor.y !== bs.blendColor.y || cache.bs.blendColor.z !== bs.blendColor.z || cache.bs.blendColor.w !== bs.blendColor.w) {
                    gl.blendColor(bs.blendColor.x, bs.blendColor.y, bs.blendColor.z, bs.blendColor.w);
                    cache.bs.blendColor.x = bs.blendColor.x;
                    cache.bs.blendColor.y = bs.blendColor.y;
                    cache.bs.blendColor.z = bs.blendColor.z;
                    cache.bs.blendColor.w = bs.blendColor.w;
                  }

                  const target0 = bs.targets[0];
                  const target0Cache = cache.bs.targets[0];

                  if (target0Cache.blend !== target0.blend) {
                    if (target0.blend) {
                      gl.enable(gl.BLEND);
                    } else {
                      gl.disable(gl.BLEND);
                    }

                    target0Cache.blend = target0.blend;
                  }

                  if (target0Cache.blendEq !== target0.blendEq || target0Cache.blendAlphaEq !== target0.blendAlphaEq) {
                    gl.blendEquationSeparate(WebGLBlendOps$1[target0.blendEq], WebGLBlendOps$1[target0.blendAlphaEq]);
                    target0Cache.blendEq = target0.blendEq;
                    target0Cache.blendAlphaEq = target0.blendAlphaEq;
                  }

                  if (target0Cache.blendSrc !== target0.blendSrc || target0Cache.blendDst !== target0.blendDst || target0Cache.blendSrcAlpha !== target0.blendSrcAlpha || target0Cache.blendDstAlpha !== target0.blendDstAlpha) {
                    gl.blendFuncSeparate(WebGLBlendFactors$1[target0.blendSrc], WebGLBlendFactors$1[target0.blendDst], WebGLBlendFactors$1[target0.blendSrcAlpha], WebGLBlendFactors$1[target0.blendDstAlpha]);
                    target0Cache.blendSrc = target0.blendSrc;
                    target0Cache.blendDst = target0.blendDst;
                    target0Cache.blendSrcAlpha = target0.blendSrcAlpha;
                    target0Cache.blendDstAlpha = target0.blendDstAlpha;
                  }

                  if (target0Cache.blendColorMask !== target0.blendColorMask) {
                    gl.colorMask((target0.blendColorMask & ColorMask.R) !== ColorMask.NONE, (target0.blendColorMask & ColorMask.G) !== ColorMask.NONE, (target0.blendColorMask & ColorMask.B) !== ColorMask.NONE, (target0.blendColorMask & ColorMask.A) !== ColorMask.NONE);
                    target0Cache.blendColorMask = target0.blendColorMask;
                  }
                }
              }

              if (gpuPipelineState && gpuPipelineState.gpuPipelineLayout && gpuShader) {
                const blockLen = gpuShader.glBlocks.length;
                const {
                  dynamicOffsetIndices
                } = gpuPipelineState.gpuPipelineLayout;

                for (let j = 0; j < blockLen; j++) {
                  const glBlock = gpuShader.glBlocks[j];
                  const gpuDescriptorSet = gpuDescriptorSets[glBlock.set];
                  const descriptorIndex = gpuDescriptorSet && gpuDescriptorSet.descriptorIndices[glBlock.binding];
                  const gpuDescriptor = descriptorIndex >= 0 && gpuDescriptorSet.gpuDescriptors[descriptorIndex];

                  if (!gpuDescriptor || !gpuDescriptor.gpuBuffer) {
                    error(`Buffer binding '${glBlock.name}' at set ${glBlock.set} binding ${glBlock.binding} is not bounded`);
                    continue;
                  }

                  const dynamicOffsetIndexSet = dynamicOffsetIndices[glBlock.set];
                  const dynamicOffsetIndex = dynamicOffsetIndexSet && dynamicOffsetIndexSet[glBlock.binding];
                  let offset = gpuDescriptor.gpuBuffer.glOffset;

                  if (dynamicOffsetIndex >= 0) {
                    offset += dynamicOffsets[dynamicOffsetIndex];
                  }

                  if (cache.glBindUBOs[glBlock.glBinding] !== gpuDescriptor.gpuBuffer.glBuffer || cache.glBindUBOOffsets[glBlock.glBinding] !== offset) {
                    if (offset) {
                      gl.bindBufferRange(gl.UNIFORM_BUFFER, glBlock.glBinding, gpuDescriptor.gpuBuffer.glBuffer, offset, gpuDescriptor.gpuBuffer.size);
                    } else {
                      gl.bindBufferBase(gl.UNIFORM_BUFFER, glBlock.glBinding, gpuDescriptor.gpuBuffer.glBuffer);
                    }

                    cache.glUniformBuffer = cache.glBindUBOs[glBlock.glBinding] = gpuDescriptor.gpuBuffer.glBuffer;
                    cache.glBindUBOOffsets[glBlock.glBinding] = offset;
                  }
                }

                const samplerLen = gpuShader.glSamplerTextures.length;

                for (let i = 0; i < samplerLen; i++) {
                  const glSampler = gpuShader.glSamplerTextures[i];
                  const gpuDescriptorSet = gpuDescriptorSets[glSampler.set];
                  let descriptorIndex = gpuDescriptorSet && gpuDescriptorSet.descriptorIndices[glSampler.binding];
                  let gpuDescriptor = descriptorIndex >= 0 && gpuDescriptorSet.gpuDescriptors[descriptorIndex];

                  for (let l = 0; l < glSampler.units.length; l++) {
                    const texUnit = glSampler.units[l];
                    const glTexUnit = cache.glTexUnits[texUnit];

                    if (!gpuDescriptor || !gpuDescriptor.gpuTexture || !gpuDescriptor.gpuSampler) {
                      error(`Sampler binding '${glSampler.name}' at set ${glSampler.set} binding ${glSampler.binding} index ${l} is not bounded`);
                      continue;
                    }

                    if (gpuDescriptor.gpuTexture && gpuDescriptor.gpuTexture.size > 0) {
                      const {
                        gpuTexture
                      } = gpuDescriptor;

                      if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                        if (cache.texUnit !== texUnit) {
                          gl.activeTexture(gl.TEXTURE0 + texUnit);
                          cache.texUnit = texUnit;
                        }

                        if (gpuTexture.glTexture) {
                          gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture);
                        } else {
                          gl.bindTexture(gpuTexture.glTarget, device.nullTex2D.gpuTexture.glTexture);
                        }

                        glTexUnit.glTexture = gpuTexture.glTexture;
                      }

                      const {
                        gpuSampler
                      } = gpuDescriptor;

                      if (cache.glSamplerUnits[texUnit] !== gpuSampler.glSampler) {
                        gl.bindSampler(texUnit, gpuSampler.glSampler);
                        cache.glSamplerUnits[texUnit] = gpuSampler.glSampler;
                      }
                    }

                    gpuDescriptor = gpuDescriptorSet.gpuDescriptors[++descriptorIndex];
                  }
                }
              }

              if (gpuInputAssembler && gpuShader && (isShaderChanged || gfxStateCache$1.gpuInputAssembler !== gpuInputAssembler)) {
                gfxStateCache$1.gpuInputAssembler = gpuInputAssembler;

                if (device.extensions.useVAO) {
                  let glVAO = gpuInputAssembler.glVAOs.get(gpuShader.glProgram);

                  if (!glVAO) {
                    glVAO = gl.createVertexArray();
                    gpuInputAssembler.glVAOs.set(gpuShader.glProgram, glVAO);
                    gl.bindVertexArray(glVAO);
                    gl.bindBuffer(gl.ARRAY_BUFFER, null);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                    cache.glArrayBuffer = null;
                    cache.glElementArrayBuffer = null;
                    let glAttrib;

                    for (let j = 0; j < gpuShader.glInputs.length; j++) {
                      const glInput = gpuShader.glInputs[j];
                      glAttrib = null;

                      for (let k = 0; k < gpuInputAssembler.glAttribs.length; k++) {
                        const attrib = gpuInputAssembler.glAttribs[k];

                        if (attrib.name === glInput.name) {
                          glAttrib = attrib;
                          break;
                        }
                      }

                      if (glAttrib) {
                        if (cache.glArrayBuffer !== glAttrib.glBuffer) {
                          gl.bindBuffer(gl.ARRAY_BUFFER, glAttrib.glBuffer);
                          cache.glArrayBuffer = glAttrib.glBuffer;
                        }

                        for (let c = 0; c < glAttrib.componentCount; ++c) {
                          const glLoc = glInput.glLoc + c;
                          const attribOffset = glAttrib.offset + glAttrib.size * c;
                          gl.enableVertexAttribArray(glLoc);
                          cache.glCurrentAttribLocs[glLoc] = true;
                          gl.vertexAttribPointer(glLoc, glAttrib.count, glAttrib.glType, glAttrib.isNormalized, glAttrib.stride, attribOffset);
                          gl.vertexAttribDivisor(glLoc, glAttrib.isInstanced ? 1 : 0);
                        }
                      }
                    }

                    const gpuBuffer = gpuInputAssembler.gpuIndexBuffer;

                    if (gpuBuffer) {
                      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
                    }

                    gl.bindVertexArray(null);
                    gl.bindBuffer(gl.ARRAY_BUFFER, null);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                    cache.glArrayBuffer = null;
                    cache.glElementArrayBuffer = null;
                  }

                  if (cache.glVAO !== glVAO) {
                    gl.bindVertexArray(glVAO);
                    cache.glVAO = glVAO;
                  }
                } else {
                  for (let a = 0; a < device.capabilities.maxVertexAttributes; ++a) {
                    cache.glCurrentAttribLocs[a] = false;
                  }

                  for (let j = 0; j < gpuShader.glInputs.length; j++) {
                    const glInput = gpuShader.glInputs[j];
                    let glAttrib = null;

                    for (let k = 0; k < gpuInputAssembler.glAttribs.length; k++) {
                      const attrib = gpuInputAssembler.glAttribs[k];

                      if (attrib.name === glInput.name) {
                        glAttrib = attrib;
                        break;
                      }
                    }

                    if (glAttrib) {
                      if (cache.glArrayBuffer !== glAttrib.glBuffer) {
                        gl.bindBuffer(gl.ARRAY_BUFFER, glAttrib.glBuffer);
                        cache.glArrayBuffer = glAttrib.glBuffer;
                      }

                      for (let c = 0; c < glAttrib.componentCount; ++c) {
                        const glLoc = glInput.glLoc + c;
                        const attribOffset = glAttrib.offset + glAttrib.size * c;

                        if (!cache.glEnabledAttribLocs[glLoc] && glLoc >= 0) {
                          gl.enableVertexAttribArray(glLoc);
                          cache.glEnabledAttribLocs[glLoc] = true;
                        }

                        cache.glCurrentAttribLocs[glLoc] = true;
                        gl.vertexAttribPointer(glLoc, glAttrib.count, glAttrib.glType, glAttrib.isNormalized, glAttrib.stride, attribOffset);
                        gl.vertexAttribDivisor(glLoc, glAttrib.isInstanced ? 1 : 0);
                      }
                    }
                  }

                  const gpuBuffer = gpuInputAssembler.gpuIndexBuffer;

                  if (gpuBuffer) {
                    if (cache.glElementArrayBuffer !== gpuBuffer.glBuffer) {
                      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
                      cache.glElementArrayBuffer = gpuBuffer.glBuffer;
                    }
                  }

                  for (let a = 0; a < device.capabilities.maxVertexAttributes; ++a) {
                    if (cache.glEnabledAttribLocs[a] !== cache.glCurrentAttribLocs[a]) {
                      gl.disableVertexAttribArray(a);
                      cache.glEnabledAttribLocs[a] = false;
                    }
                  }
                }
              }

              if (gpuPipelineState && gpuPipelineState.dynamicStates.length) {
                const dsLen = gpuPipelineState.dynamicStates.length;

                for (let k = 0; k < dsLen; k++) {
                  const dynamicState = gpuPipelineState.dynamicStates[k];

                  switch (dynamicState) {
                    case DynamicStateFlagBit.LINE_WIDTH:
                      {
                        if (cache.rs.lineWidth !== dynamicStates.lineWidth) {
                          gl.lineWidth(dynamicStates.lineWidth);
                          cache.rs.lineWidth = dynamicStates.lineWidth;
                        }

                        break;
                      }

                    case DynamicStateFlagBit.DEPTH_BIAS:
                      {
                        if (cache.rs.depthBias !== dynamicStates.depthBiasConstant || cache.rs.depthBiasSlop !== dynamicStates.depthBiasSlope) {
                          gl.polygonOffset(dynamicStates.depthBiasConstant, dynamicStates.depthBiasSlope);
                          cache.rs.depthBias = dynamicStates.depthBiasConstant;
                          cache.rs.depthBiasSlop = dynamicStates.depthBiasSlope;
                        }

                        break;
                      }

                    case DynamicStateFlagBit.BLEND_CONSTANTS:
                      {
                        const blendConstant = dynamicStates.blendConstant;

                        if (cache.bs.blendColor.x !== blendConstant.x || cache.bs.blendColor.y !== blendConstant.y || cache.bs.blendColor.z !== blendConstant.z || cache.bs.blendColor.w !== blendConstant.w) {
                          gl.blendColor(blendConstant.x, blendConstant.y, blendConstant.z, blendConstant.w);
                          cache.bs.blendColor.copy(blendConstant);
                        }

                        break;
                      }

                    case DynamicStateFlagBit.STENCIL_WRITE_MASK:
                      {
                        const front = dynamicStates.stencilStatesFront;
                        const back = dynamicStates.stencilStatesBack;

                        if (cache.dss.stencilWriteMaskFront !== front.writeMask) {
                          gl.stencilMaskSeparate(gl.FRONT, front.writeMask);
                          cache.dss.stencilWriteMaskFront = front.writeMask;
                        }

                        if (cache.dss.stencilWriteMaskBack !== back.writeMask) {
                          gl.stencilMaskSeparate(gl.BACK, back.writeMask);
                          cache.dss.stencilWriteMaskBack = back.writeMask;
                        }

                        break;
                      }

                    case DynamicStateFlagBit.STENCIL_COMPARE_MASK:
                      {
                        const front = dynamicStates.stencilStatesFront;
                        const back = dynamicStates.stencilStatesBack;

                        if (cache.dss.stencilRefFront !== front.reference || cache.dss.stencilReadMaskFront !== front.compareMask) {
                          gl.stencilFuncSeparate(gl.FRONT, WebGLCmpFuncs$1[cache.dss.stencilFuncFront], front.reference, front.compareMask);
                          cache.dss.stencilRefFront = front.reference;
                          cache.dss.stencilReadMaskFront = front.compareMask;
                        }

                        if (cache.dss.stencilRefBack !== back.reference || cache.dss.stencilReadMaskBack !== back.compareMask) {
                          gl.stencilFuncSeparate(gl.BACK, WebGLCmpFuncs$1[cache.dss.stencilFuncBack], back.reference, back.compareMask);
                          cache.dss.stencilRefBack = back.reference;
                          cache.dss.stencilReadMaskBack = back.compareMask;
                        }

                        break;
                      }
                  }
                }
              }
            }
            function WebGL2CmdFuncDraw(device, drawInfo) {
              const {
                gl
              } = device;
              const {
                gpuInputAssembler,
                glPrimitive
              } = gfxStateCache$1;
              const md = device.extensions.WEBGL_multi_draw;

              if (gpuInputAssembler) {
                const indexBuffer = gpuInputAssembler.gpuIndexBuffer;

                if (gpuInputAssembler.gpuIndirectBuffer) {
                  const {
                    indirects
                  } = gpuInputAssembler.gpuIndirectBuffer;

                  if (indirects.drawByIndex) {
                    for (let j = 0; j < indirects.drawCount; j++) {
                      indirects.byteOffsets[j] = indirects.offsets[j] * indexBuffer.stride;
                    }

                    if (md) {
                      if (indirects.instancedDraw) {
                        md.multiDrawElementsInstancedWEBGL(glPrimitive, indirects.counts, 0, gpuInputAssembler.glIndexType, indirects.byteOffsets, 0, indirects.instances, 0, indirects.drawCount);
                      } else {
                        md.multiDrawElementsWEBGL(glPrimitive, indirects.counts, 0, gpuInputAssembler.glIndexType, indirects.byteOffsets, 0, indirects.drawCount);
                      }
                    } else {
                      for (let j = 0; j < indirects.drawCount; j++) {
                        if (indirects.instances[j]) {
                          gl.drawElementsInstanced(glPrimitive, indirects.counts[j], gpuInputAssembler.glIndexType, indirects.byteOffsets[j], indirects.instances[j]);
                        } else {
                          gl.drawElements(glPrimitive, indirects.counts[j], gpuInputAssembler.glIndexType, indirects.byteOffsets[j]);
                        }
                      }
                    }
                  } else if (md) {
                    if (indirects.instancedDraw) {
                      md.multiDrawArraysInstancedWEBGL(glPrimitive, indirects.offsets, 0, indirects.counts, 0, indirects.instances, 0, indirects.drawCount);
                    } else {
                      md.multiDrawArraysWEBGL(glPrimitive, indirects.offsets, 0, indirects.counts, 0, indirects.drawCount);
                    }
                  } else {
                    for (let j = 0; j < indirects.drawCount; j++) {
                      if (indirects.instances[j]) {
                        gl.drawArraysInstanced(glPrimitive, indirects.offsets[j], indirects.counts[j], indirects.instances[j]);
                      } else {
                        gl.drawArrays(glPrimitive, indirects.offsets[j], indirects.counts[j]);
                      }
                    }
                  }
                } else if (drawInfo.instanceCount) {
                  if (indexBuffer) {
                    if (drawInfo.indexCount > 0) {
                      const offset = drawInfo.firstIndex * indexBuffer.stride;
                      gl.drawElementsInstanced(glPrimitive, drawInfo.indexCount, gpuInputAssembler.glIndexType, offset, drawInfo.instanceCount);
                    }
                  } else if (drawInfo.vertexCount > 0) {
                    gl.drawArraysInstanced(glPrimitive, drawInfo.firstVertex, drawInfo.vertexCount, drawInfo.instanceCount);
                  }
                } else if (indexBuffer) {
                  if (drawInfo.indexCount > 0) {
                    const offset = drawInfo.firstIndex * indexBuffer.stride;
                    gl.drawElements(glPrimitive, drawInfo.indexCount, gpuInputAssembler.glIndexType, offset);
                  }
                } else if (drawInfo.vertexCount > 0) {
                  gl.drawArrays(glPrimitive, drawInfo.firstVertex, drawInfo.vertexCount);
                }
              }
            }
            const cmdIds$1 = new Array(WebGL2Cmd.COUNT);
            function WebGL2CmdFuncExecuteCmds(device, cmdPackage) {
              cmdIds$1.fill(0);

              for (let i = 0; i < cmdPackage.cmds.length; ++i) {
                const cmd = cmdPackage.cmds.array[i];
                const cmdId = cmdIds$1[cmd]++;

                switch (cmd) {
                  case WebGL2Cmd.BEGIN_RENDER_PASS:
                    {
                      const cmd0 = cmdPackage.beginRenderPassCmds.array[cmdId];
                      WebGL2CmdFuncBeginRenderPass(device, cmd0.gpuRenderPass, cmd0.gpuFramebuffer, cmd0.renderArea, cmd0.clearColors, cmd0.clearDepth, cmd0.clearStencil);
                      break;
                    }

                  case WebGL2Cmd.BIND_STATES:
                    {
                      const cmd2 = cmdPackage.bindStatesCmds.array[cmdId];
                      WebGL2CmdFuncBindStates(device, cmd2.gpuPipelineState, cmd2.gpuInputAssembler, cmd2.gpuDescriptorSets, cmd2.dynamicOffsets, cmd2.dynamicStates);
                      break;
                    }

                  case WebGL2Cmd.DRAW:
                    {
                      const cmd3 = cmdPackage.drawCmds.array[cmdId];
                      WebGL2CmdFuncDraw(device, cmd3.drawInfo);
                      break;
                    }

                  case WebGL2Cmd.UPDATE_BUFFER:
                    {
                      const cmd4 = cmdPackage.updateBufferCmds.array[cmdId];
                      WebGL2CmdFuncUpdateBuffer(device, cmd4.gpuBuffer, cmd4.buffer, cmd4.offset, cmd4.size);
                      break;
                    }

                  case WebGL2Cmd.COPY_BUFFER_TO_TEXTURE:
                    {
                      const cmd5 = cmdPackage.copyBufferToTextureCmds.array[cmdId];
                      WebGL2CmdFuncCopyBuffersToTexture(device, cmd5.buffers, cmd5.gpuTexture, cmd5.regions);
                      break;
                    }
                }
              }
            }
            function WebGL2CmdFuncCopyTexImagesToTexture(device, texImages, gpuTexture, regions) {
              const {
                gl
              } = device;
              const glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

              if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture);
                glTexUnit.glTexture = gpuTexture.glTexture;
              }

              let n = 0;
              let f = 0;

              switch (gpuTexture.glTarget) {
                case gl.TEXTURE_2D:
                  {
                    for (let k = 0; k < regions.length; k++) {
                      const region = regions[k];
                      gl.texSubImage2D(gl.TEXTURE_2D, region.texSubres.mipLevel, region.texOffset.x, region.texOffset.y, gpuTexture.glFormat, gpuTexture.glType, texImages[n++]);
                    }

                    break;
                  }

                case gl.TEXTURE_CUBE_MAP:
                  {
                    for (let k = 0; k < regions.length; k++) {
                      const region = regions[k];
                      const fcount = region.texSubres.baseArrayLayer + region.texSubres.layerCount;

                      for (f = region.texSubres.baseArrayLayer; f < fcount; ++f) {
                        gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, region.texSubres.mipLevel, region.texOffset.x, region.texOffset.y, gpuTexture.glFormat, gpuTexture.glType, texImages[n++]);
                      }
                    }

                    break;
                  }

                default:
                  {
                    console.error('Unsupported GL texture type, copy buffer to texture failed.');
                  }
              }

              if (gpuTexture.flags & TextureFlagBit.GEN_MIPMAP) {
                gl.generateMipmap(gpuTexture.glTarget);
              }
            }
            function WebGL2CmdFuncCopyBuffersToTexture(device, buffers, gpuTexture, regions) {
              const {
                gl
              } = device;
              const glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

              if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture);
                glTexUnit.glTexture = gpuTexture.glTexture;
              }

              let n = 0;
              let w = 1;
              let h = 1;
              let f = 0;
              const fmtInfo = FormatInfos[gpuTexture.format];
              const {
                isCompressed
              } = fmtInfo;

              switch (gpuTexture.glTarget) {
                case gl.TEXTURE_2D:
                  {
                    for (let k = 0; k < regions.length; k++) {
                      const region = regions[k];
                      w = region.texExtent.width;
                      h = region.texExtent.height;
                      const pixels = buffers[n++];

                      if (!isCompressed) {
                        gl.texSubImage2D(gl.TEXTURE_2D, region.texSubres.mipLevel, region.texOffset.x, region.texOffset.y, w, h, gpuTexture.glFormat, gpuTexture.glType, pixels);
                      } else if (gpuTexture.glInternalFmt !== WebGL2EXT.COMPRESSED_RGB_ETC1_WEBGL) {
                        gl.compressedTexSubImage2D(gl.TEXTURE_2D, region.texSubres.mipLevel, region.texOffset.x, region.texOffset.y, w, h, gpuTexture.glFormat, pixels);
                      } else {
                        gl.compressedTexImage2D(gl.TEXTURE_2D, region.texSubres.mipLevel, gpuTexture.glInternalFmt, w, h, 0, pixels);
                      }
                    }

                    break;
                  }

                case gl.TEXTURE_CUBE_MAP:
                  {
                    for (let k = 0; k < regions.length; k++) {
                      const region = regions[k];
                      const fcount = region.texSubres.baseArrayLayer + region.texSubres.layerCount;

                      for (f = region.texSubres.baseArrayLayer; f < fcount; ++f) {
                        w = region.texExtent.width;
                        h = region.texExtent.height;
                        const pixels = buffers[n++];

                        if (!isCompressed) {
                          gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, region.texSubres.mipLevel, region.texOffset.x, region.texOffset.y, w, h, gpuTexture.glFormat, gpuTexture.glType, pixels);
                        } else if (gpuTexture.glInternalFmt !== WebGL2EXT.COMPRESSED_RGB_ETC1_WEBGL) {
                          gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, region.texSubres.mipLevel, region.texOffset.x, region.texOffset.y, w, h, gpuTexture.glFormat, pixels);
                        } else {
                          gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, region.texSubres.mipLevel, gpuTexture.glInternalFmt, w, h, 0, pixels);
                        }
                      }
                    }

                    break;
                  }

                default:
                  {
                    console.error('Unsupported GL texture type, copy buffer to texture failed.');
                  }
              }

              if (gpuTexture.flags & TextureFlagBit.GEN_MIPMAP) {
                gl.generateMipmap(gpuTexture.glTarget);
              }
            }
            function WebGL2CmdFuncCopyTextureToBuffers(device, gpuTexture, buffers, regions) {
              const {
                gl
              } = device;
              const cache = device.stateCache;
              const framebuffer = gl.createFramebuffer();
              gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
              let x = 0;
              let y = 0;
              let w = 1;
              let h = 1;

              switch (gpuTexture.glTarget) {
                case gl.TEXTURE_2D:
                  {
                    for (let k = 0; k < regions.length; k++) {
                      const region = regions[k];
                      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gpuTexture.glTarget, gpuTexture.glTexture, region.texSubres.mipLevel);
                      x = region.texOffset.x;
                      y = region.texOffset.y;
                      w = region.texExtent.width;
                      h = region.texExtent.height;
                      gl.readPixels(x, y, w, h, gpuTexture.glFormat, gpuTexture.glType, buffers[k]);
                    }

                    break;
                  }

                default:
                  {
                    console.error('Unsupported GL texture type, copy texture to buffers failed.');
                  }
              }

              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
              cache.glFramebuffer = null;
              gl.deleteFramebuffer(framebuffer);
            }

            class WebGL2IndirectDrawInfos {
              constructor() {
                this.counts = void 0;
                this.offsets = void 0;
                this.instances = void 0;
                this.drawCount = 0;
                this.drawByIndex = false;
                this.instancedDraw = false;
                this.byteOffsets = void 0;
                this._capacity = 4;
                this.counts = new Int32Array(this._capacity);
                this.offsets = new Int32Array(this._capacity);
                this.instances = new Int32Array(this._capacity);
                this.byteOffsets = new Int32Array(this._capacity);
              }

              clearDraws() {
                this.drawCount = 0;
                this.drawByIndex = false;
                this.instancedDraw = false;
              }

              setDrawInfo(idx, info) {
                this._ensureCapacity(idx);

                this.drawByIndex = info.indexCount > 0;
                this.instancedDraw = !!info.instanceCount;
                this.drawCount = Math.max(idx + 1, this.drawCount);

                if (this.drawByIndex) {
                  this.counts[idx] = info.indexCount;
                  this.offsets[idx] = info.firstIndex;
                } else {
                  this.counts[idx] = info.vertexCount;
                  this.offsets[idx] = info.firstVertex;
                }

                this.instances[idx] = Math.max(1, info.instanceCount);
              }

              _ensureCapacity(target) {
                if (this._capacity > target) return;
                this._capacity = nextPow2(target);
                const counts = new Int32Array(this._capacity);
                const offsets = new Int32Array(this._capacity);
                const instances = new Int32Array(this._capacity);
                this.byteOffsets = new Int32Array(this._capacity);
                counts.set(this.counts);
                offsets.set(this.offsets);
                instances.set(this.instances);
                this.counts = counts;
                this.offsets = offsets;
                this.instances = instances;
              }

            }

            class WebGL2Buffer extends Buffer {
              constructor(...args) {
                super(...args);
                this._gpuBuffer = null;
              }

              get gpuBuffer() {
                return this._gpuBuffer;
              }

              initialize(info) {
                if ('buffer' in info) {
                  this._isBufferView = true;
                  const buffer = info.buffer;
                  this._usage = buffer.usage;
                  this._memUsage = buffer.memUsage;
                  this._size = this._stride = info.range;
                  this._count = 1;
                  this._flags = buffer.flags;
                  this._gpuBuffer = {
                    usage: this._usage,
                    memUsage: this._memUsage,
                    size: this._size,
                    stride: this._stride,
                    buffer: null,
                    indirects: buffer.gpuBuffer.indirects,
                    glTarget: buffer.gpuBuffer.glTarget,
                    glBuffer: buffer.gpuBuffer.glBuffer,
                    glOffset: info.offset
                  };
                } else {
                  this._usage = info.usage;
                  this._memUsage = info.memUsage;
                  this._size = info.size;
                  this._stride = Math.max(info.stride || this._size, 1);
                  this._count = this._size / this._stride;
                  this._flags = info.flags;
                  this._gpuBuffer = {
                    usage: this._usage,
                    memUsage: this._memUsage,
                    size: this._size,
                    stride: this._stride,
                    buffer: null,
                    indirects: new WebGL2IndirectDrawInfos(),
                    glTarget: 0,
                    glBuffer: null,
                    glOffset: 0
                  };
                  WebGL2CmdFuncCreateBuffer(WebGL2DeviceManager.instance, this._gpuBuffer);
                  WebGL2DeviceManager.instance.memoryStatus.bufferSize += this._size;
                }
              }

              destroy() {
                if (this._gpuBuffer) {
                  if (!this._isBufferView) {
                    WebGL2CmdFuncDestroyBuffer(WebGL2DeviceManager.instance, this._gpuBuffer);
                    WebGL2DeviceManager.instance.memoryStatus.bufferSize -= this._size;
                  }

                  this._gpuBuffer = null;
                }
              }

              resize(size) {
                if (this._isBufferView) {
                  console.warn('cannot resize buffer views!');
                  return;
                }

                const oldSize = this._size;

                if (oldSize === size) {
                  return;
                }

                this._size = size;
                this._count = this._size / this._stride;

                if (this._gpuBuffer) {
                  this._gpuBuffer.size = size;

                  if (size > 0) {
                    WebGL2CmdFuncResizeBuffer(WebGL2DeviceManager.instance, this._gpuBuffer);
                    WebGL2DeviceManager.instance.memoryStatus.bufferSize -= oldSize;
                    WebGL2DeviceManager.instance.memoryStatus.bufferSize += size;
                  }
                }
              }

              update(buffer, size) {
                if (this._isBufferView) {
                  console.warn('cannot update through buffer views!');
                  return;
                }

                let buffSize;

                if (size !== undefined) {
                  buffSize = size;
                } else if (this._usage & BufferUsageBit.INDIRECT) {
                  buffSize = 0;
                } else {
                  buffSize = buffer.byteLength;
                }

                WebGL2CmdFuncUpdateBuffer(WebGL2DeviceManager.instance, this._gpuBuffer, buffer, 0, buffSize);
              }

            }

            class WebGL2CommandPool {
              constructor(Clazz, count) {
                this._frees = void 0;
                this._freeIdx = 0;
                this._freeCmds = void 0;
                this._frees = new Array(count);
                this._freeCmds = new CachedArray(count);

                for (let i = 0; i < count; ++i) {
                  this._frees[i] = new Clazz();
                }

                this._freeIdx = count - 1;
              }

              alloc(Clazz) {
                if (this._freeIdx < 0) {
                  const size = this._frees.length * 2;
                  const temp = this._frees;
                  this._frees = new Array(size);
                  const increase = size - temp.length;

                  for (let i = 0; i < increase; ++i) {
                    this._frees[i] = new Clazz();
                  }

                  for (let i = increase, j = 0; i < size; ++i, ++j) {
                    this._frees[i] = temp[j];
                  }

                  this._freeIdx += increase;
                }

                const cmd = this._frees[this._freeIdx];
                this._frees[this._freeIdx--] = null;
                ++cmd.refCount;
                return cmd;
              }

              free(cmd) {
                if (--cmd.refCount === 0) {
                  this._freeCmds.push(cmd);
                }
              }

              freeCmds(cmds) {
                for (let i = 0; i < cmds.length; ++i) {
                  if (--cmds.array[i].refCount === 0) {
                    this._freeCmds.push(cmds.array[i]);
                  }
                }
              }

              release() {
                for (let i = 0; i < this._freeCmds.length; ++i) {
                  const cmd = this._freeCmds.array[i];
                  cmd.clear();
                  this._frees[++this._freeIdx] = cmd;
                }

                this._freeCmds.clear();
              }

            }
            class WebGL2CommandAllocator {
              constructor() {
                this.beginRenderPassCmdPool = void 0;
                this.bindStatesCmdPool = void 0;
                this.drawCmdPool = void 0;
                this.updateBufferCmdPool = void 0;
                this.copyBufferToTextureCmdPool = void 0;
                this.beginRenderPassCmdPool = new WebGL2CommandPool(WebGL2CmdBeginRenderPass, 1);
                this.bindStatesCmdPool = new WebGL2CommandPool(WebGL2CmdBindStates, 1);
                this.drawCmdPool = new WebGL2CommandPool(WebGL2CmdDraw, 1);
                this.updateBufferCmdPool = new WebGL2CommandPool(WebGL2CmdUpdateBuffer, 1);
                this.copyBufferToTextureCmdPool = new WebGL2CommandPool(WebGL2CmdCopyBufferToTexture, 1);
              }

              clearCmds(cmdPackage) {
                if (cmdPackage.beginRenderPassCmds.length) {
                  this.beginRenderPassCmdPool.freeCmds(cmdPackage.beginRenderPassCmds);
                  cmdPackage.beginRenderPassCmds.clear();
                }

                if (cmdPackage.bindStatesCmds.length) {
                  this.bindStatesCmdPool.freeCmds(cmdPackage.bindStatesCmds);
                  cmdPackage.bindStatesCmds.clear();
                }

                if (cmdPackage.drawCmds.length) {
                  this.drawCmdPool.freeCmds(cmdPackage.drawCmds);
                  cmdPackage.drawCmds.clear();
                }

                if (cmdPackage.updateBufferCmds.length) {
                  this.updateBufferCmdPool.freeCmds(cmdPackage.updateBufferCmds);
                  cmdPackage.updateBufferCmds.clear();
                }

                if (cmdPackage.copyBufferToTextureCmds.length) {
                  this.copyBufferToTextureCmdPool.freeCmds(cmdPackage.copyBufferToTextureCmds);
                  cmdPackage.copyBufferToTextureCmds.clear();
                }

                cmdPackage.cmds.clear();
              }

              releaseCmds() {
                this.beginRenderPassCmdPool.release();
                this.bindStatesCmdPool.release();
                this.drawCmdPool.release();
                this.updateBufferCmdPool.release();
                this.copyBufferToTextureCmdPool.release();
              }

            }

            class WebGL2CommandBuffer extends CommandBuffer {
              constructor(...args) {
                super(...args);
                this.cmdPackage = new WebGL2CmdPackage();
                this._cmdAllocator = new WebGL2CommandAllocator();
                this._isInRenderPass = false;
                this._curGPUPipelineState = null;
                this._curGPUDescriptorSets = [];
                this._curGPUInputAssembler = null;
                this._curDynamicOffsets = Array(8).fill(0);
                this._curDynamicStates = new DynamicStates();
                this._isStateInvalied = false;
              }

              initialize(info) {
                this._type = info.type;
                this._queue = info.queue;
                const setCount = WebGL2DeviceManager.instance.bindingMappingInfo.bufferOffsets.length;

                for (let i = 0; i < setCount; i++) {
                  this._curGPUDescriptorSets.push(null);
                }
              }

              destroy() {
                this._cmdAllocator.clearCmds(this.cmdPackage);
              }

              begin(renderPass, subpass = 0, frameBuffer) {
                this._cmdAllocator.clearCmds(this.cmdPackage);

                this._curGPUPipelineState = null;
                this._curGPUInputAssembler = null;
                this._curGPUDescriptorSets.length = 0;
                this._numDrawCalls = 0;
                this._numInstances = 0;
                this._numTris = 0;
              }

              end() {
                if (this._isStateInvalied) {
                  this.bindStates();
                }

                this._isInRenderPass = false;
              }

              beginRenderPass(renderPass, framebuffer, renderArea, clearColors, clearDepth, clearStencil) {
                const cmd = this._cmdAllocator.beginRenderPassCmdPool.alloc(WebGL2CmdBeginRenderPass);

                cmd.gpuRenderPass = renderPass.gpuRenderPass;
                cmd.gpuFramebuffer = framebuffer.gpuFramebuffer;
                cmd.renderArea = renderArea;

                for (let i = 0; i < clearColors.length; ++i) {
                  cmd.clearColors[i] = clearColors[i];
                }

                cmd.clearDepth = clearDepth;
                cmd.clearStencil = clearStencil;
                this.cmdPackage.beginRenderPassCmds.push(cmd);
                this.cmdPackage.cmds.push(WebGL2Cmd.BEGIN_RENDER_PASS);
                this._isInRenderPass = true;
              }

              endRenderPass() {
                this._isInRenderPass = false;
              }

              bindPipelineState(pipelineState) {
                const gpuPipelineState = pipelineState.gpuPipelineState;

                if (gpuPipelineState !== this._curGPUPipelineState) {
                  this._curGPUPipelineState = gpuPipelineState;
                  this._isStateInvalied = true;
                }
              }

              bindDescriptorSet(set, descriptorSet, dynamicOffsets) {
                const gpuDescriptorSets = descriptorSet.gpuDescriptorSet;

                if (gpuDescriptorSets !== this._curGPUDescriptorSets[set]) {
                  this._curGPUDescriptorSets[set] = gpuDescriptorSets;
                  this._isStateInvalied = true;
                }

                if (dynamicOffsets) {
                  var _this$_curGPUPipeline;

                  const gpuPipelineLayout = (_this$_curGPUPipeline = this._curGPUPipelineState) === null || _this$_curGPUPipeline === void 0 ? void 0 : _this$_curGPUPipeline.gpuPipelineLayout;

                  if (gpuPipelineLayout) {
                    const offsets = this._curDynamicOffsets;
                    const idx = gpuPipelineLayout.dynamicOffsetOffsets[set];

                    for (let i = 0; i < dynamicOffsets.length; i++) offsets[idx + i] = dynamicOffsets[i];

                    this._isStateInvalied = true;
                  }
                }
              }

              bindInputAssembler(inputAssembler) {
                const gpuInputAssembler = inputAssembler.gpuInputAssembler;
                this._curGPUInputAssembler = gpuInputAssembler;
                this._isStateInvalied = true;
              }

              setViewport(viewport) {
                const cache = this._curDynamicStates.viewport;

                if (cache.left !== viewport.left || cache.top !== viewport.top || cache.width !== viewport.width || cache.height !== viewport.height || cache.minDepth !== viewport.minDepth || cache.maxDepth !== viewport.maxDepth) {
                  cache.left = viewport.left;
                  cache.top = viewport.top;
                  cache.width = viewport.width;
                  cache.height = viewport.height;
                  cache.minDepth = viewport.minDepth;
                  cache.maxDepth = viewport.maxDepth;
                  this._isStateInvalied = true;
                }
              }

              setScissor(scissor) {
                const cache = this._curDynamicStates.scissor;

                if (cache.x !== scissor.x || cache.y !== scissor.y || cache.width !== scissor.width || cache.height !== scissor.height) {
                  cache.x = scissor.x;
                  cache.y = scissor.y;
                  cache.width = scissor.width;
                  cache.height = scissor.height;
                  this._isStateInvalied = true;
                }
              }

              setLineWidth(lineWidth) {
                if (this._curDynamicStates.lineWidth !== lineWidth) {
                  this._curDynamicStates.lineWidth = lineWidth;
                  this._isStateInvalied = true;
                }
              }

              setDepthBias(depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor) {
                const cache = this._curDynamicStates;

                if (cache.depthBiasConstant !== depthBiasConstantFactor || cache.depthBiasClamp !== depthBiasClamp || cache.depthBiasSlope !== depthBiasSlopeFactor) {
                  cache.depthBiasConstant = depthBiasConstantFactor;
                  cache.depthBiasClamp = depthBiasClamp;
                  cache.depthBiasSlope = depthBiasSlopeFactor;
                  this._isStateInvalied = true;
                }
              }

              setBlendConstants(blendConstants) {
                const cache = this._curDynamicStates.blendConstant;

                if (cache.x !== blendConstants.x || cache.y !== blendConstants.y || cache.z !== blendConstants.z || cache.w !== blendConstants.w) {
                  cache.copy(blendConstants);
                  this._isStateInvalied = true;
                }
              }

              setDepthBound(minDepthBounds, maxDepthBounds) {
                const cache = this._curDynamicStates;

                if (cache.depthMinBounds !== minDepthBounds || cache.depthMaxBounds !== maxDepthBounds) {
                  cache.depthMinBounds = minDepthBounds;
                  cache.depthMaxBounds = maxDepthBounds;
                  this._isStateInvalied = true;
                }
              }

              setStencilWriteMask(face, writeMask) {
                const front = this._curDynamicStates.stencilStatesFront;
                const back = this._curDynamicStates.stencilStatesBack;

                if (face & StencilFace.FRONT) {
                  if (front.writeMask !== writeMask) {
                    front.writeMask = writeMask;
                    this._isStateInvalied = true;
                  }
                }

                if (face & StencilFace.BACK) {
                  if (back.writeMask !== writeMask) {
                    back.writeMask = writeMask;
                    this._isStateInvalied = true;
                  }
                }
              }

              setStencilCompareMask(face, reference, compareMask) {
                const front = this._curDynamicStates.stencilStatesFront;
                const back = this._curDynamicStates.stencilStatesBack;

                if (face & StencilFace.FRONT) {
                  if (front.compareMask !== compareMask || front.reference !== reference) {
                    front.reference = reference;
                    front.compareMask = compareMask;
                    this._isStateInvalied = true;
                  }
                }

                if (face & StencilFace.BACK) {
                  if (back.compareMask !== compareMask || back.reference !== reference) {
                    back.reference = reference;
                    back.compareMask = compareMask;
                    this._isStateInvalied = true;
                  }
                }
              }

              draw(infoOrAssembler) {
                if (this._type === CommandBufferType.PRIMARY && this._isInRenderPass || this._type === CommandBufferType.SECONDARY) {
                  if (this._isStateInvalied) {
                    this.bindStates();
                  }

                  const info = 'drawInfo' in infoOrAssembler ? infoOrAssembler.drawInfo : infoOrAssembler;

                  const cmd = this._cmdAllocator.drawCmdPool.alloc(WebGL2CmdDraw);

                  cmd.drawInfo.copy(info);
                  this.cmdPackage.drawCmds.push(cmd);
                  this.cmdPackage.cmds.push(WebGL2Cmd.DRAW);
                  ++this._numDrawCalls;
                  this._numInstances += info.instanceCount;
                  const indexCount = info.indexCount || info.vertexCount;

                  if (this._curGPUPipelineState) {
                    const glPrimitive = this._curGPUPipelineState.glPrimitive;

                    switch (glPrimitive) {
                      case 0x0004:
                        {
                          this._numTris += indexCount / 3 * Math.max(info.instanceCount, 1);
                          break;
                        }

                      case 0x0005:
                      case 0x0006:
                        {
                          this._numTris += (indexCount - 2) * Math.max(info.instanceCount, 1);
                          break;
                        }
                    }
                  }
                } else {
                  console.error('Command \'draw\' must be recorded inside a render pass.');
                }
              }

              updateBuffer(buffer, data, size) {
                if (this._type === CommandBufferType.PRIMARY && !this._isInRenderPass || this._type === CommandBufferType.SECONDARY) {
                  const gpuBuffer = buffer.gpuBuffer;

                  if (gpuBuffer) {
                    const cmd = this._cmdAllocator.updateBufferCmdPool.alloc(WebGL2CmdUpdateBuffer);

                    let buffSize = 0;
                    let buff = null;

                    if (buffer.usage & BufferUsageBit.INDIRECT) {
                      buff = data;
                    } else {
                      if (size !== undefined) {
                        buffSize = size;
                      } else {
                        buffSize = data.byteLength;
                      }

                      buff = data;
                    }

                    cmd.gpuBuffer = gpuBuffer;
                    cmd.buffer = buff;
                    cmd.offset = 0;
                    cmd.size = buffSize;
                    this.cmdPackage.updateBufferCmds.push(cmd);
                    this.cmdPackage.cmds.push(WebGL2Cmd.UPDATE_BUFFER);
                  }
                } else {
                  console.error('Command \'updateBuffer\' must be recorded outside a render pass.');
                }
              }

              copyBuffersToTexture(buffers, texture, regions) {
                if (this._type === CommandBufferType.PRIMARY && !this._isInRenderPass || this._type === CommandBufferType.SECONDARY) {
                  const gpuTexture = texture.gpuTexture;

                  if (gpuTexture) {
                    const cmd = this._cmdAllocator.copyBufferToTextureCmdPool.alloc(WebGL2CmdCopyBufferToTexture);

                    cmd.gpuTexture = gpuTexture;
                    cmd.regions = regions;
                    cmd.buffers = buffers;
                    this.cmdPackage.copyBufferToTextureCmds.push(cmd);
                    this.cmdPackage.cmds.push(WebGL2Cmd.COPY_BUFFER_TO_TEXTURE);
                  }
                } else {
                  console.error('Command \'copyBufferToTexture\' must be recorded outside a render pass.');
                }
              }

              execute(cmdBuffs, count) {
                for (let i = 0; i < count; ++i) {
                  const webGL2CmdBuff = cmdBuffs[i];

                  for (let c = 0; c < webGL2CmdBuff.cmdPackage.beginRenderPassCmds.length; ++c) {
                    const cmd = webGL2CmdBuff.cmdPackage.beginRenderPassCmds.array[c];
                    ++cmd.refCount;
                    this.cmdPackage.beginRenderPassCmds.push(cmd);
                  }

                  for (let c = 0; c < webGL2CmdBuff.cmdPackage.bindStatesCmds.length; ++c) {
                    const cmd = webGL2CmdBuff.cmdPackage.bindStatesCmds.array[c];
                    ++cmd.refCount;
                    this.cmdPackage.bindStatesCmds.push(cmd);
                  }

                  for (let c = 0; c < webGL2CmdBuff.cmdPackage.drawCmds.length; ++c) {
                    const cmd = webGL2CmdBuff.cmdPackage.drawCmds.array[c];
                    ++cmd.refCount;
                    this.cmdPackage.drawCmds.push(cmd);
                  }

                  for (let c = 0; c < webGL2CmdBuff.cmdPackage.updateBufferCmds.length; ++c) {
                    const cmd = webGL2CmdBuff.cmdPackage.updateBufferCmds.array[c];
                    ++cmd.refCount;
                    this.cmdPackage.updateBufferCmds.push(cmd);
                  }

                  for (let c = 0; c < webGL2CmdBuff.cmdPackage.copyBufferToTextureCmds.length; ++c) {
                    const cmd = webGL2CmdBuff.cmdPackage.copyBufferToTextureCmds.array[c];
                    ++cmd.refCount;
                    this.cmdPackage.copyBufferToTextureCmds.push(cmd);
                  }

                  this.cmdPackage.cmds.concat(webGL2CmdBuff.cmdPackage.cmds.array);
                  this._numDrawCalls += webGL2CmdBuff._numDrawCalls;
                  this._numInstances += webGL2CmdBuff._numInstances;
                  this._numTris += webGL2CmdBuff._numTris;
                }
              }

              pipelineBarrier(globalBarrier, textureBarriers, textures) {}

              bindStates() {
                const bindStatesCmd = this._cmdAllocator.bindStatesCmdPool.alloc(WebGL2CmdBindStates);

                bindStatesCmd.gpuPipelineState = this._curGPUPipelineState;
                Array.prototype.push.apply(bindStatesCmd.gpuDescriptorSets, this._curGPUDescriptorSets);
                Array.prototype.push.apply(bindStatesCmd.dynamicOffsets, this._curDynamicOffsets);
                bindStatesCmd.gpuInputAssembler = this._curGPUInputAssembler;
                bindStatesCmd.dynamicStates = this._curDynamicStates;
                this.cmdPackage.bindStatesCmds.push(bindStatesCmd);
                this.cmdPackage.cmds.push(WebGL2Cmd.BIND_STATES);
                this._isStateInvalied = false;
              }

            }

            class WebGL2Framebuffer extends Framebuffer {
              constructor(...args) {
                super(...args);
                this._gpuFramebuffer = null;
              }

              get gpuFramebuffer() {
                return this._gpuFramebuffer;
              }

              initialize(info) {
                this._renderPass = info.renderPass;
                this._colorTextures = info.colorTextures || [];
                this._depthStencilTexture = info.depthStencilTexture || null;
                const gpuColorTextures = [];

                for (let i = 0; i < info.colorTextures.length; i++) {
                  const colorTexture = info.colorTextures[i];

                  if (colorTexture) {
                    gpuColorTextures.push(colorTexture.gpuTexture);
                  }
                }

                let gpuDepthStencilTexture = null;

                if (info.depthStencilTexture) {
                  gpuDepthStencilTexture = info.depthStencilTexture.gpuTexture;
                }

                let width = Number.MAX_SAFE_INTEGER;
                let height = Number.MAX_SAFE_INTEGER;
                this._gpuFramebuffer = {
                  gpuRenderPass: info.renderPass.gpuRenderPass,
                  gpuColorTextures,
                  gpuDepthStencilTexture,
                  glFramebuffer: null,
                  isOffscreen: true,

                  get width() {
                    return this.isOffscreen ? width : this.gpuColorTextures[0].width;
                  },

                  set width(val) {
                    width = val;
                  },

                  get height() {
                    return this.isOffscreen ? height : this.gpuColorTextures[0].height;
                  },

                  set height(val) {
                    height = val;
                  }

                };
                WebGL2CmdFuncCreateFramebuffer(WebGL2DeviceManager.instance, this._gpuFramebuffer);
              }

              destroy() {
                if (this._gpuFramebuffer) {
                  WebGL2CmdFuncDestroyFramebuffer(WebGL2DeviceManager.instance, this._gpuFramebuffer);
                  this._gpuFramebuffer = null;
                }
              }

            }

            class WebGL2InputAssembler extends InputAssembler {
              constructor(...args) {
                super(...args);
                this._gpuInputAssembler = null;
              }

              get gpuInputAssembler() {
                return this._gpuInputAssembler;
              }

              initialize(info) {
                if (info.vertexBuffers.length === 0) {
                  console.error('InputAssemblerInfo.vertexBuffers is null.');
                  return;
                }

                this._attributes = info.attributes;
                this._attributesHash = this.computeAttributesHash();
                this._vertexBuffers = info.vertexBuffers;

                if (info.indexBuffer) {
                  this._indexBuffer = info.indexBuffer;
                  this._drawInfo.indexCount = this._indexBuffer.size / this._indexBuffer.stride;
                  this._drawInfo.firstIndex = 0;
                } else {
                  const vertBuff = this._vertexBuffers[0];
                  this._drawInfo.vertexCount = vertBuff.size / vertBuff.stride;
                  this._drawInfo.firstVertex = 0;
                  this._drawInfo.vertexOffset = 0;
                }

                this._drawInfo.instanceCount = 0;
                this._drawInfo.firstInstance = 0;
                this._indirectBuffer = info.indirectBuffer || null;
                const gpuVertexBuffers = new Array(info.vertexBuffers.length);

                for (let i = 0; i < info.vertexBuffers.length; ++i) {
                  const vb = info.vertexBuffers[i];

                  if (vb.gpuBuffer) {
                    gpuVertexBuffers[i] = vb.gpuBuffer;
                  }
                }

                let gpuIndexBuffer = null;
                let glIndexType = 0;

                if (info.indexBuffer) {
                  gpuIndexBuffer = info.indexBuffer.gpuBuffer;

                  if (gpuIndexBuffer) {
                    switch (gpuIndexBuffer.stride) {
                      case 1:
                        glIndexType = 0x1401;
                        break;

                      case 2:
                        glIndexType = 0x1403;
                        break;

                      case 4:
                        glIndexType = 0x1405;
                        break;

                      default:
                        {
                          console.error('Illegal index buffer stride.');
                        }
                    }
                  }
                }

                let gpuIndirectBuffer = null;

                if (info.indirectBuffer) {
                  gpuIndirectBuffer = info.indirectBuffer.gpuBuffer;
                }

                this._gpuInputAssembler = {
                  attributes: info.attributes,
                  gpuVertexBuffers,
                  gpuIndexBuffer,
                  gpuIndirectBuffer,
                  glAttribs: [],
                  glIndexType,
                  glVAOs: new Map()
                };
                WebGL2CmdFuncCreateInputAssember(WebGL2DeviceManager.instance, this._gpuInputAssembler);
              }

              destroy() {
                const device = WebGL2DeviceManager.instance;

                if (this._gpuInputAssembler && device.extensions.useVAO) {
                  WebGL2CmdFuncDestroyInputAssembler(device, this._gpuInputAssembler);
                }

                this._gpuInputAssembler = null;
              }

            }

            class WebGL2DescriptorSetLayout extends DescriptorSetLayout {
              constructor(...args) {
                super(...args);
                this._gpuDescriptorSetLayout = null;
              }

              get gpuDescriptorSetLayout() {
                return this._gpuDescriptorSetLayout;
              }

              initialize(info) {
                Array.prototype.push.apply(this._bindings, info.bindings);
                let descriptorCount = 0;
                let maxBinding = -1;
                const flattenedIndices = [];

                for (let i = 0; i < this._bindings.length; i++) {
                  const binding = this._bindings[i];
                  flattenedIndices.push(descriptorCount);
                  descriptorCount += binding.count;
                  if (binding.binding > maxBinding) maxBinding = binding.binding;
                }

                this._bindingIndices = Array(maxBinding + 1).fill(-1);
                const descriptorIndices = this._descriptorIndices = Array(maxBinding + 1).fill(-1);

                for (let i = 0; i < this._bindings.length; i++) {
                  const binding = this._bindings[i];
                  this._bindingIndices[binding.binding] = i;
                  descriptorIndices[binding.binding] = flattenedIndices[i];
                }

                const dynamicBindings = [];

                for (let i = 0; i < this._bindings.length; i++) {
                  const binding = this._bindings[i];

                  if (binding.descriptorType & DESCRIPTOR_DYNAMIC_TYPE) {
                    for (let j = 0; j < binding.count; j++) {
                      dynamicBindings.push(binding.binding);
                    }
                  }
                }

                this._gpuDescriptorSetLayout = {
                  bindings: this._bindings,
                  dynamicBindings,
                  descriptorIndices,
                  descriptorCount
                };
              }

              destroy() {
                this._bindings.length = 0;
              }

            }

            class WebGL2PipelineLayout extends PipelineLayout {
              constructor(...args) {
                super(...args);
                this._gpuPipelineLayout = null;
              }

              get gpuPipelineLayout() {
                return this._gpuPipelineLayout;
              }

              initialize(info) {
                Array.prototype.push.apply(this._setLayouts, info.setLayouts);
                const dynamicOffsetIndices = [];
                const gpuSetLayouts = [];
                let dynamicOffsetCount = 0;
                const dynamicOffsetOffsets = [];

                for (let i = 0; i < this._setLayouts.length; i++) {
                  const setLayout = this._setLayouts[i];
                  const dynamicBindings = setLayout.gpuDescriptorSetLayout.dynamicBindings;
                  const indices = Array(setLayout.bindingIndices.length).fill(-1);

                  for (let j = 0; j < dynamicBindings.length; j++) {
                    const binding = dynamicBindings[j];
                    if (indices[binding] < 0) indices[binding] = dynamicOffsetCount + j;
                  }

                  gpuSetLayouts.push(setLayout.gpuDescriptorSetLayout);
                  dynamicOffsetIndices.push(indices);
                  dynamicOffsetOffsets.push(dynamicOffsetCount);
                  dynamicOffsetCount += dynamicBindings.length;
                }

                this._gpuPipelineLayout = {
                  gpuSetLayouts,
                  dynamicOffsetIndices,
                  dynamicOffsetCount,
                  dynamicOffsetOffsets
                };
              }

              destroy() {
                this._setLayouts.length = 0;
              }

            }

            const WebGLPrimitives$1 = [0x0000, 0x0001, 0x0003, 0x0002, 0x0000, 0x0000, 0x0000, 0x0004, 0x0005, 0x0006, 0x0000, 0x0000, 0x0000, 0x0000];
            class WebGL2PipelineState extends PipelineState {
              constructor(...args) {
                super(...args);
                this._gpuPipelineState = null;
              }

              get gpuPipelineState() {
                return this._gpuPipelineState;
              }

              initialize(info) {
                this._primitive = info.primitive;
                this._shader = info.shader;
                this._pipelineLayout = info.pipelineLayout;
                const bs = this._bs;

                if (info.blendState) {
                  const bsInfo = info.blendState;
                  const {
                    targets
                  } = bsInfo;

                  if (targets) {
                    targets.forEach((t, i) => {
                      bs.setTarget(i, t);
                    });
                  }

                  if (bsInfo.isA2C !== undefined) {
                    bs.isA2C = bsInfo.isA2C;
                  }

                  if (bsInfo.isIndepend !== undefined) {
                    bs.isIndepend = bsInfo.isIndepend;
                  }

                  if (bsInfo.blendColor !== undefined) {
                    bs.blendColor = bsInfo.blendColor;
                  }
                }

                Object.assign(this._rs, info.rasterizerState);
                Object.assign(this._dss, info.depthStencilState);
                this._is = info.inputState;
                this._renderPass = info.renderPass;
                this._dynamicStates = info.dynamicStates;
                const dynamicStates = [];

                for (let i = 0; i < 31; i++) {
                  if (this._dynamicStates & 1 << i) {
                    dynamicStates.push(1 << i);
                  }
                }

                this._gpuPipelineState = {
                  glPrimitive: WebGLPrimitives$1[info.primitive],
                  gpuShader: info.shader.gpuShader,
                  gpuPipelineLayout: info.pipelineLayout.gpuPipelineLayout,
                  rs: info.rasterizerState,
                  dss: info.depthStencilState,
                  bs: info.blendState,
                  gpuRenderPass: info.renderPass.gpuRenderPass,
                  dynamicStates
                };
              }

              destroy() {
                this._gpuPipelineState = null;
              }

            }

            class WebGL2PrimaryCommandBuffer extends WebGL2CommandBuffer {
              beginRenderPass(renderPass, framebuffer, renderArea, clearColors, clearDepth, clearStencil) {
                WebGL2CmdFuncBeginRenderPass(WebGL2DeviceManager.instance, renderPass.gpuRenderPass, framebuffer.gpuFramebuffer, renderArea, clearColors, clearDepth, clearStencil);
                this._isInRenderPass = true;
              }

              draw(infoOrAssembler) {
                if (this._isInRenderPass) {
                  if (this._isStateInvalied) {
                    this.bindStates();
                  }

                  const info = 'drawInfo' in infoOrAssembler ? infoOrAssembler.drawInfo : infoOrAssembler;
                  WebGL2CmdFuncDraw(WebGL2DeviceManager.instance, info);
                  ++this._numDrawCalls;
                  this._numInstances += info.instanceCount;
                  const indexCount = info.indexCount || info.vertexCount;

                  if (this._curGPUPipelineState) {
                    const glPrimitive = this._curGPUPipelineState.glPrimitive;

                    switch (glPrimitive) {
                      case 0x0004:
                        {
                          this._numTris += indexCount / 3 * Math.max(info.instanceCount, 1);
                          break;
                        }

                      case 0x0005:
                      case 0x0006:
                        {
                          this._numTris += (indexCount - 2) * Math.max(info.instanceCount, 1);
                          break;
                        }
                    }
                  }
                } else {
                  console.error('Command \'draw\' must be recorded inside a render pass.');
                }
              }

              setViewport(viewport) {
                const {
                  stateCache: cache,
                  gl
                } = WebGL2DeviceManager.instance;

                if (cache.viewport.left !== viewport.left || cache.viewport.top !== viewport.top || cache.viewport.width !== viewport.width || cache.viewport.height !== viewport.height) {
                  gl.viewport(viewport.left, viewport.top, viewport.width, viewport.height);
                  cache.viewport.left = viewport.left;
                  cache.viewport.top = viewport.top;
                  cache.viewport.width = viewport.width;
                  cache.viewport.height = viewport.height;
                }
              }

              setScissor(scissor) {
                const {
                  stateCache: cache,
                  gl
                } = WebGL2DeviceManager.instance;

                if (cache.scissorRect.x !== scissor.x || cache.scissorRect.y !== scissor.y || cache.scissorRect.width !== scissor.width || cache.scissorRect.height !== scissor.height) {
                  gl.scissor(scissor.x, scissor.y, scissor.width, scissor.height);
                  cache.scissorRect.x = scissor.x;
                  cache.scissorRect.y = scissor.y;
                  cache.scissorRect.width = scissor.width;
                  cache.scissorRect.height = scissor.height;
                }
              }

              updateBuffer(buffer, data, size) {
                if (!this._isInRenderPass) {
                  const gpuBuffer = buffer.gpuBuffer;

                  if (gpuBuffer) {
                    let buffSize;

                    if (size !== undefined) {
                      buffSize = size;
                    } else if (buffer.usage & BufferUsageBit.INDIRECT) {
                      buffSize = 0;
                    } else {
                      buffSize = data.byteLength;
                    }

                    WebGL2CmdFuncUpdateBuffer(WebGL2DeviceManager.instance, gpuBuffer, data, 0, buffSize);
                  }
                } else {
                  console.error('Command \'updateBuffer\' must be recorded outside a render pass.');
                }
              }

              copyBuffersToTexture(buffers, texture, regions) {
                if (!this._isInRenderPass) {
                  const gpuTexture = texture.gpuTexture;

                  if (gpuTexture) {
                    WebGL2CmdFuncCopyBuffersToTexture(WebGL2DeviceManager.instance, buffers, gpuTexture, regions);
                  }
                } else {
                  console.error('Command \'copyBufferToTexture\' must be recorded outside a render pass.');
                }
              }

              execute(cmdBuffs, count) {
                for (let i = 0; i < count; ++i) {
                  const webGL2CmdBuff = cmdBuffs[i];
                  WebGL2CmdFuncExecuteCmds(WebGL2DeviceManager.instance, webGL2CmdBuff.cmdPackage);
                  this._numDrawCalls += webGL2CmdBuff._numDrawCalls;
                  this._numInstances += webGL2CmdBuff._numInstances;
                  this._numTris += webGL2CmdBuff._numTris;
                }
              }

              bindStates() {
                WebGL2CmdFuncBindStates(WebGL2DeviceManager.instance, this._curGPUPipelineState, this._curGPUInputAssembler, this._curGPUDescriptorSets, this._curDynamicOffsets, this._curDynamicStates);
                this._isStateInvalied = false;
              }

            }

            class WebGL2Queue extends Queue {
              constructor(...args) {
                super(...args);
                this.numDrawCalls = 0;
                this.numInstances = 0;
                this.numTris = 0;
              }

              initialize(info) {
                this._type = info.type;
              }

              destroy() {}

              submit(cmdBuffs) {
                for (let i = 0; i < cmdBuffs.length; i++) {
                  const cmdBuff = cmdBuffs[i];
                  this.numDrawCalls += cmdBuff.numDrawCalls;
                  this.numInstances += cmdBuff.numInstances;
                  this.numTris += cmdBuff.numTris;
                }
              }

              clear() {
                this.numDrawCalls = 0;
                this.numInstances = 0;
                this.numTris = 0;
              }

            }

            class WebGL2RenderPass extends RenderPass {
              constructor(...args) {
                super(...args);
                this._gpuRenderPass = null;
              }

              get gpuRenderPass() {
                return this._gpuRenderPass;
              }

              initialize(info) {
                this._colorInfos = info.colorAttachments;
                this._depthStencilInfo = info.depthStencilAttachment;
                this._subpasses = info.subpasses;
                this._gpuRenderPass = {
                  colorAttachments: this._colorInfos,
                  depthStencilAttachment: this._depthStencilInfo
                };
                this._hash = this.computeHash();
              }

              destroy() {
                this._gpuRenderPass = null;
              }

            }

            class WebGL2Sampler extends Sampler {
              get gpuSampler() {
                return this._gpuSampler;
              }

              constructor(info, hash) {
                super(info, hash);
                this._gpuSampler = null;
                this._gpuSampler = {
                  glSampler: null,
                  minFilter: this._info.minFilter,
                  magFilter: this._info.magFilter,
                  mipFilter: this._info.mipFilter,
                  addressU: this._info.addressU,
                  addressV: this._info.addressV,
                  addressW: this._info.addressW,
                  glMinFilter: 0,
                  glMagFilter: 0,
                  glWrapS: 0,
                  glWrapT: 0,
                  glWrapR: 0
                };
                WebGL2CmdFuncCreateSampler(WebGL2DeviceManager.instance, this._gpuSampler);
              }

              destroy() {
                if (this._gpuSampler) {
                  WebGL2CmdFuncDestroySampler(WebGL2DeviceManager.instance, this._gpuSampler);
                  this._gpuSampler = null;
                }
              }

            }

            class WebGL2Shader extends Shader {
              constructor(...args) {
                super(...args);
                this._gpuShader = null;
              }

              get gpuShader() {
                return this._gpuShader;
              }

              initialize(info) {
                this._name = info.name;
                this._stages = info.stages;
                this._attributes = info.attributes;
                this._blocks = info.blocks;
                this._samplers = info.samplers;
                this._gpuShader = {
                  name: info.name,
                  blocks: info.blocks.slice(),
                  samplerTextures: info.samplerTextures.slice(),
                  subpassInputs: info.subpassInputs.slice(),
                  gpuStages: new Array(info.stages.length),
                  glProgram: null,
                  glInputs: [],
                  glUniforms: [],
                  glBlocks: [],
                  glSamplerTextures: []
                };

                for (let i = 0; i < info.stages.length; ++i) {
                  const stage = info.stages[i];
                  this._gpuShader.gpuStages[i] = {
                    type: stage.stage,
                    source: stage.source,
                    glShader: null
                  };
                }

                WebGL2CmdFuncCreateShader(WebGL2DeviceManager.instance, this._gpuShader);
              }

              destroy() {
                if (this._gpuShader) {
                  WebGL2CmdFuncDestroyShader(WebGL2DeviceManager.instance, this._gpuShader);
                  this._gpuShader = null;
                }
              }

            }

            class WebGL2StateCache {
              constructor() {
                this.glArrayBuffer = null;
                this.glElementArrayBuffer = null;
                this.glUniformBuffer = null;
                this.glBindUBOs = [];
                this.glBindUBOOffsets = [];
                this.glVAO = null;
                this.texUnit = 0;
                this.glTexUnits = [];
                this.glSamplerUnits = [];
                this.glRenderbuffer = null;
                this.glFramebuffer = null;
                this.glReadFramebuffer = null;
                this.viewport = new Viewport();
                this.scissorRect = new Rect(0, 0, 0, 0);
                this.rs = new RasterizerState();
                this.dss = new DepthStencilState();
                this.bs = new BlendState();
                this.glProgram = null;
                this.glEnabledAttribLocs = [];
                this.glCurrentAttribLocs = [];
                this.texUnitCacheMap = {};
              }

              initialize(texUnit, bufferBindings, vertexAttributes) {
                for (let i = 0; i < texUnit; ++i) this.glTexUnits.push({
                  glTexture: null
                });

                this.glSamplerUnits.length = texUnit;
                this.glSamplerUnits.fill(null);
                this.glBindUBOs.length = bufferBindings;
                this.glBindUBOs.fill(null);
                this.glBindUBOOffsets.length = bufferBindings;
                this.glBindUBOOffsets.fill(0);
                this.glEnabledAttribLocs.length = vertexAttributes;
                this.glEnabledAttribLocs.fill(false);
                this.glCurrentAttribLocs.length = vertexAttributes;
                this.glCurrentAttribLocs.fill(false);
              }

            }

            class WebGL2Texture extends Texture {
              constructor(...args) {
                super(...args);
                this._gpuTexture = null;
              }

              get gpuTexture() {
                return this._gpuTexture;
              }

              initialize(info, isSwapchainTexture) {
                if ('texture' in info) {
                  console.log('WebGL2 does not support texture view.');
                  return;
                }

                this._type = info.type;
                this._usage = info.usage;
                this._format = info.format;
                this._width = info.width;
                this._height = info.height;
                this._depth = info.depth;
                this._layerCount = info.layerCount;
                this._levelCount = info.levelCount;
                this._samples = info.samples;
                this._flags = info.flags;
                this._isPowerOf2 = IsPowerOf2(this._width) && IsPowerOf2(this._height);
                this._size = FormatSurfaceSize(this._format, this.width, this.height, this.depth, this._levelCount) * this._layerCount;
                this._gpuTexture = {
                  type: this._type,
                  format: this._format,
                  usage: this._usage,
                  width: this._width,
                  height: this._height,
                  depth: this._depth,
                  size: this._size,
                  arrayLayer: this._layerCount,
                  mipLevel: this._levelCount,
                  samples: this._samples,
                  flags: this._flags,
                  isPowerOf2: this._isPowerOf2,
                  glTarget: 0,
                  glInternalFmt: 0,
                  glFormat: 0,
                  glType: 0,
                  glUsage: 0,
                  glTexture: null,
                  glRenderbuffer: null,
                  glWrapS: 0,
                  glWrapT: 0,
                  glMinFilter: 0,
                  glMagFilter: 0,
                  isSwapchainTexture: isSwapchainTexture || false
                };
                WebGL2CmdFuncCreateTexture(WebGL2DeviceManager.instance, this._gpuTexture);
                WebGL2DeviceManager.instance.memoryStatus.textureSize += this._size;
              }

              destroy() {
                if (this._gpuTexture) {
                  WebGL2CmdFuncDestroyTexture(WebGL2DeviceManager.instance, this._gpuTexture);
                  WebGL2DeviceManager.instance.memoryStatus.textureSize -= this._size;
                  this._gpuTexture = null;
                }
              }

              resize(width, height) {
                const oldSize = this._size;
                this._width = width;
                this._height = height;
                this._size = FormatSurfaceSize(this._format, this.width, this.height, this.depth, this._levelCount) * this._layerCount;

                if (this._gpuTexture) {
                  this._gpuTexture.width = width;
                  this._gpuTexture.height = height;
                  this._gpuTexture.size = this._size;
                  WebGL2CmdFuncResizeTexture(WebGL2DeviceManager.instance, this._gpuTexture);
                  WebGL2DeviceManager.instance.memoryStatus.textureSize -= oldSize;
                  WebGL2DeviceManager.instance.memoryStatus.textureSize += this._size;
                }
              }

              initAsSwapchainTexture(info) {
                const texInfo = new TextureInfo();
                texInfo.format = info.format;
                texInfo.usage = FormatInfos[info.format].hasDepth ? TextureUsageBit.DEPTH_STENCIL_ATTACHMENT : TextureUsageBit.COLOR_ATTACHMENT;
                texInfo.width = info.width;
                texInfo.height = info.height;
                this.initialize(texInfo, true);
              }

            }

            const eventWebGLContextLost$1 = 'webglcontextlost';

            function initStates$1(gl) {
              gl.activeTexture(gl.TEXTURE0);
              gl.pixelStorei(gl.PACK_ALIGNMENT, 1);
              gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
              gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
              gl.enable(gl.SCISSOR_TEST);
              gl.enable(gl.CULL_FACE);
              gl.cullFace(gl.BACK);
              gl.frontFace(gl.CCW);
              gl.polygonOffset(0.0, 0.0);
              gl.enable(gl.DEPTH_TEST);
              gl.depthMask(true);
              gl.depthFunc(gl.LESS);
              gl.stencilFuncSeparate(gl.FRONT, gl.ALWAYS, 1, 0xffff);
              gl.stencilOpSeparate(gl.FRONT, gl.KEEP, gl.KEEP, gl.KEEP);
              gl.stencilMaskSeparate(gl.FRONT, 0xffff);
              gl.stencilFuncSeparate(gl.BACK, gl.ALWAYS, 1, 0xffff);
              gl.stencilOpSeparate(gl.BACK, gl.KEEP, gl.KEEP, gl.KEEP);
              gl.stencilMaskSeparate(gl.BACK, 0xffff);
              gl.disable(gl.STENCIL_TEST);
              gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
              gl.disable(gl.BLEND);
              gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
              gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
              gl.colorMask(true, true, true, true);
              gl.blendColor(0.0, 0.0, 0.0, 0.0);
            }

            function getExtension$1(gl, ext) {
              const prefixes = ['', 'WEBKIT_', 'MOZ_'];

              for (let i = 0; i < prefixes.length; ++i) {
                const _ext = gl.getExtension(prefixes[i] + ext);

                if (_ext) {
                  return _ext;
                }
              }

              return null;
            }

            function getExtensions$1(gl) {
              const res = {
                EXT_texture_filter_anisotropic: getExtension$1(gl, 'EXT_texture_filter_anisotropic'),
                EXT_color_buffer_half_float: getExtension$1(gl, 'EXT_color_buffer_half_float'),
                EXT_color_buffer_float: getExtension$1(gl, 'EXT_color_buffer_float'),
                WEBGL_compressed_texture_etc1: getExtension$1(gl, 'WEBGL_compressed_texture_etc1'),
                WEBGL_compressed_texture_etc: getExtension$1(gl, 'WEBGL_compressed_texture_etc'),
                WEBGL_compressed_texture_pvrtc: getExtension$1(gl, 'WEBGL_compressed_texture_pvrtc'),
                WEBGL_compressed_texture_astc: getExtension$1(gl, 'WEBGL_compressed_texture_astc'),
                WEBGL_compressed_texture_s3tc: getExtension$1(gl, 'WEBGL_compressed_texture_s3tc'),
                WEBGL_compressed_texture_s3tc_srgb: getExtension$1(gl, 'WEBGL_compressed_texture_s3tc_srgb'),
                WEBGL_debug_shaders: getExtension$1(gl, 'WEBGL_debug_shaders'),
                WEBGL_lose_context: getExtension$1(gl, 'WEBGL_lose_context'),
                WEBGL_debug_renderer_info: getExtension$1(gl, 'WEBGL_debug_renderer_info'),
                OES_texture_half_float_linear: getExtension$1(gl, 'OES_texture_half_float_linear'),
                OES_texture_float_linear: getExtension$1(gl, 'OES_texture_float_linear'),
                WEBGL_multi_draw: null,
                useVAO: true
              };
              {
                if (systemInfo.os !== OS.ANDROID && systemInfo.os !== OS.IOS) {
                  res.WEBGL_multi_draw = getExtension$1(gl, 'WEBGL_multi_draw');
                }
              }
              return res;
            }
            function getContext$1(canvas) {
              let context = null;

              try {
                const webGLCtxAttribs = {
                  alpha: macro.ENABLE_TRANSPARENT_CANVAS,
                  antialias: EDITOR || macro.ENABLE_WEBGL_ANTIALIAS,
                  depth: true,
                  stencil: true,
                  premultipliedAlpha: false,
                  preserveDrawingBuffer: false,
                  powerPreference: 'default',
                  failIfMajorPerformanceCaveat: false
                };
                context = canvas.getContext('webgl2', webGLCtxAttribs);
              } catch (err) {
                return null;
              }

              return context;
            }
            class WebGL2Swapchain extends Swapchain {
              constructor(...args) {
                super(...args);
                this.stateCache = new WebGL2StateCache();
                this.nullTex2D = null;
                this.nullTexCube = null;
                this._canvas = null;
                this._webGL2ContextLostHandler = null;
                this._extensions = null;
              }

              get extensions() {
                return this._extensions;
              }

              initialize(info) {
                this._canvas = info.windowHandle;
                this._webGL2ContextLostHandler = this._onWebGLContextLost.bind(this);

                this._canvas.addEventListener(eventWebGLContextLost$1, this._onWebGLContextLost);

                const gl = WebGL2DeviceManager.instance.gl;
                this.stateCache.initialize(WebGL2DeviceManager.instance.capabilities.maxTextureUnits, WebGL2DeviceManager.instance.capabilities.maxUniformBufferBindings, WebGL2DeviceManager.instance.capabilities.maxVertexAttributes);
                this._extensions = getExtensions$1(gl);
                initStates$1(gl);
                const colorFmt = Format.RGBA8;
                let depthStencilFmt = Format.DEPTH_STENCIL;
                const depthBits = gl.getParameter(gl.DEPTH_BITS);
                const stencilBits = gl.getParameter(gl.STENCIL_BITS);
                if (depthBits && stencilBits) depthStencilFmt = Format.DEPTH_STENCIL;else if (depthBits) depthStencilFmt = Format.DEPTH;
                this._colorTexture = new WebGL2Texture();

                this._colorTexture.initAsSwapchainTexture({
                  swapchain: this,
                  format: colorFmt,
                  width: info.width,
                  height: info.height
                });

                this._depthStencilTexture = new WebGL2Texture();

                this._depthStencilTexture.initAsSwapchainTexture({
                  swapchain: this,
                  format: depthStencilFmt,
                  width: info.width,
                  height: info.height
                });

                this.nullTex2D = WebGL2DeviceManager.instance.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.SAMPLED, Format.RGBA8, 2, 2, TextureFlagBit.NONE));
                this.nullTexCube = WebGL2DeviceManager.instance.createTexture(new TextureInfo(TextureType.CUBE, TextureUsageBit.SAMPLED, Format.RGBA8, 2, 2, TextureFlagBit.NONE, 6));
                const nullTexRegion = new BufferTextureCopy();
                nullTexRegion.texExtent.width = 2;
                nullTexRegion.texExtent.height = 2;
                const nullTexBuff = new Uint8Array(this.nullTex2D.size);
                nullTexBuff.fill(0);
                WebGL2DeviceManager.instance.copyBuffersToTexture([nullTexBuff], this.nullTex2D, [nullTexRegion]);
                nullTexRegion.texSubres.layerCount = 6;
                WebGL2DeviceManager.instance.copyBuffersToTexture([nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff], this.nullTexCube, [nullTexRegion]);
              }

              destroy() {
                if (this._canvas && this._webGL2ContextLostHandler) {
                  this._canvas.removeEventListener(eventWebGLContextLost$1, this._webGL2ContextLostHandler);

                  this._webGL2ContextLostHandler = null;
                }

                if (this.nullTex2D) {
                  this.nullTex2D.destroy();
                  this.nullTex2D = null;
                }

                if (this.nullTexCube) {
                  this.nullTexCube.destroy();
                  this.nullTexCube = null;
                }

                this._extensions = null;
                this._canvas = null;
              }

              resize(width, height, surfaceTransform) {
                if (this._colorTexture.width !== width || this._colorTexture.height !== height) {
                  debug(`Resizing swapchain: ${width}x${height}`);
                  this._canvas.width = width;
                  this._canvas.height = height;

                  this._colorTexture.resize(width, height);

                  this._depthStencilTexture.resize(width, height);
                }
              }

              _onWebGLContextLost(event) {
                warnID(11000);
                warn(event);
              }

            }

            class WebGL2Device extends Device {
              constructor(...args) {
                super(...args);
                this._swapchain = null;
                this._context = null;
              }

              get gl() {
                return this._context;
              }

              get extensions() {
                return this._swapchain.extensions;
              }

              get stateCache() {
                return this._swapchain.stateCache;
              }

              get nullTex2D() {
                return this._swapchain.nullTex2D;
              }

              get nullTexCube() {
                return this._swapchain.nullTexCube;
              }

              initialize(info) {
                WebGL2DeviceManager.setInstance(this);
                this._gfxAPI = API.WEBGL2;
                this._bindingMappingInfo = info.bindingMappingInfo;
                if (!this._bindingMappingInfo.bufferOffsets.length) this._bindingMappingInfo.bufferOffsets.push(0);
                if (!this._bindingMappingInfo.samplerOffsets.length) this._bindingMappingInfo.samplerOffsets.push(0);
                const gl = this._context = getContext$1(Device.canvas);

                if (!gl) {
                  console.error('This device does not support WebGL.');
                  return false;
                }

                this._queue = this.createQueue(new QueueInfo(QueueType.GRAPHICS));
                this._cmdBuff = this.createCommandBuffer(new CommandBufferInfo(this._queue));
                this._caps.maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
                this._caps.maxVertexUniformVectors = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
                this._caps.maxFragmentUniformVectors = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
                this._caps.maxTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
                this._caps.maxVertexTextureUnits = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
                this._caps.maxUniformBufferBindings = gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS);
                this._caps.maxUniformBlockSize = gl.getParameter(gl.MAX_UNIFORM_BLOCK_SIZE);
                this._caps.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
                this._caps.maxCubeMapTextureSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
                this._caps.uboOffsetAlignment = gl.getParameter(gl.UNIFORM_BUFFER_OFFSET_ALIGNMENT);
                const extensions = gl.getSupportedExtensions();
                let extStr = '';

                if (extensions) {
                  for (const ext of extensions) {
                    extStr += `${ext} `;
                  }
                }

                const exts = getExtensions$1(gl);

                if (exts.WEBGL_debug_renderer_info) {
                  this._renderer = gl.getParameter(exts.WEBGL_debug_renderer_info.UNMASKED_RENDERER_WEBGL);
                  this._vendor = gl.getParameter(exts.WEBGL_debug_renderer_info.UNMASKED_VENDOR_WEBGL);
                } else {
                  this._renderer = gl.getParameter(gl.RENDERER);
                  this._vendor = gl.getParameter(gl.VENDOR);
                }

                const version = gl.getParameter(gl.VERSION);

                this._features.fill(false);

                this._features[Feature.TEXTURE_FLOAT] = true;
                this._features[Feature.TEXTURE_HALF_FLOAT] = true;
                this._features[Feature.FORMAT_R11G11B10F] = true;
                this._features[Feature.FORMAT_SRGB] = true;
                this._features[Feature.FORMAT_RGB8] = true;
                this._features[Feature.ELEMENT_INDEX_UINT] = true;
                this._features[Feature.INSTANCED_ARRAYS] = true;
                this._features[Feature.MULTIPLE_RENDER_TARGETS] = true;
                this._features[Feature.BLEND_MINMAX] = true;

                if (exts.EXT_color_buffer_float) {
                  this._features[Feature.COLOR_FLOAT] = true;
                  this._features[Feature.COLOR_HALF_FLOAT] = true;
                }

                if (exts.OES_texture_float_linear) {
                  this._features[Feature.TEXTURE_FLOAT_LINEAR] = true;
                }

                if (exts.OES_texture_half_float_linear) {
                  this._features[Feature.TEXTURE_HALF_FLOAT_LINEAR] = true;
                }

                let compressedFormat = '';

                if (exts.WEBGL_compressed_texture_etc1) {
                  this._features[Feature.FORMAT_ETC1] = true;
                  compressedFormat += 'etc1 ';
                }

                if (exts.WEBGL_compressed_texture_etc) {
                  this._features[Feature.FORMAT_ETC2] = true;
                  compressedFormat += 'etc2 ';
                }

                if (exts.WEBGL_compressed_texture_s3tc) {
                  this._features[Feature.FORMAT_DXT] = true;
                  compressedFormat += 'dxt ';
                }

                if (exts.WEBGL_compressed_texture_pvrtc) {
                  this._features[Feature.FORMAT_PVRTC] = true;
                  compressedFormat += 'pvrtc ';
                }

                if (exts.WEBGL_compressed_texture_astc) {
                  this._features[Feature.FORMAT_ASTC] = true;
                  compressedFormat += 'astc ';
                }

                debug('WebGL2 device initialized.');
                debug(`RENDERER: ${this._renderer}`);
                debug(`VENDOR: ${this._vendor}`);
                debug(`VERSION: ${version}`);
                debug(`COMPRESSED_FORMAT: ${compressedFormat}`);
                debug(`EXTENSIONS: ${extStr}`);
                return true;
              }

              destroy() {
                if (this._queue) {
                  this._queue.destroy();

                  this._queue = null;
                }

                if (this._cmdBuff) {
                  this._cmdBuff.destroy();

                  this._cmdBuff = null;
                }

                const it = this._samplers.values();

                let res = it.next();

                while (!res.done) {
                  res.value.destroy();
                  res = it.next();
                }

                this._swapchain = null;
              }

              flushCommands(cmdBuffs) {}

              acquire(swapchains) {}

              present() {
                const queue = this._queue;
                this._numDrawCalls = queue.numDrawCalls;
                this._numInstances = queue.numInstances;
                this._numTris = queue.numTris;
                queue.clear();
              }

              createCommandBuffer(info) {
                const Ctor = info.type === CommandBufferType.PRIMARY ? WebGL2PrimaryCommandBuffer : WebGL2CommandBuffer;
                const cmdBuff = new Ctor();
                cmdBuff.initialize(info);
                return cmdBuff;
              }

              createSwapchain(info) {
                const swapchain = new WebGL2Swapchain();
                this._swapchain = swapchain;
                swapchain.initialize(info);
                return swapchain;
              }

              createBuffer(info) {
                const buffer = new WebGL2Buffer();
                buffer.initialize(info);
                return buffer;
              }

              createTexture(info) {
                const texture = new WebGL2Texture();
                texture.initialize(info);
                return texture;
              }

              createDescriptorSet(info) {
                const descriptorSet = new WebGL2DescriptorSet();
                descriptorSet.initialize(info);
                return descriptorSet;
              }

              createShader(info) {
                const shader = new WebGL2Shader();
                shader.initialize(info);
                return shader;
              }

              createInputAssembler(info) {
                const inputAssembler = new WebGL2InputAssembler();
                inputAssembler.initialize(info);
                return inputAssembler;
              }

              createRenderPass(info) {
                const renderPass = new WebGL2RenderPass();
                renderPass.initialize(info);
                return renderPass;
              }

              createFramebuffer(info) {
                const framebuffer = new WebGL2Framebuffer();
                framebuffer.initialize(info);
                return framebuffer;
              }

              createDescriptorSetLayout(info) {
                const descriptorSetLayout = new WebGL2DescriptorSetLayout();
                descriptorSetLayout.initialize(info);
                return descriptorSetLayout;
              }

              createPipelineLayout(info) {
                const pipelineLayout = new WebGL2PipelineLayout();
                pipelineLayout.initialize(info);
                return pipelineLayout;
              }

              createPipelineState(info) {
                const pipelineState = new WebGL2PipelineState();
                pipelineState.initialize(info);
                return pipelineState;
              }

              createQueue(info) {
                const queue = new WebGL2Queue();
                queue.initialize(info);
                return queue;
              }

              getSampler(info) {
                const hash = Sampler.computeHash(info);

                if (!this._samplers.has(hash)) {
                  this._samplers.set(hash, new WebGL2Sampler(info, hash));
                }

                return this._samplers.get(hash);
              }

              getGlobalBarrier(info) {
                const hash = GlobalBarrier.computeHash(info);

                if (!this._globalBarriers.has(hash)) {
                  this._globalBarriers.set(hash, new GlobalBarrier(info, hash));
                }

                return this._globalBarriers.get(hash);
              }

              getTextureBarrier(info) {
                const hash = TextureBarrier.computeHash(info);

                if (!this._textureBarriers.has(hash)) {
                  this._textureBarriers.set(hash, new TextureBarrier(info, hash));
                }

                return this._textureBarriers.get(hash);
              }

              copyBuffersToTexture(buffers, texture, regions) {
                WebGL2CmdFuncCopyBuffersToTexture(this, buffers, texture.gpuTexture, regions);
              }

              copyTextureToBuffers(texture, buffers, regions) {
                WebGL2CmdFuncCopyTextureToBuffers(this, texture.gpuTexture, buffers, regions);
              }

              copyTexImagesToTexture(texImages, texture, regions) {
                WebGL2CmdFuncCopyTexImagesToTexture(this, texImages, texture.gpuTexture, regions);
              }

            } exports('WebGL2Device', WebGL2Device);

            legacyCC.WebGL2Device = WebGL2Device;

            function toPPM(buffer, w, h) {
              return `P3 ${w} ${h} 255\n${buffer.filter((e, i) => i % 4 < 3).toString()}\n`;
            }

            var _keyMap;

            (function (_keyMap) {
              _keyMap[_keyMap["positions"] = AttributeName.ATTR_POSITION] = "positions";
              _keyMap[_keyMap["normals"] = AttributeName.ATTR_NORMAL] = "normals";
              _keyMap[_keyMap["uvs"] = AttributeName.ATTR_TEX_COORD] = "uvs";
              _keyMap[_keyMap["colors"] = AttributeName.ATTR_COLOR] = "colors";
            })(_keyMap || (_keyMap = {}));

            function readMesh(mesh, iPrimitive = 0) {
              const out = {
                positions: []
              };
              const dataView = new DataView(mesh.data.buffer, mesh.data.byteOffset, mesh.data.byteLength);
              const struct = mesh.struct;
              const primitive = struct.primitives[iPrimitive];

              for (const idx of primitive.vertexBundelIndices) {
                const bundle = struct.vertexBundles[idx];
                let offset = bundle.view.offset;
                const {
                  length,
                  stride
                } = bundle.view;

                for (const attr of bundle.attributes) {
                  const name = _keyMap[attr.name];

                  if (name) {
                    out[name] = (out[name] || []).concat(readBuffer(dataView, attr.format, offset, length, stride));
                  }

                  offset += FormatInfos[attr.format].size;
                }
              }

              const view = primitive.indexView;
              out.indices = readBuffer(dataView, Format[`R${view.stride * 8}UI`], view.offset, view.length);
              return out;
            }

            const _defAttrs = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_NORMAL, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F), new Attribute(AttributeName.ATTR_TANGENT, Format.RGBA32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA32F)];
            const v3_1 = new Vec3();
            function createMesh(geometry, out, options) {
              options = options || {};
              const attributes = [];
              let stride = 0;
              const channels = [];
              let vertCount = 0;
              let attr;
              const positions = geometry.positions.slice();

              if (positions.length > 0) {
                attr = null;

                if (geometry.attributes) {
                  for (const att of geometry.attributes) {
                    if (att.name === AttributeName.ATTR_POSITION) {
                      attr = att;
                      break;
                    }
                  }
                }

                if (!attr) {
                  attr = _defAttrs[0];
                }

                attributes.push(attr);
                const info = FormatInfos[attr.format];
                vertCount = Math.max(vertCount, Math.floor(positions.length / info.count));
                channels.push({
                  offset: stride,
                  data: positions,
                  attribute: attr
                });
                stride += info.size;
              }

              if (geometry.normals && geometry.normals.length > 0) {
                attr = null;

                if (geometry.attributes) {
                  for (const att of geometry.attributes) {
                    if (att.name === AttributeName.ATTR_NORMAL) {
                      attr = att;
                      break;
                    }
                  }
                }

                if (!attr) {
                  attr = _defAttrs[1];
                }

                const info = FormatInfos[attr.format];
                attributes.push(attr);
                vertCount = Math.max(vertCount, Math.floor(geometry.normals.length / info.count));
                channels.push({
                  offset: stride,
                  data: geometry.normals,
                  attribute: attr
                });
                stride += info.size;
              }

              if (geometry.uvs && geometry.uvs.length > 0) {
                attr = null;

                if (geometry.attributes) {
                  for (const att of geometry.attributes) {
                    if (att.name === AttributeName.ATTR_TEX_COORD) {
                      attr = att;
                      break;
                    }
                  }
                }

                if (!attr) {
                  attr = _defAttrs[2];
                }

                const info = FormatInfos[attr.format];
                attributes.push(attr);
                vertCount = Math.max(vertCount, Math.floor(geometry.uvs.length / info.count));
                channels.push({
                  offset: stride,
                  data: geometry.uvs,
                  attribute: attr
                });
                stride += info.size;
              }

              if (geometry.tangents && geometry.tangents.length > 0) {
                attr = null;

                if (geometry.attributes) {
                  for (const att of geometry.attributes) {
                    if (att.name === AttributeName.ATTR_TANGENT) {
                      attr = att;
                      break;
                    }
                  }
                }

                if (!attr) {
                  attr = _defAttrs[3];
                }

                const info = FormatInfos[attr.format];
                attributes.push(attr);
                vertCount = Math.max(vertCount, Math.floor(geometry.tangents.length / info.count));
                channels.push({
                  offset: stride,
                  data: geometry.tangents,
                  attribute: attr
                });
                stride += info.size;
              }

              if (geometry.colors && geometry.colors.length > 0) {
                attr = null;

                if (geometry.attributes) {
                  for (const att of geometry.attributes) {
                    if (att.name === AttributeName.ATTR_COLOR) {
                      attr = att;
                      break;
                    }
                  }
                }

                if (!attr) {
                  attr = _defAttrs[4];
                }

                const info = FormatInfos[attr.format];
                attributes.push(attr);
                vertCount = Math.max(vertCount, Math.floor(geometry.colors.length / info.count));
                channels.push({
                  offset: stride,
                  data: geometry.colors,
                  attribute: attr
                });
                stride += info.size;
              }

              if (geometry.customAttributes) {
                for (const ca of geometry.customAttributes) {
                  const info = FormatInfos[ca.attr.format];
                  attributes.push(ca.attr);
                  vertCount = Math.max(vertCount, Math.floor(ca.values.length / info.count));
                  channels.push({
                    offset: stride,
                    data: ca.values,
                    attribute: ca.attr
                  });
                  stride += info.size;
                }
              }

              const bufferBlob = new BufferBlob();
              const vertexBuffer = new ArrayBuffer(vertCount * stride);
              const vertexBufferView = new DataView(vertexBuffer);

              for (const channel of channels) {
                writeBuffer(vertexBufferView, channel.data, channel.attribute.format, channel.offset, stride);
              }

              bufferBlob.setNextAlignment(0);
              const vertexBundle = {
                attributes,
                view: {
                  offset: bufferBlob.getLength(),
                  length: vertexBuffer.byteLength,
                  count: vertCount,
                  stride
                }
              };
              bufferBlob.addBuffer(vertexBuffer);
              let indexBuffer = null;
              let idxCount = 0;
              const idxStride = 2;

              if (geometry.indices) {
                const {
                  indices
                } = geometry;
                idxCount = indices.length;
                indexBuffer = new ArrayBuffer(idxStride * idxCount);
                const indexBufferView = new DataView(indexBuffer);
                writeBuffer(indexBufferView, indices, Format.R16UI);
              }

              const primitive = {
                primitiveMode: geometry.primitiveMode || PrimitiveMode.TRIANGLE_LIST,
                vertexBundelIndices: [0]
              };

              if (indexBuffer) {
                bufferBlob.setNextAlignment(idxStride);
                primitive.indexView = {
                  offset: bufferBlob.getLength(),
                  length: indexBuffer.byteLength,
                  count: idxCount,
                  stride: idxStride
                };
                bufferBlob.addBuffer(indexBuffer);
              }

              let minPosition = geometry.minPos;

              if (!minPosition && options.calculateBounds) {
                minPosition = Vec3.set(new Vec3(), Infinity, Infinity, Infinity);

                for (let iVertex = 0; iVertex < vertCount; ++iVertex) {
                  Vec3.set(v3_1, positions[iVertex * 3 + 0], positions[iVertex * 3 + 1], positions[iVertex * 3 + 2]);
                  Vec3.min(minPosition, minPosition, v3_1);
                }
              }

              let maxPosition = geometry.maxPos;

              if (!maxPosition && options.calculateBounds) {
                maxPosition = Vec3.set(new Vec3(), -Infinity, -Infinity, -Infinity);

                for (let iVertex = 0; iVertex < vertCount; ++iVertex) {
                  Vec3.set(v3_1, positions[iVertex * 3 + 0], positions[iVertex * 3 + 1], positions[iVertex * 3 + 2]);
                  Vec3.max(maxPosition, maxPosition, v3_1);
                }
              }

              const meshStruct = {
                vertexBundles: [vertexBundle],
                primitives: [primitive]
              };

              if (minPosition) {
                meshStruct.minPosition = new Vec3(minPosition.x, minPosition.y, minPosition.z);
              }

              if (maxPosition) {
                meshStruct.maxPosition = new Vec3(maxPosition.x, maxPosition.y, maxPosition.z);
              }

              if (!out) {
                out = new Mesh();
              }

              out.reset({
                struct: meshStruct,
                data: new Uint8Array(bufferBlob.getCombined())
              });
              return out;
            }

            var utils = /*#__PURE__*/Object.freeze({
                __proto__: null,
                find: find,
                toPPM: toPPM,
                readMesh: readMesh,
                createMesh: createMesh,
                readBuffer: readBuffer,
                writeBuffer: writeBuffer,
                mapBuffer: mapBuffer
            });
            exports('utils', utils);

            class MorphModel extends Model {
              constructor(...args) {
                super(...args);
                this._morphRenderingInstance = null;
                this._usedMaterials = new Set();
              }

              getMacroPatches(subModelIndex) {
                if (this._morphRenderingInstance) {
                  return this._morphRenderingInstance.requiredPatches(subModelIndex);
                } else {
                  return super.getMacroPatches(subModelIndex);
                }
              }

              initSubModel(subModelIndex, subMeshData, material) {
                return super.initSubModel(subModelIndex, subMeshData, this._launderMaterial(material));
              }

              destroy() {
                super.destroy();
                this._morphRenderingInstance = null;
              }

              setSubModelMaterial(subModelIndex, material) {
                return super.setSubModelMaterial(subModelIndex, this._launderMaterial(material));
              }

              _updateLocalDescriptors(submodelIdx, descriptorSet) {
                super._updateLocalDescriptors(submodelIdx, descriptorSet);

                if (this._morphRenderingInstance) {
                  this._morphRenderingInstance.adaptPipelineState(submodelIdx, descriptorSet);
                }
              }

              _launderMaterial(material) {
                return material;
              }

              setMorphRendering(morphRendering) {
                this._morphRenderingInstance = morphRendering;
              }

            }

            var _dec, _dec2, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _temp, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _dec10, _dec11, _dec12, _dec13, _class4, _class5, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11, _class6, _temp2;
            const ModelShadowCastingMode = Enum({
              OFF: 0,
              ON: 1
            });
            const ModelShadowReceivingMode = Enum({
              OFF: 0,
              ON: 1
            });
            let ModelLightmapSettings = (_dec = ccclass('cc.ModelLightmapSettings'), _dec2 = formerlySerializedAs('_recieveShadow'), _dec(_class = (_class2 = (_temp = class ModelLightmapSettings {
              constructor() {
                _initializerDefineProperty(this, "texture", _descriptor, this);

                _initializerDefineProperty(this, "uvParam", _descriptor2, this);

                _initializerDefineProperty(this, "_bakeable", _descriptor3, this);

                _initializerDefineProperty(this, "_castShadow", _descriptor4, this);

                _initializerDefineProperty(this, "_receiveShadow", _descriptor5, this);

                _initializerDefineProperty(this, "_lightmapSize", _descriptor6, this);
              }

              get bakeable() {
                return this._bakeable;
              }

              set bakeable(val) {
                this._bakeable = val;
              }

              get castShadow() {
                return this._castShadow;
              }

              set castShadow(val) {
                this._castShadow = val;
              }

              get receiveShadow() {
                return this._receiveShadow;
              }

              set receiveShadow(val) {
                this._receiveShadow = val;
              }

              get lightmapSize() {
                return this._lightmapSize;
              }

              set lightmapSize(val) {
                this._lightmapSize = val;
              }

            }, _temp), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "texture", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "uvParam", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec4();
              }
            }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "_bakeable", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "_castShadow", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "_receiveShadow", [_dec2], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "_lightmapSize", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 64;
              }
            }), _applyDecoratedDescriptor(_class2.prototype, "bakeable", [editable], Object.getOwnPropertyDescriptor(_class2.prototype, "bakeable"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "castShadow", [editable], Object.getOwnPropertyDescriptor(_class2.prototype, "castShadow"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "receiveShadow", [editable], Object.getOwnPropertyDescriptor(_class2.prototype, "receiveShadow"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "lightmapSize", [editable], Object.getOwnPropertyDescriptor(_class2.prototype, "lightmapSize"), _class2.prototype)), _class2)) || _class);
            let MeshRenderer = function (v) { return exports({ MeshRenderer: v, ModelComponent: v }), v; }((_dec3 = ccclass('cc.MeshRenderer'), _dec4 = help(), _dec5 = executionOrder(100), _dec6 = menu$1(), _dec7 = type$1(ModelShadowCastingMode), _dec8 = tooltip(), _dec9 = type$1(ModelShadowReceivingMode), _dec10 = tooltip(), _dec11 = type$1(Mesh), _dec12 = tooltip(), _dec13 = visible(), _dec3(_class4 = _dec4(_class4 = _dec5(_class4 = _dec6(_class4 = executeInEditMode(_class4 = (_class5 = (_temp2 = _class6 = class MeshRenderer extends RenderableComponent {
              get shadowCastingMode() {
                return this._shadowCastingMode;
              }

              set shadowCastingMode(val) {
                this._shadowCastingMode = val;

                this._updateCastShadow();
              }

              get receiveShadow() {
                return this._shadowReceivingMode;
              }

              set receiveShadow(val) {
                this._shadowReceivingMode = val;

                this._updateReceiveShadow();
              }

              get mesh() {
                return this._mesh;
              }

              set mesh(val) {
                const old = this._mesh;
                const mesh = this._mesh = val;
                mesh === null || mesh === void 0 ? void 0 : mesh.initialize();

                this._initSubMeshShapesWeights();

                this._watchMorphInMesh();

                this._onMeshChanged(old);

                this._updateModels();

                if (this.enabledInHierarchy) {
                  this._attachToScene();
                }

                this._updateCastShadow();

                this._updateReceiveShadow();
              }

              get model() {
                return this._model;
              }

              get enableMorph() {
                return this._enableMorph;
              }

              set enableMorph(value) {
                this._enableMorph = value;
              }

              constructor() {
                super();

                _initializerDefineProperty(this, "lightmapSettings", _descriptor7, this);

                _initializerDefineProperty(this, "_mesh", _descriptor8, this);

                _initializerDefineProperty(this, "_shadowCastingMode", _descriptor9, this);

                _initializerDefineProperty(this, "_shadowReceivingMode", _descriptor10, this);

                this._subMeshShapesWeights = [];
                this._modelType = void 0;
                this._model = null;
                this._morphInstance = null;

                _initializerDefineProperty(this, "_enableMorph", _descriptor11, this);

                this._modelType = Model;
              }

              onLoad() {
                if (this._mesh) {
                  this._mesh.initialize();
                }

                if (!this._validateShapeWeights()) {
                  this._initSubMeshShapesWeights();
                }

                this._watchMorphInMesh();

                this._updateModels();

                this._updateCastShadow();

                this._updateReceiveShadow();
              }

              onRestore() {
                this._updateModels();

                if (this.enabledInHierarchy) {
                  this._attachToScene();
                }

                this._updateCastShadow();

                this._updateReceiveShadow();
              }

              onEnable() {
                if (!this._model) {
                  this._updateModels();
                }

                this._updateCastShadow();

                this._updateReceiveShadow();

                this._attachToScene();
              }

              onDisable() {
                if (this._model) {
                  this._detachFromScene();
                }
              }

              onDestroy() {
                if (this._model) {
                  legacyCC.director.root.destroyModel(this._model);
                  this._model = null;
                  this._models.length = 0;
                }

                if (this._morphInstance) {
                  this._morphInstance.destroy();
                }
              }

              getWeight(subMeshIndex, shapeIndex) {
                const {
                  _subMeshShapesWeights: subMeshShapesWeights
                } = this;
                assertIsTrue(subMeshIndex < subMeshShapesWeights.length);
                const shapeWeights = this._subMeshShapesWeights[subMeshIndex];
                assertIsTrue(shapeIndex < shapeWeights.length);
                return shapeWeights[shapeIndex];
              }

              setWeights(weights, subMeshIndex) {
                const {
                  _subMeshShapesWeights: subMeshShapesWeights
                } = this;

                if (subMeshIndex >= subMeshShapesWeights.length) {
                  return;
                }

                const shapeWeights = subMeshShapesWeights[subMeshIndex];

                if (shapeWeights.length !== weights.length) {
                  return;
                }

                subMeshShapesWeights[subMeshIndex] = weights.slice(0);

                this._uploadSubMeshShapesWeights(subMeshIndex);
              }

              setWeight(weight, subMeshIndex, shapeIndex) {
                const {
                  _subMeshShapesWeights: subMeshShapesWeights
                } = this;

                if (subMeshIndex >= subMeshShapesWeights.length) {
                  return;
                }

                const shapeWeights = subMeshShapesWeights[subMeshIndex];

                if (shapeIndex >= shapeWeights.length) {
                  return;
                }

                shapeWeights[shapeIndex] = weight;

                this._uploadSubMeshShapesWeights(subMeshIndex);
              }

              setInstancedAttribute(name, value) {
                if (!this.model) {
                  return;
                }

                const {
                  attributes,
                  views
                } = this.model.instancedAttributes;

                for (let i = 0; i < attributes.length; i++) {
                  if (attributes[i].name === name) {
                    views[i].set(value);
                    break;
                  }
                }
              }

              _updateLightmap(lightmap, uOff, vOff, uScale, vScale) {
                this.lightmapSettings.texture = lightmap;
                this.lightmapSettings.uvParam.x = uOff;
                this.lightmapSettings.uvParam.y = vOff;
                this.lightmapSettings.uvParam.z = uScale;
                this.lightmapSettings.uvParam.w = vScale;

                this._onUpdateLightingmap();
              }

              _updateModels() {
                if (!this.enabledInHierarchy || !this._mesh) {
                  return;
                }

                const model = this._model;

                if (model) {
                  model.destroy();
                  model.initialize();
                  model.node = model.transform = this.node;
                } else {
                  this._createModel();
                }

                if (this._model) {
                  this._model.createBoundingShape(this._mesh.struct.minPosition, this._mesh.struct.maxPosition);

                  this._updateModelParams();

                  this._onUpdateLightingmap();
                }
              }

              _createModel() {
                const preferMorphOverPlain = !!this._morphInstance;
                const modelType = preferMorphOverPlain && this._modelType === Model ? MorphModel : this._modelType;
                const model = this._model = legacyCC.director.root.createModel(modelType);
                model.visFlags = this.visibility;
                model.node = model.transform = this.node;
                this._models.length = 0;

                this._models.push(this._model);

                if (this._morphInstance && model instanceof MorphModel) {
                  model.setMorphRendering(this._morphInstance);
                }
              }

              _attachToScene() {
                if (!this.node.scene || !this._model) {
                  return;
                }

                const renderScene = this._getRenderScene();

                if (this._model.scene !== null) {
                  this._detachFromScene();
                }

                renderScene.addModel(this._model);
              }

              _detachFromScene() {
                if (this._model && this._model.scene) {
                  this._model.scene.removeModel(this._model);
                }
              }

              _updateModelParams() {
                if (!this._mesh || !this._model) {
                  return;
                }

                this.node.hasChangedFlags |= TransformBit.POSITION;
                this._model.transform.hasChangedFlags |= TransformBit.POSITION;
                this._model.isDynamicBatching = this._isBatchingEnabled();
                const meshCount = this._mesh ? this._mesh.renderingSubMeshes.length : 0;
                const renderingMesh = this._mesh.renderingSubMeshes;

                if (renderingMesh) {
                  for (let i = 0; i < meshCount; ++i) {
                    let material = this.getRenderMaterial(i);

                    if (material && !material.isValid) {
                      material = null;
                    }

                    const subMeshData = renderingMesh[i];

                    if (subMeshData) {
                      this._model.initSubModel(i, subMeshData, material || this._getBuiltinMaterial());
                    }
                  }
                }

                this._model.enabled = true;
              }

              _onUpdateLightingmap() {
                if (this.model !== null) {
                  this.model.updateLightingmap(this.lightmapSettings.texture, this.lightmapSettings.uvParam);
                }

                this.setInstancedAttribute('a_lightingMapUVParam', [this.lightmapSettings.uvParam.x, this.lightmapSettings.uvParam.y, this.lightmapSettings.uvParam.z, this.lightmapSettings.uvParam.w]);
              }

              _onMaterialModified(idx, material) {
                if (!this._model || !this._model.inited) {
                  return;
                }

                this._onRebuildPSO(idx, material || this._getBuiltinMaterial());
              }

              _onRebuildPSO(idx, material) {
                if (!this._model || !this._model.inited) {
                  return;
                }

                this._model.isDynamicBatching = this._isBatchingEnabled();

                this._model.setSubModelMaterial(idx, material);

                this._onUpdateLightingmap();
              }

              _onMeshChanged(old) {}

              _clearMaterials() {
                if (!this._model) {
                  return;
                }

                const subModels = this._model.subModels;

                for (let i = 0; i < subModels.length; ++i) {
                  this._onMaterialModified(i, null);
                }
              }

              _getBuiltinMaterial() {
                return builtinResMgr.get('missing-material');
              }

              _onVisibilityChange(val) {
                if (!this._model) {
                  return;
                }

                this._model.visFlags = val;
              }

              _updateCastShadow() {
                if (!this._model) {
                  return;
                }

                if (this._shadowCastingMode === ModelShadowCastingMode.OFF) {
                  this._model.castShadow = false;
                } else {
                  assertIsTrue(this._shadowCastingMode === ModelShadowCastingMode.ON, `ShadowCastingMode ${this._shadowCastingMode} is not supported.`);
                  this._model.castShadow = true;
                }
              }

              _updateReceiveShadow() {
                if (!this._model) {
                  return;
                }

                if (this._shadowReceivingMode === ModelShadowReceivingMode.OFF) {
                  this._model.receiveShadow = false;
                } else {
                  this._model.receiveShadow = true;
                }
              }

              _isBatchingEnabled() {
                for (let i = 0; i < this._materials.length; ++i) {
                  const mat = this._materials[i];

                  if (!mat) {
                    continue;
                  }

                  for (let p = 0; p < mat.passes.length; ++p) {
                    const pass = mat.passes[p];

                    if (pass.batchingScheme) {
                      return true;
                    }
                  }
                }

                return false;
              }

              _watchMorphInMesh() {
                if (this._morphInstance) {
                  this._morphInstance.destroy();

                  this._morphInstance = null;
                }

                if (!this._enableMorph) {
                  return;
                }

                if (!this._mesh || !this._mesh.struct.morph || !this._mesh.morphRendering) {
                  return;
                }

                this._morphInstance = this._mesh.morphRendering.createInstance();
                const nSubMeshes = this._mesh.struct.primitives.length;

                for (let iSubMesh = 0; iSubMesh < nSubMeshes; ++iSubMesh) {
                  this._uploadSubMeshShapesWeights(iSubMesh);
                }

                if (this._model && this._model instanceof MorphModel) {
                  this._model.setMorphRendering(this._morphInstance);
                }
              }

              _initSubMeshShapesWeights() {
                const {
                  _mesh: mesh
                } = this;
                this._subMeshShapesWeights.length = 0;

                if (!mesh) {
                  return;
                }

                const morph = mesh.struct.morph;

                if (!morph) {
                  return;
                }

                const commonWeights = morph.weights;
                this._subMeshShapesWeights = morph.subMeshMorphs.map(subMeshMorph => {
                  if (!subMeshMorph) {
                    return [];
                  } else if (subMeshMorph.weights) {
                    return subMeshMorph.weights.slice(0);
                  } else if (commonWeights) {
                    assertIsTrue(commonWeights.length === subMeshMorph.targets.length);
                    return commonWeights.slice(0);
                  } else {
                    return new Array(subMeshMorph.targets.length).fill(0.0);
                  }
                });
              }

              _validateShapeWeights() {
                const {
                  _mesh: mesh,
                  _subMeshShapesWeights: subMeshShapesWeights
                } = this;

                if (!mesh || !mesh.struct.morph) {
                  return subMeshShapesWeights.length === 0;
                }

                const {
                  morph
                } = mesh.struct;

                if (morph.subMeshMorphs.length !== subMeshShapesWeights.length) {
                  return false;
                }

                return subMeshShapesWeights.every(({
                  length: shapeCount
                }, subMeshIndex) => {
                  var _morph$subMeshMorphs$, _morph$subMeshMorphs$2;

                  return ((_morph$subMeshMorphs$ = (_morph$subMeshMorphs$2 = morph.subMeshMorphs[subMeshIndex]) === null || _morph$subMeshMorphs$2 === void 0 ? void 0 : _morph$subMeshMorphs$2.targets.length) !== null && _morph$subMeshMorphs$ !== void 0 ? _morph$subMeshMorphs$ : 0) === shapeCount;
                });
              }

              _uploadSubMeshShapesWeights(subMeshIndex) {
                var _this$_morphInstance;

                (_this$_morphInstance = this._morphInstance) === null || _this$_morphInstance === void 0 ? void 0 : _this$_morphInstance.setWeights(subMeshIndex, this._subMeshShapesWeights[subMeshIndex]);
              }

            }, _class6.ShadowCastingMode = ModelShadowCastingMode, _class6.ShadowReceivingMode = ModelShadowReceivingMode, _temp2), (_descriptor7 = _applyDecoratedDescriptor(_class5.prototype, "lightmapSettings", [serializable, editable, disallowAnimation], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new ModelLightmapSettings();
              }
            }), _descriptor8 = _applyDecoratedDescriptor(_class5.prototype, "_mesh", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor9 = _applyDecoratedDescriptor(_class5.prototype, "_shadowCastingMode", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return ModelShadowCastingMode.OFF;
              }
            }), _descriptor10 = _applyDecoratedDescriptor(_class5.prototype, "_shadowReceivingMode", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return ModelShadowReceivingMode.ON;
              }
            }), _applyDecoratedDescriptor(_class5.prototype, "shadowCastingMode", [_dec7, _dec8, disallowAnimation], Object.getOwnPropertyDescriptor(_class5.prototype, "shadowCastingMode"), _class5.prototype), _applyDecoratedDescriptor(_class5.prototype, "receiveShadow", [_dec9, _dec10, disallowAnimation], Object.getOwnPropertyDescriptor(_class5.prototype, "receiveShadow"), _class5.prototype), _applyDecoratedDescriptor(_class5.prototype, "mesh", [_dec11, _dec12], Object.getOwnPropertyDescriptor(_class5.prototype, "mesh"), _class5.prototype), _applyDecoratedDescriptor(_class5.prototype, "enableMorph", [_dec13, disallowAnimation], Object.getOwnPropertyDescriptor(_class5.prototype, "enableMorph"), _class5.prototype), _descriptor11 = _applyDecoratedDescriptor(_class5.prototype, "_enableMorph", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            })), _class5)) || _class4) || _class4) || _class4) || _class4) || _class4));

            function checkMaterialisSame(comp1, comp2) {
              const matNum = comp1.sharedMaterials.length;

              if (matNum !== comp2.sharedMaterials.length) {
                return false;
              }

              for (let i = 0; i < matNum; i++) {
                if (comp1.getRenderMaterial(i) !== comp2.getRenderMaterial(i)) {
                  return false;
                }
              }

              return true;
            }

            class BatchingUtility {
              static batchStaticModel(staticModelRoot, batchedRoot) {
                const models = staticModelRoot.getComponentsInChildren(MeshRenderer);

                if (models.length < 2) {
                  console.error('the number of static models to batch is less than 2,it needn\'t batch.');
                  return false;
                }

                for (let i = 1; i < models.length; i++) {
                  if (!models[0].mesh.validateMergingMesh(models[i].mesh)) {
                    console.error(`the meshes of ${models[0].node.name} and ${models[i].node.name} can't be merged`);
                    return false;
                  }

                  if (!checkMaterialisSame(models[0], models[i])) {
                    console.error(`the materials of ${models[0].node.name} and ${models[i].node.name} can't be merged`);
                    return false;
                  }
                }

                const batchedMesh = new Mesh();
                const worldMat = new Mat4();
                const rootWorldMatInv = new Mat4();
                staticModelRoot.getWorldMatrix(rootWorldMatInv);
                Mat4.invert(rootWorldMatInv, rootWorldMatInv);

                for (let i = 0; i < models.length; i++) {
                  const comp = models[i];
                  comp.node.getWorldMatrix(worldMat);
                  Mat4.multiply(worldMat, rootWorldMatInv, worldMat);
                  batchedMesh.merge(models[i].mesh, worldMat);
                  comp.enabled = false;
                }

                const batchedModel = batchedRoot.addComponent(MeshRenderer);
                batchedModel.mesh = batchedMesh;
                batchedModel.sharedMaterials = models[0].sharedMaterials;
                return true;
              }

              static unbatchStaticModel(staticModelRoot, batchedRoot) {
                const models = staticModelRoot.getComponentsInChildren(MeshRenderer);

                for (let i = 0; i < models.length; i++) {
                  const comp = models[i];
                  comp.enabled = true;
                }

                const batchedModel = batchedRoot.getComponent(MeshRenderer);

                if (batchedModel) {
                  if (batchedModel.mesh) {
                    batchedModel.mesh.destroyRenderingMesh();
                  }

                  batchedModel.destroy();
                }

                return true;
              }

            } exports('BatchingUtility', BatchingUtility);

            removeProperty(MeshRenderer.prototype, 'MeshRenderer.prototype', [{
              name: 'enableDynamicBatching'
            }, {
              name: 'recieveShadows'
            }]);
            legacyCC.ModelComponent = MeshRenderer;
            js.setClassAlias(MeshRenderer, 'cc.ModelComponent');

            var _dec$1, _class$1, _class2$1, _descriptor$1, _descriptor2$1, _descriptor3$1, _descriptor4$1, _temp$1, _dec2$1, _dec3$1, _dec4$1, _dec5$1, _dec6$1, _dec7$1, _class4$1, _class5$1, _descriptor5$1, _descriptor6$1, _descriptor7$1, _descriptor8$1, _class6$1, _temp2$1;
            const PhotometricTerm = Enum({
              LUMINOUS_FLUX: 0,
              LUMINANCE: 1
            });

            const _color_tmp = new Vec3();

            let StaticLightSettings = (_dec$1 = ccclass('cc.StaticLightSettings'), _dec$1(_class$1 = (_class2$1 = (_temp$1 = class StaticLightSettings {
              constructor() {
                _initializerDefineProperty(this, "_baked", _descriptor$1, this);

                _initializerDefineProperty(this, "_editorOnly", _descriptor2$1, this);

                _initializerDefineProperty(this, "_bakeable", _descriptor3$1, this);

                _initializerDefineProperty(this, "_castShadow", _descriptor4$1, this);
              }

              get editorOnly() {
                return this._editorOnly;
              }

              set editorOnly(val) {
                this._editorOnly = val;
              }

              get baked() {
                return this._baked;
              }

              set baked(val) {
                this._baked = val;
              }

              get bakeable() {
                return this._bakeable;
              }

              set bakeable(val) {
                this._bakeable = val;
              }

              get castShadow() {
                return this._castShadow;
              }

              set castShadow(val) {
                this._castShadow = val;
              }

            }, _temp$1), (_descriptor$1 = _applyDecoratedDescriptor(_class2$1.prototype, "_baked", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor2$1 = _applyDecoratedDescriptor(_class2$1.prototype, "_editorOnly", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor3$1 = _applyDecoratedDescriptor(_class2$1.prototype, "_bakeable", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor4$1 = _applyDecoratedDescriptor(_class2$1.prototype, "_castShadow", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _applyDecoratedDescriptor(_class2$1.prototype, "editorOnly", [editable], Object.getOwnPropertyDescriptor(_class2$1.prototype, "editorOnly"), _class2$1.prototype), _applyDecoratedDescriptor(_class2$1.prototype, "bakeable", [editable], Object.getOwnPropertyDescriptor(_class2$1.prototype, "bakeable"), _class2$1.prototype), _applyDecoratedDescriptor(_class2$1.prototype, "castShadow", [editable], Object.getOwnPropertyDescriptor(_class2$1.prototype, "castShadow"), _class2$1.prototype)), _class2$1)) || _class$1);
            let Light = function (v) { return exports({ Light: v, LightComponent: v }), v; }((_dec2$1 = ccclass('cc.Light'), _dec3$1 = tooltip(), _dec4$1 = tooltip(), _dec5$1 = range(), _dec6$1 = tooltip(), _dec7$1 = type$1(StaticLightSettings), _dec2$1(_class4$1 = (_class5$1 = (_temp2$1 = _class6$1 = class Light extends Component {
              get color() {
                return this._color;
              }

              set color(val) {
                this._color = val;

                if (this._light) {
                  _color_tmp.x = val.r / 255.0;
                  _color_tmp.y = val.g / 255.0;
                  _color_tmp.z = val.b / 255.0;
                  this._light.color = _color_tmp;
                }
              }

              get useColorTemperature() {
                return this._useColorTemperature;
              }

              set useColorTemperature(enable) {
                this._useColorTemperature = enable;

                if (this._light) {
                  this._light.useColorTemperature = enable;
                }
              }

              get colorTemperature() {
                return this._colorTemperature;
              }

              set colorTemperature(val) {
                this._colorTemperature = val;

                if (this._light) {
                  this._light.colorTemperature = val;
                }
              }

              get staticSettings() {
                return this._staticSettings;
              }

              set staticSettings(val) {
                this._staticSettings = val;
              }

              get type() {
                return this._type;
              }

              get baked() {
                return this.staticSettings.baked;
              }

              set baked(val) {
                this.staticSettings.baked = val;

                if (this._light !== null) {
                  this._light.baked = val;
                }
              }

              constructor() {
                super();

                _initializerDefineProperty(this, "_color", _descriptor5$1, this);

                _initializerDefineProperty(this, "_useColorTemperature", _descriptor6$1, this);

                _initializerDefineProperty(this, "_colorTemperature", _descriptor7$1, this);

                _initializerDefineProperty(this, "_staticSettings", _descriptor8$1, this);

                this._type = LightType.UNKNOWN;
                this._lightType = void 0;
                this._light = null;
                this._lightType = Light$1;
              }

              onLoad() {
                this._createLight();
              }

              onEnable() {
                this._attachToScene();
              }

              onDisable() {
                this._detachFromScene();
              }

              onDestroy() {
                this._destroyLight();
              }

              _createLight() {
                if (!this._light) {
                  this._light = legacyCC.director.root.createLight(this._lightType);
                }

                this.color = this._color;
                this.useColorTemperature = this._useColorTemperature;
                this.colorTemperature = this._colorTemperature;
                this._light.node = this.node;
                this._light.baked = this.baked;
              }

              _destroyLight() {
                if (this._light) {
                  legacyCC.director.root.destroyLight(this);
                  this._light = null;
                }
              }

              _attachToScene() {
                this._detachFromScene();

                if (this._light && !this._light.scene && this.node.scene) {
                  const renderScene = this._getRenderScene();

                  switch (this._type) {
                    case LightType.DIRECTIONAL:
                      renderScene.addDirectionalLight(this._light);
                      renderScene.setMainLight(this._light);
                      break;

                    case LightType.SPHERE:
                      renderScene.addSphereLight(this._light);
                      break;

                    case LightType.SPOT:
                      renderScene.addSpotLight(this._light);
                      break;
                  }
                }
              }

              _detachFromScene() {
                if (this._light && this._light.scene) {
                  const renderScene = this._light.scene;

                  switch (this._type) {
                    case LightType.DIRECTIONAL:
                      renderScene.removeDirectionalLight(this._light);
                      renderScene.unsetMainLight(this._light);
                      break;

                    case LightType.SPHERE:
                      renderScene.removeSphereLight(this._light);
                      break;

                    case LightType.SPOT:
                      renderScene.removeSpotLight(this._light);
                      break;
                  }
                }
              }

            }, _class6$1.Type = LightType, _class6$1.PhotometricTerm = PhotometricTerm, _temp2$1), (_descriptor5$1 = _applyDecoratedDescriptor(_class5$1.prototype, "_color", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Color$1.WHITE.clone();
              }
            }), _descriptor6$1 = _applyDecoratedDescriptor(_class5$1.prototype, "_useColorTemperature", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor7$1 = _applyDecoratedDescriptor(_class5$1.prototype, "_colorTemperature", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 6550;
              }
            }), _descriptor8$1 = _applyDecoratedDescriptor(_class5$1.prototype, "_staticSettings", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new StaticLightSettings();
              }
            }), _applyDecoratedDescriptor(_class5$1.prototype, "color", [_dec3$1], Object.getOwnPropertyDescriptor(_class5$1.prototype, "color"), _class5$1.prototype), _applyDecoratedDescriptor(_class5$1.prototype, "useColorTemperature", [_dec4$1], Object.getOwnPropertyDescriptor(_class5$1.prototype, "useColorTemperature"), _class5$1.prototype), _applyDecoratedDescriptor(_class5$1.prototype, "colorTemperature", [slide, _dec5$1, _dec6$1], Object.getOwnPropertyDescriptor(_class5$1.prototype, "colorTemperature"), _class5$1.prototype), _applyDecoratedDescriptor(_class5$1.prototype, "staticSettings", [_dec7$1], Object.getOwnPropertyDescriptor(_class5$1.prototype, "staticSettings"), _class5$1.prototype)), _class5$1)) || _class4$1));

            var _dec$2, _dec2$2, _dec3$2, _dec4$2, _dec5$2, _class$2, _class2$2, _descriptor$2, _descriptor2$2, _temp$2;
            let DirectionalLight = function (v) { return exports({ DirectionalLight: v, DirectionalLightComponent: v }), v; }((_dec$2 = ccclass('cc.DirectionalLight'), _dec2$2 = help(), _dec3$2 = menu$1(), _dec4$2 = formerlySerializedAs('_illuminance'), _dec5$2 = tooltip(), _dec$2(_class$2 = _dec2$2(_class$2 = _dec3$2(_class$2 = executeInEditMode(_class$2 = (_class2$2 = (_temp$2 = class DirectionalLight extends Light {
              get illuminance() {
                const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

                if (isHDR) {
                  return this._illuminanceHDR;
                } else {
                  return this._illuminanceLDR;
                }
              }

              set illuminance(val) {
                const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

                if (isHDR) {
                  this._illuminanceHDR = val;
                  this._light && (this._light.illuminanceHDR = this._illuminanceHDR);
                } else {
                  this._illuminanceLDR = val;
                  this._light && (this._light.illuminanceLDR = this._illuminanceLDR);
                }
              }

              constructor() {
                super();

                _initializerDefineProperty(this, "_illuminanceHDR", _descriptor$2, this);

                _initializerDefineProperty(this, "_illuminanceLDR", _descriptor2$2, this);

                this._type = LightType.DIRECTIONAL;
                this._light = null;
                this._lightType = DirectionalLight$1;
              }

              _createLight() {
                super._createLight();

                this._illuminanceLDR = this._illuminanceHDR * Camera.standardExposureValue;

                if (this._light) {
                  this._light.illuminanceHDR = this._illuminanceHDR;
                  this._light.illuminanceLDR = this._illuminanceLDR;
                }
              }

            }, _temp$2), (_descriptor$2 = _applyDecoratedDescriptor(_class2$2.prototype, "_illuminanceHDR", [property$1, _dec4$2], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 65000;
              }
            }), _descriptor2$2 = _applyDecoratedDescriptor(_class2$2.prototype, "_illuminanceLDR", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1.0;
              }
            }), _applyDecoratedDescriptor(_class2$2.prototype, "illuminance", [_dec5$2], Object.getOwnPropertyDescriptor(_class2$2.prototype, "illuminance"), _class2$2.prototype)), _class2$2)) || _class$2) || _class$2) || _class$2) || _class$2));

            var _dec$3, _dec2$3, _dec3$3, _dec4$3, _dec5$3, _dec6$2, _dec7$2, _dec8$1, _dec9$1, _dec10$1, _class$3, _class2$3, _descriptor$3, _descriptor2$3, _descriptor3$2, _descriptor4$2, _descriptor5$2, _temp$3;
            let SphereLight = function (v) { return exports({ SphereLight: v, SphereLightComponent: v }), v; }((_dec$3 = ccclass('cc.SphereLight'), _dec2$3 = help(), _dec3$3 = menu$1(), _dec4$3 = formerlySerializedAs('_luminance'), _dec5$3 = tooltip(), _dec6$2 = tooltip(), _dec7$2 = type$1(PhotometricTerm), _dec8$1 = tooltip(), _dec9$1 = tooltip(), _dec10$1 = tooltip(), _dec$3(_class$3 = _dec2$3(_class$3 = _dec3$3(_class$3 = executeInEditMode(_class$3 = (_class2$3 = (_temp$3 = class SphereLight extends Light {
              get luminousFlux() {
                const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

                if (isHDR) {
                  return this._luminanceHDR * nt2lm(this._size);
                } else {
                  return this._luminanceLDR;
                }
              }

              set luminousFlux(val) {
                const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;
                let result = 0;

                if (isHDR) {
                  this._luminanceHDR = val / nt2lm(this._size);
                  result = this._luminanceHDR;
                } else {
                  this._luminanceLDR = val;
                  result = this._luminanceLDR;
                }

                this._light && (this._light.luminance = result);
              }

              get luminance() {
                const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

                if (isHDR) {
                  return this._luminanceHDR;
                } else {
                  return this._luminanceLDR;
                }
              }

              set luminance(val) {
                const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

                if (isHDR) {
                  this._luminanceHDR = val;
                  this._light && (this._light.luminanceHDR = this._luminanceHDR);
                } else {
                  this._luminanceLDR = val;
                  this._light && (this._light.luminanceLDR = this._luminanceLDR);
                }
              }

              get term() {
                return this._term;
              }

              set term(val) {
                this._term = val;
              }

              get size() {
                return this._size;
              }

              set size(val) {
                this._size = val;

                if (this._light) {
                  this._light.size = val;
                }
              }

              get range() {
                return this._range;
              }

              set range(val) {
                this._range = val;

                if (this._light) {
                  this._light.range = val;
                }
              }

              constructor() {
                super();

                _initializerDefineProperty(this, "_size", _descriptor$3, this);

                _initializerDefineProperty(this, "_luminanceHDR", _descriptor2$3, this);

                _initializerDefineProperty(this, "_luminanceLDR", _descriptor3$2, this);

                _initializerDefineProperty(this, "_term", _descriptor4$2, this);

                _initializerDefineProperty(this, "_range", _descriptor5$2, this);

                this._type = LightType.SPHERE;
                this._light = null;
                this._lightType = SphereLight$1;
              }

              _createLight() {
                super._createLight();

                this.size = this._size;
                this.range = this._range;

                if (legacyCC.director.root.pipeline.pipelineSceneData.isHDR) {
                  this._luminanceLDR = this._luminanceHDR * Camera.standardExposureValue * Camera.standardLightMeterScale;
                } else {
                  this._luminanceHDR = this._luminanceLDR / Camera.standardExposureValue / Camera.standardLightMeterScale;
                }

                if (this._light) {
                  this._light.luminanceHDR = this._luminanceHDR;
                  this._light.luminanceLDR = this._luminanceLDR;
                }
              }

            }, _temp$3), (_descriptor$3 = _applyDecoratedDescriptor(_class2$3.prototype, "_size", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.15;
              }
            }), _descriptor2$3 = _applyDecoratedDescriptor(_class2$3.prototype, "_luminanceHDR", [serializable, _dec4$3], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1700 / nt2lm(0.15);
              }
            }), _descriptor3$2 = _applyDecoratedDescriptor(_class2$3.prototype, "_luminanceLDR", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1.0;
              }
            }), _descriptor4$2 = _applyDecoratedDescriptor(_class2$3.prototype, "_term", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return PhotometricTerm.LUMINOUS_FLUX;
              }
            }), _descriptor5$2 = _applyDecoratedDescriptor(_class2$3.prototype, "_range", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            }), _applyDecoratedDescriptor(_class2$3.prototype, "luminousFlux", [_dec5$3], Object.getOwnPropertyDescriptor(_class2$3.prototype, "luminousFlux"), _class2$3.prototype), _applyDecoratedDescriptor(_class2$3.prototype, "luminance", [_dec6$2], Object.getOwnPropertyDescriptor(_class2$3.prototype, "luminance"), _class2$3.prototype), _applyDecoratedDescriptor(_class2$3.prototype, "term", [_dec7$2, _dec8$1], Object.getOwnPropertyDescriptor(_class2$3.prototype, "term"), _class2$3.prototype), _applyDecoratedDescriptor(_class2$3.prototype, "size", [_dec9$1], Object.getOwnPropertyDescriptor(_class2$3.prototype, "size"), _class2$3.prototype), _applyDecoratedDescriptor(_class2$3.prototype, "range", [_dec10$1], Object.getOwnPropertyDescriptor(_class2$3.prototype, "range"), _class2$3.prototype)), _class2$3)) || _class$3) || _class$3) || _class$3) || _class$3));

            var _dec$4, _dec2$4, _dec3$4, _dec4$4, _dec5$4, _dec6$3, _dec7$3, _dec8$2, _dec9$2, _dec10$2, _dec11$1, _dec12$1, _class$4, _class2$4, _descriptor$4, _descriptor2$4, _descriptor3$3, _descriptor4$3, _descriptor5$3, _descriptor6$2, _temp$4;
            let SpotLight = function (v) { return exports({ SpotLight: v, SpotLightComponent: v }), v; }((_dec$4 = ccclass('cc.SpotLight'), _dec2$4 = help(), _dec3$4 = menu$1(), _dec4$4 = formerlySerializedAs('_luminance'), _dec5$4 = tooltip(), _dec6$3 = tooltip(), _dec7$3 = type$1(PhotometricTerm), _dec8$2 = tooltip(), _dec9$2 = tooltip(), _dec10$2 = tooltip(), _dec11$1 = range(), _dec12$1 = tooltip(), _dec$4(_class$4 = _dec2$4(_class$4 = _dec3$4(_class$4 = executeInEditMode(_class$4 = (_class2$4 = (_temp$4 = class SpotLight extends Light {
              get luminousFlux() {
                const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

                if (isHDR) {
                  return this._luminanceHDR * nt2lm(this._size);
                } else {
                  return this._luminanceLDR;
                }
              }

              set luminousFlux(val) {
                const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;
                let result = 0;

                if (isHDR) {
                  this._luminanceHDR = val / nt2lm(this._size);
                  result = this._luminanceHDR;
                } else {
                  this._luminanceLDR = val;
                  result = this._luminanceLDR;
                }

                this._light && (this._light.luminance = result);
              }

              get luminance() {
                const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

                if (isHDR) {
                  return this._luminanceHDR;
                } else {
                  return this._luminanceLDR;
                }
              }

              set luminance(val) {
                const isHDR = legacyCC.director.root.pipeline.pipelineSceneData.isHDR;

                if (isHDR) {
                  this._luminanceHDR = val;
                  this._light && (this._light.luminanceHDR = this._luminanceHDR);
                } else {
                  this._luminanceLDR = val;
                  this._light && (this._light.luminanceLDR = this._luminanceLDR);
                }
              }

              get term() {
                return this._term;
              }

              set term(val) {
                this._term = val;
              }

              get size() {
                return this._size;
              }

              set size(val) {
                this._size = val;

                if (this._light) {
                  this._light.size = val;
                }
              }

              get range() {
                return this._range;
              }

              set range(val) {
                this._range = val;

                if (this._light) {
                  this._light.range = val;
                }
              }

              get spotAngle() {
                return this._spotAngle;
              }

              set spotAngle(val) {
                this._spotAngle = val;

                if (this._light) {
                  this._light.spotAngle = toRadian(val);
                }
              }

              constructor() {
                super();

                _initializerDefineProperty(this, "_size", _descriptor$4, this);

                _initializerDefineProperty(this, "_luminanceHDR", _descriptor2$4, this);

                _initializerDefineProperty(this, "_luminanceLDR", _descriptor3$3, this);

                _initializerDefineProperty(this, "_term", _descriptor4$3, this);

                _initializerDefineProperty(this, "_range", _descriptor5$3, this);

                _initializerDefineProperty(this, "_spotAngle", _descriptor6$2, this);

                this._type = LightType.SPOT;
                this._light = null;
                this._lightType = SpotLight$1;
              }

              _createLight() {
                super._createLight();

                this.size = this._size;
                this.range = this._range;
                this.spotAngle = this._spotAngle;

                if (legacyCC.director.root.pipeline.pipelineSceneData.isHDR) {
                  this._luminanceLDR = this._luminanceHDR * Camera.standardExposureValue * Camera.standardLightMeterScale;
                } else {
                  this._luminanceHDR = this._luminanceLDR / Camera.standardExposureValue / Camera.standardLightMeterScale;
                }

                if (this._light) {
                  this._light.luminanceHDR = this._luminanceHDR;
                  this._light.luminanceLDR = this._luminanceLDR;
                }
              }

            }, _temp$4), (_descriptor$4 = _applyDecoratedDescriptor(_class2$4.prototype, "_size", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.15;
              }
            }), _descriptor2$4 = _applyDecoratedDescriptor(_class2$4.prototype, "_luminanceHDR", [serializable, _dec4$4], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1700 / nt2lm(0.15);
              }
            }), _descriptor3$3 = _applyDecoratedDescriptor(_class2$4.prototype, "_luminanceLDR", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1.0;
              }
            }), _descriptor4$3 = _applyDecoratedDescriptor(_class2$4.prototype, "_term", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return PhotometricTerm.LUMINOUS_FLUX;
              }
            }), _descriptor5$3 = _applyDecoratedDescriptor(_class2$4.prototype, "_range", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            }), _descriptor6$2 = _applyDecoratedDescriptor(_class2$4.prototype, "_spotAngle", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 60;
              }
            }), _applyDecoratedDescriptor(_class2$4.prototype, "luminousFlux", [_dec5$4], Object.getOwnPropertyDescriptor(_class2$4.prototype, "luminousFlux"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "luminance", [_dec6$3], Object.getOwnPropertyDescriptor(_class2$4.prototype, "luminance"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "term", [_dec7$3, _dec8$2], Object.getOwnPropertyDescriptor(_class2$4.prototype, "term"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "size", [_dec9$2], Object.getOwnPropertyDescriptor(_class2$4.prototype, "size"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "range", [_dec10$2], Object.getOwnPropertyDescriptor(_class2$4.prototype, "range"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "spotAngle", [slide, _dec11$1, _dec12$1], Object.getOwnPropertyDescriptor(_class2$4.prototype, "spotAngle"), _class2$4.prototype)), _class2$4)) || _class$4) || _class$4) || _class$4) || _class$4));

            legacyCC.LightComponent = Light;
            js.setClassAlias(Light, 'cc.LightComponent');
            legacyCC.DirectionalLightComponent = DirectionalLight;
            js.setClassAlias(DirectionalLight, 'cc.DirectionalLightComponent');
            legacyCC.SphereLightComponent = SphereLight;
            js.setClassAlias(SphereLight, 'cc.SphereLightComponent');
            legacyCC.SpotLightComponent = SpotLight;
            js.setClassAlias(SpotLight, 'cc.SpotLightComponent');
            replaceProperty(SpotLight.prototype, 'SpotLight.prototype', [{
              name: 'luminousPower',
              newName: 'luminousFlux',

              customGetter() {
                return this.luminousFlux;
              },

              customSetter(value) {
                this.luminousFlux = value;
              }

            }]);
            replaceProperty(SphereLight.prototype, 'SphereLight.prototype', [{
              name: 'luminousPower',
              newName: 'luminousFlux',

              customGetter() {
                return this.luminousFlux;
              },

              customSetter(value) {
                this.luminousFlux = value;
              }

            }]);
            replaceProperty(Light.PhotometricTerm, 'Light.PhotometricTerm', [{
              name: 'LUMINOUS_POWER',
              newName: 'LUMINOUS_FLUX'
            }]);

            const uploadJointData = uploadJointDataLBS;
            const MINIMUM_JOINT_TEXTURE_SIZE =  480;
            function selectJointsMediumFormat(device) {
              if (device.hasFeature(Feature.TEXTURE_FLOAT)) {
                return Format.RGBA32F;
              }

              return Format.RGBA8;
            }

            function uploadJointDataLBS(out, base, mat, firstBone) {
              out[base + 0] = mat.m00;
              out[base + 1] = mat.m01;
              out[base + 2] = mat.m02;
              out[base + 3] = mat.m12;
              out[base + 4] = mat.m04;
              out[base + 5] = mat.m05;
              out[base + 6] = mat.m06;
              out[base + 7] = mat.m13;
              out[base + 8] = mat.m08;
              out[base + 9] = mat.m09;
              out[base + 10] = mat.m10;
              out[base + 11] = mat.m14;
            }

            const dq_0 = new Quat();
            const dq_1 = new Quat();
            const v3_1$1 = new Vec3();
            const qt_1 = new Quat();
            const v3_2 = new Vec3();

            function roundUpTextureSize(targetLength, formatSize) {
              const formatScale = 4 / Math.sqrt(formatSize);
              return Math.ceil(Math.max(MINIMUM_JOINT_TEXTURE_SIZE * formatScale, targetLength) / 12) * 12;
            }

            const jointTextureSamplerInfo = new SamplerInfo(Filter.POINT, Filter.POINT, Filter.NONE, Address.CLAMP, Address.CLAMP, Address.CLAMP);
            const v3_3 = new Vec3();
            const v3_4 = new Vec3();
            const v3_min = new Vec3();
            const v3_max = new Vec3();
            const m4_1 = new Mat4();
            const m4_2 = new Mat4();
            const ab_1 = new AABB();
            const Inf = Number.MAX_SAFE_INTEGER;
            class JointTexturePool {
              get pixelsPerJoint() {
                return this._pixelsPerJoint;
              }

              constructor(device) {
                this._device = void 0;
                this._pool = void 0;
                this._textureBuffers = new Map();
                this._formatSize = void 0;
                this._pixelsPerJoint = void 0;
                this._customPool = void 0;
                this._chunkIdxMap = new Map();
                this._device = device;
                const format = selectJointsMediumFormat(this._device);
                this._formatSize = FormatInfos[format].size;
                this._pixelsPerJoint = 48 / this._formatSize;
                this._pool = new TextureBufferPool(device);

                this._pool.initialize({
                  format,
                  roundUpFn: roundUpTextureSize
                });

                this._customPool = new TextureBufferPool(device);

                this._customPool.initialize({
                  format,
                  roundUpFn: roundUpTextureSize
                });
              }

              clear() {
                this._pool.destroy();

                this._textureBuffers.clear();
              }

              registerCustomTextureLayouts(layouts) {
                for (let i = 0; i < layouts.length; i++) {
                  const layout = layouts[i];

                  const chunkIdx = this._customPool.createChunk(layout.textureLength);

                  for (let j = 0; j < layout.contents.length; j++) {
                    const content = layout.contents[j];
                    const {
                      skeleton
                    } = content;

                    this._chunkIdxMap.set(skeleton, chunkIdx);

                    for (let k = 0; k < content.clips.length; k++) {
                      const clip = content.clips[k];

                      this._chunkIdxMap.set(skeleton ^ clip, chunkIdx);
                    }
                  }
                }
              }

              getDefaultPoseTexture(skeleton, mesh, skinningRoot) {
                const hash = skeleton.hash ^ 0;
                let texture = this._textureBuffers.get(hash) || null;

                if (texture && texture.bounds.has(mesh.hash)) {
                  texture.refCount++;
                  return texture;
                }

                const {
                  joints,
                  bindposes
                } = skeleton;
                let textureBuffer = null;
                let buildTexture = false;
                const jointCount = joints.length;

                if (!texture) {
                  const bufSize = jointCount * 12;

                  const customChunkIdx = this._chunkIdxMap.get(hash);

                  const handle = customChunkIdx !== undefined ? this._customPool.alloc(bufSize * Float32Array.BYTES_PER_ELEMENT, customChunkIdx) : this._pool.alloc(bufSize * Float32Array.BYTES_PER_ELEMENT);

                  if (!handle) {
                    return texture;
                  }

                  texture = {
                    pixelOffset: handle.start / this._formatSize,
                    refCount: 1,
                    bounds: new Map(),
                    skeletonHash: skeleton.hash,
                    clipHash: 0,
                    readyToBeDeleted: false,
                    handle
                  };
                  textureBuffer = new Float32Array(bufSize);
                  buildTexture = true;
                } else {
                  texture.refCount++;
                }

                Vec3.set(v3_min, Inf, Inf, Inf);
                Vec3.set(v3_max, -Inf, -Inf, -Inf);
                const boneSpaceBounds = mesh.getBoneSpaceBounds(skeleton);

                for (let j = 0, offset = 0; j < jointCount; j++, offset += 12) {
                  const node = skinningRoot.getChildByPath(joints[j]);
                  const mat = node ? getWorldTransformUntilRoot(node, skinningRoot, m4_1) : skeleton.inverseBindposes[j];
                  const bound = boneSpaceBounds[j];

                  if (bound) {
                    AABB.transform(ab_1, bound, mat);
                    ab_1.getBoundary(v3_3, v3_4);
                    Vec3.min(v3_min, v3_min, v3_3);
                    Vec3.max(v3_max, v3_max, v3_4);
                  }

                  if (buildTexture) {
                    if (node) {
                      Mat4.multiply(mat, mat, bindposes[j]);
                    }

                    uploadJointData(textureBuffer, offset, node ? mat : Mat4.IDENTITY);
                  }
                }

                const bounds = [new AABB()];
                texture.bounds.set(mesh.hash, bounds);
                AABB.fromPoints(bounds[0], v3_min, v3_max);

                if (buildTexture) {
                  this._pool.update(texture.handle, textureBuffer.buffer);

                  this._textureBuffers.set(hash, texture);
                }

                return texture;
              }

              getSequencePoseTexture(skeleton, clip, mesh, skinningRoot) {
                const hash = skeleton.hash ^ clip.hash;
                let texture = this._textureBuffers.get(hash) || null;

                if (texture && texture.bounds.has(mesh.hash)) {
                  texture.refCount++;
                  return texture;
                }

                const {
                  joints,
                  bindposes
                } = skeleton;
                const clipData = SkelAnimDataHub.getOrExtract(clip);
                const {
                  frames
                } = clipData;
                let textureBuffer = null;
                let buildTexture = false;
                const jointCount = joints.length;

                if (!texture) {
                  const bufSize = jointCount * 12 * frames;

                  const customChunkIdx = this._chunkIdxMap.get(hash);

                  const handle = customChunkIdx !== undefined ? this._customPool.alloc(bufSize * Float32Array.BYTES_PER_ELEMENT, customChunkIdx) : this._pool.alloc(bufSize * Float32Array.BYTES_PER_ELEMENT);

                  if (!handle) {
                    return null;
                  }

                  const animInfos = this._createAnimInfos(skeleton, clip, skinningRoot);

                  texture = {
                    pixelOffset: handle.start / this._formatSize,
                    refCount: 1,
                    bounds: new Map(),
                    skeletonHash: skeleton.hash,
                    clipHash: clip.hash,
                    readyToBeDeleted: false,
                    handle,
                    animInfos
                  };
                  textureBuffer = new Float32Array(bufSize);
                  buildTexture = true;
                } else {
                  texture.refCount++;
                }

                const boneSpaceBounds = mesh.getBoneSpaceBounds(skeleton);
                const bounds = [];
                texture.bounds.set(mesh.hash, bounds);

                for (let f = 0; f < frames; f++) {
                  bounds.push(new AABB(Inf, Inf, Inf, -Inf, -Inf, -Inf));
                }

                for (let f = 0, offset = 0; f < frames; f++) {
                  const bound = bounds[f];

                  for (let j = 0; j < jointCount; j++, offset += 12) {
                    const {
                      curveData,
                      downstream,
                      bindposeIdx,
                      bindposeCorrection
                    } = texture.animInfos[j];
                    let mat;
                    let transformValid = true;

                    if (curveData && downstream) {
                      mat = Mat4.multiply(m4_1, curveData[f], downstream);
                    } else if (curveData) {
                      mat = curveData[f];
                    } else if (downstream) {
                      mat = downstream;
                    } else {
                      mat = skeleton.inverseBindposes[bindposeIdx];
                      transformValid = false;
                    }

                    const boneSpaceBound = boneSpaceBounds[j];

                    if (boneSpaceBound) {
                      const transform = bindposeCorrection ? Mat4.multiply(m4_2, mat, bindposeCorrection) : mat;
                      AABB.transform(ab_1, boneSpaceBound, transform);
                      ab_1.getBoundary(v3_3, v3_4);
                      Vec3.min(bound.center, bound.center, v3_3);
                      Vec3.max(bound.halfExtents, bound.halfExtents, v3_4);
                    }

                    if (buildTexture) {
                      if (transformValid) {
                        Mat4.multiply(m4_1, mat, bindposes[bindposeIdx]);
                      }

                      uploadJointData(textureBuffer, offset, transformValid ? m4_1 : Mat4.IDENTITY);
                    }
                  }

                  AABB.fromPoints(bound, bound.center, bound.halfExtents);
                }

                if (buildTexture) {
                  this._pool.update(texture.handle, textureBuffer.buffer);

                  this._textureBuffers.set(hash, texture);
                }

                return texture;
              }

              releaseHandle(handle) {
                if (handle.refCount > 0) {
                  handle.refCount--;
                }

                if (!handle.refCount && handle.readyToBeDeleted) {
                  const hash = handle.skeletonHash ^ handle.clipHash;

                  const customChunkIdx = this._chunkIdxMap.get(hash);

                  (customChunkIdx !== undefined ? this._customPool : this._pool).free(handle.handle);

                  if (this._textureBuffers.get(hash) === handle) {
                    this._textureBuffers.delete(hash);
                  }
                }
              }

              releaseSkeleton(skeleton) {
                const it = this._textureBuffers.values();

                let res = it.next();

                while (!res.done) {
                  const handle = res.value;

                  if (handle.skeletonHash === skeleton.hash) {
                    handle.readyToBeDeleted = true;

                    if (handle.refCount) {
                      this._textureBuffers.delete(handle.skeletonHash ^ handle.clipHash);
                    } else {
                      this.releaseHandle(handle);
                    }
                  }

                  res = it.next();
                }
              }

              releaseAnimationClip(clip) {
                const it = this._textureBuffers.values();

                let res = it.next();

                while (!res.done) {
                  const handle = res.value;

                  if (handle.clipHash === clip.hash) {
                    handle.readyToBeDeleted = true;

                    if (handle.refCount) {
                      this._textureBuffers.delete(handle.skeletonHash ^ handle.clipHash);
                    } else {
                      this.releaseHandle(handle);
                    }
                  }

                  res = it.next();
                }
              }

              _createAnimInfos(skeleton, clip, skinningRoot) {
                const animInfos = [];
                const {
                  joints,
                  bindposes
                } = skeleton;
                const jointCount = joints.length;
                const clipData = SkelAnimDataHub.getOrExtract(clip);

                for (let j = 0; j < jointCount; j++) {
                  let animPath = joints[j];
                  let source = clipData.joints[animPath];
                  let animNode = skinningRoot.getChildByPath(animPath);
                  let downstream;
                  let correctionPath;

                  while (!source) {
                    const idx = animPath.lastIndexOf('/');
                    animPath = animPath.substring(0, idx);
                    source = clipData.joints[animPath];

                    if (animNode) {
                      if (!downstream) {
                        downstream = new Mat4();
                      }

                      Mat4.fromRTS(m4_1, animNode.rotation, animNode.position, animNode.scale);
                      Mat4.multiply(downstream, m4_1, downstream);
                      animNode = animNode.parent;
                    } else {
                      correctionPath = animPath;
                    }

                    if (idx < 0) {
                      break;
                    }
                  }

                  let bindposeIdx = j;
                  let bindposeCorrection;

                  if (correctionPath !== undefined && source) {
                    bindposeIdx = j - 1;

                    for (let t = 0; t < jointCount; t++) {
                      if (joints[t] === correctionPath) {
                        bindposeIdx = t;
                        bindposeCorrection = new Mat4();
                        Mat4.multiply(bindposeCorrection, bindposes[t], skeleton.inverseBindposes[j]);
                        break;
                      }
                    }
                  }

                  animInfos.push({
                    curveData: source && source.transforms,
                    downstream,
                    bindposeIdx,
                    bindposeCorrection
                  });
                }

                return animInfos;
              }

            }
            class JointAnimationInfo {
              constructor(device) {
                this._pool = new Map();
                this._device = void 0;
                this._device = device;
              }

              getData(nodeID = '-1') {
                const res = this._pool.get(nodeID);

                if (res) {
                  return res;
                }

                const buffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, UBOSkinningAnimation.SIZE, UBOSkinningAnimation.SIZE));

                const data = new Float32Array([0, 0, 0, 0]);
                buffer.update(data);
                const info = {
                  buffer,
                  data,
                  dirty: false
                };

                this._setAnimInfoDirty(info, false);

                this._pool.set(nodeID, info);

                return info;
              }

              destroy(nodeID) {
                const info = this._pool.get(nodeID);

                if (!info) {
                  return;
                }

                info.buffer.destroy();

                this._pool.delete(nodeID);
              }

              _setAnimInfoDirty(info, value) {
                info.dirty = value;

                {
                  const key = 'nativeDirty';
                  const convertVal = value ? 1 : 0;

                  if (!info[key]) {
                    Object.defineProperty(info, key, {
                      value: new Uint32Array(1).fill(convertVal),
                      enumerable: true
                    });
                    return;
                  }

                  info[key].fill(convertVal);
                }
              }

              switchClip(info, clip) {
                info.data[0] = 0;
                info.buffer.update(info.data);

                this._setAnimInfoDirty(info, false);

                return info;
              }

              clear() {
                for (const info of this._pool.values()) {
                  info.buffer.destroy();
                }

                this._pool.clear();
              }

            }

            class DataPoolManager {
              constructor(device) {
                this.jointTexturePool = void 0;
                this.jointAnimationInfo = void 0;
                this.jointTexturePool = new JointTexturePool(device);
                this.jointAnimationInfo = new JointAnimationInfo(device);
              }

              releaseSkeleton(skeleton) {
                this.jointTexturePool.releaseSkeleton(skeleton);
              }

              releaseAnimationClip(clip) {
                this.jointTexturePool.releaseAnimationClip(clip);
              }

              clear() {
                this.jointTexturePool.clear();
                this.jointAnimationInfo.clear();
              }

            }
            legacyCC.internal.DataPoolManager = DataPoolManager;

            const myPatches = [{
              name: 'CC_USE_SKINNING',
              value: true
            }];

            function getRelevantBuffers(outIndices, outBuffers, jointMaps, targetJoint) {
              for (let i = 0; i < jointMaps.length; i++) {
                const idxMap = jointMaps[i];
                let index = -1;

                for (let j = 0; j < idxMap.length; j++) {
                  if (idxMap[j] === targetJoint) {
                    index = j;
                    break;
                  }
                }

                if (index >= 0) {
                  outBuffers.push(i);
                  outIndices.push(index);
                }
              }
            }

            const v3_min$1 = new Vec3();
            const v3_max$1 = new Vec3();
            const v3_1$2 = new Vec3();
            const v3_2$1 = new Vec3();
            const m4_1$1 = new Mat4();
            const ab_1$1 = new AABB();
            class SkinningModel extends MorphModel {
              constructor() {
                super();
                this.uploadAnimation = null;
                this._buffers = [];
                this._dataArray = [];
                this._joints = [];
                this._bufferIndices = null;
                this.type = ModelType.SKINNING;
              }

              _init() {
                {
                  this._nativeObj = new NativeSkinningModel();
                }
              }

              destroy() {
                this.bindSkeleton();

                if (this._buffers.length) {
                  for (let i = 0; i < this._buffers.length; i++) {
                    this._buffers[i].destroy();
                  }

                  this._buffers.length = 0;
                }

                super.destroy();
              }

              bindSkeleton(skeleton = null, skinningRoot = null, mesh = null) {
                for (let i = 0; i < this._joints.length; i++) {
                  deleteTransform(this._joints[i].target);
                }

                this._bufferIndices = null;
                this._joints.length = 0;

                if (!skeleton || !skinningRoot || !mesh) {
                  return;
                }

                this.transform = skinningRoot;
                const boneSpaceBounds = mesh.getBoneSpaceBounds(skeleton);
                const jointMaps = mesh.struct.jointMaps;

                this._ensureEnoughBuffers(jointMaps && jointMaps.length || 1);

                this._bufferIndices = mesh.jointBufferIndices;
                const nativeJoints = [];

                for (let index = 0; index < skeleton.joints.length; index++) {
                  const bound = boneSpaceBounds[index];
                  const target = skinningRoot.getChildByPath(skeleton.joints[index]);

                  if (!bound || !target) {
                    continue;
                  }

                  const transform = getTransform(target, skinningRoot);
                  const bindpose = skeleton.bindposes[index];
                  const indices = [];
                  const buffers = [];

                  if (!jointMaps) {
                    indices.push(index);
                    buffers.push(0);
                  } else {
                    getRelevantBuffers(indices, buffers, jointMaps, index);
                  }

                  this._joints.push({
                    indices,
                    buffers,
                    bound,
                    target,
                    bindpose,
                    transform
                  });

                  {
                    let currParent = transform.parent;
                    const transParents = [];

                    while (currParent) {
                      transParents.push({
                        node: currParent.node.native,
                        local: currParent.local,
                        world: currParent.local,
                        stamp: currParent.stamp
                      });
                      currParent = currParent.parent;
                    }

                    nativeJoints.push({
                      indices,
                      buffers,
                      bound: bound.native,
                      target: target.native,
                      bindpose,
                      transform: {
                        node: transform.node.native,
                        local: transform.local,
                        world: transform.world,
                        stamp: transform.stamp
                      },
                      parents: transParents
                    });
                  }
                }

                {
                  this._nativeObj.setIndicesAndJoints(this._bufferIndices, nativeJoints);
                }
              }

              updateTransform(stamp) {
                const root = this.transform;

                if (root.hasChangedFlags || root._dirtyFlags) {
                  root.updateWorldTransform();
                  this._localDataUpdated = true;
                }

                Vec3.set(v3_min$1, Infinity, Infinity, Infinity);
                Vec3.set(v3_max$1, -Infinity, -Infinity, -Infinity);

                for (let i = 0; i < this._joints.length; i++) {
                  const {
                    bound,
                    transform
                  } = this._joints[i];
                  const worldMatrix = getWorldMatrix(transform, stamp);
                  AABB.transform(ab_1$1, bound, worldMatrix);
                  ab_1$1.getBoundary(v3_1$2, v3_2$1);
                  Vec3.min(v3_min$1, v3_min$1, v3_1$2);
                  Vec3.max(v3_max$1, v3_max$1, v3_2$1);
                }

                const worldBounds = this._worldBounds;

                if (this._modelBounds && worldBounds) {
                  AABB.fromPoints(this._modelBounds, v3_min$1, v3_max$1);

                  this._modelBounds.transform(root._mat, root._pos, root._rot, root._scale, this._worldBounds);

                  this._updateNativeBounds();
                }
              }

              updateUBOs(stamp) {
                super.updateUBOs(stamp);

                for (let i = 0; i < this._joints.length; i++) {
                  const {
                    indices,
                    buffers,
                    transform,
                    bindpose
                  } = this._joints[i];
                  Mat4.multiply(m4_1$1, transform.world, bindpose);

                  for (let b = 0; b < buffers.length; b++) {
                    uploadJointData(this._dataArray[buffers[b]], indices[b] * 12, m4_1$1);
                  }
                }

                for (let b = 0; b < this._buffers.length; b++) {
                  this._buffers[b].update(this._dataArray[b]);
                }

                return true;
              }

              initSubModel(idx, subMeshData, mat) {
                const original = subMeshData.vertexBuffers;
                const iaInfo = subMeshData.iaInfo;
                iaInfo.vertexBuffers = subMeshData.jointMappedBuffers;
                super.initSubModel(idx, subMeshData, mat);
                iaInfo.vertexBuffers = original;
              }

              getMacroPatches(subModelIndex) {
                const superMacroPatches = super.getMacroPatches(subModelIndex);

                if (superMacroPatches) {
                  return myPatches.concat(superMacroPatches);
                }

                return myPatches;
              }

              _updateLocalDescriptors(submodelIdx, descriptorSet) {
                super._updateLocalDescriptors(submodelIdx, descriptorSet);

                {
                  this._nativeObj.updateLocalDescriptors(submodelIdx, descriptorSet);

                  return;
                }
              }

              _updateInstancedAttributes(attributes, pass) {
                if (pass.batchingScheme !== BatchingSchemes.NONE) {
                  warnID(3936, this.node.getPathInHierarchy());
                }

                super._updateInstancedAttributes(attributes, pass);
              }

              _ensureEnoughBuffers(count) {
                for (let i = 0; i < count; i++) {
                  if (!this._buffers[i]) {
                    this._buffers[i] = this._device.createBuffer(new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, UBOSkinning.SIZE, UBOSkinning.SIZE));
                  }

                  if (!this._dataArray[i]) {
                    this._dataArray[i] = new Float32Array(UBOSkinning.COUNT);
                  }
                }

                {
                  this._nativeObj.setBuffers(this._buffers);
                }
              }

            }

            const myPatches$1 = [{
              name: 'CC_USE_SKINNING',
              value: true
            }, {
              name: 'CC_USE_BAKED_ANIMATION',
              value: true
            }];
            class BakedSkinningModel extends MorphModel {
              constructor() {
                super();
                this.uploadedAnim = undefined;
                this._jointsMedium = void 0;
                this._skeleton = null;
                this._mesh = null;
                this._dataPoolManager = void 0;
                this._instAnimInfoIdx = -1;
                this.type = ModelType.BAKED_SKINNING;
                this._dataPoolManager = legacyCC.director.root.dataPoolManager;
                const jointTextureInfo = new Float32Array(4);

                const animInfo = this._dataPoolManager.jointAnimationInfo.getData();

                this._jointsMedium = {
                  buffer: null,
                  jointTextureInfo,
                  animInfo,
                  texture: null,
                  boundsInfo: null
                };
              }

              _init() {
                {
                  this._nativeObj = new NativeBakedSkinningModel();
                }
              }

              destroy() {
                this.uploadedAnim = undefined;
                this._jointsMedium.boundsInfo = null;

                if (this._jointsMedium.buffer) {
                  this._jointsMedium.buffer.destroy();

                  this._jointsMedium.buffer = null;
                }

                this._applyJointTexture();

                this._applyNativeJointMedium();

                super.destroy();
              }

              bindSkeleton(skeleton = null, skinningRoot = null, mesh = null) {
                this._skeleton = skeleton;
                this._mesh = mesh;

                if (!skeleton || !skinningRoot || !mesh) {
                  return;
                }

                this.transform = skinningRoot;
                const resMgr = this._dataPoolManager;
                this._jointsMedium.animInfo = resMgr.jointAnimationInfo.getData(skinningRoot.uuid);

                if (!this._jointsMedium.buffer) {
                  this._jointsMedium.buffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, UBOSkinningTexture.SIZE, UBOSkinningTexture.SIZE));
                }
              }

              updateTransform(stamp) {
                super.updateTransform(stamp);

                if (!this.uploadedAnim) {
                  return;
                }

                const {
                  animInfo,
                  boundsInfo
                } = this._jointsMedium;
                const skelBound = boundsInfo[animInfo.data[0]];
                const worldBounds = this._worldBounds;

                if (worldBounds && skelBound) {
                  const node = this.transform;
                  skelBound.transform(node._mat, node._pos, node._rot, node._scale, worldBounds);
                }
              }

              updateUBOs(stamp) {
                super.updateUBOs(stamp);
                const info = this._jointsMedium.animInfo;
                const idx = this._instAnimInfoIdx;

                if (idx >= 0) {
                  const view = this.instancedAttributes.views[idx];
                  view[0] = info.data[0];
                } else if (info.dirty) {
                  info.buffer.update(info.data);
                  info.dirty = false;
                }

                return true;
              }

              _applyNativeJointMedium() {
                if ( this._nativeObj) {
                  const boundsInfo = [];

                  if (this._jointsMedium.boundsInfo) {
                    this._jointsMedium.boundsInfo.forEach(bound => {
                      boundsInfo.push(bound.native);
                    });
                  }

                  const animInfoKey = 'nativeDirty';

                  this._nativeObj.setJointMedium(!!this.uploadedAnim, {
                    boundsInfo,
                    jointTextureInfo: this._jointsMedium.jointTextureInfo.buffer,
                    animInfo: {
                      buffer: this._jointsMedium.animInfo.buffer,
                      data: this._jointsMedium.animInfo.data.buffer,
                      dirty: this._jointsMedium.animInfo[animInfoKey].buffer
                    },
                    buffer: this._jointsMedium.buffer
                  });
                }
              }

              _updateModelBounds(aabb) {
                this._modelBounds = aabb;

                {
                  this._nativeObj.updateModelBounds(aabb ? aabb.native : null);
                }
              }

              uploadAnimation(anim) {
                if (!this._skeleton || !this._mesh || this.uploadedAnim === anim) {
                  return;
                }

                this.uploadedAnim = anim;
                const resMgr = this._dataPoolManager;
                let texture = null;

                if (anim) {
                  texture = resMgr.jointTexturePool.getSequencePoseTexture(this._skeleton, anim, this._mesh, this.transform);
                  this._jointsMedium.boundsInfo = texture && texture.bounds.get(this._mesh.hash);

                  this._updateModelBounds(null);
                } else {
                  texture = resMgr.jointTexturePool.getDefaultPoseTexture(this._skeleton, this._mesh, this.transform);
                  this._jointsMedium.boundsInfo = null;

                  this._updateModelBounds(texture && texture.bounds.get(this._mesh.hash)[0]);
                }

                this._applyJointTexture(texture);

                this._applyNativeJointMedium();
              }

              _applyJointTexture(texture = null) {
                const oldTex = this._jointsMedium.texture;

                if (oldTex && oldTex !== texture) {
                  this._dataPoolManager.jointTexturePool.releaseHandle(oldTex);
                }

                this._jointsMedium.texture = texture;

                if (!texture) {
                  return;
                }

                const {
                  buffer,
                  jointTextureInfo
                } = this._jointsMedium;
                jointTextureInfo[0] = texture.handle.texture.width;
                jointTextureInfo[1] = this._skeleton.joints.length;
                jointTextureInfo[2] = texture.pixelOffset + 0.1;
                jointTextureInfo[3] = 1 / jointTextureInfo[0];
                this.updateInstancedJointTextureInfo();

                if (buffer) {
                  buffer.update(jointTextureInfo);
                }

                const tex = texture.handle.texture;

                for (let i = 0; i < this._subModels.length; ++i) {
                  const descriptorSet = this._subModels[i].descriptorSet;
                  descriptorSet.bindTexture(UNIFORM_JOINT_TEXTURE_BINDING, tex);
                }
              }

              getMacroPatches(subModelIndex) {
                const patches = super.getMacroPatches(subModelIndex);
                return patches ? patches.concat(myPatches$1) : myPatches$1;
              }

              _updateLocalDescriptors(submodelIdx, descriptorSet) {
                super._updateLocalDescriptors(submodelIdx, descriptorSet);

                const {
                  buffer,
                  texture,
                  animInfo
                } = this._jointsMedium;
                descriptorSet.bindBuffer(UBOSkinningTexture.BINDING, buffer);
                descriptorSet.bindBuffer(UBOSkinningAnimation.BINDING, animInfo.buffer);

                if (texture) {
                  const sampler = this._device.getSampler(jointTextureSamplerInfo);

                  descriptorSet.bindTexture(UNIFORM_JOINT_TEXTURE_BINDING, texture.handle.texture);
                  descriptorSet.bindSampler(UNIFORM_JOINT_TEXTURE_BINDING, sampler);
                }
              }

              _setInstAnimInfoIdx(idx) {
                this._instAnimInfoIdx = idx;

                {
                  this._nativeObj.setAnimInfoIdx(idx);
                }
              }

              _updateInstancedAttributes(attributes, pass) {
                super._updateInstancedAttributes(attributes, pass);

                this._setInstAnimInfoIdx(this._getInstancedAttributeIndex(INST_JOINT_ANIM_INFO));

                this.updateInstancedJointTextureInfo();
              }

              updateInstancedJointTextureInfo() {
                const {
                  jointTextureInfo,
                  animInfo
                } = this._jointsMedium;
                const idx = this._instAnimInfoIdx;

                if (idx >= 0) {
                  const view = this.instancedAttributes.views[idx];
                  view[0] = animInfo.data[0];
                  view[1] = jointTextureInfo[1];
                  view[2] = jointTextureInfo[2];
                }
              }

            }

            var _dec$5, _dec2$5, _dec3$5, _dec4$5, _dec5$5, _dec6$4, _dec7$4, _dec8$3, _dec9$3, _class$5, _class2$5, _descriptor$5, _descriptor2$5, _temp$5;
            let SkinnedMeshRenderer = function (v) { return exports({ SkinnedMeshRenderer: v, SkinningModelComponent: v }), v; }((_dec$5 = ccclass('cc.SkinnedMeshRenderer'), _dec2$5 = help(), _dec3$5 = executionOrder(100), _dec4$5 = menu$1(), _dec5$5 = type$1(Skeleton$1), _dec6$4 = type$1(Node), _dec7$4 = type$1(Skeleton$1), _dec8$3 = type$1(Node), _dec9$3 = tooltip(), _dec$5(_class$5 = _dec2$5(_class$5 = _dec3$5(_class$5 = executeInEditMode(_class$5 = _dec4$5(_class$5 = (_class2$5 = (_temp$5 = class SkinnedMeshRenderer extends MeshRenderer {
              get skeleton() {
                return this._skeleton;
              }

              set skeleton(val) {
                if (val === this._skeleton) {
                  return;
                }

                this._skeleton = val;

                this._update();
              }

              get skinningRoot() {
                return this._skinningRoot;
              }

              set skinningRoot(value) {
                if (value === this._skinningRoot) {
                  return;
                }

                this._skinningRoot = value;

                this._tryBindAnimation();

                this._update();
              }

              get model() {
                return this._model;
              }

              constructor() {
                super();

                _initializerDefineProperty(this, "_skeleton", _descriptor$5, this);

                _initializerDefineProperty(this, "_skinningRoot", _descriptor2$5, this);

                this._clip = null;
                this._animation = null;
                this._modelType = BakedSkinningModel;
              }

              onDestroy() {
                if (this._animation) {
                  this._animation.removeUser(this);

                  this._animation = null;
                }

                super.onDestroy();
              }

              __preload() {
                this._tryBindAnimation();
              }

              uploadAnimation(clip) {
                this._clip = clip;

                if (this.model && this.model.uploadAnimation) {
                  this.model.uploadAnimation(clip);
                }
              }

              setUseBakedAnimation(val = true, force = false) {
                const modelType = val ? BakedSkinningModel : SkinningModel;

                if (!force && this._modelType === modelType) {
                  return;
                }

                this._modelType = modelType;

                if (this._model) {
                  legacyCC.director.root.destroyModel(this._model);
                  this._model = null;
                  this._models.length = 0;

                  this._updateModels();

                  this._updateCastShadow();

                  if (this.enabledInHierarchy) {
                    this._attachToScene();
                  }
                }
              }

              setMaterial(material, index) {
                super.setMaterial(material, index);

                if (this._modelType === SkinningModel) {
                  this.getMaterialInstance(index);
                }
              }

              notifyAnimationUsable(animation) {
                if (this._animation) {
                  this._animation.removeUser(this);

                  this._animation = null;
                }

                animation.addUser(this);
                this._animation = animation;
              }

              notifyAnimationUnusable() {
                this._animation = null;
              }

              _updateModelParams() {
                this._update();

                super._updateModelParams();
              }

              _tryBindAnimation() {
                const {
                  _skinningRoot: skinningRoot
                } = this;

                if (!skinningRoot) {
                  return;
                }

                const animation = skinningRoot.getComponent('cc.SkeletalAnimation');

                if (animation) {
                  animation.addUser(this);
                } else {
                  this.setUseBakedAnimation(false);
                }
              }

              _update() {
                if (this.model) {
                  this.model.bindSkeleton(this._skeleton, this._skinningRoot, this._mesh);

                  if (this.model.uploadAnimation) {
                    this.model.uploadAnimation(this._clip);
                  }
                }
              }

            }, _temp$5), (_descriptor$5 = _applyDecoratedDescriptor(_class2$5.prototype, "_skeleton", [_dec5$5], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor2$5 = _applyDecoratedDescriptor(_class2$5.prototype, "_skinningRoot", [_dec6$4], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _applyDecoratedDescriptor(_class2$5.prototype, "skeleton", [_dec7$4], Object.getOwnPropertyDescriptor(_class2$5.prototype, "skeleton"), _class2$5.prototype), _applyDecoratedDescriptor(_class2$5.prototype, "skinningRoot", [_dec8$3, _dec9$3], Object.getOwnPropertyDescriptor(_class2$5.prototype, "skinningRoot"), _class2$5.prototype)), _class2$5)) || _class$5) || _class$5) || _class$5) || _class$5) || _class$5));

            var _dec$6, _dec2$6, _dec3$6, _dec4$6, _dec5$6, _class$6, _class2$6, _descriptor$6, _descriptor2$6, _descriptor3$4, _descriptor4$4, _descriptor5$4, _descriptor6$3, _temp$6, _dec6$5, _dec7$5, _dec8$4, _dec9$4, _dec10$3, _dec11$2, _dec12$2, _dec13$1, _dec14, _dec15, _dec16, _class4$2, _class5$2, _descriptor7$2, _descriptor8$2, _descriptor9$1, _temp2$2;

            const repeat = n => n - Math.floor(n);

            const batch_id = new Attribute(AttributeName.ATTR_BATCH_ID, Format.R32F);
            const batch_uv = new Attribute(AttributeName.ATTR_BATCH_UV, Format.RG32F);
            const batch_extras_size = FormatInfos[batch_id.format].size + FormatInfos[batch_uv.format].size;
            let SkinnedMeshUnit = function (v) { return exports({ SkinnedMeshUnit: v, SkinningModelUnit: v }), v; }((_dec$6 = ccclass('cc.SkinnedMeshUnit'), _dec2$6 = type$1(Mesh), _dec3$6 = type$1(Skeleton$1), _dec4$6 = type$1(Material), _dec5$6 = type$1(SkinnedMeshRenderer), _dec$6(_class$6 = (_class2$6 = (_temp$6 = class SkinnedMeshUnit {
              constructor() {
                _initializerDefineProperty(this, "mesh", _descriptor$6, this);

                _initializerDefineProperty(this, "skeleton", _descriptor2$6, this);

                _initializerDefineProperty(this, "material", _descriptor3$4, this);

                _initializerDefineProperty(this, "_localTransform", _descriptor4$4, this);

                _initializerDefineProperty(this, "_offset", _descriptor5$4, this);

                _initializerDefineProperty(this, "_size", _descriptor6$3, this);
              }

              set offset(offset) {
                Vec2.copy(this._offset, offset);
              }

              get offset() {
                return this._offset;
              }

              set size(size) {
                Vec2.copy(this._size, size);
              }

              get size() {
                return this._size;
              }

              set copyFrom(comp) {
                if (!comp) {
                  return;
                }

                this.mesh = comp.mesh;
                this.skeleton = comp.skeleton;
                this.material = comp.getMaterial(0);

                if (comp.skinningRoot) {
                  getWorldTransformUntilRoot(comp.node, comp.skinningRoot, this._localTransform);
                }
              }

              get copyFrom() {
                return null;
              }

            }, _temp$6), (_descriptor$6 = _applyDecoratedDescriptor(_class2$6.prototype, "mesh", [_dec2$6], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor2$6 = _applyDecoratedDescriptor(_class2$6.prototype, "skeleton", [_dec3$6], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor3$4 = _applyDecoratedDescriptor(_class2$6.prototype, "material", [_dec4$6], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor4$4 = _applyDecoratedDescriptor(_class2$6.prototype, "_localTransform", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Mat4();
              }
            }), _descriptor5$4 = _applyDecoratedDescriptor(_class2$6.prototype, "_offset", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec2(0, 0);
              }
            }), _descriptor6$3 = _applyDecoratedDescriptor(_class2$6.prototype, "_size", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec2(1, 1);
              }
            }), _applyDecoratedDescriptor(_class2$6.prototype, "offset", [editable], Object.getOwnPropertyDescriptor(_class2$6.prototype, "offset"), _class2$6.prototype), _applyDecoratedDescriptor(_class2$6.prototype, "size", [editable], Object.getOwnPropertyDescriptor(_class2$6.prototype, "size"), _class2$6.prototype), _applyDecoratedDescriptor(_class2$6.prototype, "copyFrom", [_dec5$6], Object.getOwnPropertyDescriptor(_class2$6.prototype, "copyFrom"), _class2$6.prototype)), _class2$6)) || _class$6));
            const m4_local = new Mat4();
            const m4_1$2 = new Mat4();
            const v3_1$3 = new Vec3();
            let SkinnedMeshBatchRenderer = function (v) { return exports({ SkinnedMeshBatchRenderer: v, BatchedSkinningModelComponent: v }), v; }((_dec6$5 = ccclass('cc.SkinnedMeshBatchRenderer'), _dec7$5 = help(), _dec8$4 = executionOrder(100), _dec9$4 = menu$1(), _dec10$3 = tooltip(), _dec11$2 = type$1([CCString]), _dec12$2 = tooltip(), _dec13$1 = type$1([SkinnedMeshUnit]), _dec14 = tooltip(), _dec15 = visible(), _dec16 = visible(), _dec6$5(_class4$2 = _dec7$5(_class4$2 = _dec8$4(_class4$2 = executeInEditMode(_class4$2 = _dec9$4(_class4$2 = (_class5$2 = (_temp2$2 = class SkinnedMeshBatchRenderer extends SkinnedMeshRenderer {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "atlasSize", _descriptor7$2, this);

                _initializerDefineProperty(this, "batchableTextureNames", _descriptor8$2, this);

                _initializerDefineProperty(this, "units", _descriptor9$1, this);

                this._textures = {};
                this._batchMaterial = null;
              }

              get mesh() {
                return super.mesh;
              }

              set mesh(val) {
                super.mesh = val;
              }

              get skeleton() {
                return super.skeleton;
              }

              set skeleton(val) {
                super.skeleton = val;
              }

              onLoad() {
                super.onLoad();
                this.cook();
              }

              onDestroy() {
                for (const tex in this._textures) {
                  this._textures[tex].destroy();
                }

                this._textures = {};

                if (this._mesh) {
                  this._mesh.destroy();

                  this._mesh = null;
                }

                super.onDestroy();
              }

              _onMaterialModified(idx, material) {
                this.cookMaterials();

                super._onMaterialModified(idx, this.getMaterialInstance(idx));
              }

              cook() {
                this.cookMaterials();
                this.cookSkeletons();
                this.cookMeshes();
              }

              cookMaterials() {
                if (!this._batchMaterial) {
                  this._batchMaterial = this.getMaterial(0);
                }

                const mat = this.getMaterialInstance(0);

                if (!mat || !this._batchMaterial || !this._batchMaterial.effectAsset) {
                  console.warn('incomplete batch material!');
                  return;
                }

                mat.copy(this._batchMaterial);
                this.resizeAtlases();
                const tech = mat.effectAsset.techniques[mat.technique];

                for (let i = 0; i < tech.passes.length; i++) {
                  const pass = tech.passes[i];

                  if (!pass.properties) {
                    continue;
                  }

                  for (const prop in pass.properties) {
                    if (pass.properties[prop].type >= Type$1.SAMPLER1D) {
                      let tex = null;

                      if (this.batchableTextureNames.find(n => n === prop)) {
                        tex = this._textures[prop];

                        if (!tex) {
                          tex = this.createTexture(prop);
                        }

                        this.cookTextures(tex, prop, i);
                      } else {
                        this.units.some(u => tex = u.material && u.material.getProperty(prop, i));
                      }

                      if (tex) {
                        mat.setProperty(prop, tex, i);
                      }
                    } else {
                      const value = [];

                      for (let u = 0; u < this.units.length; u++) {
                        const unit = this.units[u];

                        if (!unit.material) {
                          continue;
                        }

                        value.push(unit.material.getProperty(prop.slice(0, -3), i));
                      }

                      mat.setProperty(prop, value, i);
                    }
                  }
                }
              }

              cookSkeletons() {
                if (!this._skinningRoot) {
                  console.warn('no skinning root specified!');
                  return;
                }

                const joints = [];
                const bindposes = [];

                for (let u = 0; u < this.units.length; u++) {
                  const unit = this.units[u];

                  if (!unit || !unit.skeleton) {
                    continue;
                  }

                  const partial = unit.skeleton;
                  Mat4.invert(m4_local, unit._localTransform);

                  for (let i = 0; i < partial.joints.length; i++) {
                    const path = partial.joints[i];
                    const idx = joints.findIndex(p => p === path);

                    if (idx >= 0) {

                      continue;
                    }

                    joints.push(path);
                    bindposes.push(Mat4.multiply(new Mat4(), partial.bindposes[i] || Mat4.IDENTITY, m4_local));
                  }
                }

                const idxMap = Array.from(Array(joints.length).keys()).sort((a, b) => {
                  if (joints[a] > joints[b]) {
                    return 1;
                  }

                  if (joints[a] < joints[b]) {
                    return -1;
                  }

                  return 0;
                });
                const skeleton = new Skeleton$1();
                skeleton.joints = joints.map((_, idx, arr) => arr[idxMap[idx]]);
                skeleton.bindposes = bindposes.map((_, idx, arr) => arr[idxMap[idx]]);

                if (this._skeleton) {
                  this._skeleton.destroy();
                }

                this.skeleton = skeleton;
              }

              cookMeshes() {
                let isValid = false;

                for (let u = 0; u < this.units.length; u++) {
                  const unit = this.units[u];

                  if (unit.mesh) {
                    isValid = true;
                    break;
                  }
                }

                if (!isValid || !this._skinningRoot) {
                  return;
                }

                if (this._mesh) {
                  this._mesh.destroyRenderingMesh();
                } else {
                  this._mesh = new Mesh();
                }

                let posOffset = 0;
                let posFormat = Format.UNKNOWN;
                let normalOffset = 0;
                let normalFormat = Format.UNKNOWN;
                let tangentOffset = 0;
                let tangentFormat = Format.UNKNOWN;
                let uvOffset = 0;
                let uvFormat = Format.UNKNOWN;
                let jointOffset = 0;
                let jointFormat = Format.UNKNOWN;
                const jointIndexMap = new Array(this.units.length);
                const unitLen = this.units.length;

                for (let i = 0; i < unitLen; i++) {
                  const unit = this.units[i];

                  if (!unit || !unit.skeleton) {
                    continue;
                  }

                  jointIndexMap[i] = unit.skeleton.joints.map(j => this._skeleton.joints.findIndex(ref => j === ref));
                }

                for (let i = 0; i < unitLen; i++) {
                  const unit = this.units[i];

                  if (!unit || !unit.mesh || !unit.mesh.data) {
                    continue;
                  }

                  const newMesh = this._createUnitMesh(i, unit.mesh);

                  const dataView = new DataView(newMesh.data.buffer);
                  Mat4.inverseTranspose(m4_local, unit._localTransform);
                  const {
                    offset
                  } = unit;
                  const {
                    size
                  } = unit;

                  for (let b = 0; b < newMesh.struct.vertexBundles.length; b++) {
                    const bundle = newMesh.struct.vertexBundles[b];
                    posOffset = bundle.view.offset;
                    posFormat = Format.UNKNOWN;

                    for (let a = 0; a < bundle.attributes.length; a++) {
                      const attr = bundle.attributes[a];

                      if (attr.name === AttributeName.ATTR_POSITION) {
                        posFormat = attr.format;
                        break;
                      }

                      posOffset += FormatInfos[attr.format].size;
                    }

                    if (posFormat) {
                      const pos = readBuffer(dataView, posFormat, posOffset, bundle.view.length, bundle.view.stride);

                      for (let j = 0; j < pos.length; j += 3) {
                        Vec3.fromArray(v3_1$3, pos, j);
                        Vec3.transformMat4(v3_1$3, v3_1$3, unit._localTransform);
                        Vec3.toArray(pos, v3_1$3, j);
                      }

                      writeBuffer(dataView, pos, posFormat, posOffset, bundle.view.stride);
                    }

                    normalOffset = bundle.view.offset;
                    normalFormat = Format.UNKNOWN;

                    for (let a = 0; a < bundle.attributes.length; a++) {
                      const attr = bundle.attributes[a];

                      if (attr.name === AttributeName.ATTR_NORMAL) {
                        normalFormat = attr.format;
                        break;
                      }

                      normalOffset += FormatInfos[attr.format].size;
                    }

                    if (normalFormat) {
                      const normal = readBuffer(dataView, normalFormat, normalOffset, bundle.view.length, bundle.view.stride);

                      for (let j = 0; j < normal.length; j += 3) {
                        Vec3.fromArray(v3_1$3, normal, j);
                        Vec3.transformMat4Normal(v3_1$3, v3_1$3, m4_local);
                        Vec3.toArray(normal, v3_1$3, j);
                      }

                      writeBuffer(dataView, normal, normalFormat, normalOffset, bundle.view.stride);
                    }

                    tangentOffset = bundle.view.offset;
                    tangentFormat = Format.UNKNOWN;

                    for (let a = 0; a < bundle.attributes.length; a++) {
                      const attr = bundle.attributes[a];

                      if (attr.name === AttributeName.ATTR_TANGENT) {
                        tangentFormat = attr.format;
                        break;
                      }

                      tangentOffset += FormatInfos[attr.format].size;
                    }

                    if (tangentFormat) {
                      const tangent = readBuffer(dataView, tangentFormat, tangentOffset, bundle.view.length, bundle.view.stride);

                      for (let j = 0; j < tangent.length; j += 3) {
                        Vec3.fromArray(v3_1$3, tangent, j);
                        Vec3.transformMat4Normal(v3_1$3, v3_1$3, m4_local);
                        Vec3.toArray(tangent, v3_1$3, j);
                      }

                      writeBuffer(dataView, tangent, tangentFormat, tangentOffset, bundle.view.stride);
                    }

                    uvOffset = bundle.view.offset;
                    uvFormat = Format.UNKNOWN;

                    for (let a = 0; a < bundle.attributes.length; a++) {
                      const attr = bundle.attributes[a];

                      if (attr.name === AttributeName.ATTR_BATCH_UV) {
                        uvFormat = attr.format;
                        break;
                      }

                      uvOffset += FormatInfos[attr.format].size;
                    }

                    if (uvFormat) {
                      mapBuffer(dataView, (cur, idx) => {
                        cur = repeat(cur);
                        const comp = idx === 0 ? 'x' : 'y';
                        return cur * size[comp] + offset[comp];
                      }, uvFormat, uvOffset, bundle.view.length, bundle.view.stride, dataView);
                    }

                    const idxMap = jointIndexMap[i];

                    if (!idxMap) {
                      continue;
                    }

                    jointOffset = bundle.view.offset;
                    jointFormat = Format.UNKNOWN;

                    for (let a = 0; a < bundle.attributes.length; a++) {
                      const attr = bundle.attributes[a];

                      if (attr.name === AttributeName.ATTR_JOINTS) {
                        jointFormat = attr.format;
                        break;
                      }

                      jointOffset += FormatInfos[attr.format].size;
                    }

                    if (jointFormat) {
                      mapBuffer(dataView, cur => idxMap[cur], jointFormat, jointOffset, bundle.view.length, bundle.view.stride, dataView);
                    }
                  }

                  this._mesh.merge(newMesh);
                }

                this._onMeshChanged(this._mesh);

                this._updateModels();
              }

              cookTextures(target, prop, passIdx) {
                const texImages = [];
                const texImageRegions = [];
                const texBuffers = [];
                const texBufferRegions = [];

                for (let u = 0; u < this.units.length; u++) {
                  const unit = this.units[u];

                  if (!unit.material) {
                    continue;
                  }

                  const partial = unit.material.getProperty(prop, passIdx);

                  if (partial && partial.image && partial.image.data) {
                    const region = new BufferTextureCopy();
                    region.texOffset.x = unit.offset.x * this.atlasSize;
                    region.texOffset.y = unit.offset.y * this.atlasSize;
                    region.texExtent.width = unit.size.x * this.atlasSize;
                    region.texExtent.height = unit.size.y * this.atlasSize;
                    const {
                      data
                    } = partial.image;

                    if (!ArrayBuffer.isView(data)) {
                      texImages.push(data);
                      texImageRegions.push(region);
                    } else {
                      texBuffers.push(data);
                      texBufferRegions.push(region);
                    }
                  }
                }

                const gfxTex = target.getGFXTexture();
                const {
                  device
                } = legacyCC.director.root;

                if (texBuffers.length > 0) {
                  device.copyBuffersToTexture(texBuffers, gfxTex, texBufferRegions);
                }

                if (texImages.length > 0) {
                  device.copyTexImagesToTexture(texImages, gfxTex, texImageRegions);
                }
              }

              createTexture(prop) {
                const tex = new Texture2D();
                tex.setFilters(Filter$1.LINEAR, Filter$1.LINEAR);
                tex.setMipFilter(Filter$1.NEAREST);
                tex.reset({
                  width: this.atlasSize,
                  height: this.atlasSize,
                  format: PixelFormat.RGBA8888
                });
                this._textures[prop] = tex;
                return tex;
              }

              resizeAtlases() {
                for (const prop in this._textures) {
                  const tex = this._textures[prop];
                  tex.reset({
                    width: this.atlasSize,
                    height: this.atlasSize,
                    format: PixelFormat.RGBA8888
                  });
                }
              }

              _createUnitMesh(unitIdx, mesh) {
                const newMeshStruct = JSON.parse(JSON.stringify(mesh.struct));
                const modifiedBundles = {};

                for (let p = 0; p < mesh.struct.primitives.length; p++) {
                  const primitive = mesh.struct.primitives[p];
                  let uvOffset = 0;
                  let uvFormat = Format.UNKNOWN;
                  let bundleIdx = 0;

                  for (; bundleIdx < primitive.vertexBundelIndices.length; bundleIdx++) {
                    const bundle = mesh.struct.vertexBundles[primitive.vertexBundelIndices[bundleIdx]];
                    uvOffset = bundle.view.offset;
                    uvFormat = Format.UNKNOWN;

                    for (let a = 0; a < bundle.attributes.length; a++) {
                      const attr = bundle.attributes[a];

                      if (attr.name === AttributeName.ATTR_TEX_COORD) {
                        uvFormat = attr.format;
                        break;
                      }

                      uvOffset += FormatInfos[attr.format].size;
                    }

                    if (uvFormat) {
                      break;
                    }
                  }

                  if (modifiedBundles[bundleIdx] !== undefined) {
                    continue;
                  }

                  modifiedBundles[bundleIdx] = [uvFormat, uvOffset];
                  const newBundle = newMeshStruct.vertexBundles[bundleIdx];
                  newBundle.attributes.push(batch_id);
                  newBundle.attributes.push(batch_uv);
                  newBundle.view.offset = 0;
                  newBundle.view.length += newBundle.view.count * batch_extras_size;
                  newBundle.view.stride += batch_extras_size;
                }

                let totalLength = 0;

                for (let b = 0; b < newMeshStruct.vertexBundles.length; b++) {
                  totalLength += newMeshStruct.vertexBundles[b].view.length;
                }

                for (let p = 0; p < newMeshStruct.primitives.length; p++) {
                  const pm = newMeshStruct.primitives[p];

                  if (pm.indexView) {
                    pm.indexView.offset = totalLength;
                    totalLength += pm.indexView.length;
                  }
                }

                const newMeshData = new Uint8Array(totalLength);
                const oldMeshData = mesh.data;
                const newDataView = new DataView(newMeshData.buffer);
                const oldDataView = new DataView(oldMeshData.buffer);
                const {
                  isLittleEndian
                } = legacyCC.sys;

                for (const b in modifiedBundles) {
                  const newBundle = newMeshStruct.vertexBundles[b];
                  const oldBundle = mesh.struct.vertexBundles[b];
                  const [uvFormat, uvOffset] = modifiedBundles[b];
                  const uvs = readBuffer(oldDataView, uvFormat, uvOffset, oldBundle.view.length, oldBundle.view.stride);
                  const oldView = oldBundle.view;
                  const newView = newBundle.view;
                  const oldStride = oldView.stride;
                  const newStride = newView.stride;
                  let oldOffset = oldView.offset;
                  let newOffset = newView.offset;

                  for (let j = 0; j < newView.count; j++) {
                    const srcVertex = oldMeshData.subarray(oldOffset, oldOffset + oldStride);
                    newMeshData.set(srcVertex, newOffset);
                    newDataView.setFloat32(newOffset + oldStride, unitIdx);
                    newDataView.setFloat32(newOffset + oldStride + 4, uvs[j * 2], isLittleEndian);
                    newDataView.setFloat32(newOffset + oldStride + 8, uvs[j * 2 + 1], isLittleEndian);
                    newOffset += newStride;
                    oldOffset += oldStride;
                  }
                }

                for (let k = 0; k < newMeshStruct.primitives.length; k++) {
                  const oldPrimitive = mesh.struct.primitives[k];
                  const newPrimitive = newMeshStruct.primitives[k];

                  if (oldPrimitive.indexView && newPrimitive.indexView) {
                    const oldStride = oldPrimitive.indexView.stride;
                    const newStride = newPrimitive.indexView.stride;
                    let oldOffset = oldPrimitive.indexView.offset;
                    let newOffset = newPrimitive.indexView.offset;

                    for (let j = 0; j < newPrimitive.indexView.count; j++) {
                      const srcIndices = oldMeshData.subarray(oldOffset, oldOffset + oldStride);
                      newMeshData.set(srcIndices, newOffset);
                      newOffset += newStride;
                      oldOffset += oldStride;
                    }
                  }
                }

                const newMesh = new Mesh();
                newMesh.reset({
                  struct: newMeshStruct,
                  data: newMeshData
                });
                return newMesh;
              }

            }, _temp2$2), (_descriptor7$2 = _applyDecoratedDescriptor(_class5$2.prototype, "atlasSize", [serializable, _dec10$3], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1024;
              }
            }), _descriptor8$2 = _applyDecoratedDescriptor(_class5$2.prototype, "batchableTextureNames", [_dec11$2, serializable, _dec12$2], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor9$1 = _applyDecoratedDescriptor(_class5$2.prototype, "units", [_dec13$1, serializable, _dec14], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _applyDecoratedDescriptor(_class5$2.prototype, "mesh", [override, _dec15], Object.getOwnPropertyDescriptor(_class5$2.prototype, "mesh"), _class5$2.prototype), _applyDecoratedDescriptor(_class5$2.prototype, "skeleton", [override, _dec16], Object.getOwnPropertyDescriptor(_class5$2.prototype, "skeleton"), _class5$2.prototype)), _class5$2)) || _class4$2) || _class4$2) || _class4$2) || _class4$2) || _class4$2));

            legacyCC.SkinningModelComponent = SkinnedMeshRenderer;
            js.setClassAlias(SkinnedMeshRenderer, 'cc.SkinningModelComponent');
            legacyCC.SkinningModelUnit = SkinnedMeshUnit;
            js.setClassAlias(SkinnedMeshUnit, 'cc.SkinningModelUnit');
            legacyCC.BatchedSkinningModelComponent = SkinnedMeshBatchRenderer;
            js.setClassAlias(SkinnedMeshBatchRenderer, 'cc.BatchedSkinningModelComponent');

            const m4_1$3 = new Mat4();
            const m4_2$1 = new Mat4();
            class SkeletalAnimationState extends AnimationState$2 {
              constructor(clip, name = '') {
                super(clip, name);
                this._frames = 1;
                this._bakedDuration = 0;
                this._animInfo = null;
                this._sockets = [];
                this._animInfoMgr = void 0;
                this._parent = null;
                this._curvesInited = false;
                this._animInfoMgr = legacyCC.director.root.dataPoolManager.jointAnimationInfo;
              }

              initialize(root) {
                if (this._curveLoaded) {
                  return;
                }

                this._parent = root.getComponent('cc.SkeletalAnimation');
                const baked = this._parent.useBakedAnimation;
                this._doNotCreateEval = baked;
                super.initialize(root);
                this._curvesInited = !baked;
                const {
                  frames,
                  samples
                } = SkelAnimDataHub.getOrExtract(this.clip);
                this._frames = frames - 1;
                this._animInfo = this._animInfoMgr.getData(root.uuid);
                this._bakedDuration = this._frames / samples;
              }

              onPlay() {
                super.onPlay();
                const baked = this._parent.useBakedAnimation;

                if (baked) {
                  this._sampleCurves = this._sampleCurvesBaked;
                  this.duration = this._bakedDuration;

                  this._animInfoMgr.switchClip(this._animInfo, this.clip);

                  const users = this._parent.getUsers();

                  users.forEach(user => {
                    user.uploadAnimation(this.clip);
                  });
                } else {
                  this._sampleCurves = super._sampleCurves;
                  this.duration = this.clip.duration;

                  if (!this._curvesInited) {
                    this._curveLoaded = false;
                    super.initialize(this._targetNode);
                    this._curvesInited = true;
                  }
                }
              }

              rebuildSocketCurves(sockets) {
                this._sockets.length = 0;

                if (!this._targetNode) {
                  return;
                }

                const root = this._targetNode;

                for (let i = 0; i < sockets.length; ++i) {
                  const socket = sockets[i];
                  const targetNode = root.getChildByPath(socket.path);

                  if (!socket.target) {
                    continue;
                  }

                  const clipData = SkelAnimDataHub.getOrExtract(this.clip);
                  let animPath = socket.path;
                  let source = clipData.joints[animPath];
                  let animNode = targetNode;
                  let downstream;

                  while (!source) {
                    const idx = animPath.lastIndexOf('/');
                    animPath = animPath.substring(0, idx);
                    source = clipData.joints[animPath];

                    if (animNode) {
                      if (!downstream) {
                        downstream = Mat4.identity(m4_2$1);
                      }

                      Mat4.fromRTS(m4_1$3, animNode.rotation, animNode.position, animNode.scale);
                      Mat4.multiply(downstream, m4_1$3, downstream);
                      animNode = animNode.parent;
                    }

                    if (idx < 0) {
                      break;
                    }
                  }

                  const curveData = source && source.transforms;
                  const {
                    frames
                  } = clipData;
                  const transforms = [];

                  for (let f = 0; f < frames; f++) {
                    let mat;

                    if (curveData && downstream) {
                      mat = Mat4.multiply(m4_1$3, curveData[f], downstream);
                    } else if (curveData) {
                      mat = curveData[f];
                    } else if (downstream) {
                      mat = downstream;
                    } else {
                      mat = new Mat4();
                    }

                    const tfm = {
                      pos: new Vec3(),
                      rot: new Quat(),
                      scale: new Vec3()
                    };
                    Mat4.toRTS(mat, tfm.rot, tfm.pos, tfm.scale);
                    transforms.push(tfm);
                  }

                  this._sockets.push({
                    target: socket.target,
                    frames: transforms
                  });
                }
              }

              _setAnimInfoDirty(info, value) {
                info.dirty = value;

                {
                  const key = 'nativeDirty';
                  info[key].fill(value ? 1 : 0);
                }
              }

              _sampleCurvesBaked(time) {
                const ratio = time / this.duration;
                const info = this._animInfo;
                const curFrame = ratio * this._frames + 0.5 | 0;

                if (curFrame === info.data[0]) {
                  return;
                }

                info.data[0] = curFrame;

                this._setAnimInfoDirty(info, true);

                for (let i = 0; i < this._sockets.length; ++i) {
                  const {
                    target,
                    frames
                  } = this._sockets[i];
                  const {
                    pos,
                    rot,
                    scale
                  } = frames[curFrame];
                  target.setRTS(rot, pos, scale);
                }
              }

            } exports('SkeletalAnimationState', SkeletalAnimationState);

            var _dec$7, _dec2$7, _class$7, _class2$7, _descriptor$7, _descriptor2$7, _temp$7, _dec3$7, _dec4$7, _dec5$7, _dec6$6, _dec7$6, _dec8$5, _dec9$5, _dec10$4, _class4$3, _class5$3, _descriptor3$5, _descriptor4$5, _class6$2, _temp2$3;
            let Socket = exports('Socket', (_dec$7 = ccclass('cc.SkeletalAnimation.Socket'), _dec2$7 = type$1(Node), _dec$7(_class$7 = (_class2$7 = (_temp$7 = class Socket {
              constructor(path = '', target = null) {
                _initializerDefineProperty(this, "path", _descriptor$7, this);

                _initializerDefineProperty(this, "target", _descriptor2$7, this);

                this.path = path;
                this.target = target;
              }

            }, _temp$7), (_descriptor$7 = _applyDecoratedDescriptor(_class2$7.prototype, "path", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            }), _descriptor2$7 = _applyDecoratedDescriptor(_class2$7.prototype, "target", [_dec2$7], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            })), _class2$7)) || _class$7));
            js.setClassAlias(Socket, 'cc.SkeletalAnimationComponent.Socket');
            const m4_1$4 = new Mat4();
            const m4_2$2 = new Mat4();

            function collectRecursively(node, prefix = '', out = []) {
              for (let i = 0; i < node.children.length; i++) {
                const child = node.children[i];

                if (!child) {
                  continue;
                }

                const path = prefix ? `${prefix}/${child.name}` : child.name;
                out.push(path);
                collectRecursively(child, path, out);
              }

              return out;
            }

            let SkeletalAnimation = function (v) { return exports({ SkeletalAnimation: v, SkeletalAnimationComponent: v }), v; }((_dec3$7 = ccclass('cc.SkeletalAnimation'), _dec4$7 = help(), _dec5$7 = executionOrder(99), _dec6$6 = menu$1(), _dec7$6 = type$1([Socket]), _dec8$5 = tooltip(), _dec9$5 = tooltip(), _dec10$4 = type$1([Socket]), _dec3$7(_class4$3 = _dec4$7(_class4$3 = _dec5$7(_class4$3 = executeInEditMode(_class4$3 = _dec6$6(_class4$3 = (_class5$3 = (_temp2$3 = _class6$2 = class SkeletalAnimation extends Animation$3 {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "_useBakedAnimation", _descriptor3$5, this);

                _initializerDefineProperty(this, "_sockets", _descriptor4$5, this);

                this._users = new Set();
                this._currentBakedState = null;
              }

              get sockets() {
                return this._sockets;
              }

              set sockets(val) {
                if (!this._useBakedAnimation) {
                  const animMgr = legacyCC.director.getAnimationManager();
                  animMgr.removeSockets(this.node, this._sockets);
                  animMgr.addSockets(this.node, val);
                }

                this._sockets = val;
                this.rebuildSocketAnimations();
              }

              get useBakedAnimation() {
                return this._useBakedAnimation;
              }

              set useBakedAnimation(val) {
                this._useBakedAnimation = val;

                this._removeAllUsers();

                const comps = this.node.getComponentsInChildren(SkinnedMeshRenderer);

                for (let i = 0; i < comps.length; ++i) {
                  const comp = comps[i];

                  if (comp.skinningRoot === this.node) {
                    comp.notifyAnimationUsable(this);
                  }
                }

                if (this._useBakedAnimation) {
                  legacyCC.director.getAnimationManager().removeSockets(this.node, this._sockets);
                } else {
                  legacyCC.director.getAnimationManager().addSockets(this.node, this._sockets);
                  this._currentBakedState = null;
                }
              }

              onDestroy() {
                super.onDestroy();
                legacyCC.director.root.dataPoolManager.jointAnimationInfo.destroy(this.node.uuid);
                legacyCC.director.getAnimationManager().removeSockets(this.node, this._sockets);
              }

              start() {
                this.sockets = this._sockets;
                this.useBakedAnimation = this._useBakedAnimation;
                super.start();
              }

              pause() {
                if (!this._useBakedAnimation) {
                  super.pause();
                } else {
                  var _this$_currentBakedSt;

                  (_this$_currentBakedSt = this._currentBakedState) === null || _this$_currentBakedSt === void 0 ? void 0 : _this$_currentBakedSt.pause();
                }
              }

              resume() {
                if (!this._useBakedAnimation) {
                  super.resume();
                } else {
                  var _this$_currentBakedSt2;

                  (_this$_currentBakedSt2 = this._currentBakedState) === null || _this$_currentBakedSt2 === void 0 ? void 0 : _this$_currentBakedSt2.resume();
                }
              }

              stop() {
                if (!this._useBakedAnimation) {
                  super.stop();
                } else if (this._currentBakedState) {
                  this._currentBakedState.stop();

                  this._currentBakedState = null;
                }
              }

              querySockets() {
                const animPaths = this._defaultClip && Object.keys(SkelAnimDataHub.getOrExtract(this._defaultClip).joints).sort().reduce((acc, cur) => cur.startsWith(acc[acc.length - 1]) ? acc : (acc.push(cur), acc), []) || [];

                if (!animPaths.length) {
                  return ['please specify a valid default animation clip first'];
                }

                const out = [];

                for (let i = 0; i < animPaths.length; i++) {
                  const path = animPaths[i];
                  const node = this.node.getChildByPath(path);

                  if (!node) {
                    continue;
                  }

                  out.push(path);
                  collectRecursively(node, path, out);
                }

                return out;
              }

              rebuildSocketAnimations() {
                for (const socket of this._sockets) {
                  const joint = this.node.getChildByPath(socket.path);
                  const {
                    target
                  } = socket;

                  if (joint && target) {
                    target.name = `${socket.path.substring(socket.path.lastIndexOf('/') + 1)} Socket`;
                    target.parent = this.node;
                    getWorldTransformUntilRoot(joint, this.node, m4_1$4);
                    Mat4.fromRTS(m4_2$2, target.rotation, target.position, target.scale);

                    if (!Mat4.equals(m4_2$2, m4_1$4)) {
                      target.matrix = m4_1$4;
                    }
                  }
                }

                for (const stateName of Object.keys(this._nameToState)) {
                  const state = this._nameToState[stateName];
                  state.rebuildSocketCurves(this._sockets);
                }
              }

              createSocket(path) {
                const socket = this._sockets.find(s => s.path === path);

                if (socket) {
                  return socket.target;
                }

                const joint = this.node.getChildByPath(path);

                if (!joint) {
                  console.warn('illegal socket path');
                  return null;
                }

                const target = new Node();
                target.parent = this.node;

                this._sockets.push(new Socket(path, target));

                this.rebuildSocketAnimations();
                return target;
              }

              addUser(user) {
                this._users.add(user);

                const {
                  _useBakedAnimation: useBakedAnimation
                } = this;
                user.setUseBakedAnimation(useBakedAnimation, true);

                if (useBakedAnimation) {
                  const {
                    _currentBakedState: playingState
                  } = this;

                  if (playingState) {
                    user.uploadAnimation(playingState.clip);
                  }
                }
              }

              removeUser(user) {
                user.setUseBakedAnimation(false);
                user.notifyAnimationUnusable();

                this._users.delete(user);
              }

              getUsers() {
                return this._users;
              }

              _createState(clip, name) {
                return new SkeletalAnimationState(clip, name);
              }

              _doCreateState(clip, name) {
                const state = super._doCreateState(clip, name);

                state.rebuildSocketCurves(this._sockets);
                return state;
              }

              doPlayOrCrossFade(state) {
                const skeletalAnimationState = state;
                this._currentBakedState = skeletalAnimationState;
                skeletalAnimationState.play();
              }

              _removeAllUsers() {
                Array.from(this._users).forEach(user => {
                  this.removeUser(user);
                });
              }

            }, _class6$2.Socket = Socket, _temp2$3), (_applyDecoratedDescriptor(_class5$3.prototype, "sockets", [_dec7$6, _dec8$5], Object.getOwnPropertyDescriptor(_class5$3.prototype, "sockets"), _class5$3.prototype), _applyDecoratedDescriptor(_class5$3.prototype, "useBakedAnimation", [_dec9$5], Object.getOwnPropertyDescriptor(_class5$3.prototype, "useBakedAnimation"), _class5$3.prototype), _descriptor3$5 = _applyDecoratedDescriptor(_class5$3.prototype, "_useBakedAnimation", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _descriptor4$5 = _applyDecoratedDescriptor(_class5$3.prototype, "_sockets", [_dec10$4], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            })), _class5$3)) || _class4$3) || _class4$3) || _class4$3) || _class4$3) || _class4$3));

            legacyCC.SkeletalAnimationComponent = SkeletalAnimation;
            js.setClassAlias(SkeletalAnimation, 'cc.SkeletalAnimationComponent');

            legacyCC.utils = utils;

            const vec3_temp = new Vec3();

            const _worldMatrix = new Mat4();

            function fillVertices3D(node, renderer, renderData, color) {
              const dataList = renderData.data;
              let buffer = renderer.acquireBufferBatch();
              let vertexOffset = buffer.byteOffset >> 2;
              const vertexCount = renderData.vertexCount;
              let indicesOffset = buffer.indicesOffset;
              let vertexId = buffer.vertexOffset;
              const isRecreate = buffer.request(vertexCount, renderData.indicesCount);

              if (!isRecreate) {
                buffer = renderer.currBufferBatch;
                vertexOffset = 0;
                indicesOffset = 0;
                vertexId = 0;
              }

              const vBuf = buffer.vData;
              node.getWorldMatrix(_worldMatrix);

              for (let i = 0; i < vertexCount; i++) {
                const vert = dataList[i];
                Vec3.set(vec3_temp, vert.x, vert.y, 0);
                Vec3.transformMat4(vec3_temp, vec3_temp, _worldMatrix);
                vBuf[vertexOffset++] = vec3_temp.x;
                vBuf[vertexOffset++] = vec3_temp.y;
                vBuf[vertexOffset++] = vec3_temp.z;
                vBuf[vertexOffset++] = vert.u;
                vBuf[vertexOffset++] = vert.v;
                Color$1.toArray(vBuf, color, vertexOffset);
                vertexOffset += 4;
              }

              const iBuf = buffer.iData;

              for (let i = 0; i < renderData.dataLength; i++) {
                iBuf[indicesOffset + i] = vertexId + i;
              }
            }
            function fillMeshVertices3D(node, renderer, renderData, color) {
              const dataList = renderData.data;
              let buffer = renderer.acquireBufferBatch();
              let vertexOffset = buffer.byteOffset >> 2;
              const vertexCount = renderData.vertexCount;
              let indicesOffset = buffer.indicesOffset;
              let vertexId = buffer.vertexOffset;
              const isRecreate = buffer.request(vertexCount, renderData.indicesCount);

              if (!isRecreate) {
                buffer = renderer.currBufferBatch;
                vertexOffset = 0;
                indicesOffset = 0;
                vertexId = 0;
              }

              const vBuf = buffer.vData;
              const iBuf = buffer.iData;
              node.getWorldMatrix(_worldMatrix);

              for (let i = 0; i < vertexCount; i++) {
                const vert = dataList[i];
                Vec3.set(vec3_temp, vert.x, vert.y, 0);
                Vec3.transformMat4(vec3_temp, vec3_temp, _worldMatrix);
                vBuf[vertexOffset++] = vec3_temp.x;
                vBuf[vertexOffset++] = vec3_temp.y;
                vBuf[vertexOffset++] = vec3_temp.z;
                vBuf[vertexOffset++] = vert.u;
                vBuf[vertexOffset++] = vert.v;
                Color$1.toArray(vBuf, color, vertexOffset);
                vertexOffset += 4;
              }

              for (let i = 0, count = vertexCount / 4; i < count; i++) {
                const start = vertexId + i * 4;
                iBuf[indicesOffset++] = start;
                iBuf[indicesOffset++] = start + 1;
                iBuf[indicesOffset++] = start + 2;
                iBuf[indicesOffset++] = start + 1;
                iBuf[indicesOffset++] = start + 3;
                iBuf[indicesOffset++] = start + 2;
              }
            }
            function fillVerticesWithoutCalc3D(node, renderer, renderData, color) {
              const dataList = renderData.data;
              let buffer = renderer.acquireBufferBatch();
              let vertexOffset = buffer.byteOffset >> 2;
              const vertexCount = renderData.vertexCount;
              let indicesOffset = buffer.indicesOffset;
              let vertexId = buffer.vertexOffset;
              const isRecreate = buffer.request(vertexCount, renderData.indicesCount);

              if (!isRecreate) {
                buffer = renderer.currBufferBatch;
                vertexOffset = 0;
                indicesOffset = 0;
                vertexId = 0;
              }

              const vBuf = buffer.vData;

              for (let i = 0; i < vertexCount; i++) {
                const vert = dataList[i];
                vBuf[vertexOffset++] = vert.x;
                vBuf[vertexOffset++] = vert.y;
                vBuf[vertexOffset++] = vert.z;
                vBuf[vertexOffset++] = vert.u;
                vBuf[vertexOffset++] = vert.v;
                Color$1.toArray(vBuf, color, vertexOffset);
                vertexOffset += 4;
              }

              const iBuf = buffer.iData;
              iBuf[indicesOffset++] = vertexId;
              iBuf[indicesOffset++] = vertexId + 1;
              iBuf[indicesOffset++] = vertexId + 2;
              iBuf[indicesOffset++] = vertexId + 1;
              iBuf[indicesOffset++] = vertexId + 3;
              iBuf[indicesOffset++] = vertexId + 2;
            }

            const space = 2;
            class Atlas {
              constructor(width, height) {
                this._texture = void 0;
                this._width = void 0;
                this._height = void 0;
                this._x = void 0;
                this._y = void 0;
                this._nexty = void 0;
                this._innerTextureInfos = {};
                this._innerSpriteFrames = void 0;
                this._count = void 0;
                const texture = new DynamicAtlasTexture();
                texture.initWithSize(width, height);
                this._texture = texture;
                this._width = width;
                this._height = height;
                this._x = space;
                this._y = space;
                this._nexty = space;
                this._innerTextureInfos = {};
                this._innerSpriteFrames = [];
                this._count = 0;
              }

              insertSpriteFrame(spriteFrame) {
                const rect = spriteFrame.rect;
                const texture = spriteFrame.texture;

                const info = this._innerTextureInfos[texture.getId()];

                let sx = rect.x;
                let sy = rect.y;

                if (info) {
                  sx += info.x;
                  sy += info.y;
                } else {
                  const width = texture.width;
                  const height = texture.height;

                  if (this._x + width + space > this._width) {
                    this._x = space;
                    this._y = this._nexty;
                  }

                  if (this._y + height + space > this._nexty) {
                    this._nexty = this._y + height + space;
                  }

                  if (this._nexty > this._height) {
                    return null;
                  }

                  if (legacyCC.internal.dynamicAtlasManager.textureBleeding) {
                    if (width <= 8 || height <= 8) {
                      this._texture.drawTextureAt(texture.image, this._x - 1, this._y - 1);

                      this._texture.drawTextureAt(texture.image, this._x - 1, this._y + 1);

                      this._texture.drawTextureAt(texture.image, this._x + 1, this._y - 1);

                      this._texture.drawTextureAt(texture.image, this._x + 1, this._y + 1);
                    }

                    this._texture.drawTextureAt(texture.image, this._x - 1, this._y);

                    this._texture.drawTextureAt(texture.image, this._x + 1, this._y);

                    this._texture.drawTextureAt(texture.image, this._x, this._y - 1);

                    this._texture.drawTextureAt(texture.image, this._x, this._y + 1);
                  }

                  this._texture.drawTextureAt(texture.image, this._x, this._y);

                  this._innerTextureInfos[texture.getId()] = {
                    x: this._x,
                    y: this._y,
                    texture
                  };
                  this._count++;
                  sx += this._x;
                  sy += this._y;
                  this._x += width + space;
                }

                const frame = {
                  x: sx,
                  y: sy,
                  texture: this._texture
                };

                this._innerSpriteFrames.push(spriteFrame);

                return frame;
              }

              deleteInnerTexture(texture) {
                if (texture && this._innerTextureInfos[texture.getId()]) {
                  delete this._innerTextureInfos[texture.getId()];
                  this._count--;
                }
              }

              isEmpty() {
                return this._count <= 0;
              }

              reset() {
                this._x = space;
                this._y = space;
                this._nexty = space;
                const frames = this._innerSpriteFrames;

                for (let i = 0, l = frames.length; i < l; i++) {
                  const frame = frames[i];

                  if (!frame.isValid) {
                    continue;
                  }

                  frame._resetDynamicAtlasFrame();
                }

                this._innerSpriteFrames.length = 0;
                this._innerTextureInfos = {};
              }

              destroy() {
                this.reset();

                this._texture.destroy();
              }

            }
            class DynamicAtlasTexture extends Texture2D {
              initWithSize(width, height, format = PixelFormat.RGBA8888) {
                this.reset({
                  width,
                  height,
                  format
                });
              }

              drawTextureAt(image, x, y) {
                const gfxTexture = this.getGFXTexture();

                if (!image || !gfxTexture) {
                  return;
                }

                const gfxDevice = this._getGFXDevice();

                if (!gfxDevice) {
                  console.warn('Unable to get device');
                  return;
                }

                const region = new BufferTextureCopy();
                region.texOffset.x = x;
                region.texOffset.y = y;
                region.texExtent.width = image.width;
                region.texExtent.height = image.height;
                gfxDevice.copyTexImagesToTexture([image.data], gfxTexture, [region]);
              }

            }

            class DynamicAtlasManager {
              constructor() {
                this._atlases = [];
                this._atlasIndex = -1;
                this._maxAtlasCount = 5;
                this._textureSize = 2048;
                this._maxFrameSize = 512;
                this._textureBleeding = true;
                this._enabled = false;
              }

              get enabled() {
                return this._enabled;
              }

              set enabled(value) {
                if (this._enabled === value) return;

                if (value) {
                  this.reset();
                  legacyCC.director.on(legacyCC.Director.EVENT_BEFORE_SCENE_LAUNCH, this.beforeSceneLoad, this);
                } else {
                  this.reset();
                  legacyCC.director.off(legacyCC.Director.EVENT_BEFORE_SCENE_LAUNCH, this.beforeSceneLoad, this);
                }

                this._enabled = value;
              }

              get maxAtlasCount() {
                return this._maxAtlasCount;
              }

              set maxAtlasCount(value) {
                this._maxAtlasCount = value;
              }

              get atlasCount() {
                return this._atlases.length;
              }

              get textureBleeding() {
                return this._textureBleeding;
              }

              set textureBleeding(enable) {
                this._textureBleeding = enable;
              }

              get textureSize() {
                return this._textureSize;
              }

              set textureSize(value) {
                this._textureSize = value;
              }

              get maxFrameSize() {
                return this._maxFrameSize;
              }

              set maxFrameSize(value) {
                this._maxFrameSize = value;
              }

              newAtlas() {
                let atlas = this._atlases[++this._atlasIndex];

                if (!atlas) {
                  atlas = new Atlas(this._textureSize, this._textureSize);

                  this._atlases.push(atlas);
                }

                return atlas;
              }

              beforeSceneLoad() {
                this.reset();
              }

              insertSpriteFrame(spriteFrame) {
                if (!this._enabled || this._atlasIndex === this._maxAtlasCount || !spriteFrame || spriteFrame._original) return null;
                if (!spriteFrame.packable) return null;
                const sampler = spriteFrame.texture.getSamplerInfo();

                if (sampler.minFilter !== Filter$1.LINEAR || sampler.magFilter !== Filter$1.LINEAR || sampler.mipFilter !== Filter$1.NONE) {
                  return null;
                }

                let atlas = this._atlases[this._atlasIndex];

                if (!atlas) {
                  atlas = this.newAtlas();
                }

                const frame = atlas.insertSpriteFrame(spriteFrame);

                if (!frame && this._atlasIndex !== this._maxAtlasCount) {
                  atlas = this.newAtlas();
                  return atlas.insertSpriteFrame(spriteFrame);
                }

                return frame;
              }

              reset() {
                for (let i = 0, l = this._atlases.length; i < l; i++) {
                  this._atlases[i].destroy();
                }

                this._atlases.length = 0;
                this._atlasIndex = -1;
              }

              deleteAtlasSpriteFrame(spriteFrame) {
                if (!spriteFrame._original) return;
                let atlas;

                for (let i = this._atlases.length - 1; i >= 0; i--) {
                  atlas = this._atlases[i];
                  js.array.fastRemove(atlas._innerSpriteFrames, spriteFrame);
                }

                const texture = spriteFrame._original._texture;
                this.deleteAtlasTexture(texture);
              }

              deleteAtlasTexture(texture) {
                if (texture) {
                  for (let i = this._atlases.length - 1; i >= 0; i--) {
                    this._atlases[i].deleteInnerTexture(texture);

                    if (this._atlases[i].isEmpty()) {
                      this._atlases[i].destroy();

                      this._atlases.splice(i, 1);

                      this._atlasIndex--;
                    }
                  }
                }
              }

              packToDynamicAtlas(comp, frame) {

                if (!frame._original && frame.packable) {
                  const packedFrame = this.insertSpriteFrame(frame);

                  if (packedFrame) {
                    frame._setDynamicAtlasFrame(packedFrame);
                  }
                }
              }

            }
            DynamicAtlasManager.instance = void 0;
            const dynamicAtlasManager = exports('dynamicAtlasManager', DynamicAtlasManager.instance = new DynamicAtlasManager());
            legacyCC.internal.dynamicAtlasManager = dynamicAtlasManager;

            var _dec$8, _class$8, _temp$8;
            const INSET_LEFT = 0;
            const INSET_TOP = 1;
            const INSET_RIGHT = 2;
            const INSET_BOTTOM = 3;
            const temp_uvs = [{
              u: 0,
              v: 0
            }, {
              u: 0,
              v: 0
            }, {
              u: 0,
              v: 0
            }, {
              u: 0,
              v: 0
            }];
            let SpriteFrame = exports('SpriteFrame', (_dec$8 = ccclass('cc.SpriteFrame'), _dec$8(_class$8 = (_temp$8 = class SpriteFrame extends Asset {
              static createWithImage(imageSourceOrImageAsset) {
                const img = imageSourceOrImageAsset instanceof ImageAsset ? imageSourceOrImageAsset : new ImageAsset(imageSourceOrImageAsset);
                const tex = new Texture2D();
                tex.image = img;
                const spf = new SpriteFrame();
                spf.texture = tex;
                return spf;
              }

              get insetTop() {
                return this._capInsets[INSET_TOP];
              }

              set insetTop(value) {
                if (this._capInsets[INSET_TOP] === value) {
                  return;
                }

                this._capInsets[INSET_TOP] = value;

                if (this._texture) {
                  this._calculateSlicedUV();
                }
              }

              get insetBottom() {
                return this._capInsets[INSET_BOTTOM];
              }

              set insetBottom(value) {
                if (this._capInsets[INSET_BOTTOM] === value) {
                  return;
                }

                this._capInsets[INSET_BOTTOM] = value;

                if (this._texture) {
                  this._calculateSlicedUV();
                }
              }

              get insetLeft() {
                return this._capInsets[INSET_LEFT];
              }

              set insetLeft(value) {
                if (this._capInsets[INSET_LEFT] === value) {
                  return;
                }

                this._capInsets[INSET_LEFT] = value;

                if (this._texture) {
                  this._calculateSlicedUV();
                }
              }

              get insetRight() {
                return this._capInsets[INSET_RIGHT];
              }

              set insetRight(value) {
                if (this._capInsets[INSET_RIGHT] === value) {
                  return;
                }

                this._capInsets[INSET_RIGHT] = value;

                if (this._texture) {
                  this._calculateSlicedUV();
                }
              }

              get rect() {
                return this._rect;
              }

              set rect(value) {
                if (this._rect.equals(value)) {
                  return;
                }

                this._rect.set(value);

                if (this._texture) {
                  this._calculateUV();
                }
              }

              get originalSize() {
                return this._originalSize;
              }

              set originalSize(value) {
                if (this._originalSize.equals(value)) {
                  return;
                }

                this._originalSize.set(value);

                if (this._texture) {
                  this._calculateUV();
                }
              }

              get offset() {
                return this._offset;
              }

              set offset(value) {
                this._offset.set(value);
              }

              get rotated() {
                return this._rotated;
              }

              set rotated(rotated) {
                if (this._rotated === rotated) {
                  return;
                }

                this._rotated = rotated;

                if (this._texture) {
                  this._calculateUV();
                }
              }

              get texture() {
                return this._texture;
              }

              set texture(value) {
                if (!value) {
                  warnID(3122, this.name);
                  return;
                }

                if (value === this._texture) {
                  return;
                }

                this.reset({
                  texture: value
                }, true);
              }

              get atlasUuid() {
                return this._atlasUuid;
              }

              set atlasUuid(value) {
                this._atlasUuid = value;
              }

              get width() {
                return this._texture.width;
              }

              get height() {
                return this._texture.height;
              }

              set _textureSource(value) {
                if (window.Build) {
                  this._texture = value;
                  return;
                }

                if (value) {
                  this._refreshTexture(value);

                  this._calculateUV();
                }
              }

              get flipUVX() {
                return this._isFlipUVX;
              }

              set flipUVX(value) {
                this._isFlipUVX = value;

                this._calculateUV();
              }

              get flipUVY() {
                return this._isFlipUVY;
              }

              set flipUVY(value) {
                this._isFlipUVY = value;

                this._calculateUV();
              }

              get packable() {
                return this._packable;
              }

              set packable(value) {
                this._packable = value;
              }

              get original() {
                return this._original;
              }

              constructor() {
                super();
                this.vertices = null;
                this.uv = [];
                this.uvHash = 0;
                this.unbiasUV = [];
                this.uvSliced = [];
                this._rect = new Rect$1();
                this._offset = new Vec2();
                this._originalSize = new Size$1();
                this._rotated = false;
                this._capInsets = [0, 0, 0, 0];
                this._atlasUuid = '';
                this._texture = void 0;
                this._isFlipUVY = false;
                this._isFlipUVX = false;
                this._original = null;
                this._packable = true;
              }

              textureLoaded() {
                return !!this.texture;
              }

              isRotated() {
                return this._rotated;
              }

              setRotated(rotated) {
                this.rotated = rotated;
              }

              getRect(out) {
                if (out) {
                  out.set(this._rect);
                  return out;
                }

                return this._rect.clone();
              }

              setRect(rect) {
                this.rect = rect;
              }

              getOriginalSize(out) {
                if (out) {
                  out.set(this._originalSize);
                  return out;
                }

                return this._originalSize.clone();
              }

              setOriginalSize(size) {
                this.originalSize = size;
              }

              getOffset(out) {
                if (out) {
                  out.set(this._offset);
                  return out;
                }

                return this._offset.clone();
              }

              setOffset(offset) {
                this.offset = offset;
              }

              getGFXTexture() {
                return this._texture.getGFXTexture();
              }

              getGFXSampler() {
                return this._texture.getGFXSampler();
              }

              getHash() {
                return this._texture.getHash();
              }

              getSamplerInfo() {
                return this._texture.getSamplerInfo();
              }

              reset(info, clearData = false) {
                let calUV = false;

                if (clearData) {
                  this._originalSize.set(0, 0);

                  this._rect.set(0, 0, 0, 0);

                  this._offset.set(0, 0);

                  this._capInsets = [0, 0, 0, 0];
                  this._rotated = false;
                  calUV = true;
                }

                if (info) {
                  if (info.texture) {
                    this._rect.x = this._rect.y = 0;
                    this._rect.width = info.texture.width;
                    this._rect.height = info.texture.height;

                    this._refreshTexture(info.texture);

                    this.checkRect(this._texture);
                  }

                  if (info.originalSize) {
                    this._originalSize.set(info.originalSize);
                  }

                  if (info.rect) {
                    this._rect.set(info.rect);
                  }

                  if (info.offset) {
                    this._offset.set(info.offset);
                  }

                  if (info.borderTop !== undefined) {
                    this._capInsets[INSET_TOP] = info.borderTop;
                  }

                  if (info.borderBottom !== undefined) {
                    this._capInsets[INSET_BOTTOM] = info.borderBottom;
                  }

                  if (info.borderLeft !== undefined) {
                    this._capInsets[INSET_LEFT] = info.borderLeft;
                  }

                  if (info.borderRight !== undefined) {
                    this._capInsets[INSET_RIGHT] = info.borderRight;
                  }

                  if (info.isRotate !== undefined) {
                    this._rotated = !!info.isRotate;
                  }

                  if (info.isFlipUv !== undefined) {
                    this._isFlipUVY = !!info.isFlipUv;
                  }

                  calUV = true;
                }

                if (calUV && this.texture) {
                  this._calculateUV();
                }
              }

              checkRect(texture) {
                const rect = this._rect;
                let maxX = rect.x;
                let maxY = rect.y;

                if (this._rotated) {
                  maxX += rect.height;
                  maxY += rect.width;
                } else {
                  maxX += rect.width;
                  maxY += rect.height;
                }

                if (maxX > texture.width) {
                  errorID(3300, `${this.name}/${texture.name}`, maxX, texture.width);
                  return false;
                }

                if (maxY > texture.height) {
                  errorID(3301, `${this.name}/${texture.name}`, maxY, texture.height);
                  return false;
                }

                return true;
              }

              destroy() {
                if (this._packable && dynamicAtlasManager) {
                  dynamicAtlasManager.deleteAtlasSpriteFrame(this);
                }

                return super.destroy();
              }

              _calculateSlicedUV() {

                const rect = this._rect;
                const tex = this.texture;
                const atlasWidth = tex.width;
                const atlasHeight = tex.height;
                const leftWidth = this._capInsets[INSET_LEFT];
                const rightWidth = this._capInsets[INSET_RIGHT];
                const centerWidth = rect.width - leftWidth - rightWidth;
                const topHeight = this._capInsets[INSET_TOP];
                const bottomHeight = this._capInsets[INSET_BOTTOM];
                const centerHeight = rect.height - topHeight - bottomHeight;
                const uvSliced = this.uvSliced;
                uvSliced.length = 0;

                if (this._rotated) {
                  temp_uvs[0].u = rect.x / atlasWidth;
                  temp_uvs[1].u = (rect.x + bottomHeight) / atlasWidth;
                  temp_uvs[2].u = (rect.x + bottomHeight + centerHeight) / atlasWidth;
                  temp_uvs[3].u = (rect.x + rect.height) / atlasWidth;
                  temp_uvs[3].v = rect.y / atlasHeight;
                  temp_uvs[2].v = (rect.y + leftWidth) / atlasHeight;
                  temp_uvs[1].v = (rect.y + leftWidth + centerWidth) / atlasHeight;
                  temp_uvs[0].v = (rect.y + rect.width) / atlasHeight;

                  for (let row = 0; row < 4; ++row) {
                    const rowD = temp_uvs[row];

                    for (let col = 0; col < 4; ++col) {
                      const colD = temp_uvs[3 - col];
                      uvSliced.push({
                        u: rowD.u,
                        v: colD.v
                      });
                    }
                  }
                } else {
                  temp_uvs[0].u = rect.x / atlasWidth;
                  temp_uvs[1].u = (rect.x + leftWidth) / atlasWidth;
                  temp_uvs[2].u = (rect.x + leftWidth + centerWidth) / atlasWidth;
                  temp_uvs[3].u = (rect.x + rect.width) / atlasWidth;
                  temp_uvs[3].v = rect.y / atlasHeight;
                  temp_uvs[2].v = (rect.y + topHeight) / atlasHeight;
                  temp_uvs[1].v = (rect.y + topHeight + centerHeight) / atlasHeight;
                  temp_uvs[0].v = (rect.y + rect.height) / atlasHeight;

                  for (let row = 0; row < 4; ++row) {
                    const rowD = temp_uvs[row];

                    for (let col = 0; col < 4; ++col) {
                      const colD = temp_uvs[col];
                      uvSliced.push({
                        u: colD.u,
                        v: rowD.v
                      });
                    }
                  }
                }
              }

              _calculateUV() {
                const rect = this._rect;
                const uv = this.uv;
                const unbiasUV = this.unbiasUV;
                const tex = this.texture;
                const texw = tex.width;
                const texh = tex.height;

                if (this._rotated) {
                  const l = texw === 0 ? 0 : rect.x / texw;
                  const r = texw === 0 ? 1 : (rect.x + rect.height) / texw;
                  const t = texh === 0 ? 0 : rect.y / texh;
                  const b = texh === 0 ? 1 : (rect.y + rect.width) / texh;

                  if (this._isFlipUVX && this._isFlipUVY) {
                    uv[0] = r;
                    uv[1] = b;
                    uv[2] = r;
                    uv[3] = t;
                    uv[4] = l;
                    uv[5] = b;
                    uv[6] = l;
                    uv[7] = t;
                  } else if (this._isFlipUVX) {
                    uv[0] = r;
                    uv[1] = t;
                    uv[2] = r;
                    uv[3] = b;
                    uv[4] = l;
                    uv[5] = t;
                    uv[6] = l;
                    uv[7] = b;
                  } else if (this._isFlipUVY) {
                    uv[0] = l;
                    uv[1] = b;
                    uv[2] = l;
                    uv[3] = t;
                    uv[4] = r;
                    uv[5] = b;
                    uv[6] = r;
                    uv[7] = t;
                  } else {
                    uv[0] = l;
                    uv[1] = t;
                    uv[2] = l;
                    uv[3] = b;
                    uv[4] = r;
                    uv[5] = t;
                    uv[6] = r;
                    uv[7] = b;
                  }

                  const ul = texw === 0 ? 0 : rect.x / texw;
                  const ur = texw === 0 ? 1 : (rect.x + rect.height) / texw;
                  const ut = texh === 0 ? 0 : rect.y / texh;
                  const ub = texh === 0 ? 1 : (rect.y + rect.width) / texh;

                  if (this._isFlipUVX && this._isFlipUVY) {
                    unbiasUV[0] = ur;
                    unbiasUV[1] = ub;
                    unbiasUV[2] = ur;
                    unbiasUV[3] = ut;
                    unbiasUV[4] = ul;
                    unbiasUV[5] = ub;
                    unbiasUV[6] = ul;
                    unbiasUV[7] = ut;
                  } else if (this._isFlipUVX) {
                    unbiasUV[0] = ur;
                    unbiasUV[1] = ut;
                    unbiasUV[2] = ur;
                    unbiasUV[3] = ub;
                    unbiasUV[4] = ul;
                    unbiasUV[5] = ut;
                    unbiasUV[6] = ul;
                    unbiasUV[7] = ub;
                  } else if (this._isFlipUVY) {
                    unbiasUV[0] = ul;
                    unbiasUV[1] = ub;
                    unbiasUV[2] = ul;
                    unbiasUV[3] = ut;
                    unbiasUV[4] = ur;
                    unbiasUV[5] = ub;
                    unbiasUV[6] = ur;
                    unbiasUV[7] = ut;
                  } else {
                    unbiasUV[0] = ul;
                    unbiasUV[1] = ut;
                    unbiasUV[2] = ul;
                    unbiasUV[3] = ub;
                    unbiasUV[4] = ur;
                    unbiasUV[5] = ut;
                    unbiasUV[6] = ur;
                    unbiasUV[7] = ub;
                  }
                } else {
                  const l = texw === 0 ? 0 : rect.x / texw;
                  const r = texw === 0 ? 1 : (rect.x + rect.width) / texw;
                  const b = texh === 0 ? 1 : (rect.y + rect.height) / texh;
                  const t = texh === 0 ? 0 : rect.y / texh;

                  if (this._isFlipUVX && this._isFlipUVY) {
                    uv[0] = r;
                    uv[1] = t;
                    uv[2] = l;
                    uv[3] = t;
                    uv[4] = r;
                    uv[5] = b;
                    uv[6] = l;
                    uv[7] = b;
                  } else if (this._isFlipUVX) {
                    uv[0] = r;
                    uv[1] = b;
                    uv[2] = l;
                    uv[3] = b;
                    uv[4] = r;
                    uv[5] = t;
                    uv[6] = l;
                    uv[7] = t;
                  } else if (this._isFlipUVY) {
                    uv[0] = l;
                    uv[1] = t;
                    uv[2] = r;
                    uv[3] = t;
                    uv[4] = l;
                    uv[5] = b;
                    uv[6] = r;
                    uv[7] = b;
                  } else {
                    uv[0] = l;
                    uv[1] = b;
                    uv[2] = r;
                    uv[3] = b;
                    uv[4] = l;
                    uv[5] = t;
                    uv[6] = r;
                    uv[7] = t;
                  }

                  const ul = texw === 0 ? 0 : rect.x / texw;
                  const ur = texw === 0 ? 1 : (rect.x + rect.width) / texw;
                  const ub = texh === 0 ? 1 : (rect.y + rect.height) / texh;
                  const ut = texh === 0 ? 0 : rect.y / texh;

                  if (this._isFlipUVX && this._isFlipUVY) {
                    unbiasUV[0] = ur;
                    unbiasUV[1] = ut;
                    unbiasUV[2] = ul;
                    unbiasUV[3] = ut;
                    unbiasUV[4] = ur;
                    unbiasUV[5] = ub;
                    unbiasUV[6] = ul;
                    unbiasUV[7] = ub;
                  } else if (this._isFlipUVX) {
                    unbiasUV[0] = ur;
                    unbiasUV[1] = ub;
                    unbiasUV[2] = ul;
                    unbiasUV[3] = ub;
                    unbiasUV[4] = ur;
                    unbiasUV[5] = ut;
                    unbiasUV[6] = ul;
                    unbiasUV[7] = ut;
                  } else if (this._isFlipUVY) {
                    unbiasUV[0] = ul;
                    unbiasUV[1] = ut;
                    unbiasUV[2] = ur;
                    unbiasUV[3] = ut;
                    unbiasUV[4] = ul;
                    unbiasUV[5] = ub;
                    unbiasUV[6] = ur;
                    unbiasUV[7] = ub;
                  } else {
                    unbiasUV[0] = ul;
                    unbiasUV[1] = ub;
                    unbiasUV[2] = ur;
                    unbiasUV[3] = ub;
                    unbiasUV[4] = ul;
                    unbiasUV[5] = ut;
                    unbiasUV[6] = ur;
                    unbiasUV[7] = ut;
                  }
                }

                let uvHashStr = '';

                for (let i = 0; i < uv.length; i++) {
                  uvHashStr += uv[i];
                }

                this.uvHash = murmurhash2_32_gc(uvHashStr, 666);
                const vertices = this.vertices;

                if (vertices) {
                  vertices.nu.length = 0;
                  vertices.nv.length = 0;

                  for (let i = 0; i < vertices.u.length; i++) {
                    vertices.nu[i] = vertices.u[i] / texw;
                    vertices.nv[i] = vertices.v[i] / texh;
                  }
                }

                this._calculateSlicedUV();
              }

              _setDynamicAtlasFrame(frame) {
                if (!frame) return;
                this._original = {
                  _texture: this._texture,
                  _x: this._rect.x,
                  _y: this._rect.y
                };
                this._texture = frame.texture;
                this._rect.x = frame.x;
                this._rect.y = frame.y;

                this._calculateUV();
              }

              _resetDynamicAtlasFrame() {
                if (!this._original) return;
                this._rect.x = this._original._x;
                this._rect.y = this._original._y;
                this._texture = this._original._texture;
                this._original = null;

                this._calculateUV();
              }

              _checkPackable() {
                const dynamicAtlas = dynamicAtlasManager;
                if (!dynamicAtlas) return;
                const texture = this._texture;

                if (!(texture instanceof Texture2D) || texture.isCompressed) {
                  this._packable = false;
                  return;
                }

                const w = this.width;
                const h = this.height;

                if (!texture.image || w > dynamicAtlas.maxFrameSize || h > dynamicAtlas.maxFrameSize) {
                  this._packable = false;
                  return;
                }

                if (texture.image && texture.image instanceof HTMLCanvasElement) {
                  this._packable = true;
                }
              }

              _serialize(ctxForExporting) {

                return null;
              }

              _deserialize(serializeData, handle) {
                const data = serializeData;
                const rect = data.rect;

                if (rect) {
                  this._rect = new Rect$1(rect.x, rect.y, rect.width, rect.height);
                }

                const offset = data.offset;

                if (data.offset) {
                  this._offset = new Vec2(offset.x, offset.y);
                }

                const originalSize = data.originalSize;

                if (data.originalSize) {
                  this._originalSize = new Size$1(originalSize.width, originalSize.height);
                }

                this._rotated = !!data.rotated;
                this._name = data.name;
                this._packable = !!data.packable;
                const capInsets = data.capInsets;

                if (capInsets) {
                  this._capInsets[INSET_LEFT] = capInsets[INSET_LEFT];
                  this._capInsets[INSET_TOP] = capInsets[INSET_TOP];
                  this._capInsets[INSET_RIGHT] = capInsets[INSET_RIGHT];
                  this._capInsets[INSET_BOTTOM] = capInsets[INSET_BOTTOM];
                }

                this.vertices = data.vertices;

                if (this.vertices) {
                  this.vertices.nu = [];
                  this.vertices.nv = [];
                }
              }

              clone() {
                var _v$nu, _v$u, _v$nv, _v$v;

                const sp = new SpriteFrame();
                const v = this.vertices;
                sp.vertices = v ? {
                  x: v.x,
                  y: v.y,
                  triangles: v.triangles,
                  nu: (_v$nu = v.nu) === null || _v$nu === void 0 ? void 0 : _v$nu.slice(0),
                  u: (_v$u = v.u) === null || _v$u === void 0 ? void 0 : _v$u.slice(0),
                  nv: (_v$nv = v.nv) === null || _v$nv === void 0 ? void 0 : _v$nv.slice(0),
                  v: (_v$v = v.v) === null || _v$v === void 0 ? void 0 : _v$v.slice(0)
                } : null;
                sp.uv.splice(0, sp.uv.length, ...this.uv);
                sp.uvHash = this.uvHash;
                sp.unbiasUV.splice(0, sp.unbiasUV.length, ...this.unbiasUV);
                sp.uvSliced.splice(0, sp.uvSliced.length, ...this.uvSliced);

                sp._rect.set(this._rect);

                sp._offset.set(this._offset);

                sp._originalSize.set(this._originalSize);

                sp._rotated = this._rotated;

                sp._capInsets.splice(0, sp._capInsets.length, ...this._capInsets);

                sp._atlasUuid = this._atlasUuid;
                sp._texture = this._texture;
                sp._isFlipUVX = this._isFlipUVX;
                sp._isFlipUVY = this._isFlipUVY;
                return sp;
              }

              _refreshTexture(texture) {
                this._texture = texture;
                const tex = this._texture;
                const config = {};
                let isReset = false;

                if (this._rect.width === 0 || this._rect.height === 0 || !this.checkRect(tex)) {
                  config.rect = new Rect$1(0, 0, tex.width, tex.height);
                  isReset = true;
                }

                if (this._originalSize.width === 0 || this._originalSize.height === 0 || isReset) {
                  config.originalSize = new Size$1(tex.width, tex.height);
                  isReset = true;
                }

                if (isReset) {
                  this.reset(config);
                  this.onLoaded();
                }

                this._checkPackable();
              }

              initDefault(uuid) {
                super.initDefault(uuid);
                const texture = new Texture2D();
                texture.initDefault();

                this._refreshTexture(texture);

                this._calculateUV();
              }

              validate() {
                return this._texture && this._rect && this._rect.width !== 0 && this._rect.height !== 0;
              }

              _calculateTillingOffset() {
                if (this._rotated) {
                  this.tillingOffset[0] = this.uv[4] - this.uv[0];
                  this.tillingOffset[1] = this.uv[3] - this.uv[5];
                  this.tillingOffset[2] = this.uv[0];
                  this.tillingOffset[3] = this.uv[5];
                  this.tillingOffset[0] = -this.tillingOffset[0];
                } else {
                  this.tillingOffset[0] = this.uv[2] - this.uv[0];
                  this.tillingOffset[1] = this.uv[1] - this.uv[5];
                  this.tillingOffset[2] = this.uv[4];
                  this.tillingOffset[3] = this.uv[5];
                }
              }

              _calculateSlicedData() {
                const rect = this._rect;
                const leftWidth = this._capInsets[INSET_LEFT];
                const rightWidth = this._capInsets[INSET_RIGHT];
                const centerWidth = rect.width - leftWidth - rightWidth;
                const topHeight = this._capInsets[INSET_TOP];
                const bottomHeight = this._capInsets[INSET_BOTTOM];
                const centerHeight = rect.height - topHeight - bottomHeight;
                const uvSliced = this.slicedData;
                uvSliced.length = 0;
                uvSliced[0] = leftWidth / rect.width;
                uvSliced[1] = topHeight / rect.height;
                uvSliced[2] = (leftWidth + centerWidth) / rect.width;
                uvSliced[3] = (topHeight + centerHeight) / rect.height;
              }

            }, _temp$8)) || _class$8));
            legacyCC.SpriteFrame = SpriteFrame;

            var _dec$9, _class$9, _class2$8, _descriptor$8, _temp$9;
            let SpriteAtlas = exports('SpriteAtlas', (_dec$9 = ccclass('cc.SpriteAtlas'), _dec$9(_class$9 = (_class2$8 = (_temp$9 = class SpriteAtlas extends Asset {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "spriteFrames", _descriptor$8, this);
              }

              getTexture() {
                const keys = Object.keys(this.spriteFrames);

                if (keys.length > 0) {
                  const spriteFrame = this.spriteFrames[keys[0]];
                  return spriteFrame && spriteFrame.texture;
                } else {
                  return null;
                }
              }

              getSpriteFrame(key) {
                const sf = this.spriteFrames[key];

                if (!sf) {
                  return null;
                }

                if (!sf.name) {
                  sf.name = key;
                }

                return sf;
              }

              getSpriteFrames() {
                const frames = [];
                const spriteFrames = this.spriteFrames;

                for (const key of Object.keys(spriteFrames)) {
                  frames.push(spriteFrames[key]);
                }

                return frames;
              }

              _serialize(ctxForExporting) {
              }

              _deserialize(serializeData, handle) {
                const data = serializeData;
                this._name = data.name;
                const frames = data.spriteFrames;
                this.spriteFrames = createMap();

                for (let i = 0; i < frames.length; i += 2) {
                  handle.result.push(this.spriteFrames, frames[i], frames[i + 1], _getClassId(SpriteFrame));
                }
              }

            }, _temp$9), (_descriptor$8 = _applyDecoratedDescriptor(_class2$8.prototype, "spriteFrames", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return createMap();
              }
            })), _class2$8)) || _class$9));
            legacyCC.SpriteAtlas = SpriteAtlas;

            var _dec$a, _class$a;
            let Font = exports('Font', (_dec$a = ccclass('cc.Font'), _dec$a(_class$a = class Font extends Asset {}) || _class$a));
            legacyCC.Font = Font;

            var _dec$b, _class$b, _class2$9, _descriptor$9, _temp$a;
            let TTFFont = exports('TTFFont', (_dec$b = ccclass('cc.TTFFont'), _dec$b(_class$b = (_class2$9 = (_temp$a = class TTFFont extends Font {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "_fontFamily", _descriptor$9, this);
              }

              get _nativeAsset() {
                return this._fontFamily;
              }

              set _nativeAsset(value) {
                this._fontFamily = value || 'Arial';
              }

              get _nativeDep() {
                return {
                  uuid: this._uuid,
                  __nativeName__: this._native,
                  ext: extname(this._native),
                  __isNative__: true
                };
              }

              initDefault(uuid) {
                this._fontFamily = 'Arial';
                super.initDefault(uuid);
              }

            }, _temp$a), (_descriptor$9 = _applyDecoratedDescriptor(_class2$9.prototype, "_fontFamily", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _applyDecoratedDescriptor(_class2$9.prototype, "_nativeAsset", [override, string], Object.getOwnPropertyDescriptor(_class2$9.prototype, "_nativeAsset"), _class2$9.prototype), _applyDecoratedDescriptor(_class2$9.prototype, "_nativeDep", [override], Object.getOwnPropertyDescriptor(_class2$9.prototype, "_nativeDep"), _class2$9.prototype)), _class2$9)) || _class$b));
            legacyCC.TTFFont = TTFFont;

            var _dec$c, _dec2$8, _class$c, _class2$a, _descriptor$a, _descriptor2$8, _descriptor3$6, _descriptor4$6, _temp$b;
            class FontLetterDefinition {
              constructor() {
                this.u = 0;
                this.v = 0;
                this.w = 0;
                this.h = 0;
                this.offsetX = 0;
                this.offsetY = 0;
                this.textureID = 0;
                this.valid = false;
                this.xAdvance = 0;
              }

            }
            class FontAtlas {
              constructor(texture) {
                this.letterDefinitions = {};
                this.texture = texture;
              }

              addLetterDefinitions(letter, letterDefinition) {
                this.letterDefinitions[letter] = letterDefinition;
              }

              cloneLetterDefinition() {
                const copyLetterDefinitions = {};

                for (const key of Object.keys(this.letterDefinitions)) {
                  const value = new FontLetterDefinition();
                  mixin(value, this.letterDefinitions[key]);
                  copyLetterDefinitions[key] = value;
                }

                return copyLetterDefinitions;
              }

              getTexture() {
                return this.texture;
              }

              getLetter(key) {
                return this.letterDefinitions[key];
              }

              getLetterDefinitionForChar(char, labelInfo) {
                const key = char.charCodeAt(0);
                const hasKey = this.letterDefinitions.hasOwnProperty(key);
                let letter;

                if (hasKey) {
                  letter = this.letterDefinitions[key];
                } else {
                  letter = null;
                }

                return letter;
              }

              clear() {
                this.letterDefinitions = {};
              }

            }
            let BitmapFont = exports('BitmapFont', (_dec$c = ccclass('cc.BitmapFont'), _dec2$8 = type$1(SpriteFrame), _dec$c(_class$c = (_class2$a = (_temp$b = class BitmapFont extends Font {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "fntDataStr", _descriptor$a, this);

                _initializerDefineProperty(this, "spriteFrame", _descriptor2$8, this);

                _initializerDefineProperty(this, "fontSize", _descriptor3$6, this);

                _initializerDefineProperty(this, "fntConfig", _descriptor4$6, this);
              }

              onLoaded() {
                const spriteFrame = this.spriteFrame;

                if (!this.fontDefDictionary && spriteFrame) {
                  this.fontDefDictionary = new FontAtlas(spriteFrame.texture);
                }

                const fntConfig = this.fntConfig;

                if (!fntConfig) {
                  warn('The fnt config is not exists!');
                  return;
                }

                const fontDict = fntConfig.fontDefDictionary;

                for (const fontDef in fontDict) {
                  const letter = new FontLetterDefinition();
                  const rect = fontDict[fontDef].rect;
                  letter.offsetX = fontDict[fontDef].xOffset;
                  letter.offsetY = fontDict[fontDef].yOffset;
                  letter.w = rect.width;
                  letter.h = rect.height;
                  letter.u = rect.x;
                  letter.v = rect.y;
                  letter.textureID = 0;
                  letter.valid = true;
                  letter.xAdvance = fontDict[fontDef].xAdvance;
                  this.fontDefDictionary.addLetterDefinitions(fontDef, letter);
                }
              }

            }, _temp$b), (_descriptor$a = _applyDecoratedDescriptor(_class2$a.prototype, "fntDataStr", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            }), _descriptor2$8 = _applyDecoratedDescriptor(_class2$a.prototype, "spriteFrame", [_dec2$8], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor3$6 = _applyDecoratedDescriptor(_class2$a.prototype, "fontSize", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return -1;
              }
            }), _descriptor4$6 = _applyDecoratedDescriptor(_class2$a.prototype, "fntConfig", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            })), _class2$a)) || _class$c));
            legacyCC.BitmapFont = BitmapFont;

            var _dec$d, _class$d;
            let LabelAtlas = exports('LabelAtlas', (_dec$d = ccclass('cc.LabelAtlas'), _dec$d(_class$d = class LabelAtlas extends BitmapFont {}) || _class$d));
            legacyCC.LabelAtlas = LabelAtlas;

            const BASELINE_RATIO = exports('BASELINE_RATIO', 0.26);
            let _BASELINE_OFFSET = 0;

            const MIDDLE_RATIO = exports('MIDDLE_RATIO', (BASELINE_RATIO + 1) / 2 - BASELINE_RATIO);
            function getBaselineOffset() {
              return _BASELINE_OFFSET;
            }
            const MAX_CACHE_SIZE = 100;
            const pool = new Pool$1(2);

            pool.get = function () {
              return this._get() || {
                key: '',
                value: 0,
                prev: null,
                next: null
              };
            };

            class LRUCache {
              constructor(size) {
                this.count = 0;
                this.limit = 0;
                this.datas = {};
                this.limit = size;
              }

              moveToHead(node) {
                node.next = this.head;
                node.prev = null;
                if (this.head) this.head.prev = node;
                this.head = node;
                if (!this.tail) this.tail = node;
                this.count++;
                this.datas[node.key] = node;
              }

              put(key, value) {
                const node = pool.get();
                node.key = key;
                node.value = value;

                if (this.count >= this.limit) {
                  const discard = this.tail;
                  delete this.datas[discard.key];
                  this.count--;
                  this.tail = discard.prev;
                  this.tail.next = null;
                  discard.prev = null;
                  discard.next = null;
                  pool.put(discard);
                }

                this.moveToHead(node);
              }

              remove(node) {
                if (node.prev) {
                  node.prev.next = node.next;
                } else {
                  this.head = node.next;
                }

                if (node.next) {
                  node.next.prev = node.prev;
                } else {
                  this.tail = node.prev;
                }

                delete this.datas[node.key];
                this.count--;
              }

              get(key) {
                const node = this.datas[key];

                if (node) {
                  this.remove(node);
                  this.moveToHead(node);
                  return node.value;
                }

                return null;
              }

              clear() {
                this.count = 0;
                this.datas = {};
                this.head = null;
                this.tail = null;
              }

              has(key) {
                return !!this.datas[key];
              }

              delete(key) {
                const node = this.datas[key];
                this.remove(node);
              }

            }

            const measureCache = new LRUCache(MAX_CACHE_SIZE);
            const WORD_REG = /([a-zA-Z0-9--]+|\S)/;
            const SYMBOL_REG = /^[!,.:;'}\]%\?>]/;
            const LAST_WORD_REG = /([a-zA-Z0-9--]+|\S)$/;
            const LAST_ENGLISH_REG = /[a-zA-Z0-9--]+$/;
            const FIRST_ENGLISH_REG = /^[a-zA-Z0-9--]/;
            function isUnicodeCJK(ch) {
              const __CHINESE_REG = /^[\u4E00-\u9FFF\u3400-\u4DFF]+$/;
              const __JAPANESE_REG = /[\u3000-\u303F]|[\u3040-\u309F]|[\u30A0-\u30FF]|[\uFF00-\uFFEF]|[\u4E00-\u9FAF]|[\u2605-\u2606]|[\u2190-\u2195]|\u203B/g;
              const __KOREAN_REG = /^[\u1100-\u11FF]|[\u3130-\u318F]|[\uA960-\uA97F]|[\uAC00-\uD7AF]|[\uD7B0-\uD7FF]+$/;
              return __CHINESE_REG.test(ch) || __JAPANESE_REG.test(ch) || __KOREAN_REG.test(ch);
            }
            function isUnicodeSpace(ch) {
              const chCode = ch.charCodeAt(0);
              return chCode >= 9 && chCode <= 13 || chCode === 32 || chCode === 133 || chCode === 160 || chCode === 5760 || chCode >= 8192 && chCode <= 8202 || chCode === 8232 || chCode === 8233 || chCode === 8239 || chCode === 8287 || chCode === 12288;
            }
            function safeMeasureText(ctx, string, desc) {
              const font = desc || ctx.font;
              const key = `${font}\uD83C\uDFAE${string}`;
              const cache = measureCache.get(key);

              if (cache !== null) {
                return cache;
              }

              const metric = ctx.measureText(string);
              const width = metric && metric.width || 0;
              measureCache.put(key, width);
              return width;
            }

            function _safeSubstring(targetString, startIndex, endIndex) {
              let newStartIndex = startIndex;
              let newEndIndex = endIndex;
              const startChar = targetString[startIndex];

              if (startChar >= '\uDC00' && startChar <= '\uDFFF') {
                newStartIndex--;
              }

              if (endIndex !== undefined) {
                if (endIndex - 1 !== startIndex) {
                  const endChar = targetString[endIndex - 1];

                  if (endChar >= '\uD800' && endChar <= '\uDBFF') {
                    newEndIndex--;
                  }
                } else if (startChar >= '\uD800' && startChar <= '\uDBFF') {
                  newEndIndex++;
                }
              }

              return targetString.substring(newStartIndex, newEndIndex);
            }

            function fragmentText(stringToken, allWidth, maxWidth, measureText) {
              const wrappedWords = [];

              if (stringToken.length === 0 || maxWidth < 0) {
                wrappedWords.push('');
                return wrappedWords;
              }

              let text = stringToken;

              while (allWidth > maxWidth && text.length > 1) {
                let fuzzyLen = text.length * (maxWidth / allWidth) | 0;

                let tmpText = _safeSubstring(text, fuzzyLen);

                let width = allWidth - measureText(tmpText);
                let sLine = tmpText;
                let pushNum = 0;
                let checkWhile = 0;
                const checkCount = 10;

                while (width > maxWidth && checkWhile++ < checkCount) {
                  fuzzyLen *= maxWidth / width;
                  fuzzyLen |= 0;
                  tmpText = _safeSubstring(text, fuzzyLen);
                  width = allWidth - measureText(tmpText);
                }

                checkWhile = 0;

                while (width <= maxWidth && checkWhile++ < checkCount) {
                  if (tmpText) {
                    const exec = WORD_REG.exec(tmpText);
                    pushNum = exec ? exec[0].length : 1;
                    sLine = tmpText;
                  }

                  fuzzyLen += pushNum;
                  tmpText = _safeSubstring(text, fuzzyLen);
                  width = allWidth - measureText(tmpText);
                }

                fuzzyLen -= pushNum;

                if (fuzzyLen === 0) {
                  fuzzyLen = 1;
                  sLine = _safeSubstring(text, 1);
                } else if (fuzzyLen === 1 && text[0] >= '\uD800' && text[0] <= '\uDBFF') {
                  fuzzyLen = 2;
                  sLine = _safeSubstring(text, 2);
                }

                let sText = _safeSubstring(text, 0, fuzzyLen);

                let result;

                {
                  if (SYMBOL_REG.test(sLine || tmpText)) {
                    result = LAST_WORD_REG.exec(sText);
                    fuzzyLen -= result ? result[0].length : 0;

                    if (fuzzyLen === 0) {
                      fuzzyLen = 1;
                    }

                    sLine = _safeSubstring(text, fuzzyLen);
                    sText = _safeSubstring(text, 0, fuzzyLen);
                  }
                }

                if (FIRST_ENGLISH_REG.test(sLine)) {
                  result = LAST_ENGLISH_REG.exec(sText);

                  if (result && sText !== result[0]) {
                    fuzzyLen -= result[0].length;
                    sLine = _safeSubstring(text, fuzzyLen);
                    sText = _safeSubstring(text, 0, fuzzyLen);
                  }
                }

                if (wrappedWords.length === 0) {
                  wrappedWords.push(sText);
                } else {
                  sText = sText.trim();

                  if (sText.length > 0) {
                    wrappedWords.push(sText);
                  }
                }

                text = sLine || tmpText;
                allWidth = measureText(text);
              }

              if (wrappedWords.length === 0) {
                wrappedWords.push(text);
              } else {
                text = text.trim();

                if (text.length > 0) {
                  wrappedWords.push(text);
                }
              }

              return wrappedWords;
            }

            let _canvasPool;

            class CanvasPool {
              constructor() {
                this.pool = [];
              }

              static getInstance() {
                if (!_canvasPool) {
                  _canvasPool = new CanvasPool();
                }

                return _canvasPool;
              }

              get() {
                let data = this.pool.pop();

                if (!data) {
                  const canvas = document.createElement('canvas');
                  const context = canvas.getContext('2d');
                  data = {
                    canvas,
                    context
                  };
                }

                return data;
              }

              put(canvas) {
                if (this.pool.length >= macro.MAX_LABEL_CANVAS_POOL_SIZE) {
                  return;
                }

                this.pool.push(canvas);
              }

            } exports('CanvasPool', CanvasPool);
            const WHITE = Color$1.WHITE.clone();
            const space$1 = 0;
            const bleed = 2;

            class FontLetterDefinition$1 {
              constructor() {
                this.u = 0;
                this.v = 0;
                this.w = 0;
                this.h = 0;
                this.texture = null;
                this.offsetX = 0;
                this.offsetY = 0;
                this.valid = false;
                this.xAdvance = 0;
              }

            }

            const _backgroundStyle = `rgba(255, 255, 255, ${(1 / 255).toFixed(3)})`;
            const BASELINE_OFFSET = getBaselineOffset();

            class LetterTexture {
              constructor(char, labelInfo) {
                this.image = null;
                this.labelInfo = void 0;
                this.char = void 0;
                this.data = null;
                this.canvas = null;
                this.context = null;
                this.width = 0;
                this.height = 0;
                this.offsetY = 0;
                this.hash = void 0;
                this.char = char;
                this.labelInfo = labelInfo;
                this.hash = char.charCodeAt(0) + labelInfo.hash;
              }

              updateRenderData() {
                this._updateProperties();

                this._updateTexture();
              }

              destroy() {
                this.image = null;
              }

              _updateProperties() {
                this.data = CanvasPool.getInstance().get();
                this.canvas = this.data.canvas;
                this.context = this.data.context;

                if (this.context) {
                  this.context.font = this.labelInfo.fontDesc;
                  const width = safeMeasureText(this.context, this.char, this.labelInfo.fontDesc);
                  const blank = this.labelInfo.margin * 2 + bleed;
                  this.width = parseFloat(width.toFixed(2)) + blank;
                  this.height = (1 + BASELINE_RATIO) * this.labelInfo.fontSize + blank;
                  this.offsetY = -(this.labelInfo.fontSize * BASELINE_RATIO) / 2;
                }

                if (this.canvas.width !== this.width) {
                  this.canvas.width = this.width;
                }

                if (this.canvas.height !== this.height) {
                  this.canvas.height = this.height;
                }

                if (!this.image) {
                  this.image = new ImageAsset();
                }

                this.image.reset(this.canvas);
              }

              _updateTexture() {
                if (!this.context || !this.canvas) {
                  return;
                }

                const context = this.context;
                const labelInfo = this.labelInfo;
                const width = this.canvas.width;
                const height = this.canvas.height;
                context.textAlign = 'center';
                context.textBaseline = 'alphabetic';
                context.clearRect(0, 0, width, height);
                context.fillStyle = _backgroundStyle;
                context.fillRect(0, 0, width, height);
                context.font = labelInfo.fontDesc;
                const fontSize = labelInfo.fontSize;
                const startX = width / 2;
                const startY = height / 2 + fontSize * MIDDLE_RATIO + fontSize * BASELINE_OFFSET;
                const color = labelInfo.color;
                context.lineJoin = 'round';
                context.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${1})`;

                if (labelInfo.isOutlined) {
                  const strokeColor = labelInfo.out || WHITE;
                  context.strokeStyle = `rgba(${strokeColor.r}, ${strokeColor.g}, ${strokeColor.b}, ${strokeColor.a / 255})`;
                  context.lineWidth = labelInfo.margin * 2;
                  context.strokeText(this.char, startX, startY);
                }

                context.fillText(this.char, startX, startY);
              }

            }

            class LetterRenderTexture extends Texture2D {
              initWithSize(width, height, format = PixelFormat.RGBA8888) {
                this.reset({
                  width,
                  height,
                  format
                });
              }

              drawTextureAt(image, x, y) {
                const gfxTexture = this.getGFXTexture();

                if (!image || !gfxTexture) {
                  return;
                }

                const gfxDevice = this._getGFXDevice();

                if (!gfxDevice) {
                  console.warn('Unable to get device');
                  return;
                }

                const region = new BufferTextureCopy();
                region.texOffset.x = x;
                region.texOffset.y = y;
                region.texExtent.width = image.width;
                region.texExtent.height = image.height;
                gfxDevice.copyTexImagesToTexture([image.data], gfxTexture, [region]);
              }

            }
            class LetterAtlas {
              get width() {
                return this._width;
              }

              get height() {
                return this._height;
              }

              constructor(width, height) {
                this._x = space$1;
                this._y = space$1;
                this._nextY = space$1;
                this._width = 0;
                this._height = 0;
                this._halfBleed = 0;
                this._dirty = false;
                const texture = new LetterRenderTexture();
                texture.initWithSize(width, height);
                this.fontDefDictionary = new FontAtlas(texture);
                this._halfBleed = bleed / 2;
                this._width = width;
                this._height = height;
                director.on(Director.EVENT_BEFORE_SCENE_LAUNCH, this.beforeSceneLoad, this);
              }

              insertLetterTexture(letterTexture) {
                const texture = letterTexture.image;
                const device = director.root.device;

                if (!texture || !this.fontDefDictionary || !device) {
                  return null;
                }

                const width = texture.width;
                const height = texture.height;

                if (this._x + width + space$1 > this._width) {
                  this._x = space$1;
                  this._y = this._nextY;
                }

                if (this._y + height > this._nextY) {
                  this._nextY = this._y + height + space$1;
                }

                if (this._nextY > this._height) {
                  warnID(12100);
                  return null;
                }

                this.fontDefDictionary.texture.drawTextureAt(texture, this._x, this._y);
                this._dirty = true;
                const letterDefinition = new FontLetterDefinition$1();
                letterDefinition.u = this._x + this._halfBleed;
                letterDefinition.v = this._y + this._halfBleed;
                letterDefinition.texture = this.fontDefDictionary.texture;
                letterDefinition.valid = true;
                letterDefinition.w = letterTexture.width - bleed;
                letterDefinition.h = letterTexture.height - bleed;
                letterDefinition.xAdvance = letterDefinition.w;
                letterDefinition.offsetY = letterTexture.offsetY;
                this._x += width + space$1;
                this.fontDefDictionary.addLetterDefinitions(letterTexture.hash, letterDefinition);
                return letterDefinition;
              }

              update() {
                if (!this._dirty) {
                  return;
                }

                this._dirty = false;
              }

              reset() {
                this._x = space$1;
                this._y = space$1;
                this._nextY = space$1;
                this.fontDefDictionary.clear();
              }

              destroy() {
                this.reset();

                if (this.fontDefDictionary) {
                  this.fontDefDictionary.texture.destroy();
                  this.fontDefDictionary.texture = null;
                }
              }

              getTexture() {
                return this.fontDefDictionary.getTexture();
              }

              beforeSceneLoad() {
                this.clearAllCache();
              }

              clearAllCache() {
                this.destroy();
                const texture = new LetterRenderTexture();
                texture.initWithSize(this._width, this._height);
                this.fontDefDictionary.texture = texture;
              }

              getLetter(key) {
                return this.fontDefDictionary.letterDefinitions[key];
              }

              getLetterDefinitionForChar(char, labelInfo) {
                const hash = char.charCodeAt(0) + labelInfo.hash;
                let letter = this.fontDefDictionary.letterDefinitions[hash];

                if (!letter) {
                  const temp = new LetterTexture(char, labelInfo);
                  temp.updateRenderData();
                  letter = this.insertLetterTexture(temp);
                  temp.destroy();
                }

                return letter;
              }

            }
            const shareLabelInfo = {
              fontAtlas: null,
              fontSize: 0,
              lineHeight: 0,
              hAlign: 0,
              vAlign: 0,
              hash: '',
              fontFamily: '',
              fontDesc: 'Arial',
              color: Color$1.WHITE.clone(),
              isOutlined: false,
              out: Color$1.WHITE.clone(),
              margin: 0
            };
            function computeHash(labelInfo) {
              const hashData = '';
              const color = labelInfo.color.toHEX();
              let out = '';

              if (labelInfo.isOutlined && labelInfo.margin > 0) {
                out = out + labelInfo.margin + labelInfo.out.toHEX();
              }

              return hashData + labelInfo.fontSize + labelInfo.fontFamily + color + out;
            }

            class BaseRenderData {
              constructor() {
                this.material = null;
                this.vertexCount = 0;
                this.indicesCount = 0;
              }

            }
            class RenderData extends BaseRenderData {
              constructor(...args) {
                super(...args);
                this.vData = null;
                this.uvDirty = true;
                this.vertDirty = true;
                this._data = [];
                this._indices = [];
                this._pivotX = 0;
                this._pivotY = 0;
                this._width = 0;
                this._height = 0;
                this.renderScene = null;
                this.layer = 0;
                this.nodeDirty = true;
                this.blendHash = -1;
                this.passDirty = true;
                this.frame = void 0;
                this.textureHash = 0;
                this.textureDirty = true;
                this.hashDirty = true;
                this.dataHash = 0;
              }

              get dataLength() {
                return this._data.length;
              }

              set dataLength(length) {
                const data = this._data;

                if (data.length !== length) {
                  const value = data.length;
                  let i = 0;

                  for (i = length; i < value; i++) {
                    _dataPool.free(data[i]);
                  }

                  for (i = value; i < length; i++) {
                    data[i] = _dataPool.alloc();
                  }

                  data.length = length;
                }
              }

              get data() {
                return this._data;
              }

              static add() {
                return _pool.add();
              }

              static remove(data) {
                const idx = _pool.data.indexOf(data);

                if (idx === -1) {
                  return;
                }

                _pool.data[idx].clear();

                _pool.removeAt(idx);
              }

              updateNode(comp) {
                this.renderScene = comp.node.scene ? comp._getRenderScene() : null;
                this.layer = comp.node.layer;
                this.nodeDirty = false;
                this.hashDirty = true;
              }

              updatePass(comp) {
                this.material = comp.getRenderMaterial(0);
                this.blendHash = comp.blendHash;
                this.passDirty = false;
                this.hashDirty = true;
              }

              updateTexture(frame) {
                this.frame = frame;
                this.textureHash = frame.getHash();
                this.textureDirty = false;
                this.hashDirty = true;
              }

              updateHash() {
                const hashString = ` ${this.layer} ${this.blendHash} ${this.textureHash}`;
                this.dataHash = murmurhash2_32_gc(hashString, 666);
                this.hashDirty = false;
              }

              updateRenderData(comp, frame) {
                if (this.passDirty) {
                  this.material = comp.getRenderMaterial(0);
                  this.blendHash = comp.blendHash;
                  this.passDirty = false;
                  this.hashDirty = true;
                }

                if (this.nodeDirty) {
                  this.renderScene = comp.node.scene ? comp._getRenderScene() : null;
                  this.layer = comp.node.layer;

                  if (this.renderScene !== null) {
                    this.nodeDirty = false;
                  }

                  this.hashDirty = true;
                }

                if (this.textureDirty) {
                  this.frame = frame;
                  this.textureHash = frame.getHash();
                  this.textureDirty = false;
                  this.hashDirty = true;
                }

                if (this.hashDirty) {
                  const hashString = ` ${this.layer} ${this.blendHash} ${this.textureHash}`;
                  this.dataHash = murmurhash2_32_gc(hashString, 666);
                  this.hashDirty = false;
                }
              }

              updateSizeNPivot(width, height, pivotX, pivotY) {
                if (width !== this._width || height !== this._height || pivotX !== this._pivotX || pivotY !== this._pivotY) {
                  this._width = width;
                  this._height = height;
                  this._pivotX = pivotX;
                  this._pivotY = pivotY;
                  this.vertDirty = true;
                }
              }

              clear() {
                this._data.length = 0;
                this._indices.length = 0;
                this._pivotX = 0;
                this._pivotY = 0;
                this._width = 0;
                this._height = 0;
                this.uvDirty = true;
                this.vertDirty = true;
                this.material = null;
                this.vertexCount = 0;
                this.indicesCount = 0;
                this.nodeDirty = true;
                this.passDirty = true;
                this.textureDirty = true;
                this.hashDirty = true;
                this.renderScene = null;
                this.layer = 0;
                this.blendHash = -1;
                this.frame = null;
                this.textureHash = 0;
                this.dataHash = 0;
              }

            }
            class MeshRenderData extends BaseRenderData {
              constructor(vertexFloatCnt = 9) {
                super();
                this.vData = void 0;
                this.iData = void 0;
                this.vertexStart = 0;
                this.indicesStart = 0;
                this.byteStart = 0;
                this.byteCount = 0;
                this.lastFilledIndices = 0;
                this.lastFilledVertex = 0;
                this._formatByte = void 0;
                this._formatByte = vertexFloatCnt * Float32Array.BYTES_PER_ELEMENT;
                this.vData = new Float32Array(256 * vertexFloatCnt * Float32Array.BYTES_PER_ELEMENT);
                this.iData = new Uint16Array(256 * 6);
              }

              set formatByte(value) {
                this._formatByte = value;
              }

              get formatByte() {
                return this._formatByte;
              }

              get floatStride() {
                return this._formatByte >> 2;
              }

              get vDataOffset() {
                return this.byteCount >>> 2;
              }

              static add() {
                return _meshDataPool.add();
              }

              static remove(data) {
                const idx = _meshDataPool.data.indexOf(data);

                if (idx === -1) {
                  return;
                }

                _meshDataPool.data[idx].reset();

                _meshDataPool.removeAt(idx);
              }

              request(vertexCount, indicesCount) {
                const byteOffset = this.byteCount + vertexCount * this._formatByte;
                this.reserve(vertexCount, indicesCount);
                this.vertexCount += vertexCount;
                this.indicesCount += indicesCount;
                this.byteCount = byteOffset;
                return true;
              }

              reserve(vertexCount, indicesCount) {
                const newVBytes = this.byteCount + vertexCount * this._formatByte;
                const newICount = this.indicesCount + indicesCount;

                if (vertexCount + this.vertexCount > 65535) {
                  return false;
                }

                let byteLength = this.vData.byteLength;
                let indicesLength = this.iData.length;
                let vCount = this.vData.length;
                let iCount = this.iData.length;

                if (newVBytes > byteLength || newICount > indicesLength) {
                  while (byteLength < newVBytes || indicesLength < newICount) {
                    vCount *= 2;
                    iCount *= 2;
                    byteLength = vCount * 4;
                    indicesLength = iCount;
                  }

                  this._reallocBuffer(vCount, iCount);
                }

                return true;
              }

              advance(vertexCount, indicesCount) {
                this.vertexCount += vertexCount;
                this.indicesCount += indicesCount;
                this.byteCount += vertexCount * this._formatByte;
              }

              reset() {
                this.vertexCount = 0;
                this.indicesCount = 0;
                this.byteCount = 0;
                this.vertexStart = 0;
                this.indicesStart = 0;
                this.byteStart = 0;
                this.lastFilledIndices = 0;
                this.lastFilledVertex = 0;
              }

              _reallocBuffer(vCount, iCount) {
                const oldVData = this.vData;
                this.vData = new Float32Array(vCount);
                this.vData.set(oldVData, 0);
                const oldIData = this.iData;
                this.iData = new Uint16Array(iCount);
                this.iData.set(oldIData, 0);
              }

            }

            const _dataPool = new Pool(() => ({
              x: 0,
              y: 0,
              z: 0,
              u: 0,
              v: 0,
              color: Color$1.WHITE.clone()
            }), 128);

            const _pool = new RecyclePool(() => new RenderData(), 32);

            const _meshDataPool = new RecyclePool(() => new MeshRenderData(), 32);

            var _dec$e, _dec2$9, _dec3$8, _dec4$8, _dec5$8, _dec6$7, _dec7$7, _dec8$6, _class$e, _class2$b, _descriptor$b, _descriptor2$9, _class3, _temp$c;

            const _vec2a = new Vec2();

            const _vec2b = new Vec2();

            const _vec3a = new Vec3();

            const _mat4_temp = new Mat4();

            const _matrix = new Mat4();

            const _worldMatrix$1 = new Mat4();

            const _zeroMatrix = new Mat4(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

            const _rect = new Rect$1();

            let UITransform = function (v) { return exports({ UITransform: v, UITransformComponent: v }), v; }((_dec$e = ccclass('cc.UITransform'), _dec2$9 = help(), _dec3$8 = executionOrder(110), _dec4$8 = menu$1(), _dec5$8 = displayOrder(), _dec6$7 = tooltip(), _dec7$7 = displayOrder(), _dec8$6 = tooltip(), _dec$e(_class$e = _dec2$9(_class$e = _dec3$8(_class$e = _dec4$8(_class$e = disallowMultiple(_class$e = executeInEditMode(_class$e = (_class2$b = (_temp$c = _class3 = class UITransform extends Component {
              get contentSize() {
                return this._contentSize;
              }

              set contentSize(value) {
                if (this._contentSize.equals(value)) {
                  return;
                }

                this._contentSize.set(value);

                {
                  this.node.emit(NodeEventType.SIZE_CHANGED);
                }

                this._markRenderDataDirty();
              }

              get width() {
                return this._contentSize.width;
              }

              set width(value) {
                if (this._contentSize.width === value) {
                  return;
                }

                this._contentSize.width = value;

                {
                  this.node.emit(NodeEventType.SIZE_CHANGED);
                }

                this._markRenderDataDirty();
              }

              get height() {
                return this._contentSize.height;
              }

              set height(value) {
                if (this.contentSize.height === value) {
                  return;
                }

                this._contentSize.height = value;

                {
                  this.node.emit(NodeEventType.SIZE_CHANGED);
                }

                this._markRenderDataDirty();
              }

              get anchorPoint() {
                return this._anchorPoint;
              }

              set anchorPoint(value) {
                if (this._anchorPoint.equals(value)) {
                  return;
                }

                this._anchorPoint.set(value);

                this.node.emit(NodeEventType.ANCHOR_CHANGED, this._anchorPoint);

                this._markRenderDataDirty();
              }

              get anchorX() {
                return this._anchorPoint.x;
              }

              set anchorX(value) {
                if (this._anchorPoint.x === value) {
                  return;
                }

                this._anchorPoint.x = value;
                this.node.emit(NodeEventType.ANCHOR_CHANGED, this._anchorPoint);

                this._markRenderDataDirty();
              }

              get anchorY() {
                return this._anchorPoint.y;
              }

              set anchorY(value) {
                if (this._anchorPoint.y === value) {
                  return;
                }

                this._anchorPoint.y = value;
                this.node.emit(NodeEventType.ANCHOR_CHANGED, this._anchorPoint);

                this._markRenderDataDirty();
              }

              get priority() {
                return this._priority;
              }

              set priority(value) {
                if (this._priority === value) {
                  return;
                }

                if (this.node.getComponent('cc.RenderRoot2D')) {
                  warnID(6706);
                  return;
                }

                this._priority = value;

                if (this.node.parent) {
                  UITransform.insertChangeMap(this.node.parent);
                }
              }

              get visibility() {
                const camera = director.root.batcher2D.getFirstRenderCamera(this.node);
                return camera ? camera.visibility : 0;
              }

              get cameraPriority() {
                const camera = director.root.batcher2D.getFirstRenderCamera(this.node);
                return camera ? camera.priority : 0;
              }

              constructor() {
                super();
                this._priority = 0;

                _initializerDefineProperty(this, "_contentSize", _descriptor$b, this);

                _initializerDefineProperty(this, "_anchorPoint", _descriptor2$9, this);
              }

              __preload() {
                this.node._uiProps.uiTransformComp = this;
              }

              onLoad() {
                if (this.node.parent) {
                  UITransform.insertChangeMap(this.node.parent);
                }
              }

              onEnable() {
                this.node.on(NodeEventType.PARENT_CHANGED, this._parentChanged, this);

                this._markRenderDataDirty();
              }

              onDisable() {
                this.node.off(NodeEventType.PARENT_CHANGED, this._parentChanged, this);
              }

              onDestroy() {
                this.node._uiProps.uiTransformComp = null;
              }

              setContentSize(size, height) {
                const locContentSize = this._contentSize;

                if (height === undefined) {
                  size = size;

                  if (size.width === locContentSize.width && size.height === locContentSize.height) {
                    return;
                  }

                  locContentSize.width = size.width;
                  locContentSize.height = size.height;
                } else {
                  if (size === locContentSize.width && height === locContentSize.height) {
                    return;
                  }

                  locContentSize.width = size;
                  locContentSize.height = height;
                }

                {
                  this.node.emit(NodeEventType.SIZE_CHANGED);
                }

                this._markRenderDataDirty();
              }

              setAnchorPoint(point, y) {
                const locAnchorPoint = this._anchorPoint;

                if (y === undefined) {
                  point = point;

                  if (point.x === locAnchorPoint.x && point.y === locAnchorPoint.y) {
                    return;
                  }

                  locAnchorPoint.x = point.x;
                  locAnchorPoint.y = point.y;
                } else {
                  if (point === locAnchorPoint.x && y === locAnchorPoint.y) {
                    return;
                  }

                  locAnchorPoint.x = point;
                  locAnchorPoint.y = y;
                }

                this.node.emit(NodeEventType.ANCHOR_CHANGED, this._anchorPoint);

                this._markRenderDataDirty();
              }

              isHit(point) {
                var _this$node;

                const w = this._contentSize.width;
                const h = this._contentSize.height;
                const cameraPt = _vec2a;
                const testPt = _vec2b;
                const nodeEventProcessor = (_this$node = this.node) === null || _this$node === void 0 ? void 0 : _this$node.eventProcessor;

                const cameras = this._getRenderScene().cameras;

                for (let i = 0; i < cameras.length; i++) {
                  const camera = cameras[i];
                  if (!(camera.visibility & this.node.layer)) continue;
                  camera.node.getWorldRT(_mat4_temp);
                  const m12 = _mat4_temp.m12;
                  const m13 = _mat4_temp.m13;
                  const center = visibleRect.center;
                  _mat4_temp.m12 = center.x - (_mat4_temp.m00 * m12 + _mat4_temp.m04 * m13);
                  _mat4_temp.m13 = center.y - (_mat4_temp.m01 * m12 + _mat4_temp.m05 * m13);
                  Mat4.invert(_mat4_temp, _mat4_temp);
                  Vec2.transformMat4(cameraPt, point, _mat4_temp);
                  this.node.getWorldMatrix(_worldMatrix$1);
                  Mat4.invert(_mat4_temp, _worldMatrix$1);

                  if (Mat4.strictEquals(_mat4_temp, _zeroMatrix)) {
                    continue;
                  }

                  Vec2.transformMat4(testPt, cameraPt, _mat4_temp);
                  testPt.x += this._anchorPoint.x * w;
                  testPt.y += this._anchorPoint.y * h;
                  let hit = false;

                  if (testPt.x >= 0 && testPt.y >= 0 && testPt.x <= w && testPt.y <= h) {
                    hit = true;

                    if (nodeEventProcessor && nodeEventProcessor.maskList) {
                      const maskList = nodeEventProcessor.maskList;
                      let parent = this.node;
                      const length = maskList ? maskList.length : 0;

                      for (let i = 0, j = 0; parent && j < length; ++i, parent = parent.parent) {
                        const temp = maskList[j];

                        if (i === temp.index) {
                          if (parent === temp.comp.node) {
                            const comp = temp.comp;

                            if (comp && comp._enabled && !comp.isHit(cameraPt)) {
                              hit = false;
                              break;
                            }

                            j++;
                          } else {
                            maskList.length = j;
                            break;
                          }
                        } else if (i > temp.index) {
                          maskList.length = j;
                          break;
                        }
                      }
                    }
                  }

                  if (hit) {
                    return true;
                  }
                }

                return false;
              }

              convertToNodeSpaceAR(worldPoint, out) {
                this.node.getWorldMatrix(_worldMatrix$1);
                Mat4.invert(_mat4_temp, _worldMatrix$1);

                if (!out) {
                  out = new Vec3();
                }

                return Vec3.transformMat4(out, worldPoint, _mat4_temp);
              }

              convertToWorldSpaceAR(nodePoint, out) {
                this.node.getWorldMatrix(_worldMatrix$1);

                if (!out) {
                  out = new Vec3();
                }

                return Vec3.transformMat4(out, nodePoint, _worldMatrix$1);
              }

              getBoundingBox() {
                Mat4.fromRTS(_matrix, this.node.getRotation(), this.node.getPosition(), this.node.getScale());
                const width = this._contentSize.width;
                const height = this._contentSize.height;
                const rect = new Rect$1(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height);
                rect.transformMat4(_matrix);
                return rect;
              }

              getBoundingBoxToWorld() {
                if (this.node.parent) {
                  this.node.parent.getWorldMatrix(_worldMatrix$1);
                  return this.getBoundingBoxTo(_worldMatrix$1);
                }

                return this.getBoundingBox();
              }

              getBoundingBoxTo(parentMat) {
                Mat4.fromRTS(_matrix, this.node.getRotation(), this.node.getPosition(), this.node.getScale());
                const width = this._contentSize.width;
                const height = this._contentSize.height;
                const rect = new Rect$1(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height);
                Mat4.multiply(_worldMatrix$1, parentMat, _matrix);
                rect.transformMat4(_worldMatrix$1);

                if (!this.node.children) {
                  return rect;
                }

                const locChildren = this.node.children;

                for (const child of locChildren) {
                  if (child && child.active) {
                    const uiTransform = child.getComponent(UITransform);

                    if (uiTransform) {
                      const childRect = uiTransform.getBoundingBoxTo(parentMat);

                      if (childRect) {
                        Rect$1.union(rect, rect, childRect);
                      }
                    }
                  }
                }

                return rect;
              }

              getComputeAABB(out) {
                const width = this._contentSize.width;
                const height = this._contentSize.height;

                _rect.set(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height);

                _rect.transformMat4(this.node.worldMatrix);

                const px = _rect.x + _rect.width * 0.5;
                const py = _rect.y + _rect.height * 0.5;
                const pz = this.node.worldPosition.z;
                const w = _rect.width / 2;
                const h = _rect.height / 2;
                const l = 0.001;

                if (out != null) {
                  AABB.set(out, px, py, pz, w, h, l);
                  return out;
                } else {
                  return new AABB(px, py, pz, w, h, l);
                }
              }

              _parentChanged(node) {
                if (this.node.getComponent('cc.RenderRoot2D')) {
                  return;
                }

                if (this.node.parent) {
                  UITransform.insertChangeMap(this.node.parent);
                }
              }

              _markRenderDataDirty() {

                const uiComp = this.node._uiProps.uiComp;

                if (uiComp) {
                  uiComp.markForUpdateRenderData();

                  if (uiComp.renderData) {
                    uiComp.renderData.vertDirty = true;
                  }
                }
              }

              checkAndUpdateRect(rot, scale) {
                if (this._rectDirty) {
                  this._rectWithScale.x = scale.x * this.width;
                  this._rectWithScale.y = scale.y * this.height;
                  this._rectWithScale.z = scale.z;
                  const lenX = (0.5 - this.anchorPoint.x) * this.width * scale.x;
                  const lenY = (0.5 - this.anchorPoint.y) * this.height * scale.y;
                  Vec3.transformQuat(this._anchorCache, _vec3a.set(lenX, lenY, 0), rot);
                }
              }

              setRectDirty(transformBit) {
                if (transformBit & TransformBit.RS) {
                  this._rectDirty = true;
                }
              }

              static insertChangeMap(node) {
                const key = node.uuid;

                if (!UITransform.priorityChangeNodeMap.has(key)) {
                  UITransform.priorityChangeNodeMap.set(key, node);
                }
              }

              static _sortChildrenSibling(node) {
                const siblings = node.children;

                if (siblings) {
                  siblings.sort((a, b) => {
                    const aComp = a._uiProps.uiTransformComp;
                    const bComp = b._uiProps.uiTransformComp;
                    const ca = aComp ? aComp._priority : 0;
                    const cb = bComp ? bComp._priority : 0;
                    const diff = ca - cb;
                    if (diff === 0) return a.getSiblingIndex() - b.getSiblingIndex();
                    return diff;
                  });
                }
              }

              static _sortSiblings() {
                UITransform.priorityChangeNodeMap.forEach((node, ID) => {
                  UITransform._sortChildrenSibling(node);

                  node._updateSiblingIndex();

                  node.emit('childrenSiblingOrderChanged');
                });
                UITransform.priorityChangeNodeMap.clear();
              }

              static _cleanChangeMap() {
                UITransform.priorityChangeNodeMap.clear();
              }

            }, _class3.EventType = NodeEventType, _class3.priorityChangeNodeMap = new Map(), _temp$c), (_applyDecoratedDescriptor(_class2$b.prototype, "contentSize", [_dec5$8, _dec6$7], Object.getOwnPropertyDescriptor(_class2$b.prototype, "contentSize"), _class2$b.prototype), _applyDecoratedDescriptor(_class2$b.prototype, "anchorPoint", [_dec7$7, _dec8$6], Object.getOwnPropertyDescriptor(_class2$b.prototype, "anchorPoint"), _class2$b.prototype), _descriptor$b = _applyDecoratedDescriptor(_class2$b.prototype, "_contentSize", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Size$1(100, 100);
              }
            }), _descriptor2$9 = _applyDecoratedDescriptor(_class2$b.prototype, "_anchorPoint", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec2(0.5, 0.5);
              }
            })), _class2$b)) || _class$e) || _class$e) || _class$e) || _class$e) || _class$e) || _class$e));
            director.on(Director.EVENT_AFTER_UPDATE, UITransform._sortSiblings);
            director.on(Director.EVENT_BEFORE_SCENE_LAUNCH, UITransform._cleanChangeMap);

            let Stage;

            (function (Stage) {
              Stage[Stage["DISABLED"] = 0] = "DISABLED";
              Stage[Stage["CLEAR"] = 1] = "CLEAR";
              Stage[Stage["ENTER_LEVEL"] = 2] = "ENTER_LEVEL";
              Stage[Stage["ENABLED"] = 3] = "ENABLED";
              Stage[Stage["EXIT_LEVEL"] = 4] = "EXIT_LEVEL";
              Stage[Stage["CLEAR_INVERTED"] = 5] = "CLEAR_INVERTED";
              Stage[Stage["ENTER_LEVEL_INVERTED"] = 6] = "ENTER_LEVEL_INVERTED";
            })(Stage || (Stage = {}));

            class StencilManager {
              constructor() {
                this.stage = Stage.DISABLED;
                this._maskStack = [];
                this._stencilPattern = {
                  stencilTest: true,
                  func: ComparisonFunc.ALWAYS,
                  stencilMask: 0xffff,
                  writeMask: 0xffff,
                  failOp: StencilOp.KEEP,
                  zFailOp: StencilOp.KEEP,
                  passOp: StencilOp.KEEP,
                  ref: 1
                };
                this.stencilStateMap = new Map();
                this.stencilStateMapWithDepth = new Map();
              }

              get pattern() {
                return this._stencilPattern;
              }

              pushMask(mask) {
                this._maskStack.push(mask);
              }

              clear(comp) {
                comp.stencilStage = comp.inverted ? Stage.CLEAR_INVERTED : Stage.CLEAR;
              }

              enterLevel(comp) {
                comp.graphics.stencilStage = comp.inverted ? Stage.ENTER_LEVEL_INVERTED : Stage.ENTER_LEVEL;
              }

              enableMask() {
                this.stage = Stage.ENABLED;
              }

              exitMask() {
                if (this._maskStack.length === 0) {
                  return;
                }

                this._maskStack.pop();

                if (this._maskStack.length === 0) {
                  this.stage = Stage.DISABLED;
                } else {
                  this.stage = Stage.ENABLED;
                }
              }

              getWriteMask() {
                return 1 << this._maskStack.length - 1;
              }

              getExitWriteMask() {
                return 1 << this._maskStack.length;
              }

              getStencilRef() {
                let result = 0;

                for (let i = 0; i < this._maskStack.length; ++i) {
                  result += 0x00000001 << i;
                }

                return result;
              }

              reset() {
                this._maskStack.length = 0;
                this.stage = Stage.DISABLED;
              }

              destroy() {
                this.stencilStateMap.forEach((value, key) => {
                  value.destroy();
                });
                this.stencilStateMap.clear();
              }

              getStencilStage(stage, mat) {
                let key = 0;
                let depthTest = false;
                let depthWrite = false;
                let depthFunc = ComparisonFunc.LESS;
                let cacheMap = this.stencilStateMap;

                if (mat && mat.passes[0]) {
                  const pass = mat.passes[0];
                  const dss = pass.depthStencilState;
                  let depthTestValue = 0;
                  let depthWriteValue = 0;
                  if (dss.depthTest) depthTestValue = 1;
                  if (dss.depthWrite) depthWriteValue = 1;
                  key = depthTestValue | depthWriteValue << 1 | dss.depthFunc << 2 | stage << 6 | this._maskStack.length << 9;
                  depthTest = dss.depthTest;
                  depthWrite = dss.depthWrite;
                  depthFunc = dss.depthFunc;
                  cacheMap = this.stencilStateMapWithDepth;
                } else {
                  key = stage << 16 | this._maskStack.length;
                }

                if (cacheMap && cacheMap.has(key)) {
                  return cacheMap.get(key);
                }

                this.setStateFromStage(stage);
                const depthStencilState = new DepthStencilState$1(depthTest, depthWrite, depthFunc, this._stencilPattern.stencilTest, this._stencilPattern.func, this._stencilPattern.stencilMask, this._stencilPattern.writeMask, this._stencilPattern.failOp, this._stencilPattern.zFailOp, this._stencilPattern.passOp, this._stencilPattern.ref, this._stencilPattern.stencilTest, this._stencilPattern.func, this._stencilPattern.stencilMask, this._stencilPattern.writeMask, this._stencilPattern.failOp, this._stencilPattern.zFailOp, this._stencilPattern.passOp, this._stencilPattern.ref);
                cacheMap.set(key, depthStencilState);
                return depthStencilState;
              }

              getStencilHash(stage) {
                return stage << 8 | this._maskStack.length;
              }

              setStateFromStage(stage) {
                const pattern = this._stencilPattern;

                if (stage === Stage.DISABLED) {
                  pattern.stencilTest = false;
                  pattern.func = ComparisonFunc.ALWAYS;
                  pattern.failOp = StencilOp.KEEP;
                  pattern.stencilMask = pattern.writeMask = 0xffff;
                  pattern.ref = 1;
                } else {
                  pattern.stencilTest = true;

                  if (stage === Stage.ENABLED) {
                    pattern.func = ComparisonFunc.EQUAL;
                    pattern.failOp = StencilOp.KEEP;
                    pattern.stencilMask = pattern.ref = this.getStencilRef();
                    pattern.writeMask = this.getWriteMask();
                  } else if (stage === Stage.CLEAR) {
                    pattern.func = ComparisonFunc.NEVER;
                    pattern.failOp = StencilOp.ZERO;
                    pattern.writeMask = pattern.stencilMask = pattern.ref = this.getWriteMask();
                  } else if (stage === Stage.CLEAR_INVERTED) {
                    pattern.func = ComparisonFunc.NEVER;
                    pattern.failOp = StencilOp.REPLACE;
                    pattern.writeMask = pattern.stencilMask = pattern.ref = this.getWriteMask();
                  } else if (stage === Stage.ENTER_LEVEL) {
                    pattern.func = ComparisonFunc.NEVER;
                    pattern.failOp = StencilOp.REPLACE;
                    pattern.writeMask = pattern.stencilMask = pattern.ref = this.getWriteMask();
                  } else if (stage === Stage.ENTER_LEVEL_INVERTED) {
                    pattern.func = ComparisonFunc.NEVER;
                    pattern.failOp = StencilOp.ZERO;
                    pattern.writeMask = pattern.stencilMask = pattern.ref = this.getWriteMask();
                  }
                }
              }

            } exports('StencilManager', StencilManager);
            StencilManager.sharedManager = null;
            StencilManager.sharedManager = new StencilManager();

            var _dec$f, _dec2$a, _dec3$9, _dec4$9, _dec5$9, _dec6$8, _dec7$8, _dec8$7, _dec9$6, _dec10$5, _class$f, _class2$c, _descriptor$c, _descriptor2$a, _descriptor3$7, _descriptor4$7, _descriptor5$5, _class3$1, _temp$d;
            ccenum(BlendFactor);
            let InstanceMaterialType;

            (function (InstanceMaterialType) {
              InstanceMaterialType[InstanceMaterialType["ADD_COLOR"] = 0] = "ADD_COLOR";
              InstanceMaterialType[InstanceMaterialType["ADD_COLOR_AND_TEXTURE"] = 1] = "ADD_COLOR_AND_TEXTURE";
              InstanceMaterialType[InstanceMaterialType["GRAYSCALE"] = 2] = "GRAYSCALE";
              InstanceMaterialType[InstanceMaterialType["USE_ALPHA_SEPARATED"] = 3] = "USE_ALPHA_SEPARATED";
              InstanceMaterialType[InstanceMaterialType["USE_ALPHA_SEPARATED_AND_GRAY"] = 4] = "USE_ALPHA_SEPARATED_AND_GRAY";
            })(InstanceMaterialType || (InstanceMaterialType = exports('InstanceMaterialType', {})));

            let Renderable2D = function (v) { return exports({ Renderable2D: v, RenderComponent: v, UIRenderable: v }), v; }((_dec$f = ccclass('cc.Renderable2D'), _dec2$a = requireComponent(UITransform), _dec3$9 = visible(), _dec4$9 = type$1(Material), _dec5$9 = type$1(Material), _dec6$8 = displayOrder(), _dec7$8 = tooltip(), _dec8$7 = displayName(), _dec9$6 = displayOrder(), _dec10$5 = tooltip(), _dec$f(_class$f = _dec2$a(_class$f = disallowMultiple(_class$f = executeInEditMode(_class$f = (_class2$c = (_temp$d = _class3$1 = class Renderable2D extends RenderableComponent {
              get sharedMaterials() {
                return  this._materials;
              }

              set sharedMaterials(val) {
                for (let i = 0; i < val.length; i++) {
                  if (val[i] !== this._materials[i]) {
                    this.setMaterial(val[i], i);
                  }
                }

                if (val.length < this._materials.length) {
                  for (let i = val.length; i < this._materials.length; i++) {
                    this.setMaterial(null, i);
                  }

                  this._materials.splice(val.length);
                }
              }

              get customMaterial() {
                return this._customMaterial;
              }

              set customMaterial(val) {
                this._customMaterial = val;
                this.updateMaterial();
              }

              updateMaterial() {
                if (this._customMaterial) {
                  this.setMaterial(this._customMaterial, 0);

                  if (this._renderData) {
                    this._renderData.material = this._customMaterial;
                    this.markForUpdateRenderData();
                    this._renderData.passDirty = true;
                  }

                  this._blendHash = -1;

                  return;
                }

                const mat = this._updateBuiltinMaterial();

                this.setMaterial(mat, 0);

                if (this._renderData) {
                  this._renderData.material = mat;
                  this.markForUpdateRenderData();
                }

                this._updateBlendFunc();
              }

              get color() {
                return this._color;
              }

              set color(value) {
                if (this._color.equals(value)) {
                  return;
                }

                const oldAlpha = this._color.a;

                this._color.set(value);

                if (oldAlpha !== this.color.a) {
                  NodeUIProperties.markOpacityTree(this.node);
                }

                this._colorDirty = true;
              }

              get renderData() {
                return this._renderData;
              }

              set delegateSrc(value) {
                this._delegateSrc = value;
              }

              constructor() {
                super();

                _initializerDefineProperty(this, "_materials", _descriptor$c, this);

                _initializerDefineProperty(this, "_customMaterial", _descriptor2$a, this);

                this.stencilStage = Stage.DISABLED;

                _initializerDefineProperty(this, "_srcBlendFactor", _descriptor3$7, this);

                _initializerDefineProperty(this, "_dstBlendFactor", _descriptor4$7, this);

                _initializerDefineProperty(this, "_color", _descriptor5$5, this);

                this._assembler = null;
                this._postAssembler = null;
                this._renderData = null;
                this._renderDataFlag = true;
                this._renderFlag = true;
                this._delegateSrc = null;
                this._instanceMaterialType = -1;
                this._blendState = new BlendState$2();
                this._blendHash = 0;
                this._colorDirty = true;
                this._lastParent = null;
              }

              get blendHash() {
                return this._blendHash;
              }

              updateBlendHash() {
                const dst = this._blendState.targets[0].blendDst << 4;
                this._blendHash = dst | this._blendState.targets[0].blendSrc;
              }

              __preload() {
                this.node._uiProps.uiComp = this;

                if (this._flushAssembler) {
                  this._flushAssembler();
                }

                NodeUIProperties.markOpacityTree(this.node);
              }

              onEnable() {
                this.node.on(NodeEventType.ANCHOR_CHANGED, this._nodeStateChange, this);
                this.node.on(NodeEventType.SIZE_CHANGED, this._nodeStateChange, this);
                this.updateMaterial();
                this._renderFlag = this._canRender();
              }

              onRestore() {
                this.updateMaterial();
                this._renderFlag = this._canRender();
              }

              onDisable() {
                this.node.off(NodeEventType.ANCHOR_CHANGED, this._nodeStateChange, this);
                this.node.off(NodeEventType.SIZE_CHANGED, this._nodeStateChange, this);
                this._renderFlag = false;
              }

              onDestroy() {
                if (this.node._uiProps.uiComp === this) {
                  this.node._uiProps.uiComp = null;
                }

                this.destroyRenderData();

                if (this._materialInstances) {
                  for (let i = 0; i < this._materialInstances.length; i++) {
                    this._materialInstances[i] && this._materialInstances[i].destroy();
                  }
                }

                this._renderData = null;

                if (this._blendState) {
                  this._blendState.destroy();
                }
              }

              markForUpdateRenderData(enable = true) {
                this._renderFlag = this._canRender();

                if (enable && this._renderFlag) {
                  const renderData = this._renderData;

                  if (renderData) {
                    renderData.vertDirty = true;
                  }

                  this._renderDataFlag = enable;
                } else if (!enable) {
                  this._renderDataFlag = enable;
                }
              }

              requestRenderData() {
                const data = RenderData.add();
                this._renderData = data;
                return data;
              }

              destroyRenderData() {
                if (!this._renderData) {
                  return;
                }

                RenderData.remove(this._renderData);
                this._renderData = null;
              }

              updateAssembler(render) {
                this._updateColor();

                if (this._renderFlag) {
                  this._checkAndUpdateRenderData();

                  this._render(render);
                }
              }

              postUpdateAssembler(render) {
                if (this._renderFlag) {
                  this._postRender(render);
                }
              }

              _render(render) {}

              _postRender(render) {}

              _checkAndUpdateRenderData() {
                if (this._renderDataFlag) {
                  this._assembler.updateRenderData(this);

                  this._renderDataFlag = false;
                }
              }

              _canRender() {
                return this.isValid && this.getMaterial(0) !== null && this.enabled && (this._delegateSrc ? this._delegateSrc.activeInHierarchy : this.enabledInHierarchy) && this.node._uiProps.opacity > 0;
              }

              _postCanRender() {}

              _updateColor() {

                if (this._colorDirty && this._assembler && this._assembler.updateColor) {
                  this._assembler.updateColor(this);

                  this._renderFlag = this._canRender();
                  this._colorDirty = false;
                }
              }

              markColorDirty() {
                this._colorDirty = true;
              }

              _updateBlendFunc() {
                let target = this._blendState.targets[0];

                if (!target) {
                  target = new BlendTarget$1();

                  this._blendState.setTarget(0, target);
                }

                if (target.blendDst !== this._dstBlendFactor || target.blendSrc !== this._srcBlendFactor) {
                  target.blend = true;
                  target.blendDstAlpha = BlendFactor.ONE_MINUS_SRC_ALPHA;
                  target.blendDst = this._dstBlendFactor;
                  target.blendSrc = this._srcBlendFactor;

                  if (this.renderData) {
                    this.renderData.passDirty = true;
                  }
                }

                this.updateBlendHash();
              }

              getBlendState() {
                return this._blendState;
              }

              _nodeStateChange(transformType) {
                if (this._renderData) {
                  this.markForUpdateRenderData();
                }

                for (let i = 0; i < this.node.children.length; ++i) {
                  const child = this.node.children[i];
                  const renderComp = child.getComponent(Renderable2D);

                  if (renderComp) {
                    renderComp.markForUpdateRenderData();
                  }
                }
              }

              _onMaterialModified(idx, material) {
                if (this._renderData) {
                  this.markForUpdateRenderData();
                  this._renderData.passDirty = true;
                }

                super._onMaterialModified(idx, material);
              }

              _updateBuiltinMaterial() {
                let gpuMat = '';

                let mat;

                switch (this._instanceMaterialType) {
                  case InstanceMaterialType.ADD_COLOR:
                    mat = builtinResMgr.get(`ui-base${gpuMat}-material`);
                    break;

                  case InstanceMaterialType.GRAYSCALE:
                    mat = builtinResMgr.get(`ui-sprite-gray${gpuMat}-material`);
                    break;

                  case InstanceMaterialType.USE_ALPHA_SEPARATED:
                    mat = builtinResMgr.get(`ui-sprite-alpha-sep${gpuMat}-material`);
                    break;

                  case InstanceMaterialType.USE_ALPHA_SEPARATED_AND_GRAY:
                    mat = builtinResMgr.get(`ui-sprite-gray-alpha-sep${gpuMat}-material`);
                    break;

                  default:
                    mat = builtinResMgr.get(`ui-sprite${gpuMat}-material`);
                    break;
                }

                return mat;
              }

              setNodeDirty() {
                if (this.renderData) {
                  this.renderData.nodeDirty = true;
                }
              }

              setTextureDirty() {
                if (this.renderData) {
                  this.renderData.textureDirty = true;
                }
              }

            }, _class3$1.BlendState = BlendFactor, _class3$1.Assembler = null, _class3$1.PostAssembler = null, _temp$d), (_descriptor$c = _applyDecoratedDescriptor(_class2$c.prototype, "_materials", [override], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _applyDecoratedDescriptor(_class2$c.prototype, "sharedMaterials", [override, _dec3$9], Object.getOwnPropertyDescriptor(_class2$c.prototype, "sharedMaterials"), _class2$c.prototype), _descriptor2$a = _applyDecoratedDescriptor(_class2$c.prototype, "_customMaterial", [_dec4$9], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _applyDecoratedDescriptor(_class2$c.prototype, "customMaterial", [_dec5$9, _dec6$8, _dec7$8, _dec8$7], Object.getOwnPropertyDescriptor(_class2$c.prototype, "customMaterial"), _class2$c.prototype), _applyDecoratedDescriptor(_class2$c.prototype, "color", [_dec9$6, _dec10$5], Object.getOwnPropertyDescriptor(_class2$c.prototype, "color"), _class2$c.prototype), _descriptor3$7 = _applyDecoratedDescriptor(_class2$c.prototype, "_srcBlendFactor", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return BlendFactor.SRC_ALPHA;
              }
            }), _descriptor4$7 = _applyDecoratedDescriptor(_class2$c.prototype, "_dstBlendFactor", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return BlendFactor.ONE_MINUS_SRC_ALPHA;
              }
            }), _descriptor5$5 = _applyDecoratedDescriptor(_class2$c.prototype, "_color", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Color$1.WHITE.clone();
              }
            })), _class2$c)) || _class$f) || _class$f) || _class$f) || _class$f));
            legacyCC.internal.Renderable2D = Renderable2D;

            var _dec$g, _dec2$b, _dec3$a, _dec4$a, _dec5$a, _dec6$9, _dec7$9, _dec8$8, _dec9$7, _dec10$6, _dec11$3, _dec12$3, _dec13$2, _dec14$1, _dec15$1, _dec16$1, _dec17, _dec18, _dec19, _dec20, _dec21, _dec22, _dec23, _dec24, _dec25, _dec26, _dec27, _dec28, _dec29, _dec30, _dec31, _dec32, _dec33, _dec34, _dec35, _dec36, _dec37, _dec38, _dec39, _dec40, _dec41, _dec42, _dec43, _dec44, _dec45, _class$g, _class2$d, _descriptor$d, _descriptor2$b, _descriptor3$8, _descriptor4$8, _descriptor5$6, _descriptor6$4, _descriptor7$3, _descriptor8$3, _descriptor9$2, _descriptor10$1, _descriptor11$1, _descriptor12, _descriptor13, _descriptor14, _descriptor15, _descriptor16, _descriptor17, _class3$2, _temp$e;
            let HorizontalTextAlignment;

            (function (HorizontalTextAlignment) {
              HorizontalTextAlignment[HorizontalTextAlignment["LEFT"] = 0] = "LEFT";
              HorizontalTextAlignment[HorizontalTextAlignment["CENTER"] = 1] = "CENTER";
              HorizontalTextAlignment[HorizontalTextAlignment["RIGHT"] = 2] = "RIGHT";
            })(HorizontalTextAlignment || (HorizontalTextAlignment = exports('HorizontalTextAlignment', {})));

            ccenum(HorizontalTextAlignment);
            let VerticalTextAlignment;

            (function (VerticalTextAlignment) {
              VerticalTextAlignment[VerticalTextAlignment["TOP"] = 0] = "TOP";
              VerticalTextAlignment[VerticalTextAlignment["CENTER"] = 1] = "CENTER";
              VerticalTextAlignment[VerticalTextAlignment["BOTTOM"] = 2] = "BOTTOM";
            })(VerticalTextAlignment || (VerticalTextAlignment = exports('VerticalTextAlignment', {})));

            ccenum(VerticalTextAlignment);
            let Overflow;

            (function (Overflow) {
              Overflow[Overflow["NONE"] = 0] = "NONE";
              Overflow[Overflow["CLAMP"] = 1] = "CLAMP";
              Overflow[Overflow["SHRINK"] = 2] = "SHRINK";
              Overflow[Overflow["RESIZE_HEIGHT"] = 3] = "RESIZE_HEIGHT";
            })(Overflow || (Overflow = exports('Overflow', {})));

            ccenum(Overflow);
            let CacheMode;

            (function (CacheMode) {
              CacheMode[CacheMode["NONE"] = 0] = "NONE";
              CacheMode[CacheMode["BITMAP"] = 1] = "BITMAP";
              CacheMode[CacheMode["CHAR"] = 2] = "CHAR";
            })(CacheMode || (CacheMode = exports('CacheMode', {})));

            ccenum(CacheMode);
            let Label = function (v) { return exports({ Label: v, LabelComponent: v }), v; }((_dec$g = ccclass('cc.Label'), _dec2$b = help(), _dec3$a = executionOrder(110), _dec4$a = menu$1(), _dec5$a = displayOrder(), _dec6$9 = tooltip(), _dec7$9 = type$1(HorizontalTextAlignment), _dec8$8 = displayOrder(), _dec9$7 = tooltip(), _dec10$6 = type$1(VerticalTextAlignment), _dec11$3 = displayOrder(), _dec12$3 = tooltip(), _dec13$2 = displayOrder(), _dec14$1 = tooltip(), _dec15$1 = displayOrder(), _dec16$1 = visible(), _dec17 = tooltip(), _dec18 = displayOrder(), _dec19 = tooltip(), _dec20 = visible(), _dec21 = displayOrder(), _dec22 = tooltip(), _dec23 = type$1(Overflow), _dec24 = displayOrder(), _dec25 = tooltip(), _dec26 = displayOrder(), _dec27 = tooltip(), _dec28 = type$1(Font), _dec29 = displayOrder(), _dec30 = visible(), _dec31 = tooltip(), _dec32 = displayOrder(), _dec33 = tooltip(), _dec34 = type$1(CacheMode), _dec35 = displayOrder(), _dec36 = tooltip(), _dec37 = displayOrder(), _dec38 = tooltip(), _dec39 = displayOrder(), _dec40 = tooltip(), _dec41 = displayOrder(), _dec42 = tooltip(), _dec43 = visible(), _dec44 = displayOrder(), _dec45 = tooltip(), _dec$g(_class$g = _dec2$b(_class$g = _dec3$a(_class$g = _dec4$a(_class$g = (_class2$d = (_temp$e = _class3$2 = class Label extends Renderable2D {
              get string() {
                return this._string;
              }

              set string(value) {
                if (value === null || value === undefined) {
                  value = '';
                } else {
                  value = value.toString();
                }

                if (this._string === value) {
                  return;
                }

                this._string = value;
                this.updateRenderData();
              }

              get horizontalAlign() {
                return this._horizontalAlign;
              }

              set horizontalAlign(value) {
                if (this._horizontalAlign === value) {
                  return;
                }

                this._horizontalAlign = value;
                this.updateRenderData();
              }

              get verticalAlign() {
                return this._verticalAlign;
              }

              set verticalAlign(value) {
                if (this._verticalAlign === value) {
                  return;
                }

                this._verticalAlign = value;
                this.updateRenderData();
              }

              get actualFontSize() {
                return this._actualFontSize;
              }

              set actualFontSize(value) {
                this._actualFontSize = value;
              }

              get fontSize() {
                return this._fontSize;
              }

              set fontSize(value) {
                if (this._fontSize === value) {
                  return;
                }

                this._fontSize = value;
                this.updateRenderData();
              }

              get fontFamily() {
                return this._fontFamily;
              }

              set fontFamily(value) {
                if (this._fontFamily === value) {
                  return;
                }

                this._fontFamily = value;
                this.updateRenderData();
              }

              get lineHeight() {
                return this._lineHeight;
              }

              set lineHeight(value) {
                if (this._lineHeight === value) {
                  return;
                }

                this._lineHeight = value;
                this.updateRenderData();
              }

              get spacingX() {
                return this._spacingX;
              }

              set spacingX(value) {
                if (this._spacingX === value) {
                  return;
                }

                this._spacingX = value;
                this.updateRenderData();
              }

              get overflow() {
                return this._overflow;
              }

              set overflow(value) {
                if (this._overflow === value) {
                  return;
                }

                this._overflow = value;
                this.updateRenderData();
              }

              get enableWrapText() {
                return this._enableWrapText;
              }

              set enableWrapText(value) {
                if (this._enableWrapText === value) {
                  return;
                }

                this._enableWrapText = value;
                this.updateRenderData();
              }

              get font() {
                return this._font;
              }

              set font(value) {
                if (this._font === value) {
                  return;
                }

                this._isSystemFontUsed = !value;

                this._font = value;

                if (this._renderData) {
                  this.destroyRenderData();
                  this._renderData = null;
                }

                this._fontAtlas = null;
                this.updateRenderData(true);
              }

              get useSystemFont() {
                return this._isSystemFontUsed;
              }

              set useSystemFont(value) {
                if (this._isSystemFontUsed === value) {
                  return;
                }

                this.destroyRenderData();
                this._renderData = null;

                this._isSystemFontUsed = !!value;

                if (value) {
                  this.font = null;
                }

                this._flushAssembler();

                this.updateRenderData();
              }

              get cacheMode() {
                return this._cacheMode;
              }

              set cacheMode(value) {
                if (this._cacheMode === value) {
                  return;
                }

                if (this._cacheMode === CacheMode.BITMAP && !(this._font instanceof BitmapFont) && this._ttfSpriteFrame) {
                  this._ttfSpriteFrame._resetDynamicAtlasFrame();
                }

                if (this._cacheMode === CacheMode.CHAR) {
                  this._ttfSpriteFrame = null;
                }

                this._cacheMode = value;
                this.updateRenderData(true);
              }

              get spriteFrame() {
                return this._texture;
              }

              get ttfSpriteFrame() {
                return this._ttfSpriteFrame;
              }

              get isBold() {
                return this._isBold;
              }

              set isBold(value) {
                if (this._isBold === value) {
                  return;
                }

                this._isBold = value;
                this.updateRenderData();
              }

              get isItalic() {
                return this._isItalic;
              }

              set isItalic(value) {
                if (this._isItalic === value) {
                  return;
                }

                this._isItalic = value;
                this.updateRenderData();
              }

              get isUnderline() {
                return this._isUnderline;
              }

              set isUnderline(value) {
                if (this._isUnderline === value) {
                  return;
                }

                this._isUnderline = value;
                this.updateRenderData();
              }

              get underlineHeight() {
                return this._underlineHeight;
              }

              set underlineHeight(value) {
                if (this._underlineHeight === value) return;
                this._underlineHeight = value;
                this.updateRenderData();
              }

              get assemblerData() {
                return this._assemblerData;
              }

              get fontAtlas() {
                return this._fontAtlas;
              }

              set fontAtlas(value) {
                this._fontAtlas = value;
              }

              get _bmFontOriginalSize() {
                if (this._font instanceof BitmapFont) {
                  return this._font.fontSize;
                } else {
                  return -1;
                }
              }

              constructor() {
                super();

                _initializerDefineProperty(this, "_string", _descriptor$d, this);

                _initializerDefineProperty(this, "_horizontalAlign", _descriptor2$b, this);

                _initializerDefineProperty(this, "_verticalAlign", _descriptor3$8, this);

                _initializerDefineProperty(this, "_actualFontSize", _descriptor4$8, this);

                _initializerDefineProperty(this, "_fontSize", _descriptor5$6, this);

                _initializerDefineProperty(this, "_fontFamily", _descriptor6$4, this);

                _initializerDefineProperty(this, "_lineHeight", _descriptor7$3, this);

                _initializerDefineProperty(this, "_overflow", _descriptor8$3, this);

                _initializerDefineProperty(this, "_enableWrapText", _descriptor9$2, this);

                _initializerDefineProperty(this, "_font", _descriptor10$1, this);

                _initializerDefineProperty(this, "_isSystemFontUsed", _descriptor11$1, this);

                _initializerDefineProperty(this, "_spacingX", _descriptor12, this);

                _initializerDefineProperty(this, "_isItalic", _descriptor13, this);

                _initializerDefineProperty(this, "_isBold", _descriptor14, this);

                _initializerDefineProperty(this, "_isUnderline", _descriptor15, this);

                _initializerDefineProperty(this, "_underlineHeight", _descriptor16, this);

                _initializerDefineProperty(this, "_cacheMode", _descriptor17, this);

                this._N$file = null;
                this._texture = null;
                this._ttfSpriteFrame = null;
                this._userDefinedFont = null;
                this._assemblerData = null;
                this._fontAtlas = null;
                this._letterTexture = null;

                this._ttfSpriteFrame = null;
              }

              onEnable() {
                super.onEnable();

                if (!this._font && !this._isSystemFontUsed) {
                  this.useSystemFont = true;
                }

                if (this._isSystemFontUsed && !this._fontFamily) {
                  this.fontFamily = 'Arial';
                }

                this._applyFontTexture();
              }

              onDestroy() {
                if (this._assembler && this._assembler.resetAssemblerData) {
                  this._assembler.resetAssemblerData(this._assemblerData);
                }

                this._assemblerData = null;

                if (this._ttfSpriteFrame) {
                  this._ttfSpriteFrame._resetDynamicAtlasFrame();

                  const tex = this._ttfSpriteFrame.texture;

                  this._ttfSpriteFrame.destroy();

                  if (tex) {
                    const tex2d = tex;

                    if (tex2d.image) {
                      tex2d.image.destroy();
                    }

                    tex.destroy();
                  }

                  this._ttfSpriteFrame = null;
                }

                this._letterTexture = null;
                super.onDestroy();
              }

              updateRenderData(force = false) {
                this.markForUpdateRenderData();

                if (force) {
                  this._flushAssembler();

                  if (this.renderData) this.renderData.vertDirty = true;

                  this._applyFontTexture();

                  if (this._assembler) {
                    this._assembler.updateRenderData(this);
                  }
                }
              }

              _render(render) {
                render.commitComp(this, this._texture, this._assembler, null);
              }

              _updateColor() {
                if (this._colorDirty) {
                  this.updateRenderData(false);
                  this._colorDirty = false;
                }
              }

              _canRender() {
                if (!super._canRender() || !this._string) {
                  return false;
                }

                const font = this._font;

                if (font && font instanceof BitmapFont) {
                  const spriteFrame = font.spriteFrame;

                  if (!spriteFrame || !spriteFrame.texture) {
                    return false;
                  }
                }

                return true;
              }

              _flushAssembler() {
                const assembler = Label.Assembler.getAssembler(this);

                if (this._assembler !== assembler) {
                  this.destroyRenderData();
                  this._assembler = assembler;
                }

                if (!this._renderData) {
                  if (this._assembler && this._assembler.createData) {
                    this._renderData = this._assembler.createData(this);
                    this._renderData.material = this.material;
                  }
                }
              }

              _applyFontTexture() {
                this.markForUpdateRenderData();
                const font = this._font;

                if (font instanceof BitmapFont) {
                  const spriteFrame = font.spriteFrame;

                  if (spriteFrame && spriteFrame.texture) {
                    this._texture = spriteFrame;

                    if (this.renderData) {
                      this.renderData.textureDirty = true;
                    }

                    this.changeMaterialForDefine();

                    if (this._assembler) {
                      this._assembler.updateRenderData(this);
                    }
                  }
                } else {
                  if (this.cacheMode === CacheMode.CHAR) {
                    this._letterTexture = this._assembler.getAssemblerData();
                    this._texture = this._letterTexture;
                  } else if (!this._ttfSpriteFrame) {
                    this._ttfSpriteFrame = new SpriteFrame();
                    this._assemblerData = this._assembler.getAssemblerData();
                    const image = new ImageAsset(this._assemblerData.canvas);
                    const texture = new Texture2D();
                    texture.image = image;
                    this._ttfSpriteFrame.texture = texture;
                  }

                  if (this.cacheMode !== CacheMode.CHAR) {
                    this._texture = this._ttfSpriteFrame;
                  }

                  this.changeMaterialForDefine();
                }
              }

              changeMaterialForDefine() {
                if (!this._texture) {
                  return;
                }

                let value = false;

                if (this.cacheMode !== CacheMode.CHAR) {
                  const spriteFrame = this._texture;
                  const texture = spriteFrame.texture;

                  if (texture instanceof TextureBase) {
                    const format = texture.getPixelFormat();
                    value = format === PixelFormat.RGBA_ETC1 || format === PixelFormat.RGB_A_PVRTC_4BPPV1 || format === PixelFormat.RGB_A_PVRTC_2BPPV1;
                  }
                }

                if (value) {
                  this._instanceMaterialType = InstanceMaterialType.USE_ALPHA_SEPARATED;
                } else {
                  this._instanceMaterialType = InstanceMaterialType.ADD_COLOR_AND_TEXTURE;
                }

                this.updateMaterial();
              }

            }, _class3$2.HorizontalAlign = HorizontalTextAlignment, _class3$2.VerticalAlign = VerticalTextAlignment, _class3$2.Overflow = Overflow, _class3$2.CacheMode = CacheMode, _class3$2._canvasPool = CanvasPool.getInstance(), _temp$e), (_applyDecoratedDescriptor(_class2$d.prototype, "string", [_dec5$a, _dec6$9, multiline], Object.getOwnPropertyDescriptor(_class2$d.prototype, "string"), _class2$d.prototype), _applyDecoratedDescriptor(_class2$d.prototype, "horizontalAlign", [_dec7$9, _dec8$8, _dec9$7], Object.getOwnPropertyDescriptor(_class2$d.prototype, "horizontalAlign"), _class2$d.prototype), _applyDecoratedDescriptor(_class2$d.prototype, "verticalAlign", [_dec10$6, _dec11$3, _dec12$3], Object.getOwnPropertyDescriptor(_class2$d.prototype, "verticalAlign"), _class2$d.prototype), _applyDecoratedDescriptor(_class2$d.prototype, "fontSize", [_dec13$2, _dec14$1], Object.getOwnPropertyDescriptor(_class2$d.prototype, "fontSize"), _class2$d.prototype), _applyDecoratedDescriptor(_class2$d.prototype, "fontFamily", [_dec15$1, _dec16$1, _dec17], Object.getOwnPropertyDescriptor(_class2$d.prototype, "fontFamily"), _class2$d.prototype), _applyDecoratedDescriptor(_class2$d.prototype, "lineHeight", [_dec18, _dec19], Object.getOwnPropertyDescriptor(_class2$d.prototype, "lineHeight"), _class2$d.prototype), _applyDecoratedDescriptor(_class2$d.prototype, "spacingX", [_dec20, _dec21, _dec22], Object.getOwnPropertyDescriptor(_class2$d.prototype, "spacingX"), _class2$d.prototype), _applyDecoratedDescriptor(_class2$d.prototype, "overflow", [_dec23, _dec24, _dec25], Object.getOwnPropertyDescriptor(_class2$d.prototype, "overflow"), _class2$d.prototype), _applyDecoratedDescriptor(_class2$d.prototype, "enableWrapText", [_dec26, _dec27], Object.getOwnPropertyDescriptor(_class2$d.prototype, "enableWrapText"), _class2$d.prototype), _applyDecoratedDescriptor(_class2$d.prototype, "font", [_dec28, _dec29, _dec30, _dec31], Object.getOwnPropertyDescriptor(_class2$d.prototype, "font"), _class2$d.prototype), _applyDecoratedDescriptor(_class2$d.prototype, "useSystemFont", [_dec32, _dec33], Object.getOwnPropertyDescriptor(_class2$d.prototype, "useSystemFont"), _class2$d.prototype), _applyDecoratedDescriptor(_class2$d.prototype, "cacheMode", [_dec34, _dec35, _dec36], Object.getOwnPropertyDescriptor(_class2$d.prototype, "cacheMode"), _class2$d.prototype), _applyDecoratedDescriptor(_class2$d.prototype, "isBold", [_dec37, _dec38], Object.getOwnPropertyDescriptor(_class2$d.prototype, "isBold"), _class2$d.prototype), _applyDecoratedDescriptor(_class2$d.prototype, "isItalic", [_dec39, _dec40], Object.getOwnPropertyDescriptor(_class2$d.prototype, "isItalic"), _class2$d.prototype), _applyDecoratedDescriptor(_class2$d.prototype, "isUnderline", [_dec41, _dec42], Object.getOwnPropertyDescriptor(_class2$d.prototype, "isUnderline"), _class2$d.prototype), _applyDecoratedDescriptor(_class2$d.prototype, "underlineHeight", [_dec43, editable, _dec44, _dec45], Object.getOwnPropertyDescriptor(_class2$d.prototype, "underlineHeight"), _class2$d.prototype), _descriptor$d = _applyDecoratedDescriptor(_class2$d.prototype, "_string", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 'label';
              }
            }), _descriptor2$b = _applyDecoratedDescriptor(_class2$d.prototype, "_horizontalAlign", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return HorizontalTextAlignment.CENTER;
              }
            }), _descriptor3$8 = _applyDecoratedDescriptor(_class2$d.prototype, "_verticalAlign", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return VerticalTextAlignment.CENTER;
              }
            }), _descriptor4$8 = _applyDecoratedDescriptor(_class2$d.prototype, "_actualFontSize", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor5$6 = _applyDecoratedDescriptor(_class2$d.prototype, "_fontSize", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 40;
              }
            }), _descriptor6$4 = _applyDecoratedDescriptor(_class2$d.prototype, "_fontFamily", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 'Arial';
              }
            }), _descriptor7$3 = _applyDecoratedDescriptor(_class2$d.prototype, "_lineHeight", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 40;
              }
            }), _descriptor8$3 = _applyDecoratedDescriptor(_class2$d.prototype, "_overflow", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Overflow.NONE;
              }
            }), _descriptor9$2 = _applyDecoratedDescriptor(_class2$d.prototype, "_enableWrapText", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _descriptor10$1 = _applyDecoratedDescriptor(_class2$d.prototype, "_font", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor11$1 = _applyDecoratedDescriptor(_class2$d.prototype, "_isSystemFontUsed", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _descriptor12 = _applyDecoratedDescriptor(_class2$d.prototype, "_spacingX", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor13 = _applyDecoratedDescriptor(_class2$d.prototype, "_isItalic", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor14 = _applyDecoratedDescriptor(_class2$d.prototype, "_isBold", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor15 = _applyDecoratedDescriptor(_class2$d.prototype, "_isUnderline", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor16 = _applyDecoratedDescriptor(_class2$d.prototype, "_underlineHeight", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 2;
              }
            }), _descriptor17 = _applyDecoratedDescriptor(_class2$d.prototype, "_cacheMode", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return CacheMode.NONE;
              }
            })), _class2$d)) || _class$g) || _class$g) || _class$g) || _class$g));

            let LineCap;

            (function (LineCap) {
              LineCap[LineCap["BUTT"] = 0] = "BUTT";
              LineCap[LineCap["ROUND"] = 1] = "ROUND";
              LineCap[LineCap["SQUARE"] = 2] = "SQUARE";
            })(LineCap || (LineCap = {}));

            ccenum(LineCap);
            let LineJoin;

            (function (LineJoin) {
              LineJoin[LineJoin["BEVEL"] = 0] = "BEVEL";
              LineJoin[LineJoin["ROUND"] = 1] = "ROUND";
              LineJoin[LineJoin["MITER"] = 2] = "MITER";
            })(LineJoin || (LineJoin = {}));

            ccenum(LineJoin);
            let PointFlags;

            (function (PointFlags) {
              PointFlags[PointFlags["PT_CORNER"] = 1] = "PT_CORNER";
              PointFlags[PointFlags["PT_LEFT"] = 2] = "PT_LEFT";
              PointFlags[PointFlags["PT_BEVEL"] = 4] = "PT_BEVEL";
              PointFlags[PointFlags["PT_INNERBEVEL"] = 8] = "PT_INNERBEVEL";
            })(PointFlags || (PointFlags = {}));

            ccenum(PointFlags);

            const PI = Math.PI;
            const min = Math.min;
            const max = Math.max;
            const cos = Math.cos;
            const sin = Math.sin;
            const abs = Math.abs;
            const sign = Math.sign;
            const KAPPA90 = 0.5522847493;
            function arc(ctx, cx, cy, r, startAngle, endAngle, counterclockwise) {
              counterclockwise = counterclockwise || false;
              let a = 0;
              let da = 0;
              let hda = 0;
              let kappa = 0;
              let dx = 0;
              let dy = 0;
              let x = 0;
              let y = 0;
              let tanx = 0;
              let tany = 0;
              let px = 0;
              let py = 0;
              let ptanx = 0;
              let ptany = 0;
              let i = 0;
              let ndivs = 0;
              da = endAngle - startAngle;

              if (counterclockwise) {
                if (abs(da) >= PI * 2) {
                  da = PI * 2;
                } else {
                  while (da < 0) {
                    da += PI * 2;
                  }
                }
              } else if (abs(da) >= PI * 2) {
                da = -PI * 2;
              } else {
                while (da > 0) {
                  da -= PI * 2;
                }
              }

              ndivs = max(1, min(abs(da) / (PI * 0.5) + 0.5, 5)) | 0;
              hda = da / ndivs / 2.0;
              kappa = abs(4.0 / 3.0 * (1 - cos(hda)) / sin(hda));

              if (!counterclockwise) {
                kappa = -kappa;
              }

              for (i = 0; i <= ndivs; i++) {
                a = startAngle + da * (i / ndivs);
                dx = cos(a);
                dy = sin(a);
                x = cx + dx * r;
                y = cy + dy * r;
                tanx = -dy * r * kappa;
                tany = dx * r * kappa;

                if (i === 0) {
                  ctx.moveTo(x, y);
                } else {
                  ctx.bezierCurveTo(px + ptanx, py + ptany, x - tanx, y - tany, x, y);
                }

                px = x;
                py = y;
                ptanx = tanx;
                ptany = tany;
              }
            }
            function ellipse(ctx, cx, cy, rx, ry) {
              ctx.moveTo(cx - rx, cy);
              ctx.bezierCurveTo(cx - rx, cy + ry * KAPPA90, cx - rx * KAPPA90, cy + ry, cx, cy + ry);
              ctx.bezierCurveTo(cx + rx * KAPPA90, cy + ry, cx + rx, cy + ry * KAPPA90, cx + rx, cy);
              ctx.bezierCurveTo(cx + rx, cy - ry * KAPPA90, cx + rx * KAPPA90, cy - ry, cx, cy - ry);
              ctx.bezierCurveTo(cx - rx * KAPPA90, cy - ry, cx - rx, cy - ry * KAPPA90, cx - rx, cy);
              ctx.close();
            }
            function roundRect(ctx, x, y, w, h, r) {
              if (r < 0.1) {
                ctx.rect(x, y, w, h);
              } else {
                const rx = min(r, abs(w) * 0.5) * sign(w);
                const ry = min(r, abs(h) * 0.5) * sign(h);
                ctx.moveTo(x, y + ry);
                ctx.lineTo(x, y + h - ry);
                ctx.bezierCurveTo(x, y + h - ry * (1 - KAPPA90), x + rx * (1 - KAPPA90), y + h, x + rx, y + h);
                ctx.lineTo(x + w - rx, y + h);
                ctx.bezierCurveTo(x + w - rx * (1 - KAPPA90), y + h, x + w, y + h - ry * (1 - KAPPA90), x + w, y + h - ry);
                ctx.lineTo(x + w, y + ry);
                ctx.bezierCurveTo(x + w, y + ry * (1 - KAPPA90), x + w - rx * (1 - KAPPA90), y, x + w - rx, y);
                ctx.lineTo(x + rx, y);
                ctx.bezierCurveTo(x + rx * (1 - KAPPA90), y, x, y + ry * (1 - KAPPA90), x, y + ry);
                ctx.close();
              }
            }
            function tesselateBezier(ctx, x1, y1, x2, y2, x3, y3, x4, y4, level, type) {
              let x12 = 0;
              let y12 = 0;
              let x23 = 0;
              let y23 = 0;
              let x34 = 0;
              let y34 = 0;
              let x123 = 0;
              let y123 = 0;
              let x234 = 0;
              let y234 = 0;
              let x1234 = 0;
              let y1234 = 0;
              let dx = 0;
              let dy = 0;
              let d2 = 0;
              let d3 = 0;

              if (level > 10) {
                return;
              }

              x12 = (x1 + x2) * 0.5;
              y12 = (y1 + y2) * 0.5;
              x23 = (x2 + x3) * 0.5;
              y23 = (y2 + y3) * 0.5;
              x34 = (x3 + x4) * 0.5;
              y34 = (y3 + y4) * 0.5;
              x123 = (x12 + x23) * 0.5;
              y123 = (y12 + y23) * 0.5;
              dx = x4 - x1;
              dy = y4 - y1;
              d2 = abs((x2 - x4) * dy - (y2 - y4) * dx);
              d3 = abs((x3 - x4) * dy - (y3 - y4) * dx);

              if ((d2 + d3) * (d2 + d3) < ctx.tessTol * (dx * dx + dy * dy)) {
                ctx.addPoint(x4, y4, type === 0 ? type | PointFlags.PT_BEVEL : type);
                return;
              }

              x234 = (x23 + x34) * 0.5;
              y234 = (y23 + y34) * 0.5;
              x1234 = (x123 + x234) * 0.5;
              y1234 = (y123 + y234) * 0.5;
              tesselateBezier(ctx, x1, y1, x12, y12, x123, y123, x1234, y1234, level + 1, 0);
              tesselateBezier(ctx, x1234, y1234, x234, y234, x34, y34, x4, y4, level + 1, type);
            }

            class Point extends Vec2 {
              constructor(x, y) {
                super(x, y);
                this.dx = 0;
                this.dy = 0;
                this.dmx = 0;
                this.dmy = 0;
                this.flags = 0;
                this.len = 0;
                this.reset();
              }

              reset() {
                this.dx = 0;
                this.dy = 0;
                this.dmx = 0;
                this.dmy = 0;
                this.flags = 0;
                this.len = 0;
              }

            }
            class Path {
              constructor() {
                this.closed = false;
                this.bevel = 0;
                this.complex = true;
                this.points = [];
                this.reset();
              }

              reset() {
                this.closed = false;
                this.bevel = 0;
                this.complex = true;

                if (this.points) {
                  this.points.length = 0;
                } else {
                  this.points = [];
                }
              }

            }
            class Impl {
              constructor() {
                this.dataOffset = 0;
                this.updatePathOffset = false;
                this.pathLength = 0;
                this.pathOffset = 0;
                this.paths = [];
                this.tessTol = 0.25;
                this.distTol = 0.01;
                this.fillColor = Color$1.WHITE.clone();
                this.lineCap = LineCap.BUTT;
                this.strokeColor = Color$1.BLACK.clone();
                this.lineJoin = LineJoin.MITER;
                this.lineWidth = 0;
                this.pointsOffset = 0;
                this._commandX = 0;
                this._commandY = 0;
                this._points = [];
                this._renderDataList = [];
                this._curPath = null;
              }

              moveTo(x, y) {
                if (this.updatePathOffset) {
                  this.pathOffset = this.pathLength;
                  this.updatePathOffset = false;
                }

                this._addPath();

                this.addPoint(x, y, PointFlags.PT_CORNER);
                this._commandX = x;
                this._commandY = y;
              }

              lineTo(x, y) {
                this.addPoint(x, y, PointFlags.PT_CORNER);
                this._commandX = x;
                this._commandY = y;
              }

              bezierCurveTo(c1x, c1y, c2x, c2y, x, y) {
                const path = this._curPath;
                const last = path.points[path.points.length - 1];

                if (!last) {
                  return;
                }

                if (last.x === c1x && last.y === c1y && c2x === x && c2y === y) {
                  this.lineTo(x, y);
                  return;
                }

                tesselateBezier(this, last.x, last.y, c1x, c1y, c2x, c2y, x, y, 0, PointFlags.PT_CORNER);
                this._commandX = x;
                this._commandY = y;
              }

              quadraticCurveTo(cx, cy, x, y) {
                const x0 = this._commandX;
                const y0 = this._commandY;
                this.bezierCurveTo(x0 + 2.0 / 3.0 * (cx - x0), y0 + 2.0 / 3.0 * (cy - y0), x + 2.0 / 3.0 * (cx - x), y + 2.0 / 3.0 * (cy - y), x, y);
              }

              arc(cx, cy, r, startAngle, endAngle, counterclockwise) {
                arc(this, cx, cy, r, startAngle, endAngle, counterclockwise);
              }

              ellipse(cx, cy, rx, ry) {
                ellipse(this, cx, cy, rx, ry);
                this._curPath.complex = false;
              }

              circle(cx, cy, r) {
                ellipse(this, cx, cy, r, r);
                this._curPath.complex = false;
              }

              rect(x, y, w, h) {
                this.moveTo(x, y);
                this.lineTo(x + w, y);
                this.lineTo(x + w, y + h);
                this.lineTo(x, y + h);
                this.close();
                this._curPath.complex = false;
              }

              roundRect(x, y, w, h, r) {
                roundRect(this, x, y, w, h, r);
                this._curPath.complex = false;
              }

              clear() {
                this.pathLength = 0;
                this.pathOffset = 0;
                this.pointsOffset = 0;
                this.dataOffset = 0;
                this._curPath = null;
                this.paths.length = 0;
                this._points.length = 0;
                const dataList = this._renderDataList;

                for (let i = 0, l = dataList.length; i < l; i++) {
                  const data = dataList[i];

                  if (!data) {
                    continue;
                  }

                  MeshRenderData.remove(data);
                }

                this._renderDataList.length = 0;
              }

              close() {
                this._curPath.closed = true;
              }

              requestRenderData() {
                const renderData = MeshRenderData.add();

                this._renderDataList.push(renderData);

                return renderData;
              }

              getRenderDataList() {
                if (this._renderDataList.length === 0) {
                  this.requestRenderData();
                }

                return this._renderDataList;
              }

              addPoint(x, y, flags) {
                const path = this._curPath;

                if (!path) {
                  return;
                }

                const points = this._points;
                const pathPoints = path.points;
                const offset = this.pointsOffset++;
                let pt = points[offset];

                if (!pt) {
                  pt = new Point(x, y);
                  points.push(pt);
                } else {
                  pt.x = x;
                  pt.y = y;
                }

                pt.flags = flags;
                pathPoints.push(pt);
              }

              _addPath() {
                const offset = this.pathLength;
                let path = this.paths[offset];

                if (!path) {
                  path = new Path();
                  this.paths.push(path);
                } else {
                  path.reset();
                }

                this.pathLength++;
                this._curPath = path;
                return path;
              }

            }

            const vfmt = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F)];
            const vfmtPosColor = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA32F)];
            const vfmtPosUvColor = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA32F)];
            const vfmtPosUvTwoColor = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA32F), new Attribute(AttributeName.ATTR_COLOR2, Format.RGBA32F)];
            function getComponentPerVertex(attrs) {
              let count = 0;

              for (let i = 0; i < attrs.length; i++) {
                const attr = attrs[i];
                const info = FormatInfos[attr.format];
                count += info.count;
              }

              return count;
            }
            function getAttributeStride(attrs) {
              let count = 0;

              for (let i = 0; i < attrs.length; i++) {
                const attr = attrs[i];
                const info = FormatInfos[attr.format];
                count += info.size;
              }

              return count;
            }
            legacyCC.internal.vfmtPosUvColor = vfmtPosUvColor;
            legacyCC.internal.vfmtPosUvTwoColor = vfmtPosUvTwoColor;

            var vertexFormat = /*#__PURE__*/Object.freeze({
                __proto__: null,
                vfmt: vfmt,
                vfmtPosColor: vfmtPosColor,
                vfmtPosUvColor: vfmtPosUvColor,
                vfmtPosUvTwoColor: vfmtPosUvTwoColor,
                getComponentPerVertex: getComponentPerVertex,
                getAttributeStride: getAttributeStride
            });
            exports('UIVertexFormat', vertexFormat);

            var _dec$h, _dec2$c, _dec3$b, _dec4$b, _dec5$b, _dec6$a, _dec7$a, _dec8$9, _dec9$8, _dec10$7, _dec11$4, _dec12$4, _dec13$3, _class$h, _class2$e, _descriptor$e, _descriptor2$c, _descriptor3$9, _descriptor4$9, _descriptor5$7, _descriptor6$5, _class3$3, _temp$f;
            const attributes = vfmtPosColor.concat([new Attribute('a_dist', Format.R32F)]);
            const componentPerVertex = getComponentPerVertex(attributes);
            const stride = getAttributeStride(attributes);
            let Graphics = function (v) { return exports({ Graphics: v, GraphicsComponent: v }), v; }((_dec$h = ccclass('cc.Graphics'), _dec2$c = help(), _dec3$b = executionOrder(110), _dec4$b = menu$1(), _dec5$b = tooltip(), _dec6$a = type$1(LineJoin), _dec7$a = tooltip(), _dec8$9 = type$1(LineCap), _dec9$8 = tooltip(), _dec10$7 = tooltip(), _dec11$4 = tooltip(), _dec12$4 = tooltip(), _dec13$3 = visible(), _dec$h(_class$h = _dec2$c(_class$h = _dec3$b(_class$h = _dec4$b(_class$h = (_class2$e = (_temp$f = _class3$3 = class Graphics extends Renderable2D {
              get lineWidth() {
                return this._lineWidth;
              }

              set lineWidth(value) {
                this._lineWidth = value;

                if (!this.impl) {
                  return;
                }

                this.impl.lineWidth = value;
              }

              get lineJoin() {
                return this._lineJoin;
              }

              set lineJoin(value) {
                this._lineJoin = value;

                if (!this.impl) {
                  return;
                }

                this.impl.lineJoin = value;
              }

              get lineCap() {
                return this._lineCap;
              }

              set lineCap(value) {
                this._lineCap = value;

                if (!this.impl) {
                  return;
                }

                this.impl.lineCap = value;
              }

              get strokeColor() {
                return this._strokeColor;
              }

              set strokeColor(value) {
                if (!this.impl) {
                  return;
                }

                this._strokeColor.set(value);

                this.impl.strokeColor = this._strokeColor;
              }

              get fillColor() {
                return this._fillColor;
              }

              set fillColor(value) {
                if (!this.impl) {
                  return;
                }

                this._fillColor.set(value);

                this.impl.fillColor = this._fillColor;
              }

              get miterLimit() {
                return this._miterLimit;
              }

              set miterLimit(value) {
                this._miterLimit = value;
              }

              get color() {
                return this._color;
              }

              set color(value) {
                if (this._color === value) {
                  return;
                }

                this._color.set(value);
              }

              get srcBlendFactor() {
                return this._srcBlendFactor;
              }

              set srcBlendFactor(value) {}

              get dstBlendFactor() {
                return this._dstBlendFactor;
              }

              set dstBlendFactor(value) {}

              constructor() {
                super();
                this.impl = null;
                this.model = null;

                _initializerDefineProperty(this, "_lineWidth", _descriptor$e, this);

                _initializerDefineProperty(this, "_strokeColor", _descriptor2$c, this);

                _initializerDefineProperty(this, "_lineJoin", _descriptor3$9, this);

                _initializerDefineProperty(this, "_lineCap", _descriptor4$9, this);

                _initializerDefineProperty(this, "_fillColor", _descriptor5$7, this);

                _initializerDefineProperty(this, "_miterLimit", _descriptor6$5, this);

                this._isDrawing = false;
                this._isNeedUploadData = true;
                this._graphicsUseSubMeshes = [];
                this._instanceMaterialType = InstanceMaterialType.ADD_COLOR;
                this.impl = new Impl();
              }

              onRestore() {
                if (!this.impl) {
                  this._flushAssembler();
                }
              }

              onLoad() {
                this.model = director.root.createModel(Model);
                this.model.node = this.model.transform = this.node;

                this._flushAssembler();
              }

              onEnable() {
                super.onEnable();

                this._updateMtlForGraphics();
              }

              onDisable() {
                super.onDisable();
              }

              onDestroy() {
                super.onDestroy();
                this._sceneGetter = null;

                if (this.model) {
                  director.root.destroyModel(this.model);
                  this.model = null;
                }

                const subMeshLength = this._graphicsUseSubMeshes.length;

                if (subMeshLength > 0) {
                  for (let i = 0; i < subMeshLength; ++i) {
                    this._graphicsUseSubMeshes[i].destroy();
                  }

                  this._graphicsUseSubMeshes.length = 0;
                }

                if (!this.impl) {
                  return;
                }

                this._isDrawing = false;
                this.impl.clear();
                this.impl = null;
              }

              moveTo(x, y) {
                if (!this.impl) {
                  return;
                }

                this.impl.moveTo(x, y);
              }

              lineTo(x, y) {
                if (!this.impl) {
                  return;
                }

                this.impl.lineTo(x, y);
              }

              bezierCurveTo(c1x, c1y, c2x, c2y, x, y) {
                if (!this.impl) {
                  return;
                }

                this.impl.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
              }

              quadraticCurveTo(cx, cy, x, y) {
                if (!this.impl) {
                  return;
                }

                this.impl.quadraticCurveTo(cx, cy, x, y);
              }

              arc(cx, cy, r, startAngle, endAngle, counterclockwise) {
                if (!this.impl) {
                  return;
                }

                this.impl.arc(cx, cy, r, startAngle, endAngle, counterclockwise);
              }

              ellipse(cx, cy, rx, ry) {
                if (!this.impl) {
                  return;
                }

                this.impl.ellipse(cx, cy, rx, ry);
              }

              circle(cx, cy, r) {
                if (!this.impl) {
                  return;
                }

                this.impl.circle(cx, cy, r);
              }

              rect(x, y, w, h) {
                if (!this.impl) {
                  return;
                }

                this.impl.rect(x, y, w, h);
              }

              roundRect(x, y, w, h, r) {
                if (!this.impl) {
                  return;
                }

                this.impl.roundRect(x, y, w, h, r);
              }

              fillRect(x, y, w, h) {
                this.rect(x, y, w, h);
                this.fill();
              }

              clear() {
                if (!this.impl) {
                  return;
                }

                this.impl.clear();
                this._isDrawing = false;

                if (this.model) {
                  for (let i = 0; i < this.model.subModels.length; i++) {
                    const subModel = this.model.subModels[i];
                    subModel.inputAssembler.indexCount = 0;
                  }
                }

                this.markForUpdateRenderData();
              }

              close() {
                if (!this.impl) {
                  return;
                }

                this.impl.close();
              }

              stroke() {
                if (!this._assembler) {
                  this._flushAssembler();
                }

                this._isDrawing = true;
                this._isNeedUploadData = true;

                this._assembler.stroke(this);
              }

              fill() {
                if (!this._assembler) {
                  this._flushAssembler();
                }

                this._isDrawing = true;
                this._isNeedUploadData = true;

                this._assembler.fill(this);
              }

              _updateMtlForGraphics() {
                let mat;

                if (this._customMaterial) {
                  mat = this.getMaterialInstance(0);
                } else {
                  mat = builtinResMgr.get('ui-graphics-material');
                  this.setMaterial(mat, 0);
                  mat = this.getMaterialInstance(0);
                  mat.recompileShaders({
                    USE_LOCAL: true
                  });
                }
              }

              activeSubModel(idx) {
                if (!this.model) {
                  warnID(4500, this.node.name);
                  return;
                }

                if (this.model.subModels.length <= idx) {
                  const gfxDevice = legacyCC.director.root.device;
                  const vertexBuffer = gfxDevice.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, 65535 * stride, stride));
                  const indexBuffer = gfxDevice.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, 65535 * Uint16Array.BYTES_PER_ELEMENT * 2, Uint16Array.BYTES_PER_ELEMENT));
                  const renderMesh = new RenderingSubMesh([vertexBuffer], attributes, PrimitiveMode.TRIANGLE_LIST, indexBuffer);
                  renderMesh.subMeshIdx = 0;
                  this.model.initSubModel(idx, renderMesh, this.getMaterialInstance(0));

                  this._graphicsUseSubMeshes.push(renderMesh);
                }
              }

              _uploadData() {
                const impl = this.impl;

                if (!impl) {
                  return;
                }

                const renderDataList = impl && impl.getRenderDataList();

                if (renderDataList.length <= 0 || !this.model) {
                  return;
                }

                const subModelList = this.model.subModels;

                for (let i = 0; i < renderDataList.length; i++) {
                  const renderData = renderDataList[i];
                  const ia = subModelList[i].inputAssembler;

                  if (renderData.lastFilledVertex === renderData.vertexStart) {
                    continue;
                  }

                  const vb = new Float32Array(renderData.vData.buffer, 0, renderData.vertexStart * componentPerVertex);
                  ia.vertexBuffers[0].update(vb);
                  ia.vertexCount = renderData.vertexStart;
                  const ib = new Uint16Array(renderData.iData.buffer, 0, renderData.indicesStart);
                  ia.indexBuffer.update(ib);
                  ia.indexCount = renderData.indicesStart;
                  renderData.lastFilledVertex = renderData.vertexStart;
                  renderData.lastFilledIndices = renderData.indicesStart;
                }

                this._isNeedUploadData = false;
              }

              _render(render) {
                if (this._isNeedUploadData) {
                  if (this.impl) {
                    const renderDataList = this.impl.getRenderDataList();
                    const len = this.model.subModels.length;

                    if (renderDataList.length > len) {
                      for (let i = len; i < renderDataList.length; i++) {
                        this.activeSubModel(i);
                      }
                    }
                  }

                  this._uploadData();
                }

                render.commitModel(this, this.model, this.getMaterialInstance(0));
              }

              _flushAssembler() {
                const assembler = Graphics.Assembler.getAssembler(this);

                if (this._assembler !== assembler) {
                  this._assembler = assembler;
                }
              }

              _canRender() {
                if (!super._canRender()) {
                  return false;
                }

                return !!this.model && this._isDrawing;
              }

            }, _class3$3.LineJoin = LineJoin, _class3$3.LineCap = LineCap, _temp$f), (_applyDecoratedDescriptor(_class2$e.prototype, "lineWidth", [editable, _dec5$b], Object.getOwnPropertyDescriptor(_class2$e.prototype, "lineWidth"), _class2$e.prototype), _applyDecoratedDescriptor(_class2$e.prototype, "lineJoin", [_dec6$a, _dec7$a], Object.getOwnPropertyDescriptor(_class2$e.prototype, "lineJoin"), _class2$e.prototype), _applyDecoratedDescriptor(_class2$e.prototype, "lineCap", [_dec8$9, _dec9$8], Object.getOwnPropertyDescriptor(_class2$e.prototype, "lineCap"), _class2$e.prototype), _applyDecoratedDescriptor(_class2$e.prototype, "strokeColor", [_dec10$7], Object.getOwnPropertyDescriptor(_class2$e.prototype, "strokeColor"), _class2$e.prototype), _applyDecoratedDescriptor(_class2$e.prototype, "fillColor", [_dec11$4], Object.getOwnPropertyDescriptor(_class2$e.prototype, "fillColor"), _class2$e.prototype), _applyDecoratedDescriptor(_class2$e.prototype, "miterLimit", [_dec12$4], Object.getOwnPropertyDescriptor(_class2$e.prototype, "miterLimit"), _class2$e.prototype), _applyDecoratedDescriptor(_class2$e.prototype, "color", [override, _dec13$3], Object.getOwnPropertyDescriptor(_class2$e.prototype, "color"), _class2$e.prototype), _descriptor$e = _applyDecoratedDescriptor(_class2$e.prototype, "_lineWidth", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            }), _descriptor2$c = _applyDecoratedDescriptor(_class2$e.prototype, "_strokeColor", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Color$1.BLACK.clone();
              }
            }), _descriptor3$9 = _applyDecoratedDescriptor(_class2$e.prototype, "_lineJoin", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return LineJoin.MITER;
              }
            }), _descriptor4$9 = _applyDecoratedDescriptor(_class2$e.prototype, "_lineCap", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return LineCap.BUTT;
              }
            }), _descriptor5$7 = _applyDecoratedDescriptor(_class2$e.prototype, "_fillColor", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Color$1.WHITE.clone();
              }
            }), _descriptor6$5 = _applyDecoratedDescriptor(_class2$e.prototype, "_miterLimit", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 10;
              }
            })), _class2$e)) || _class$h) || _class$h) || _class$h) || _class$h));

            var _dec$i, _dec2$d, _dec3$c, _dec4$c, _dec5$c, _dec6$b, _dec7$b, _dec8$a, _dec9$9, _dec10$8, _dec11$5, _dec12$5, _dec13$4, _dec14$2, _dec15$2, _dec16$2, _class$i, _class2$f, _descriptor$f, _descriptor2$d, _descriptor3$a, _descriptor4$a, _descriptor5$8, _class3$4, _temp$g;

            const _worldMatrix$2 = new Mat4();

            const _vec2_temp = new Vec2();

            const _mat4_temp$1 = new Mat4();

            const _circlePoints = [];

            function _calculateCircle(center, radius, segments) {
              _circlePoints.length = 0;
              const anglePerStep = Math.PI * 2 / segments;

              for (let step = 0; step < segments; ++step) {
                _circlePoints.push(new Vec3(radius.x * Math.cos(anglePerStep * step) + center.x, radius.y * Math.sin(anglePerStep * step) + center.y, 0));
              }

              return _circlePoints;
            }

            let MaskType;

            (function (MaskType) {
              MaskType[MaskType["RECT"] = 0] = "RECT";
              MaskType[MaskType["ELLIPSE"] = 1] = "ELLIPSE";
              MaskType[MaskType["GRAPHICS_STENCIL"] = 2] = "GRAPHICS_STENCIL";
              MaskType[MaskType["IMAGE_STENCIL"] = 3] = "IMAGE_STENCIL";
            })(MaskType || (MaskType = {}));

            ccenum(MaskType);
            const SEGMENTS_MIN = 3;
            const SEGMENTS_MAX = 10000;
            let Mask = function (v) { return exports({ Mask: v, MaskComponent: v }), v; }((_dec$i = ccclass('cc.Mask'), _dec2$d = help(), _dec3$c = executionOrder(110), _dec4$c = menu$1(), _dec5$c = type$1(MaskType), _dec6$b = displayOrder(), _dec7$b = tooltip(), _dec8$a = displayOrder(), _dec9$9 = tooltip(), _dec10$8 = visible(), _dec11$5 = type$1(SpriteFrame), _dec12$5 = visible(), _dec13$4 = visible(), _dec14$2 = range(), _dec15$2 = visible(), _dec16$2 = visible(), _dec$i(_class$i = _dec2$d(_class$i = _dec3$c(_class$i = _dec4$c(_class$i = (_class2$f = (_temp$g = _class3$4 = class Mask extends Renderable2D {
              get type() {
                return this._type;
              }

              set type(value) {
                if (this._type === value) {
                  return;
                }

                this._type = value;
                this.markForUpdateRenderData(false);

                this._updateMaterial();

                if (this._type !== MaskType.IMAGE_STENCIL) {
                  this._spriteFrame = null;

                  this._updateGraphics();

                  if (this._renderData) {
                    this.destroyRenderData();
                    this._renderData = null;
                  }
                } else {
                  this._useRenderData();

                  if (this._graphics) {
                    this._graphics.clear();
                  }
                }
              }

              get inverted() {
                return this._inverted;
              }

              set inverted(value) {
                this._inverted = value;
                this.stencilStage = Stage.DISABLED;

                if (this._graphics) {
                  this._graphics.stencilStage = Stage.DISABLED;
                }
              }

              get segments() {
                return this._segments;
              }

              set segments(value) {
                if (this._segments === value) {
                  return;
                }

                this._segments = clamp$1(value, SEGMENTS_MIN, SEGMENTS_MAX);

                this._updateGraphics();
              }

              get spriteFrame() {
                return this._spriteFrame;
              }

              set spriteFrame(value) {
                if (this._spriteFrame === value) {
                  return;
                }

                const lastSp = this._spriteFrame;
                this._spriteFrame = value;

                if (this._type === MaskType.IMAGE_STENCIL) {
                  if (!lastSp && value) {
                    this.markForUpdateRenderData();
                  }
                }
              }

              get alphaThreshold() {
                return this._alphaThreshold;
              }

              set alphaThreshold(value) {
                if (this._alphaThreshold === value) {
                  return;
                }

                this._alphaThreshold = value;

                if (this.type === MaskType.IMAGE_STENCIL && this._graphics) {
                  const mat = this._graphics.getMaterialInstance(0);

                  mat.setProperty('alphaThreshold', this._alphaThreshold);
                }
              }

              get graphics() {
                return this._graphics;
              }

              get dstBlendFactor() {
                return this._dstBlendFactor;
              }

              set dstBlendFactor(value) {
                if (this._dstBlendFactor === value) {
                  return;
                }

                this._dstBlendFactor = value;

                this._updateBlendFunc();
              }

              get srcBlendFactor() {
                return this._srcBlendFactor;
              }

              set srcBlendFactor(value) {
                if (this._srcBlendFactor === value) {
                  return;
                }

                this._srcBlendFactor = value;

                this._updateBlendFunc();
              }

              get color() {
                return this._color;
              }

              set color(value) {
                if (this._color === value) {
                  return;
                }

                this._color.set(value);

                this.markForUpdateRenderData();
              }

              get customMaterial() {
                return this._customMaterial;
              }

              set customMaterial(val) {}

              constructor() {
                super();
                this._clearStencilMtl = null;
                this._clearModel = null;

                _initializerDefineProperty(this, "_type", _descriptor$f, this);

                _initializerDefineProperty(this, "_inverted", _descriptor2$d, this);

                _initializerDefineProperty(this, "_segments", _descriptor3$a, this);

                _initializerDefineProperty(this, "_spriteFrame", _descriptor4$a, this);

                _initializerDefineProperty(this, "_alphaThreshold", _descriptor5$8, this);

                this._graphics = null;
                this._clearModelMesh = null;
                this._instanceMaterialType = InstanceMaterialType.ADD_COLOR;
              }

              onLoad() {
                this._createClearModel();

                this._createGraphics();

                if (this._graphics) {
                  this._graphics.onLoad();
                }
              }

              onEnable() {
                super.onEnable();

                this._updateGraphics();

                this._enableGraphics();
              }

              onRestore() {
                this._createGraphics();

                super.updateMaterial();

                this._updateGraphics();

                this._renderFlag = this._canRender();
              }

              onDisable() {
                super.onDisable();

                this._disableGraphics();
              }

              onDestroy() {
                super.onDestroy();

                if (this._clearModel && this._clearModelMesh) {
                  director.root.destroyModel(this._clearModel);

                  this._clearModelMesh.destroy();
                }

                if (this._clearStencilMtl) {
                  this._clearStencilMtl.destroy();
                }

                this._removeGraphics();
              }

              isHit(cameraPt) {
                const uiTrans = this.node._uiProps.uiTransformComp;
                const size = uiTrans.contentSize;
                const w = size.width;
                const h = size.height;
                const testPt = _vec2_temp;
                this.node.getWorldMatrix(_worldMatrix$2);
                Mat4.invert(_mat4_temp$1, _worldMatrix$2);
                Vec2.transformMat4(testPt, cameraPt, _mat4_temp$1);
                const ap = uiTrans.anchorPoint;
                testPt.x += ap.x * w;
                testPt.y += ap.y * h;
                let result = false;

                if (this.type === MaskType.RECT || this.type === MaskType.GRAPHICS_STENCIL) {
                  result = testPt.x >= 0 && testPt.y >= 0 && testPt.x <= w && testPt.y <= h;
                } else if (this.type === MaskType.ELLIPSE) {
                  const rx = w / 2;
                  const ry = h / 2;
                  const px = testPt.x - 0.5 * w;
                  const py = testPt.y - 0.5 * h;
                  result = px * px / (rx * rx) + py * py / (ry * ry) < 1;
                }

                if (this._inverted) {
                  result = !result;
                }

                return result;
              }

              _render(render) {
                render.commitComp(this, null, this._assembler, null);
              }

              _postRender(render) {
                if (!this._postAssembler) {
                  return;
                }

                render.commitComp(this, null, this._postAssembler, null);
              }

              _nodeStateChange(type) {
                super._nodeStateChange(type);

                this._updateGraphics();
              }

              _canRender() {
                if (!super._canRender()) {
                  return false;
                }

                return this._graphics !== null && (this._type !== MaskType.IMAGE_STENCIL || this._spriteFrame !== null);
              }

              _flushAssembler() {
                const assembler = Mask.Assembler.getAssembler(this);
                const posAssembler = Mask.PostAssembler.getAssembler(this);

                if (this._assembler !== assembler) {
                  this.destroyRenderData();
                  this._assembler = assembler;
                }

                if (this._postAssembler !== posAssembler) {
                  this._postAssembler = posAssembler;
                }

                this._useRenderData();
              }

              _createGraphics() {
                if (!this._graphics) {
                  const graphics = this._graphics = new Graphics();
                  graphics._objFlags |= CCObject.Flags.IsOnLoadCalled;
                  graphics.node = this.node;
                  graphics.node.getWorldMatrix();
                  graphics.lineWidth = 0;
                  const color = Color$1.WHITE.clone();
                  color.a = 0;
                  graphics.fillColor = color;
                }

                this._updateMaterial();
              }

              _updateGraphics() {
                if (!this._graphics || this._type !== MaskType.RECT && this._type !== MaskType.ELLIPSE) {
                  return;
                }

                const uiTrans = this.node._uiProps.uiTransformComp;
                const graphics = this._graphics;
                graphics.clear();
                const size = uiTrans.contentSize;
                const width = size.width;
                const height = size.height;
                const ap = uiTrans.anchorPoint;
                const x = -width * ap.x;
                const y = -height * ap.y;

                if (this._type === MaskType.RECT) {
                  graphics.rect(x, y, width, height);
                } else if (this._type === MaskType.ELLIPSE) {
                  const center = new Vec3(x + width / 2, y + height / 2, 0);
                  const radius = new Vec3(width / 2, height / 2, 0);

                  const points = _calculateCircle(center, radius, this._segments);

                  for (let i = 0; i < points.length; ++i) {
                    const point = points[i];

                    if (i === 0) {
                      graphics.moveTo(point.x, point.y);
                    } else {
                      graphics.lineTo(point.x, point.y);
                    }
                  }

                  graphics.close();
                }

                graphics.fill();
              }

              _createClearModel() {
                if (!this._clearModel) {
                  const mtl = builtinResMgr.get('default-clear-stencil');
                  this._clearStencilMtl = new MaterialInstance({
                    parent: mtl,
                    owner: this,
                    subModelIdx: 0
                  });
                  this._clearModel = director.root.createModel(Model);
                  this._clearModel.node = this._clearModel.transform = this.node;
                  const stride = getAttributeStride(vfmt);
                  const gfxDevice = legacyCC.director.root.device;
                  const vertexBuffer = gfxDevice.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, 4 * stride, stride));
                  const vb = new Float32Array([-1, -1, 0, 1, -1, 0, -1, 1, 0, 1, 1, 0]);
                  vertexBuffer.update(vb);
                  const indexBuffer = gfxDevice.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, 6 * Uint16Array.BYTES_PER_ELEMENT, Uint16Array.BYTES_PER_ELEMENT));
                  const ib = new Uint16Array([0, 1, 2, 2, 1, 3]);
                  indexBuffer.update(ib);
                  this._clearModelMesh = new RenderingSubMesh([vertexBuffer], vfmt, PrimitiveMode.TRIANGLE_LIST, indexBuffer);
                  this._clearModelMesh.subMeshIdx = 0;

                  this._clearModel.initSubModel(0, this._clearModelMesh, this._clearStencilMtl);
                }
              }

              _updateMaterial() {
                if (this._graphics) {
                  const target = this._graphics;
                  target.stencilStage = Stage.DISABLED;
                  let mat;

                  if (this._type === MaskType.IMAGE_STENCIL) {
                    mat = builtinResMgr.get('ui-alpha-test-material');
                    target.setMaterial(mat, 0);
                    mat = target.getMaterialInstance(0);
                    mat.setProperty('alphaThreshold', this._alphaThreshold);
                  } else {
                    mat = builtinResMgr.get('ui-graphics-material');
                    target.setMaterial(mat, 0);
                    target.getMaterialInstance(0);
                  }
                }
              }

              _enableGraphics() {
                if (this._graphics) {
                  this._graphics._renderFlag = this._graphics._canRender();
                }
              }

              _disableGraphics() {
                if (this._graphics) {
                  this._graphics.onDisable();
                }
              }

              _removeGraphics() {
                if (this._graphics) {
                  this._graphics.destroy();

                  this._graphics._destroyImmediate();

                  this._graphics = null;
                }
              }

              _useRenderData() {
                if (this._type === MaskType.IMAGE_STENCIL && !this._renderData) {
                  if (this._assembler && this._assembler.createData) {
                    this._renderData = this._assembler.createData(this);
                    this.markForUpdateRenderData();
                  }
                }
              }

            }, _class3$4.Type = MaskType, _temp$g), (_applyDecoratedDescriptor(_class2$f.prototype, "type", [_dec5$c, _dec6$b, _dec7$b], Object.getOwnPropertyDescriptor(_class2$f.prototype, "type"), _class2$f.prototype), _applyDecoratedDescriptor(_class2$f.prototype, "inverted", [_dec8$a, _dec9$9], Object.getOwnPropertyDescriptor(_class2$f.prototype, "inverted"), _class2$f.prototype), _applyDecoratedDescriptor(_class2$f.prototype, "segments", [_dec10$8], Object.getOwnPropertyDescriptor(_class2$f.prototype, "segments"), _class2$f.prototype), _applyDecoratedDescriptor(_class2$f.prototype, "spriteFrame", [_dec11$5, _dec12$5], Object.getOwnPropertyDescriptor(_class2$f.prototype, "spriteFrame"), _class2$f.prototype), _applyDecoratedDescriptor(_class2$f.prototype, "alphaThreshold", [_dec13$4, _dec14$2, slide], Object.getOwnPropertyDescriptor(_class2$f.prototype, "alphaThreshold"), _class2$f.prototype), _applyDecoratedDescriptor(_class2$f.prototype, "color", [override, _dec15$2], Object.getOwnPropertyDescriptor(_class2$f.prototype, "color"), _class2$f.prototype), _applyDecoratedDescriptor(_class2$f.prototype, "customMaterial", [override, _dec16$2], Object.getOwnPropertyDescriptor(_class2$f.prototype, "customMaterial"), _class2$f.prototype), _descriptor$f = _applyDecoratedDescriptor(_class2$f.prototype, "_type", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return MaskType.RECT;
              }
            }), _descriptor2$d = _applyDecoratedDescriptor(_class2$f.prototype, "_inverted", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor3$a = _applyDecoratedDescriptor(_class2$f.prototype, "_segments", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 64;
              }
            }), _descriptor4$a = _applyDecoratedDescriptor(_class2$f.prototype, "_spriteFrame", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor5$8 = _applyDecoratedDescriptor(_class2$f.prototype, "_alphaThreshold", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.1;
              }
            })), _class2$f)) || _class$i) || _class$i) || _class$i) || _class$i));
            NodeEventProcessor._maskComp = Mask;
            legacyCC.Mask = Mask;

            const eventRegx = /^(click)(\s)*=|(param)(\s)*=/;
            const imageAttrReg = /(\s)*src(\s)*=|(\s)*height(\s)*=|(\s)*width(\s)*=|(\s)*align(\s)*=|(\s)*offset(\s)*=|(\s)*click(\s)*=|(\s)*param(\s)*=/;
            class HtmlTextParser {
              constructor() {
                this._specialSymbolArray = [];
                this._stack = [];
                this._resultObjectArray = [];

                this._specialSymbolArray.push([/&lt;/g, '<']);

                this._specialSymbolArray.push([/&gt;/g, '>']);

                this._specialSymbolArray.push([/&amp;/g, '&']);

                this._specialSymbolArray.push([/&quot;/g, '"']);

                this._specialSymbolArray.push([/&apos;/g, '\'']);
              }

              parse(htmlString) {
                this._resultObjectArray.length = 0;
                this._stack.length = 0;
                let startIndex = 0;
                const length = htmlString.length;

                while (startIndex < length) {
                  let tagEndIndex = htmlString.indexOf('>', startIndex);
                  let tagBeginIndex = -1;

                  if (tagEndIndex >= 0) {
                    tagBeginIndex = htmlString.lastIndexOf('<', tagEndIndex);
                    const noTagBegin = tagBeginIndex < startIndex - 1;

                    if (noTagBegin) {
                      tagBeginIndex = htmlString.indexOf('<', tagEndIndex + 1);
                      tagEndIndex = htmlString.indexOf('>', tagBeginIndex + 1);
                    }
                  }

                  if (tagBeginIndex < 0) {
                    this._stack.pop();

                    this._processResult(htmlString.substring(startIndex));

                    startIndex = length;
                  } else {
                    let newStr = htmlString.substring(startIndex, tagBeginIndex);
                    const tagStr = htmlString.substring(tagBeginIndex + 1, tagEndIndex);
                    if (tagStr === '') newStr = htmlString.substring(startIndex, tagEndIndex + 1);

                    this._processResult(newStr);

                    if (tagEndIndex === -1) {
                      tagEndIndex = tagBeginIndex;
                    } else if (htmlString.charAt(tagBeginIndex + 1) === '/') {
                      this._stack.pop();
                    } else {
                      this._addToStack(tagStr);
                    }

                    startIndex = tagEndIndex + 1;
                  }
                }

                return this._resultObjectArray;
              }

              _attributeToObject(attribute) {
                attribute = attribute.trim();
                const obj = {};
                let header = /^(color|size)(\s)*=/.exec(attribute);
                let tagName = '';
                let nextSpace = 0;
                let eventHanlderString = '';

                if (header) {
                  tagName = header[0];
                  attribute = attribute.substring(tagName.length).trim();

                  if (attribute === '') {
                    return obj;
                  }

                  nextSpace = attribute.indexOf(' ');

                  switch (tagName[0]) {
                    case 'c':
                      if (nextSpace > -1) {
                        obj.color = attribute.substring(0, nextSpace).trim();
                      } else {
                        obj.color = attribute;
                      }

                      break;

                    case 's':
                      obj.size = parseInt(attribute);
                      break;
                  }

                  if (nextSpace > -1) {
                    eventHanlderString = attribute.substring(nextSpace + 1).trim();
                    obj.event = this._processEventHandler(eventHanlderString);
                  }

                  return obj;
                }

                header = /^(br(\s)*\/)/.exec(attribute);

                if (header && header[0].length > 0) {
                  tagName = header[0].trim();

                  if (tagName.startsWith('br') && tagName[tagName.length - 1] === '/') {
                    obj.isNewLine = true;

                    this._resultObjectArray.push({
                      text: '',
                      style: {
                        isNewLine: true
                      }
                    });

                    return obj;
                  }
                }

                header = /^(img(\s)*src(\s)*=[^>]+\/)/.exec(attribute);
                let remainingArgument = '';

                if (header && header[0].length > 0) {
                  tagName = header[0].trim();

                  if (tagName.startsWith('img') && tagName[tagName.length - 1] === '/') {
                    header = imageAttrReg.exec(attribute);
                    let tagValue;
                    let isValidImageTag = false;

                    while (header) {
                      attribute = attribute.substring(attribute.indexOf(header[0]));
                      tagName = attribute.substr(0, header[0].length);
                      remainingArgument = attribute.substring(tagName.length).trim();
                      nextSpace = remainingArgument.indexOf(' ');
                      tagValue = nextSpace > -1 ? remainingArgument.substr(0, nextSpace) : remainingArgument;
                      tagName = tagName.replace(/[^a-zA-Z]/g, '').trim();
                      tagName = tagName.toLowerCase();
                      attribute = remainingArgument.substring(nextSpace).trim();
                      if (tagValue.endsWith('/')) tagValue = tagValue.slice(0, -1);

                      if (tagName === 'src') {
                        switch (tagValue.charCodeAt(0)) {
                          case 34:
                          case 39:
                            isValidImageTag = true;
                            tagValue = tagValue.slice(1, -1);
                            break;
                        }

                        obj.isImage = true;
                        obj.src = tagValue;
                      } else if (tagName === 'height') {
                        obj.imageHeight = parseInt(tagValue);
                      } else if (tagName === 'width') {
                        obj.imageWidth = parseInt(tagValue);
                      } else if (tagName === 'align') {
                        switch (tagValue.charCodeAt(0)) {
                          case 34:
                          case 39:
                            tagValue = tagValue.slice(1, -1);
                            break;
                        }

                        obj.imageAlign = tagValue.toLowerCase();
                      } else if (tagName === 'offset') {
                        obj.imageOffset = tagValue;
                      } else if (tagName === 'click') {
                        obj.event = this._processEventHandler(`${tagName}=${tagValue}`);
                      }

                      if (obj.event && tagName === 'param') {
                        obj.event[tagName] = tagValue.replace(/^"|"$/g, '');
                      }

                      header = imageAttrReg.exec(attribute);
                    }

                    if (isValidImageTag && obj.isImage) {
                      this._resultObjectArray.push({
                        text: '',
                        style: obj
                      });
                    }

                    return {};
                  }
                }

                header = /^(outline(\s)*[^>]*)/.exec(attribute);

                if (header) {
                  attribute = header[0].substring('outline'.length).trim();
                  const defaultOutlineObject = {
                    color: '#ffffff',
                    width: 1
                  };

                  if (attribute) {
                    const outlineAttrReg = /(\s)*color(\s)*=|(\s)*width(\s)*=|(\s)*click(\s)*=|(\s)*param(\s)*=/;
                    header = outlineAttrReg.exec(attribute);
                    let tagValue;

                    while (header) {
                      attribute = attribute.substring(attribute.indexOf(header[0]));
                      tagName = attribute.substr(0, header[0].length);
                      remainingArgument = attribute.substring(tagName.length).trim();
                      nextSpace = remainingArgument.indexOf(' ');

                      if (nextSpace > -1) {
                        tagValue = remainingArgument.substr(0, nextSpace);
                      } else {
                        tagValue = remainingArgument;
                      }

                      tagName = tagName.replace(/[^a-zA-Z]/g, '').trim();
                      tagName = tagName.toLowerCase();
                      attribute = remainingArgument.substring(nextSpace).trim();

                      if (tagName === 'click') {
                        obj.event = this._processEventHandler(`${tagName}=${tagValue}`);
                      } else if (tagName === 'color') {
                        defaultOutlineObject.color = tagValue;
                      } else if (tagName === 'width') {
                        defaultOutlineObject.width = parseInt(tagValue);
                      }

                      if (obj.event && tagName === 'param') {
                        obj.event[tagName] = tagValue.replace(/^"|"$/g, '');
                      }

                      header = outlineAttrReg.exec(attribute);
                    }
                  }

                  obj.outline = defaultOutlineObject;
                }

                header = /^(on|u|b|i)(\s)*/.exec(attribute);

                if (header && header[0].length > 0) {
                  tagName = header[0];
                  attribute = attribute.substring(tagName.length).trim();

                  switch (tagName[0]) {
                    case 'u':
                      obj.underline = true;
                      break;

                    case 'i':
                      obj.italic = true;
                      break;

                    case 'b':
                      obj.bold = true;
                      break;
                  }

                  if (attribute === '') {
                    return obj;
                  }

                  obj.event = this._processEventHandler(attribute);
                }

                return obj;
              }

              _processEventHandler(eventString) {
                const obj = {};
                let index = 0;
                let isValidTag = false;
                let eventNames = eventRegx.exec(eventString);

                while (eventNames) {
                  let eventName = eventNames[0];
                  let eventValue = '';
                  isValidTag = false;
                  eventString = eventString.substring(eventName.length).trim();

                  if (eventString.charAt(0) === '"') {
                    index = eventString.indexOf('"', 1);

                    if (index > -1) {
                      eventValue = eventString.substring(1, index).trim();
                      isValidTag = true;
                    }

                    index++;
                  } else if (eventString.charAt(0) === '\'') {
                    index = eventString.indexOf('\'', 1);

                    if (index > -1) {
                      eventValue = eventString.substring(1, index).trim();
                      isValidTag = true;
                    }

                    index++;
                  } else {
                    const match = /(\S)+/.exec(eventString);

                    if (match) {
                      eventValue = match[0];
                    } else {
                      eventValue = '';
                    }

                    index = eventValue.length;
                  }

                  if (isValidTag) {
                    eventName = eventName.substring(0, eventName.length - 1).trim();
                    obj[eventName] = eventValue;
                  }

                  eventString = eventString.substring(index).trim();
                  eventNames = eventRegx.exec(eventString);
                }

                return obj;
              }

              _addToStack(attribute) {
                const obj = this._attributeToObject(attribute);

                if (this._stack.length === 0) {
                  this._stack.push(obj);
                } else {
                  if (obj.isNewLine || obj.isImage) {
                    return;
                  }

                  const previousTagObj = this._stack[this._stack.length - 1];

                  for (const key in previousTagObj) {
                    if (!obj[key]) {
                      obj[key] = previousTagObj[key];
                    }
                  }

                  this._stack.push(obj);
                }
              }

              _processResult(value) {
                if (value.length === 0) {
                  return;
                }

                value = this._escapeSpecialSymbol(value);

                if (this._stack.length > 0) {
                  this._resultObjectArray.push({
                    text: value,
                    style: this._stack[this._stack.length - 1]
                  });
                } else {
                  this._resultObjectArray.push({
                    text: value
                  });
                }
              }

              _escapeSpecialSymbol(str) {
                for (const symbolArr of this._specialSymbolArray) {
                  const key = symbolArr[0];
                  const value = symbolArr[1];
                  str = str.replace(key, value);
                }

                return str;
              }

            } exports('HtmlTextParser', HtmlTextParser);

            var _dec$j, _dec2$e, _dec3$d, _dec4$d, _dec5$d, _dec6$c, _dec7$c, _class$j, _class2$g, _descriptor$g, _descriptor2$e, _temp$h;
            let LabelOutline = function (v) { return exports({ LabelOutline: v, LabelOutlineComponent: v }), v; }((_dec$j = ccclass('cc.LabelOutline'), _dec2$e = help(), _dec3$d = executionOrder(110), _dec4$d = menu$1(), _dec5$d = requireComponent(Label), _dec6$c = tooltip(), _dec7$c = tooltip(), _dec$j(_class$j = _dec2$e(_class$j = _dec3$d(_class$j = _dec4$d(_class$j = _dec5$d(_class$j = executeInEditMode(_class$j = (_class2$g = (_temp$h = class LabelOutline extends Component {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "_color", _descriptor$g, this);

                _initializerDefineProperty(this, "_width", _descriptor2$e, this);
              }

              get color() {
                return this._color;
              }

              set color(value) {
                if (this._color === value) {
                  return;
                }

                this._color.set(value);

                this._updateRenderData();
              }

              get width() {
                return this._width;
              }

              set width(value) {
                if (this._width === value) {
                  return;
                }

                this._width = value;

                this._updateRenderData();
              }

              onEnable() {
                this._updateRenderData();
              }

              onDisable() {
                this._updateRenderData();
              }

              _updateRenderData() {
                const label = this.node.getComponent(Label);

                if (label) {
                  label.updateRenderData(true);
                }
              }

            }, _temp$h), (_descriptor$g = _applyDecoratedDescriptor(_class2$g.prototype, "_color", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Color$1(0, 0, 0, 255);
              }
            }), _descriptor2$e = _applyDecoratedDescriptor(_class2$g.prototype, "_width", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 2;
              }
            }), _applyDecoratedDescriptor(_class2$g.prototype, "color", [_dec6$c], Object.getOwnPropertyDescriptor(_class2$g.prototype, "color"), _class2$g.prototype), _applyDecoratedDescriptor(_class2$g.prototype, "width", [_dec7$c], Object.getOwnPropertyDescriptor(_class2$g.prototype, "width"), _class2$g.prototype)), _class2$g)) || _class$j) || _class$j) || _class$j) || _class$j) || _class$j) || _class$j));

            var _dec$k, _dec2$f, _dec3$e, _dec4$e, _dec5$e, _dec6$d, _dec7$d, _dec8$b, _dec9$a, _dec10$9, _dec11$6, _dec12$6, _dec13$5, _dec14$3, _dec15$3, _dec16$3, _dec17$1, _dec18$1, _dec19$1, _dec20$1, _dec21$1, _dec22$1, _dec23$1, _dec24$1, _dec25$1, _dec26$1, _dec27$1, _dec28$1, _dec29$1, _dec30$1, _class$k, _class2$h, _descriptor$h, _descriptor2$f, _descriptor3$b, _descriptor4$b, _descriptor5$9, _descriptor6$6, _descriptor7$4, _descriptor8$4, _descriptor9$3, _descriptor10$2, _class3$5, _temp$i;
            let SpriteType;

            (function (SpriteType) {
              SpriteType[SpriteType["SIMPLE"] = 0] = "SIMPLE";
              SpriteType[SpriteType["SLICED"] = 1] = "SLICED";
              SpriteType[SpriteType["TILED"] = 2] = "TILED";
              SpriteType[SpriteType["FILLED"] = 3] = "FILLED";
            })(SpriteType || (SpriteType = {}));

            ccenum(SpriteType);
            var FillType;

            (function (FillType) {
              FillType[FillType["HORIZONTAL"] = 0] = "HORIZONTAL";
              FillType[FillType["VERTICAL"] = 1] = "VERTICAL";
              FillType[FillType["RADIAL"] = 2] = "RADIAL";
            })(FillType || (FillType = {}));

            ccenum(FillType);
            var SizeMode;

            (function (SizeMode) {
              SizeMode[SizeMode["CUSTOM"] = 0] = "CUSTOM";
              SizeMode[SizeMode["TRIMMED"] = 1] = "TRIMMED";
              SizeMode[SizeMode["RAW"] = 2] = "RAW";
            })(SizeMode || (SizeMode = {}));

            ccenum(SizeMode);
            var EventType;

            (function (EventType) {
              EventType["SPRITE_FRAME_CHANGED"] = "spriteframe-changed";
            })(EventType || (EventType = {}));

            let Sprite = function (v) { return exports({ Sprite: v, SpriteComponent: v }), v; }((_dec$k = ccclass('cc.Sprite'), _dec2$f = help(), _dec3$e = executionOrder(110), _dec4$e = menu$1(), _dec5$e = type$1(Material), _dec6$d = displayOrder(), _dec7$d = displayName(), _dec8$b = type$1(SpriteAtlas), _dec9$a = displayOrder(), _dec10$9 = tooltip(), _dec11$6 = type$1(SpriteFrame), _dec12$6 = displayOrder(), _dec13$5 = tooltip(), _dec14$3 = type$1(SpriteType), _dec15$3 = displayOrder(), _dec16$3 = tooltip(), _dec17$1 = type$1(FillType), _dec18$1 = tooltip(), _dec19$1 = tooltip(), _dec20$1 = range(), _dec21$1 = tooltip(), _dec22$1 = range(), _dec23$1 = tooltip(), _dec24$1 = visible(), _dec25$1 = displayOrder(), _dec26$1 = tooltip(), _dec27$1 = tooltip(), _dec28$1 = type$1(SizeMode), _dec29$1 = displayOrder(), _dec30$1 = tooltip(), _dec$k(_class$k = _dec2$f(_class$k = _dec3$e(_class$k = _dec4$e(_class$k = (_class2$h = (_temp$i = _class3$5 = class Sprite extends Renderable2D {
              get customMaterial() {
                return this._customMaterial;
              }

              set customMaterial(val) {
                this._customMaterial = val;
                this.updateMaterial();
              }

              get spriteAtlas() {
                return this._atlas;
              }

              set spriteAtlas(value) {
                if (this._atlas === value) {
                  return;
                }

                this._atlas = value;
              }

              get spriteFrame() {
                return this._spriteFrame;
              }

              set spriteFrame(value) {
                if (this._spriteFrame === value) {
                  return;
                }

                const lastSprite = this._spriteFrame;
                this._spriteFrame = value;
                this.markForUpdateRenderData(false);

                this._applySpriteFrame(lastSprite);
              }

              get type() {
                return this._type;
              }

              set type(value) {
                if (this._type !== value) {
                  this._type = value;

                  this._flushAssembler();
                }
              }

              get fillType() {
                return this._fillType;
              }

              set fillType(value) {
                if (this._fillType !== value) {
                  if (value === FillType.RADIAL || this._fillType === FillType.RADIAL) {
                    this.destroyRenderData();
                    this._renderData = null;
                  } else if (this._renderData) {
                    this.markForUpdateRenderData(true);
                  }
                }

                this._fillType = value;

                this._flushAssembler();
              }

              get fillCenter() {
                return this._fillCenter;
              }

              set fillCenter(value) {
                this._fillCenter.x = value.x;
                this._fillCenter.y = value.y;

                if (this._type === SpriteType.FILLED && this._renderData) {
                  this.markForUpdateRenderData();
                }
              }

              get fillStart() {
                return this._fillStart;
              }

              set fillStart(value) {
                this._fillStart = clamp$1(value, 0, 1);

                if (this._type === SpriteType.FILLED && this._renderData) {
                  this.markForUpdateRenderData();
                  this._renderData.uvDirty = true;
                }
              }

              get fillRange() {
                return this._fillRange;
              }

              set fillRange(value) {
                this._fillRange = clamp$1(value, -1, 1);

                if (this._type === SpriteType.FILLED && this._renderData) {
                  this.markForUpdateRenderData();
                  this._renderData.uvDirty = true;
                }
              }

              get trim() {
                return this._isTrimmedMode;
              }

              set trim(value) {
                if (this._isTrimmedMode === value) {
                  return;
                }

                this._isTrimmedMode = value;

                if (this._type === SpriteType.SIMPLE && this._renderData) {
                  this.markForUpdateRenderData(true);
                }
              }

              get grayscale() {
                return this._useGrayscale;
              }

              set grayscale(value) {
                if (this._useGrayscale === value) {
                  return;
                }

                this._useGrayscale = value;

                if (value === true) {
                  this._instanceMaterialType = InstanceMaterialType.GRAYSCALE;
                } else {
                  this._instanceMaterialType = InstanceMaterialType.ADD_COLOR_AND_TEXTURE;
                }

                this.updateMaterial();
              }

              get sizeMode() {
                return this._sizeMode;
              }

              set sizeMode(value) {
                if (this._sizeMode === value) {
                  return;
                }

                this._sizeMode = value;

                if (value !== SizeMode.CUSTOM) {
                  this._applySpriteSize();
                }
              }

              constructor() {
                super();

                _initializerDefineProperty(this, "_spriteFrame", _descriptor$h, this);

                _initializerDefineProperty(this, "_type", _descriptor2$f, this);

                _initializerDefineProperty(this, "_fillType", _descriptor3$b, this);

                _initializerDefineProperty(this, "_sizeMode", _descriptor4$b, this);

                _initializerDefineProperty(this, "_fillCenter", _descriptor5$9, this);

                _initializerDefineProperty(this, "_fillStart", _descriptor6$6, this);

                _initializerDefineProperty(this, "_fillRange", _descriptor7$4, this);

                _initializerDefineProperty(this, "_isTrimmedMode", _descriptor8$4, this);

                _initializerDefineProperty(this, "_useGrayscale", _descriptor9$3, this);

                _initializerDefineProperty(this, "_atlas", _descriptor10$2, this);
              }

              __preload() {
                this.changeMaterialForDefine();

                super.__preload();
              }

              onEnable() {
                super.onEnable();

                this._activateMaterial();

                this._markForUpdateUvDirty();
              }

              onDestroy() {
                this.destroyRenderData();

                super.onDestroy();
              }

              changeSpriteFrameFromAtlas(name) {
                if (!this._atlas) {
                  console.warn('SpriteAtlas is null.');
                  return;
                }

                const sprite = this._atlas.getSpriteFrame(name);

                this.spriteFrame = sprite;
              }

              changeMaterialForDefine() {
                let texture;
                const lastInstanceMaterialType = this._instanceMaterialType;

                if (this._spriteFrame) {
                  texture = this._spriteFrame.texture;
                }

                let value = false;

                if (texture instanceof TextureBase) {
                  const format = texture.getPixelFormat();
                  value = format === PixelFormat.RGBA_ETC1 || format === PixelFormat.RGB_A_PVRTC_4BPPV1 || format === PixelFormat.RGB_A_PVRTC_2BPPV1;
                }

                if (value && this.grayscale) {
                  this._instanceMaterialType = InstanceMaterialType.USE_ALPHA_SEPARATED_AND_GRAY;
                } else if (value) {
                  this._instanceMaterialType = InstanceMaterialType.USE_ALPHA_SEPARATED;
                } else if (this.grayscale) {
                  this._instanceMaterialType = InstanceMaterialType.GRAYSCALE;
                } else {
                  this._instanceMaterialType = InstanceMaterialType.ADD_COLOR_AND_TEXTURE;
                }

                if (lastInstanceMaterialType !== this._instanceMaterialType) {
                  this.updateMaterial();
                }
              }

              _updateBuiltinMaterial() {
                let mat = super._updateBuiltinMaterial();

                if (this.spriteFrame && this.spriteFrame.texture instanceof RenderTexture) {
                  const defines = {
                    SAMPLE_FROM_RT: true,
                    ...mat.passes[0].defines
                  };
                  const renderMat = new Material();
                  renderMat.initialize({
                    effectAsset: mat.effectAsset,
                    defines
                  });
                  mat = renderMat;
                }

                return mat;
              }

              _render(render) {
                render.commitComp(this, this._spriteFrame, this._assembler, null);
              }

              _canRender() {
                if (!super._canRender()) {
                  return false;
                }

                const spriteFrame = this._spriteFrame;

                if (!spriteFrame || !spriteFrame.texture) {
                  return false;
                }

                return true;
              }

              _flushAssembler() {
                const assembler = Sprite.Assembler.getAssembler(this);

                if (this._assembler !== assembler) {
                  this.destroyRenderData();
                  this._assembler = assembler;
                }

                if (!this._renderData) {
                  if (this._assembler && this._assembler.createData) {
                    this._renderData = this._assembler.createData(this);
                    this._renderData.material = this.getRenderMaterial(0);
                    this.markForUpdateRenderData();
                    this._colorDirty = true;

                    this._updateColor();
                  }
                }
              }

              _applySpriteSize() {
                if (this._spriteFrame) {
                  if (!this._spriteFrame.isDefault) {
                    if (SizeMode.RAW === this._sizeMode) {
                      const size = this._spriteFrame.originalSize;

                      this.node._uiProps.uiTransformComp.setContentSize(size);
                    } else if (SizeMode.TRIMMED === this._sizeMode) {
                      const rect = this._spriteFrame.getRect();

                      this.node._uiProps.uiTransformComp.setContentSize(rect.width, rect.height);
                    }
                  }

                  this._activateMaterial();
                }
              }

              _resized() {
                {
                  return;
                }
              }

              _activateMaterial() {
                const spriteFrame = this._spriteFrame;
                const material = this.getRenderMaterial(0);

                if (spriteFrame) {
                  if (material) {
                    this.markForUpdateRenderData();
                  }
                }

                if (this._renderData) {
                  this._renderData.material = material;
                }
              }

              _applySpriteFrame(oldFrame) {
                const spriteFrame = this._spriteFrame;

                if (this._renderData) {
                  if (!this._renderData.uvDirty) {
                    if (oldFrame && spriteFrame) {
                      this._renderData.uvDirty = oldFrame.uvHash !== spriteFrame.uvHash;
                    } else {
                      this._renderData.uvDirty = true;
                    }
                  }

                  this._renderDataFlag = this._renderData.uvDirty;
                }

                let textureChanged = false;

                if (spriteFrame) {
                  if (!oldFrame || oldFrame.texture !== spriteFrame.texture) {
                    textureChanged = true;
                  }

                  if (textureChanged) {
                    if (this._renderData) this._renderData.textureDirty = true;
                    this.changeMaterialForDefine();
                  }

                  this._applySpriteSize();
                }
              }

              _markForUpdateUvDirty() {
                if (this._renderData) {
                  this._renderData.uvDirty = true;
                  this._renderDataFlag = true;
                }
              }

              _calculateSlicedData(out) {
                const content = this.node._uiProps.uiTransformComp.contentSize;
                const spriteWidth = content.width;
                const spriteHeight = content.height;
                const leftWidth = this.spriteFrame.insetLeft;
                const rightWidth = this.spriteFrame.insetRight;
                const centerWidth = spriteWidth - leftWidth - rightWidth;
                const topHeight = this.spriteFrame.insetTop;
                const bottomHeight = this.spriteFrame.insetBottom;
                const centerHeight = spriteHeight - topHeight - bottomHeight;
                out.length = 0;
                out[0] = leftWidth / spriteWidth;
                out[1] = topHeight / spriteHeight;
                out[2] = (leftWidth + centerWidth) / spriteWidth;
                out[3] = (topHeight + centerHeight) / spriteHeight;
                return out;
              }

              calculateTiledData(out) {
                const content = this.node._uiProps.uiTransformComp.contentSize;
                const rect = this.spriteFrame.rect;
                out.x = content.width / rect.width;
                out.y = content.height / rect.height;
              }

              _updateUVWithTrim() {
                this.tillingOffsetWithTrim.length = 0;
                const frame = this.spriteFrame;
                const originSize = frame.originalSize;
                const rect = frame.rect;
                const tex = frame.texture;
                const texw = tex.width;
                const texh = tex.height;
                let x = 0;
                let y = 0;

                if (frame.original) {
                  x = rect.x - frame.original._x;
                  y = rect.y - frame.original._y;
                }

                let l = texw === 0 ? 0 : x / texw;
                let r = texw === 0 ? 1 : (x + originSize.width) / texw;
                let b = texh === 0 ? 1 : (y + originSize.height) / texh;
                let t = texh === 0 ? 0 : y / texh;

                if (frame.rotated) {
                  l = texw === 0 ? 0 : x / texw;
                  r = texw === 0 ? 1 : (x + originSize.height) / texw;
                  t = texh === 0 ? 0 : y / texh;
                  b = texh === 0 ? 1 : (y + originSize.width) / texh;
                }

                this.tillingOffsetWithTrim[0] = r - l;
                this.tillingOffsetWithTrim[1] = b - t;
                this.tillingOffsetWithTrim[2] = l;
                this.tillingOffsetWithTrim[3] = t;

                if (frame.rotated) {
                  this.tillingOffsetWithTrim[0] = -this.tillingOffsetWithTrim[0];
                }
              }

            }, _class3$5.FillType = FillType, _class3$5.Type = SpriteType, _class3$5.SizeMode = SizeMode, _class3$5.EventType = EventType, _temp$i), (_applyDecoratedDescriptor(_class2$h.prototype, "customMaterial", [_dec5$e, _dec6$d, _dec7$d, override], Object.getOwnPropertyDescriptor(_class2$h.prototype, "customMaterial"), _class2$h.prototype), _applyDecoratedDescriptor(_class2$h.prototype, "spriteAtlas", [_dec8$b, _dec9$a, _dec10$9], Object.getOwnPropertyDescriptor(_class2$h.prototype, "spriteAtlas"), _class2$h.prototype), _applyDecoratedDescriptor(_class2$h.prototype, "spriteFrame", [_dec11$6, _dec12$6, _dec13$5], Object.getOwnPropertyDescriptor(_class2$h.prototype, "spriteFrame"), _class2$h.prototype), _applyDecoratedDescriptor(_class2$h.prototype, "type", [_dec14$3, _dec15$3, _dec16$3], Object.getOwnPropertyDescriptor(_class2$h.prototype, "type"), _class2$h.prototype), _applyDecoratedDescriptor(_class2$h.prototype, "fillType", [_dec17$1, _dec18$1], Object.getOwnPropertyDescriptor(_class2$h.prototype, "fillType"), _class2$h.prototype), _applyDecoratedDescriptor(_class2$h.prototype, "fillCenter", [_dec19$1], Object.getOwnPropertyDescriptor(_class2$h.prototype, "fillCenter"), _class2$h.prototype), _applyDecoratedDescriptor(_class2$h.prototype, "fillStart", [_dec20$1, _dec21$1], Object.getOwnPropertyDescriptor(_class2$h.prototype, "fillStart"), _class2$h.prototype), _applyDecoratedDescriptor(_class2$h.prototype, "fillRange", [_dec22$1, _dec23$1], Object.getOwnPropertyDescriptor(_class2$h.prototype, "fillRange"), _class2$h.prototype), _applyDecoratedDescriptor(_class2$h.prototype, "trim", [_dec24$1, _dec25$1, _dec26$1], Object.getOwnPropertyDescriptor(_class2$h.prototype, "trim"), _class2$h.prototype), _applyDecoratedDescriptor(_class2$h.prototype, "grayscale", [editable, _dec27$1], Object.getOwnPropertyDescriptor(_class2$h.prototype, "grayscale"), _class2$h.prototype), _applyDecoratedDescriptor(_class2$h.prototype, "sizeMode", [_dec28$1, _dec29$1, _dec30$1], Object.getOwnPropertyDescriptor(_class2$h.prototype, "sizeMode"), _class2$h.prototype), _descriptor$h = _applyDecoratedDescriptor(_class2$h.prototype, "_spriteFrame", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor2$f = _applyDecoratedDescriptor(_class2$h.prototype, "_type", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return SpriteType.SIMPLE;
              }
            }), _descriptor3$b = _applyDecoratedDescriptor(_class2$h.prototype, "_fillType", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return FillType.HORIZONTAL;
              }
            }), _descriptor4$b = _applyDecoratedDescriptor(_class2$h.prototype, "_sizeMode", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return SizeMode.TRIMMED;
              }
            }), _descriptor5$9 = _applyDecoratedDescriptor(_class2$h.prototype, "_fillCenter", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec2(0, 0);
              }
            }), _descriptor6$6 = _applyDecoratedDescriptor(_class2$h.prototype, "_fillStart", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor7$4 = _applyDecoratedDescriptor(_class2$h.prototype, "_fillRange", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor8$4 = _applyDecoratedDescriptor(_class2$h.prototype, "_isTrimmedMode", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _descriptor9$3 = _applyDecoratedDescriptor(_class2$h.prototype, "_useGrayscale", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor10$2 = _applyDecoratedDescriptor(_class2$h.prototype, "_atlas", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            })), _class2$h)) || _class$k) || _class$k) || _class$k) || _class$k));

            var _dec$l, _dec2$g, _dec3$f, _dec4$f, _class$l;
            let RenderRoot2D = exports('RenderRoot2D', (_dec$l = ccclass('cc.RenderRoot2D'), _dec2$g = executionOrder(100), _dec3$f = menu$1(), _dec4$f = requireComponent(UITransform), _dec$l(_class$l = _dec2$g(_class$l = _dec3$f(_class$l = _dec4$f(_class$l = disallowMultiple(_class$l = executeInEditMode(_class$l = class RenderRoot2D extends Component {
              onEnable() {
                legacyCC.director.root.batcher2D.addScreen(this);
              }

              onDisable() {
                legacyCC.director.root.batcher2D.removeScreen(this);
              }

              onDestroy() {
                legacyCC.director.root.batcher2D.removeScreen(this);
              }

            }) || _class$l) || _class$l) || _class$l) || _class$l) || _class$l) || _class$l));

            var _dec$m, _dec2$h, _dec3$g, _dec4$g, _dec5$f, _dec6$e, _dec7$e, _dec8$c, _class$m, _class2$i, _descriptor$i, _descriptor2$g, _temp$j;

            const _worldPos = new Vec3();

            const RenderMode = Enum({
              OVERLAY: 0,
              INTERSPERSE: 1
            });
            let Canvas = function (v) { return exports({ Canvas: v, CanvasComponent: v }), v; }((_dec$m = ccclass('cc.Canvas'), _dec2$h = help(), _dec3$g = executionOrder(100), _dec4$g = menu$1(), _dec5$f = type$1(Camera$1), _dec6$e = tooltip(), _dec7$e = tooltip(), _dec8$c = type$1(Camera$1), _dec$m(_class$m = _dec2$h(_class$m = _dec3$g(_class$m = _dec4$g(_class$m = executeInEditMode(_class$m = disallowMultiple(_class$m = (_class2$i = (_temp$j = class Canvas extends RenderRoot2D {
              get renderMode() {
                return this._renderMode;
              }

              set renderMode(val) {
                this._renderMode = val;

                if (this._cameraComponent) {
                  this._cameraComponent.priority = this._getViewPriority();
                }
              }

              get cameraComponent() {
                return this._cameraComponent;
              }

              set cameraComponent(value) {
                if (this._cameraComponent === value) {
                  return;
                }

                this._cameraComponent = value;

                this._onResizeCamera();
              }

              get alignCanvasWithScreen() {
                return this._alignCanvasWithScreen;
              }

              set alignCanvasWithScreen(value) {
                this._alignCanvasWithScreen = value;

                this._onResizeCamera();
              }

              constructor() {
                super();

                _initializerDefineProperty(this, "_cameraComponent", _descriptor$i, this);

                _initializerDefineProperty(this, "_alignCanvasWithScreen", _descriptor2$g, this);

                this._thisOnCameraResized = void 0;
                this._fitDesignResolution = void 0;
                this._pos = new Vec3();
                this._renderMode = RenderMode.OVERLAY;
                this._thisOnCameraResized = this._onResizeCamera.bind(this);
              }

              __preload() {
                const widget = this.getComponent('cc.Widget');

                if (widget) {
                  widget.updateAlignment();
                }

                {
                  if (this._cameraComponent) {
                    this._cameraComponent._createCamera();

                    this._cameraComponent.node.on(Camera$1.TARGET_TEXTURE_CHANGE, this._thisOnCameraResized);
                  }
                }

                this._onResizeCamera();

                this.node.on(NodeEventType.TRANSFORM_CHANGED, this._thisOnCameraResized);
              }

              onEnable() {
                super.onEnable();

                if ( this._cameraComponent) {
                  this._cameraComponent.node.on(Camera$1.TARGET_TEXTURE_CHANGE, this._thisOnCameraResized);
                }
              }

              onDisable() {
                super.onDisable();

                if (this._cameraComponent) {
                  this._cameraComponent.node.off(Camera$1.TARGET_TEXTURE_CHANGE, this._thisOnCameraResized);
                }
              }

              onDestroy() {
                super.onDestroy();

                this.node.off(NodeEventType.TRANSFORM_CHANGED, this._thisOnCameraResized);
              }

              _onResizeCamera() {
                if (this._cameraComponent && this._alignCanvasWithScreen) {
                  if (this._cameraComponent.targetTexture) {
                    this._cameraComponent.orthoHeight = visibleRect.height / 2;
                  } else {
                    const size = screen.windowSize;
                    this._cameraComponent.orthoHeight = size.height / view.getScaleY() / 2;
                  }

                  this.node.getWorldPosition(_worldPos);

                  this._cameraComponent.node.setWorldPosition(_worldPos.x, _worldPos.y, 1000);
                }
              }

              _getViewPriority() {
                if (this._cameraComponent) {
                  var _this$cameraComponent;

                  let priority = (_this$cameraComponent = this.cameraComponent) === null || _this$cameraComponent === void 0 ? void 0 : _this$cameraComponent.priority;
                  priority = this._renderMode === RenderMode.OVERLAY ? priority | 1 << 30 : priority & ~(1 << 30);
                  return priority;
                }

                return 0;
              }

            }, _temp$j), (_applyDecoratedDescriptor(_class2$i.prototype, "cameraComponent", [_dec5$f, _dec6$e], Object.getOwnPropertyDescriptor(_class2$i.prototype, "cameraComponent"), _class2$i.prototype), _applyDecoratedDescriptor(_class2$i.prototype, "alignCanvasWithScreen", [_dec7$e], Object.getOwnPropertyDescriptor(_class2$i.prototype, "alignCanvasWithScreen"), _class2$i.prototype), _descriptor$i = _applyDecoratedDescriptor(_class2$i.prototype, "_cameraComponent", [_dec8$c], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor2$g = _applyDecoratedDescriptor(_class2$i.prototype, "_alignCanvasWithScreen", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            })), _class2$i)) || _class$m) || _class$m) || _class$m) || _class$m) || _class$m) || _class$m));
            legacyCC.Canvas = Canvas;

            var _dec$n, _dec2$i, _dec3$h, _class$n, _temp$k;
            let UIComponent = exports('UIComponent', (_dec$n = ccclass('cc.UIComponent'), _dec2$i = requireComponent(UITransform), _dec3$h = executionOrder(110), _dec$n(_class$n = _dec2$i(_class$n = _dec3$h(_class$n = disallowMultiple(_class$n = executeInEditMode(_class$n = (_temp$k = class UIComponent extends Component {
              constructor(...args) {
                super(...args);
                this._lastParent = null;
                this.stencilStage = Stage.DISABLED;
              }

              __preload() {
                this.node._uiProps.uiComp = this;
              }

              onEnable() {}

              onDisable() {}

              onDestroy() {
                if (this.node._uiProps.uiComp === this) {
                  this.node._uiProps.uiComp = null;
                }
              }

              updateAssembler(render) {}

              postUpdateAssembler(render) {}

              markForUpdateRenderData(enable = true) {}

              setNodeDirty() {}

              setTextureDirty() {}

            }, _temp$k)) || _class$n) || _class$n) || _class$n) || _class$n) || _class$n));

            removeProperty(UIComponent.prototype, 'UIComponent', [{
              name: '_visibility'
            }, {
              name: 'setVisibility'
            }]);
            removeProperty(Renderable2D.prototype, 'Renderable2D.prototype', [{
              name: 'srcBlendFactor'
            }, {
              name: 'dstBlendFactor'
            }]);
            replaceProperty(Canvas.prototype, 'Canvas.prototype', [{
              name: 'camera',
              newName: 'cameraComponent.camera',

              customGetter() {
                return this._cameraComponent.camera;
              }

            }, {
              name: 'clearFlag',
              newName: 'cameraComponent.clearFlags',

              customGetter() {
                return this._cameraComponent ? this._cameraComponent.clearFlags : 0;
              },

              customSetter(val) {
                if (this._cameraComponent) this._cameraComponent.clearFlags = val;
              }

            }, {
              name: 'color',
              newName: 'cameraComponent.clearColor',

              customGetter() {
                return this._cameraComponent ? this._cameraComponent.clearColor : Color$1.BLACK;
              },

              customSetter(val) {
                if (this._cameraComponent) this._cameraComponent.clearColor = val;
              }

            }, {
              name: 'priority',
              newName: 'cameraComponent.priority',

              customGetter() {
                return this._cameraComponent ? this._cameraComponent.priority : 0;
              },

              customSetter(val) {
                if (this._cameraComponent) this._cameraComponent.priority = val;
              }

            }, {
              name: 'targetTexture',
              newName: 'cameraComponent.targetTexture',

              customGetter() {
                return this._cameraComponent ? this._cameraComponent.targetTexture : null;
              },

              customSetter(value) {
                if (this._cameraComponent) this._cameraComponent.targetTexture = value;
              }

            }, {
              name: 'visibility',
              newName: 'cameraComponent.visibility',

              customGetter() {
                return this._cameraComponent ? this._cameraComponent.visibility : 0;
              }

            }]);
            markAsWarning(UITransform.prototype, 'UITransform.prototype', [{
              name: 'priority',
              suggest: `Please use setSiblingIndex to change index of the current node in its parent's children array.`
            }]);
            legacyCC.UITransformComponent = UITransform;
            js.setClassAlias(UITransform, 'cc.UITransformComponent');
            js.setClassAlias(Renderable2D, 'cc.RenderComponent');
            legacyCC.CanvasComponent = Canvas;
            js.setClassAlias(Canvas, 'cc.CanvasComponent');

            var _dec$o, _dec2$j, _dec3$i, _dec4$h, _dec5$g, _dec6$f, _dec7$f, _dec8$d, _dec9$b, _dec10$a, _dec11$7, _dec12$7, _dec13$6, _dec14$4, _dec15$4, _dec16$4, _dec17$2, _dec18$2, _dec19$2, _class$o, _class2$j, _descriptor$j, _descriptor2$h, _descriptor3$c, _descriptor4$c, _descriptor5$a, _descriptor6$7, _descriptor7$5, _descriptor8$5, _descriptor9$4, _descriptor10$3, _descriptor11$2, _descriptor12$1, _class3$6, _temp$l;

            const _htmlTextParser = new HtmlTextParser();

            const RichTextChildName = 'RICHTEXT_CHILD';
            const RichTextChildImageName = 'RICHTEXT_Image_CHILD';
            const labelPool = new Pool$1(seg => {

              if (!legacyCC.isValid(seg.node)) {
                return false;
              } else {
                const outline = seg.node.getComponent(LabelOutline);

                if (outline) {
                  outline.width = 0;
                }
              }

              return true;
            }, 20);
            const imagePool = new Pool$1(seg => {

              return legacyCC.isValid(seg.node);
            }, 10);

            function createSegment(type) {
              return {
                node: new Node(type),
                comp: null,
                lineCount: 0,
                styleIndex: 0,
                imageOffset: '',
                clickParam: '',
                clickHandler: '',
                type
              };
            }

            function getSegmentByPool(type, content) {
              let seg;

              if (type === RichTextChildName) {
                seg = labelPool._get();
              } else if (type === RichTextChildImageName) {
                seg = imagePool._get();
              }

              seg = seg || createSegment(type);
              let node = seg.node;

              if (!node) {
                node = new Node(type);
              }

              node.hideFlags |= CCObject.Flags.DontSave | CCObject.Flags.HideInHierarchy;

              if (type === RichTextChildImageName) {
                seg.comp = node.getComponent(Sprite) || node.addComponent(Sprite);
                seg.comp.spriteFrame = content;
                seg.comp.type = Sprite.Type.SLICED;
                seg.comp.sizeMode = Sprite.SizeMode.CUSTOM;
              } else {
                seg.comp = node.getComponent(Label) || node.addComponent(Label);
                seg.comp.string = content;
                seg.comp.horizontalAlign = HorizontalTextAlignment.LEFT;
                seg.comp.verticalAlign = VerticalTextAlignment.TOP;
              }

              node.setPosition(0, 0, 0);
              const trans = node._uiProps.uiTransformComp;
              trans.setAnchorPoint(0.5, 0.5);
              seg.node = node;
              seg.lineCount = 0;
              seg.styleIndex = 0;
              seg.imageOffset = '';
              seg.clickParam = '';
              seg.clickHandler = '';
              return seg;
            }

            let RichText = function (v) { return exports({ RichText: v, RichTextComponent: v }), v; }((_dec$o = ccclass('cc.RichText'), _dec2$j = help(), _dec3$i = executionOrder(110), _dec4$h = menu$1(), _dec5$g = tooltip(), _dec6$f = type$1(HorizontalTextAlignment), _dec7$f = tooltip(), _dec8$d = tooltip(), _dec9$b = tooltip(), _dec10$a = type$1(Font), _dec11$7 = tooltip(), _dec12$7 = tooltip(), _dec13$6 = type$1(CacheMode), _dec14$4 = tooltip(), _dec15$4 = tooltip(), _dec16$4 = tooltip(), _dec17$2 = type$1(SpriteAtlas), _dec18$2 = tooltip(), _dec19$2 = tooltip(), _dec$o(_class$o = _dec2$j(_class$o = _dec3$i(_class$o = _dec4$h(_class$o = executeInEditMode(_class$o = (_class2$j = (_temp$l = _class3$6 = class RichText extends UIComponent {
              get string() {
                return this._string;
              }

              set string(value) {
                if (this._string === value) {
                  return;
                }

                this._string = value;

                this._updateRichTextStatus();
              }

              get horizontalAlign() {
                return this._horizontalAlign;
              }

              set horizontalAlign(value) {
                if (this.horizontalAlign === value) {
                  return;
                }

                this._horizontalAlign = value;
                this._layoutDirty = true;

                this._updateRichTextStatus();
              }

              get fontSize() {
                return this._fontSize;
              }

              set fontSize(value) {
                if (this._fontSize === value) {
                  return;
                }

                this._fontSize = value;
                this._layoutDirty = true;

                this._updateRichTextStatus();
              }

              get fontFamily() {
                return this._fontFamily;
              }

              set fontFamily(value) {
                if (this._fontFamily === value) return;
                this._fontFamily = value;
                this._layoutDirty = true;

                this._updateRichTextStatus();
              }

              get font() {
                return this._font;
              }

              set font(value) {
                if (this._font === value) {
                  return;
                }

                this._font = value;
                this._layoutDirty = true;

                if (this._font) {

                  this.useSystemFont = false;

                  this._onTTFLoaded();
                } else {
                  this.useSystemFont = true;
                }

                this._updateRichTextStatus();
              }

              get useSystemFont() {
                return this._isSystemFontUsed;
              }

              set useSystemFont(value) {
                if (this._isSystemFontUsed === value) {
                  return;
                }

                this._isSystemFontUsed = value;

                this._layoutDirty = true;

                this._updateRichTextStatus();
              }

              get cacheMode() {
                return this._cacheMode;
              }

              set cacheMode(value) {
                if (this._cacheMode === value) {
                  return;
                }

                this._cacheMode = value;

                this._updateRichTextStatus();
              }

              get maxWidth() {
                return this._maxWidth;
              }

              set maxWidth(value) {
                if (this._maxWidth === value) {
                  return;
                }

                this._maxWidth = value;
                this._layoutDirty = true;

                this._updateRichTextStatus();
              }

              get lineHeight() {
                return this._lineHeight;
              }

              set lineHeight(value) {
                if (this._lineHeight === value) {
                  return;
                }

                this._lineHeight = value;
                this._layoutDirty = true;

                this._updateRichTextStatus();
              }

              get imageAtlas() {
                return this._imageAtlas;
              }

              set imageAtlas(value) {
                if (this._imageAtlas === value) {
                  return;
                }

                this._imageAtlas = value;
                this._layoutDirty = true;

                this._updateRichTextStatus();
              }

              get handleTouchEvent() {
                return this._handleTouchEvent;
              }

              set handleTouchEvent(value) {
                if (this._handleTouchEvent === value) {
                  return;
                }

                this._handleTouchEvent = value;

                if (this.enabledInHierarchy) {
                  if (this.handleTouchEvent) {
                    this._addEventListeners();
                  } else {
                    this._removeEventListeners();
                  }
                }
              }

              constructor() {
                super();

                _initializerDefineProperty(this, "_lineHeight", _descriptor$j, this);

                _initializerDefineProperty(this, "_string", _descriptor2$h, this);

                _initializerDefineProperty(this, "_horizontalAlign", _descriptor3$c, this);

                _initializerDefineProperty(this, "_fontSize", _descriptor4$c, this);

                _initializerDefineProperty(this, "_maxWidth", _descriptor5$a, this);

                _initializerDefineProperty(this, "_fontFamily", _descriptor6$7, this);

                _initializerDefineProperty(this, "_font", _descriptor7$5, this);

                _initializerDefineProperty(this, "_isSystemFontUsed", _descriptor8$5, this);

                _initializerDefineProperty(this, "_userDefinedFont", _descriptor9$4, this);

                _initializerDefineProperty(this, "_cacheMode", _descriptor10$3, this);

                _initializerDefineProperty(this, "_imageAtlas", _descriptor11$2, this);

                _initializerDefineProperty(this, "_handleTouchEvent", _descriptor12$1, this);

                this._textArray = [];
                this._segments = [];
                this._labelSegmentsCache = [];
                this._linesWidth = [];
                this._lineCount = 1;
                this._labelWidth = 0;
                this._labelHeight = 0;
                this._layoutDirty = true;
                this._lineOffsetX = 0;
                this._updateRichTextStatus = void 0;

                this._updateRichTextStatus = this._updateRichText;
              }

              onLoad() {
                this.node.on(NodeEventType.LAYER_CHANGED, this._applyLayer, this);
              }

              onEnable() {
                if (this.handleTouchEvent) {
                  this._addEventListeners();
                }

                this._updateRichText();

                this._activateChildren(true);
              }

              onDisable() {
                if (this.handleTouchEvent) {
                  this._removeEventListeners();
                }

                this._activateChildren(false);
              }

              start() {
                this._onTTFLoaded();

                this.node.on(NodeEventType.ANCHOR_CHANGED, this._updateRichTextPosition, this);
              }

              onRestore() {
                {
                  return;
                }
              }

              onDestroy() {
                for (const seg of this._segments) {
                  seg.node.removeFromParent();

                  if (seg.type === RichTextChildName) {
                    labelPool.put(seg);
                  } else if (seg.type === RichTextChildImageName) {
                    imagePool.put(seg);
                  }
                }

                this.node.off(NodeEventType.ANCHOR_CHANGED, this._updateRichTextPosition, this);
                this.node.off(NodeEventType.LAYER_CHANGED, this._applyLayer, this);
              }

              _addEventListeners() {
                this.node.on(NodeEventType.TOUCH_END, this._onTouchEnded, this);
              }

              _removeEventListeners() {
                this.node.off(NodeEventType.TOUCH_END, this._onTouchEnded, this);
              }

              _updateLabelSegmentTextAttributes() {
                this._segments.forEach(item => {
                  this._applyTextAttribute(item);
                });
              }

              _createFontLabel(str) {
                return getSegmentByPool(RichTextChildName, str);
              }

              _createImage(spriteFrame) {
                return getSegmentByPool(RichTextChildImageName, spriteFrame);
              }

              _onTTFLoaded() {
                if (this._font instanceof TTFFont) {
                  this._layoutDirty = true;

                  this._updateRichText();
                } else {
                  this._layoutDirty = true;

                  this._updateRichText();
                }
              }

              _measureText(styleIndex, string) {
                const func = s => {
                  let label;

                  if (this._labelSegmentsCache.length === 0) {
                    label = this._createFontLabel(s);

                    this._labelSegmentsCache.push(label);
                  } else {
                    label = this._labelSegmentsCache[0];
                    label.node.getComponent(Label).string = s;
                  }

                  label.styleIndex = styleIndex;

                  this._applyTextAttribute(label);

                  const labelSize = label.node._uiProps.uiTransformComp.contentSize;
                  return labelSize.width;
                };

                if (string) {
                  return func(string);
                } else {
                  return func;
                }
              }

              _onTouchEnded(event) {
                const components = this.node.getComponents(Component);

                for (const seg of this._segments) {
                  const clickHandler = seg.clickHandler;
                  const clickParam = seg.clickParam;

                  if (clickHandler && this._containsTouchLocation(seg, event.touch.getUILocation())) {
                    components.forEach(component => {
                      const func = component[clickHandler];

                      if (component.enabledInHierarchy && func) {
                        func.call(component, event, clickParam);
                      }
                    });
                    event.propagationStopped = true;
                  }
                }
              }

              _containsTouchLocation(label, point) {
                const comp = label.node.getComponent(UITransform);

                if (!comp) {
                  return false;
                }

                const myRect = comp.getBoundingBoxToWorld();
                return myRect.contains(point);
              }

              _resetState() {
                const children = this.node.children;

                for (let i = children.length - 1; i >= 0; i--) {
                  const child = children[i];

                  if (child.name === RichTextChildName || child.name === RichTextChildImageName) {
                    if (child.parent === this.node) {
                      child.parent = null;
                    } else {
                      children.splice(i, 1);
                    }

                    const segment = createSegment(child.name);
                    segment.node = child;

                    if (child.name === RichTextChildName) {
                      segment.comp = child.getComponent(Label);
                      labelPool.put(segment);
                    } else {
                      segment.comp = child.getComponent(Sprite);
                      imagePool.put(segment);
                    }
                  }
                }

                children.length = 0;
                this._segments.length = 0;
                this._labelSegmentsCache.length = 0;
                this._linesWidth.length = 0;
                this._lineOffsetX = 0;
                this._lineCount = 1;
                this._labelWidth = 0;
                this._labelHeight = 0;
                this._layoutDirty = true;
              }

              _activateChildren(active) {
                for (let i = this.node.children.length - 1; i >= 0; i--) {
                  const child = this.node.children[i];

                  if (child.name === RichTextChildName || child.name === RichTextChildImageName) {
                    child.active = active;
                  }
                }
              }

              _addLabelSegment(stringToken, styleIndex) {
                let labelSegment;

                if (this._labelSegmentsCache.length === 0) {
                  labelSegment = this._createFontLabel(stringToken);
                } else {
                  labelSegment = this._labelSegmentsCache.pop();
                  const label = labelSegment.node.getComponent(Label);

                  if (label) {
                    label.string = stringToken;
                  }
                }

                labelSegment.styleIndex = styleIndex;
                labelSegment.lineCount = this._lineCount;

                labelSegment.node._uiProps.uiTransformComp.setAnchorPoint(0, 0);

                labelSegment.node.layer = this.node.layer;
                this.node.addChild(labelSegment.node);

                this._applyTextAttribute(labelSegment);

                this._segments.push(labelSegment);

                return labelSegment;
              }

              _updateRichTextWithMaxWidth(labelString, labelWidth, styleIndex) {
                let fragmentWidth = labelWidth;
                let labelSegment;

                if (this._lineOffsetX > 0 && fragmentWidth + this._lineOffsetX > this._maxWidth) {
                  let checkStartIndex = 0;

                  while (this._lineOffsetX <= this._maxWidth) {
                    const checkEndIndex = this._getFirstWordLen(labelString, checkStartIndex, labelString.length);

                    const checkString = labelString.substr(checkStartIndex, checkEndIndex);

                    const checkStringWidth = this._measureText(styleIndex, checkString);

                    if (this._lineOffsetX + checkStringWidth <= this._maxWidth) {
                      this._lineOffsetX += checkStringWidth;
                      checkStartIndex += checkEndIndex;
                    } else {
                      if (checkStartIndex > 0) {
                        const remainingString = labelString.substr(0, checkStartIndex);

                        this._addLabelSegment(remainingString, styleIndex);

                        labelString = labelString.substr(checkStartIndex, labelString.length);
                        fragmentWidth = this._measureText(styleIndex, labelString);
                      }

                      this._updateLineInfo();

                      break;
                    }
                  }
                }

                if (fragmentWidth > this._maxWidth) {
                  const fragments = fragmentText(labelString, fragmentWidth, this._maxWidth, this._measureText(styleIndex));

                  for (let k = 0; k < fragments.length; ++k) {
                    const splitString = fragments[k];
                    labelSegment = this._addLabelSegment(splitString, styleIndex);
                    const labelSize = labelSegment.node._uiProps.uiTransformComp.contentSize;
                    this._lineOffsetX += labelSize.width;

                    if (fragments.length > 1 && k < fragments.length - 1) {
                      this._updateLineInfo();
                    }
                  }
                } else {
                  this._lineOffsetX += fragmentWidth;

                  this._addLabelSegment(labelString, styleIndex);
                }
              }

              _isLastComponentCR(stringToken) {
                return stringToken.length - 1 === stringToken.lastIndexOf('\n');
              }

              _updateLineInfo() {
                this._linesWidth.push(this._lineOffsetX);

                this._lineOffsetX = 0;
                this._lineCount++;
              }

              _needsUpdateTextLayout(newTextArray) {
                if (this._layoutDirty || !this._textArray || !newTextArray) {
                  return true;
                }

                if (this._textArray.length !== newTextArray.length) {
                  return true;
                }

                for (let i = 0; i < this._textArray.length; i++) {
                  const oldItem = this._textArray[i];
                  const newItem = newTextArray[i];

                  if (oldItem.text !== newItem.text) {
                    return true;
                  } else {
                    const oldStyle = oldItem.style;
                    const newStyle = newItem.style;

                    if (oldStyle) {
                      if (newStyle) {
                        if (!!newStyle.outline !== !!oldStyle.outline) {
                          return true;
                        }

                        if (oldStyle.size !== newStyle.size || oldStyle.italic !== newStyle.italic || oldStyle.isImage !== newStyle.isImage) {
                          return true;
                        }

                        if (oldStyle.src !== newStyle.src || oldStyle.imageAlign !== newStyle.imageAlign || oldStyle.imageHeight !== newStyle.imageHeight || oldStyle.imageWidth !== newStyle.imageWidth || oldStyle.imageOffset !== newStyle.imageOffset) {
                          return true;
                        }
                      } else if (oldStyle.size || oldStyle.italic || oldStyle.isImage || oldStyle.outline) {
                        return true;
                      }
                    } else if (newStyle) {
                      if (newStyle.size || newStyle.italic || newStyle.isImage || newStyle.outline) {
                        return true;
                      }
                    }
                  }
                }

                return false;
              }

              _addRichTextImageElement(richTextElement) {
                if (!richTextElement.style) {
                  return;
                }

                const style = richTextElement.style;
                const spriteFrameName = style.src;

                const spriteFrame = this._imageAtlas && spriteFrameName && this._imageAtlas.getSpriteFrame(spriteFrameName);

                if (!spriteFrame) {
                  warnID(4400);
                } else {
                  const segment = this._createImage(spriteFrame);

                  const sprite = segment.comp;

                  switch (style.imageAlign) {
                    case 'top':
                      segment.node._uiProps.uiTransformComp.setAnchorPoint(0, 1);

                      break;

                    case 'center':
                      segment.node._uiProps.uiTransformComp.setAnchorPoint(0, 0.5);

                      break;

                    default:
                      segment.node._uiProps.uiTransformComp.setAnchorPoint(0, 0);

                      break;
                  }

                  if (style.imageOffset) {
                    segment.imageOffset = style.imageOffset;
                  }

                  segment.node.layer = this.node.layer;
                  this.node.addChild(segment.node);

                  this._segments.push(segment);

                  const spriteRect = spriteFrame.rect.clone();
                  let scaleFactor = 1;
                  let spriteWidth = spriteRect.width;
                  let spriteHeight = spriteRect.height;
                  const expectWidth = style.imageWidth || 0;
                  const expectHeight = style.imageHeight || 0;

                  if (expectHeight > 0) {
                    scaleFactor = expectHeight / spriteHeight;
                    spriteWidth *= scaleFactor;
                    spriteHeight *= scaleFactor;
                  } else {
                    scaleFactor = this._lineHeight / spriteHeight;
                    spriteWidth *= scaleFactor;
                    spriteHeight *= scaleFactor;
                  }

                  if (expectWidth > 0) {
                    spriteWidth = expectWidth;
                  }

                  if (this._maxWidth > 0) {
                    if (this._lineOffsetX + spriteWidth > this._maxWidth) {
                      this._updateLineInfo();
                    }

                    this._lineOffsetX += spriteWidth;
                  } else {
                    this._lineOffsetX += spriteWidth;

                    if (this._lineOffsetX > this._labelWidth) {
                      this._labelWidth = this._lineOffsetX;
                    }
                  }

                  segment.node._uiProps.uiTransformComp.setContentSize(spriteWidth, spriteHeight);

                  segment.lineCount = this._lineCount;
                  segment.clickHandler = '';
                  segment.clickParam = '';
                  const event = style.event;

                  if (event) {
                    segment.clickHandler = event.click;
                    segment.clickParam = event.param;
                  }
                }
              }

              _updateRichText() {
                if (!this.enabledInHierarchy) {
                  return;
                }

                const newTextArray = _htmlTextParser.parse(this._string);

                if (!this._needsUpdateTextLayout(newTextArray)) {
                  this._textArray = newTextArray.slice();

                  this._updateLabelSegmentTextAttributes();

                  return;
                }

                this._textArray = newTextArray.slice();

                this._resetState();

                let lastEmptyLine = false;
                let label;

                for (let i = 0; i < this._textArray.length; ++i) {
                  const richTextElement = this._textArray[i];
                  const text = richTextElement.text;

                  if (text === undefined) {
                    continue;
                  }

                  if (text === '') {
                    if (richTextElement.style && richTextElement.style.isNewLine) {
                      this._updateLineInfo();

                      continue;
                    }

                    if (richTextElement.style && richTextElement.style.isImage && this._imageAtlas) {
                      this._addRichTextImageElement(richTextElement);

                      continue;
                    }
                  }

                  const multilineTexts = text.split('\n');

                  for (let j = 0; j < multilineTexts.length; ++j) {
                    const labelString = multilineTexts[j];

                    if (labelString === '') {
                      if (this._isLastComponentCR(text) && j === multilineTexts.length - 1) {
                        continue;
                      }

                      this._updateLineInfo();

                      lastEmptyLine = true;
                      continue;
                    }

                    lastEmptyLine = false;

                    if (this._maxWidth > 0) {
                      const labelWidth = this._measureText(i, labelString);

                      this._updateRichTextWithMaxWidth(labelString, labelWidth, i);

                      if (multilineTexts.length > 1 && j < multilineTexts.length - 1) {
                        this._updateLineInfo();
                      }
                    } else {
                      label = this._addLabelSegment(labelString, i);
                      this._lineOffsetX += label.node._uiProps.uiTransformComp.width;

                      if (this._lineOffsetX > this._labelWidth) {
                        this._labelWidth = this._lineOffsetX;
                      }

                      if (multilineTexts.length > 1 && j < multilineTexts.length - 1) {
                        this._updateLineInfo();
                      }
                    }
                  }
                }

                if (!lastEmptyLine) {
                  this._linesWidth.push(this._lineOffsetX);
                }

                if (this._maxWidth > 0) {
                  this._labelWidth = this._maxWidth;
                }

                this._labelHeight = (this._lineCount + BASELINE_RATIO) * this._lineHeight;

                this.node._uiProps.uiTransformComp.setContentSize(this._labelWidth, this._labelHeight);

                this._updateRichTextPosition();

                this._layoutDirty = false;
              }

              _getFirstWordLen(text, startIndex, textLen) {
                let character = text.charAt(startIndex);

                if (isUnicodeCJK(character) || isUnicodeSpace(character)) {
                  return 1;
                }

                let len = 1;

                for (let index = startIndex + 1; index < textLen; ++index) {
                  character = text.charAt(index);

                  if (isUnicodeSpace(character) || isUnicodeCJK(character)) {
                    break;
                  }

                  len++;
                }

                return len;
              }

              _updateRichTextPosition() {
                let nextTokenX = 0;
                let nextLineIndex = 1;
                const totalLineCount = this._lineCount;
                const trans = this.node._uiProps.uiTransformComp;
                const anchorX = trans.anchorX;
                const anchorY = trans.anchorY;

                for (let i = 0; i < this._segments.length; ++i) {
                  const segment = this._segments[i];
                  const lineCount = segment.lineCount;

                  if (lineCount > nextLineIndex) {
                    nextTokenX = 0;
                    nextLineIndex = lineCount;
                  }

                  let lineOffsetX = this._labelWidth * (this._horizontalAlign * 0.5 - anchorX);

                  switch (this._horizontalAlign) {
                    case HorizontalTextAlignment.LEFT:
                      break;

                    case HorizontalTextAlignment.CENTER:
                      lineOffsetX -= this._linesWidth[lineCount - 1] / 2;
                      break;

                    case HorizontalTextAlignment.RIGHT:
                      lineOffsetX -= this._linesWidth[lineCount - 1];
                      break;
                  }

                  const pos = segment.node.position;
                  segment.node.setPosition(nextTokenX + lineOffsetX, this._lineHeight * (totalLineCount - lineCount) - this._labelHeight * anchorY, pos.z);

                  if (lineCount === nextLineIndex) {
                    nextTokenX += segment.node._uiProps.uiTransformComp.width;
                  }

                  const sprite = segment.node.getComponent(Sprite);

                  if (sprite) {
                    const position = segment.node.position.clone();
                    const lineHeightSet = this._lineHeight;
                    const lineHeightReal = this._lineHeight * (1 + BASELINE_RATIO);

                    switch (segment.node._uiProps.uiTransformComp.anchorY) {
                      case 1:
                        position.y += lineHeightSet + (lineHeightReal - lineHeightSet) / 2;
                        break;

                      case 0.5:
                        position.y += lineHeightReal / 2;
                        break;

                      default:
                        position.y += (lineHeightReal - lineHeightSet) / 2;
                        break;
                    }

                    if (segment.imageOffset) {
                      const offsets = segment.imageOffset.split(',');

                      if (offsets.length === 1 && offsets[0]) {
                        const offsetY = parseFloat(offsets[0]);
                        if (Number.isInteger(offsetY)) position.y += offsetY;
                      } else if (offsets.length === 2) {
                        const offsetX = parseFloat(offsets[0]);
                        const offsetY = parseFloat(offsets[1]);
                        if (Number.isInteger(offsetX)) position.x += offsetX;
                        if (Number.isInteger(offsetY)) position.y += offsetY;
                      }
                    }

                    segment.node.position = position;
                  }

                  const outline = segment.node.getComponent(LabelOutline);

                  if (outline) {
                    const position = segment.node.position.clone();
                    position.y -= outline.width;
                    segment.node.position = position;
                  }
                }
              }

              _convertLiteralColorValue(color) {
                const colorValue = color.toUpperCase();

                if (Color$1[colorValue]) {
                  const colorUse = Color$1[colorValue];
                  return colorUse;
                } else {
                  const out = new Color$1();
                  return out.fromHEX(color);
                }
              }

              _applyTextAttribute(labelSeg) {
                const label = labelSeg.node.getComponent(Label);

                if (!label) {
                  return;
                }

                this._resetLabelState(label);

                const index = labelSeg.styleIndex;
                let textStyle;

                if (this._textArray[index]) {
                  textStyle = this._textArray[index].style;
                }

                if (textStyle) {
                  label.color = this._convertLiteralColorValue(textStyle.color || 'white');
                  label.isBold = !!textStyle.bold;
                  label.isItalic = !!textStyle.italic;
                  label.isUnderline = !!textStyle.underline;

                  if (textStyle.outline) {
                    let labelOutline = labelSeg.node.getComponent(LabelOutline);

                    if (!labelOutline) {
                      labelOutline = labelSeg.node.addComponent(LabelOutline);
                    }

                    labelOutline.color = this._convertLiteralColorValue(textStyle.outline.color);
                    labelOutline.width = textStyle.outline.width;
                  }

                  label.fontSize = textStyle.size || this._fontSize;
                  labelSeg.clickHandler = '';
                  labelSeg.clickParam = '';
                  const event = textStyle.event;

                  if (event) {
                    labelSeg.clickHandler = event.click || '';
                    labelSeg.clickParam = event.param || '';
                  }
                }

                label.cacheMode = this._cacheMode;
                const isAsset = this._font instanceof Font;

                if (isAsset && !this._isSystemFontUsed) {
                  label.font = this._font;
                } else {
                  label.fontFamily = this._fontFamily;
                }

                label.useSystemFont = this._isSystemFontUsed;
                label.lineHeight = this._lineHeight;
                label.updateRenderData(true);
                const assembler = label._assembler;

                if (assembler) {
                  assembler.updateRenderData(label);
                }
              }

              _applyLayer() {
                for (const seg of this._segments) {
                  seg.node.layer = this.node.layer;
                }
              }

              _resetLabelState(label) {
                label.fontSize = this._fontSize;
                label.color = Color$1.WHITE;
                label.isBold = false;
                label.isItalic = false;
                label.isUnderline = false;
              }

            }, _class3$6.HorizontalAlign = HorizontalTextAlignment, _class3$6.VerticalAlign = VerticalTextAlignment, _temp$l), (_applyDecoratedDescriptor(_class2$j.prototype, "string", [multiline, _dec5$g], Object.getOwnPropertyDescriptor(_class2$j.prototype, "string"), _class2$j.prototype), _applyDecoratedDescriptor(_class2$j.prototype, "horizontalAlign", [_dec6$f, _dec7$f], Object.getOwnPropertyDescriptor(_class2$j.prototype, "horizontalAlign"), _class2$j.prototype), _applyDecoratedDescriptor(_class2$j.prototype, "fontSize", [_dec8$d], Object.getOwnPropertyDescriptor(_class2$j.prototype, "fontSize"), _class2$j.prototype), _applyDecoratedDescriptor(_class2$j.prototype, "fontFamily", [_dec9$b], Object.getOwnPropertyDescriptor(_class2$j.prototype, "fontFamily"), _class2$j.prototype), _applyDecoratedDescriptor(_class2$j.prototype, "font", [_dec10$a, _dec11$7], Object.getOwnPropertyDescriptor(_class2$j.prototype, "font"), _class2$j.prototype), _applyDecoratedDescriptor(_class2$j.prototype, "useSystemFont", [_dec12$7], Object.getOwnPropertyDescriptor(_class2$j.prototype, "useSystemFont"), _class2$j.prototype), _applyDecoratedDescriptor(_class2$j.prototype, "cacheMode", [_dec13$6, _dec14$4], Object.getOwnPropertyDescriptor(_class2$j.prototype, "cacheMode"), _class2$j.prototype), _applyDecoratedDescriptor(_class2$j.prototype, "maxWidth", [_dec15$4], Object.getOwnPropertyDescriptor(_class2$j.prototype, "maxWidth"), _class2$j.prototype), _applyDecoratedDescriptor(_class2$j.prototype, "lineHeight", [_dec16$4], Object.getOwnPropertyDescriptor(_class2$j.prototype, "lineHeight"), _class2$j.prototype), _applyDecoratedDescriptor(_class2$j.prototype, "imageAtlas", [_dec17$2, _dec18$2], Object.getOwnPropertyDescriptor(_class2$j.prototype, "imageAtlas"), _class2$j.prototype), _applyDecoratedDescriptor(_class2$j.prototype, "handleTouchEvent", [_dec19$2], Object.getOwnPropertyDescriptor(_class2$j.prototype, "handleTouchEvent"), _class2$j.prototype), _descriptor$j = _applyDecoratedDescriptor(_class2$j.prototype, "_lineHeight", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 40;
              }
            }), _descriptor2$h = _applyDecoratedDescriptor(_class2$j.prototype, "_string", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '<color=#00ff00>Rich</color><color=#0fffff>Text</color>';
              }
            }), _descriptor3$c = _applyDecoratedDescriptor(_class2$j.prototype, "_horizontalAlign", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return HorizontalTextAlignment.LEFT;
              }
            }), _descriptor4$c = _applyDecoratedDescriptor(_class2$j.prototype, "_fontSize", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 40;
              }
            }), _descriptor5$a = _applyDecoratedDescriptor(_class2$j.prototype, "_maxWidth", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor6$7 = _applyDecoratedDescriptor(_class2$j.prototype, "_fontFamily", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 'Arial';
              }
            }), _descriptor7$5 = _applyDecoratedDescriptor(_class2$j.prototype, "_font", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor8$5 = _applyDecoratedDescriptor(_class2$j.prototype, "_isSystemFontUsed", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _descriptor9$4 = _applyDecoratedDescriptor(_class2$j.prototype, "_userDefinedFont", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor10$3 = _applyDecoratedDescriptor(_class2$j.prototype, "_cacheMode", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return CacheMode.NONE;
              }
            }), _descriptor11$2 = _applyDecoratedDescriptor(_class2$j.prototype, "_imageAtlas", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor12$1 = _applyDecoratedDescriptor(_class2$j.prototype, "_handleTouchEvent", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            })), _class2$j)) || _class$o) || _class$o) || _class$o) || _class$o) || _class$o));

            var _dec$p, _dec2$k, _dec3$j, _dec4$i, _class$p, _temp$m;
            let UIMeshRenderer = function (v) { return exports({ UIMeshRenderer: v, UIModelComponent: v }), v; }((_dec$p = ccclass('cc.UIMeshRenderer'), _dec2$k = help(), _dec3$j = executionOrder(110), _dec4$i = menu$1(), _dec$p(_class$p = _dec2$k(_class$p = _dec3$j(_class$p = _dec4$i(_class$p = (_temp$m = class UIMeshRenderer extends UIComponent {
              constructor(...args) {
                super(...args);
                this._models = null;
                this._modelComponent = null;
              }

              get modelComponent() {
                return this._modelComponent;
              }

              onLoad() {
                if (!this.node._uiProps.uiTransformComp) {
                  this.node.addComponent('cc.UITransform');
                }

                this._modelComponent = this.getComponent('cc.RenderableComponent');

                if (!this._modelComponent) {
                  console.warn(`node '${this.node && this.node.name}' doesn't have any renderable component`);
                  return;
                }

                this._models = this._modelComponent._collectModels();
              }

              onEnable() {
                super.onEnable();
              }

              onDisable() {
                super.onDisable();
              }

              onDestroy() {
                super.onDestroy();
                this._modelComponent = this.getComponent('cc.RenderableComponent');

                if (!this._modelComponent) {
                  return;
                }

                this._modelComponent._sceneGetter = null;
                this._models = null;
              }

              updateAssembler(render) {
                if (this._models) {
                  this._modelComponent._detachFromScene();

                  for (const m of this._models) {
                    render.commitModel.call(render, this, m, this._modelComponent.material);
                  }

                  return true;
                }

                return false;
              }

              update() {
                this._fitUIRenderQueue();
              }

              _fitUIRenderQueue() {
                if (!this._modelComponent) {
                  return;
                }

                const matNum = this._modelComponent.sharedMaterials.length;

                for (let i = 0; i < matNum; i++) {
                  const material = this._modelComponent.getMaterialInstance(i);

                  if (material == null) {
                    continue;
                  }

                  const passes = material.passes;
                  const passNum = passes.length;

                  for (let j = 0; j < passNum; j++) {
                    const pass = passes[j];
                    pass._priority = RenderPriority.MAX - 11;
                    material.recompileShaders({
                      CC_FORCE_FORWARD_SHADING: true
                    }, j);
                  }
                }
              }

            }, _temp$m)) || _class$p) || _class$p) || _class$p) || _class$p));

            class MeshBuffer extends ScalableContainer {
              get attributes() {
                return this._attributes;
              }

              get vertexBuffers() {
                return this._vertexBuffers;
              }

              get indexBuffer() {
                return this._indexBuffer;
              }

              constructor(batcher) {
                super();
                this.vData = null;
                this.iData = null;
                this.byteStart = 0;
                this.byteOffset = 0;
                this.indicesStart = 0;
                this.indicesOffset = 0;
                this.vertexStart = 0;
                this.vertexOffset = 0;
                this.lastByteOffset = 1;
                this._attributes = null;
                this._vertexBuffers = [];
                this._indexBuffer = null;
                this._iaInfo = null;
                this._batcher = void 0;
                this._dirty = false;
                this._vertexFormatBytes = 0;
                this._initVDataCount = 0;
                this._initIDataCount = 256 * 6;
                this._outOfCallback = null;
                this._hInputAssemblers = [];
                this._nextFreeIAHandle = 0;
                this._lastUsedVDataSize = 0;
                this._lastUsedIDataSize = 0;
                this._batcher = batcher;
              }

              get vertexFormatBytes() {
                return this._vertexFormatBytes;
              }

              initialize(attrs, outOfCallback) {
                this._outOfCallback = outOfCallback;
                const formatBytes = getComponentPerVertex(attrs);
                this._vertexFormatBytes = formatBytes * Float32Array.BYTES_PER_ELEMENT;
                this._initVDataCount = 256 * this._vertexFormatBytes;
                const vbStride = Float32Array.BYTES_PER_ELEMENT * formatBytes;

                if (!this.vertexBuffers.length) {
                  this.vertexBuffers.push(this._batcher.device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, vbStride, vbStride)));
                }

                const ibStride = Uint16Array.BYTES_PER_ELEMENT;

                if (!this.indexBuffer) {
                  this._indexBuffer = this._batcher.device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, ibStride, ibStride));
                }

                this._attributes = attrs;
                this._iaInfo = new InputAssemblerInfo(this.attributes, this.vertexBuffers, this.indexBuffer);

                if (!this.vData || !this.iData) {
                  this._reallocBuffer();
                }
              }

              request(vertexCount = 4, indicesCount = 6) {
                this.lastByteOffset = this.byteOffset;
                const byteOffset = this.byteOffset + vertexCount * this._vertexFormatBytes;
                const indicesOffset = this.indicesOffset + indicesCount;

                if (vertexCount + this.vertexOffset > 65535) {
                  if (this._outOfCallback) {
                    this._outOfCallback.call(this._batcher, vertexCount, indicesCount);
                  }

                  return false;
                }

                let byteLength = this.vData.byteLength;
                let indicesLength = this.iData.length;

                if (byteOffset > byteLength || indicesOffset > indicesLength) {
                  while (byteLength < byteOffset || indicesLength < indicesOffset) {
                    this._initVDataCount *= 2;
                    this._initIDataCount *= 2;
                    byteLength = this._initVDataCount * 4;
                    indicesLength = this._initIDataCount;
                  }

                  this._reallocBuffer();
                }

                this.vertexOffset += vertexCount;
                this.indicesOffset += indicesCount;
                this.byteOffset = byteOffset;
                this._dirty = true;
                return true;
              }

              reset() {
                this.byteStart = 0;
                this.byteOffset = 0;
                this.indicesStart = 0;
                this.indicesOffset = 0;
                this.vertexStart = 0;
                this.vertexOffset = 0;
                this.lastByteOffset = 0;
                this._nextFreeIAHandle = 0;
                this._dirty = false;
              }

              tryShrink() {
                if (this._dirty || !this.vData || !this.iData) return;

                if (this.vData.byteLength >> 2 > this._lastUsedVDataSize && this.iData.length >> 2 > this._lastUsedIDataSize) {
                  const vDataCount = Math.max(256 * this._vertexFormatBytes, this._initVDataCount >> 1);
                  const iDataCount = Math.max(256 * 6, this._initIDataCount >> 1);

                  if (vDataCount !== this._initVDataCount || iDataCount !== this._initIDataCount) {
                    this._initIDataCount = iDataCount;
                    this._initVDataCount = vDataCount;

                    this._reallocBuffer();
                  }
                }
              }

              destroy() {
                this._attributes = null;
                this.vertexBuffers[0].destroy();
                this.vertexBuffers.length = 0;
                this.indexBuffer.destroy();
                this._indexBuffer = null;

                for (let i = 0; i < this._hInputAssemblers.length; i++) {
                  this._hInputAssemblers[i].destroy();
                }

                this._hInputAssemblers.length = 0;
                super.destroy();
              }

              recordBatch() {
                const vCount = this.indicesOffset - this.indicesStart;

                if (!vCount) {
                  return null;
                }

                if (this._hInputAssemblers.length <= this._nextFreeIAHandle) {
                  this._hInputAssemblers.push(this._batcher.device.createInputAssembler(this._iaInfo));
                }

                const ia = this._hInputAssemblers[this._nextFreeIAHandle++];
                ia.firstIndex = this.indicesStart;
                ia.indexCount = vCount;
                return ia;
              }

              uploadBuffers() {
                if (this.byteOffset === 0 || !this._dirty) {
                  return;
                }

                const verticesData = new Float32Array(this.vData.buffer, 0, this.byteOffset >> 2);
                const indicesData = new Uint16Array(this.iData.buffer, 0, this.indicesOffset);

                if (this.byteOffset > this.vertexBuffers[0].size) {
                  this.vertexBuffers[0].resize(this.byteOffset);
                }

                this.vertexBuffers[0].update(verticesData);

                if (this.indicesOffset * 2 > this.indexBuffer.size) {
                  this.indexBuffer.resize(this.indicesOffset * 2);
                }

                this.indexBuffer.update(indicesData);
                this._lastUsedVDataSize = this.byteOffset;
                this._lastUsedIDataSize = this.indicesOffset;
                this._dirty = false;
              }

              _reallocBuffer() {
                this._reallocVData(true);

                this._reallocIData(true);
              }

              _reallocVData(copyOldData) {
                let oldVData;

                if (this.vData) {
                  oldVData = new Uint8Array(this.vData.buffer);
                }

                this.vData = new Float32Array(this._initVDataCount);

                if (oldVData && copyOldData) {
                  const newData = new Uint8Array(this.vData.buffer);

                  for (let i = 0, l = oldVData.length; i < l; i++) {
                    newData[i] = oldVData[i];
                  }
                }
              }

              _reallocIData(copyOldData) {
                const oldIData = this.iData;
                this.iData = new Uint16Array(this._initIDataCount);

                if (oldIData && copyOldData) {
                  const iData = this.iData;

                  for (let i = 0, l = oldIData.length; i < l; i++) {
                    iData[i] = oldIData[i];
                  }
                }
              }

            } exports('MeshBuffer', MeshBuffer);
            MeshBuffer.OPACITY_OFFSET = 8;

            const UI_VIS_FLAG = Layers.Enum.NONE | Layers.Enum.UI_3D;
            class DrawBatch2D {
              get native() {
                return this._nativeObj;
              }

              get inputAssembler() {
                return this._inputAssember;
              }

              set inputAssembler(ia) {
                this._inputAssember = ia;

                {
                  this._nativeObj.inputAssembler = ia;
                }
              }

              get descriptorSet() {
                return this._descriptorSet;
              }

              set descriptorSet(ds) {
                this._descriptorSet = ds;

                {
                  this._nativeObj.descriptorSet = ds;
                }
              }

              get visFlags() {
                return this._visFlags;
              }

              set visFlags(vis) {
                this._visFlags = vis;

                {
                  this._nativeObj.visFlags = vis;
                }
              }

              get passes() {
                return this._passes;
              }

              get shaders() {
                return this._shaders;
              }

              constructor() {
                this.bufferBatch = null;
                this.camera = null;
                this.renderScene = null;
                this.model = null;
                this.texture = null;
                this.sampler = null;
                this.useLocalData = null;
                this.isStatic = false;
                this.textureHash = 0;
                this.samplerHash = 0;
                this._passes = [];
                this._shaders = [];
                this._visFlags = UI_VIS_FLAG;
                this._inputAssember = null;
                this._descriptorSet = null;

                {
                  this._nativeObj = new NativeDrawBatch2D();
                  // this._nativeObj.visFlags = this._visFlags; // TODO
                }
              }

              destroy(ui) {
                this._passes = [];

                {
                  this._nativeObj = null;
                }
              }

              clear() {
                this.bufferBatch = null;
                this.inputAssembler = null;
                this.descriptorSet = null;
                this.camera = null;
                this.texture = null;
                this.sampler = null;
                this.model = null;
                this.isStatic = false;
                this.useLocalData = null;
                this.visFlags = UI_VIS_FLAG;
                this.renderScene = null;
              }

              fillPasses(mat, dss, dssHash, bs, bsHash, patches, batcher) {
                if (mat) {
                  const passes = mat.passes;

                  if (!passes) {
                    return;
                  }

                  let hashFactor = 0;
                  let dirty = false;
                  this._shaders.length = passes.length;

                  for (let i = 0; i < passes.length; i++) {
                    if (!this._passes[i]) {
                      this._passes[i] = new Pass(legacyCC.director.root);
                    }

                    const mtlPass = passes[i];
                    const passInUse = this._passes[i];
                    mtlPass.update();

                    if (!dss) {
                      dss = mtlPass.depthStencilState;
                      dssHash = 0;
                    }

                    if (!bs) {
                      bs = mtlPass.blendState;
                      bsHash = 0;
                    }

                    if (bsHash === -1) {
                      bsHash = 0;
                    }

                    hashFactor = dssHash << 16 | bsHash;

                    passInUse._initPassFromTarget(mtlPass, dss, bs, hashFactor);

                    this._shaders[i] = passInUse.getShaderVariant(patches);
                    dirty = true;
                  }

                  {
                    if (dirty) {
                      const nativePasses = [];
                      const passes = this._passes;

                      for (let i = 0; i < passes.length; i++) {
                        nativePasses.push(passes[i].native);
                      }

                      this._nativeObj.passes = nativePasses;
                      this._nativeObj.shaders = this._shaders;
                    }
                  }
                }
              }

            } exports('UIDrawBatch', DrawBatch2D);

            var _dec$q, _dec2$l, _dec3$k, _dec4$j, _dec5$h, _class$q, _class2$k, _temp$n;
            let UIStaticBatch = function (v) { return exports({ UIStaticBatch: v, UIStaticBatchComponent: v }), v; }((_dec$q = ccclass('cc.UIStaticBatch'), _dec2$l = help(), _dec3$k = menu$1(), _dec4$j = executionOrder(110), _dec5$h = visible(), _dec$q(_class$q = _dec2$l(_class$q = _dec3$k(_class$q = _dec4$j(_class$q = (_class2$k = (_temp$n = class UIStaticBatch extends Renderable2D {
              constructor(...args) {
                super(...args);
                this._init = false;
                this._meshBuffer = null;
                this._dirty = true;
                this._lastMeshBuffer = null;
                this._uiDrawBatchList = [];
              }

              get color() {
                return this._color;
              }

              set color(value) {
                if (this._color === value) {
                  return;
                }

                this._color.set(value);
              }

              get drawBatchList() {
                return this._uiDrawBatchList;
              }

              onLoad() {
                const ui = this._getBatcher();

                if (!ui) {
                  return;
                }
                const attr = vfmtPosUvColor;
                const buffer = new MeshBuffer(ui);
                buffer.initialize(attr, this._arrivalMaxBuffer.bind(this));
                this._meshBuffer = buffer;
              }

              onDestroy() {
                super.onDestroy();

                this._clearData();

                if (this._meshBuffer) {
                  this._meshBuffer.destroy();

                  this._meshBuffer = null;
                }
              }

              updateAssembler(render) {
                render.currIsStatic = true;

                if (this._dirty) {
                  render.finishMergeBatches();
                  this._lastMeshBuffer = render.currBufferBatch;
                  render.currBufferBatch = this._meshBuffer;
                  render.currStaticRoot = this;
                }

                if (this._init) {
                  render.finishMergeBatches();
                  render.commitStaticBatch(this);
                }
              }

              postUpdateAssembler(render) {

                if (this._dirty) {
                  render.finishMergeBatches();
                  render.currBufferBatch = this._lastMeshBuffer;
                  render.currStaticRoot = null;
                  this._dirty = false;
                  this._init = true;
                  this.node._static = true;

                  this._meshBuffer.uploadBuffers();
                }

                render.currIsStatic = false;
              }

              markAsDirty() {

                if (!this._getBatcher()) {
                  return;
                }

                this.node._static = false;
                this._dirty = true;
                this._init = false;

                this._clearData();
              }

              _requireDrawBatch() {
                const batch = new DrawBatch2D();
                batch.isStatic = true;

                this._uiDrawBatchList.push(batch);

                return batch;
              }

              _clearData() {
                if (this._meshBuffer) {
                  this._meshBuffer.reset();

                  const ui = this._getBatcher();

                  for (let i = 0; i < this._uiDrawBatchList.length; i++) {
                    const element = this._uiDrawBatchList[i];
                    element.destroy(ui);
                  }
                }

                this._uiDrawBatchList.length = 0;
                this._init = false;
              }

              _getBatcher() {
                if (director.root && director.root.batcher2D) {
                  return director.root.batcher2D;
                }

                warnID(9301);
                return null;
              }

              _arrivalMaxBuffer() {
                const ui = this._getBatcher();

                if (ui) {
                  ui.autoMergeBatches();
                }

                warnID(9300);
              }

            }, _temp$n), (_applyDecoratedDescriptor(_class2$k.prototype, "color", [override, _dec5$h], Object.getOwnPropertyDescriptor(_class2$k.prototype, "color"), _class2$k.prototype)), _class2$k)) || _class$q) || _class$q) || _class$q) || _class$q));

            var _dec$r, _dec2$m, _dec3$l, _dec4$k, _dec5$i, _dec6$g, _dec7$g, _dec8$e, _class$r, _class2$l, _descriptor$k, _descriptor2$i, _descriptor3$d, _temp$o;
            let LabelShadow = exports('LabelShadow', (_dec$r = ccclass('cc.LabelShadow'), _dec2$m = help(), _dec3$l = executionOrder(110), _dec4$k = menu$1(), _dec5$i = requireComponent(Label), _dec6$g = tooltip(), _dec7$g = tooltip(), _dec8$e = tooltip(), _dec$r(_class$r = _dec2$m(_class$r = _dec3$l(_class$r = _dec4$k(_class$r = _dec5$i(_class$r = executeInEditMode(_class$r = (_class2$l = (_temp$o = class LabelShadow extends Component {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "_color", _descriptor$k, this);

                _initializerDefineProperty(this, "_offset", _descriptor2$i, this);

                _initializerDefineProperty(this, "_blur", _descriptor3$d, this);
              }

              get color() {
                return this._color;
              }

              set color(value) {
                if (this._color === value) {
                  return;
                }

                this._color.set(value);

                this._updateRenderData();
              }

              get offset() {
                return this._offset;
              }

              set offset(value) {
                this._offset = value;

                this._updateRenderData();
              }

              get blur() {
                return this._blur;
              }

              set blur(value) {
                this._blur = value;

                this._updateRenderData();
              }

              onEnable() {
                this._updateRenderData();
              }

              onDisable() {
                this._updateRenderData();
              }

              _updateRenderData() {
                const label = this.node.getComponent(Label);

                if (label) {
                  label.updateRenderData(true);
                }
              }

            }, _temp$o), (_descriptor$k = _applyDecoratedDescriptor(_class2$l.prototype, "_color", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Color$1(0, 0, 0, 255);
              }
            }), _descriptor2$i = _applyDecoratedDescriptor(_class2$l.prototype, "_offset", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec2(2, 2);
              }
            }), _descriptor3$d = _applyDecoratedDescriptor(_class2$l.prototype, "_blur", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 2;
              }
            }), _applyDecoratedDescriptor(_class2$l.prototype, "color", [_dec6$g], Object.getOwnPropertyDescriptor(_class2$l.prototype, "color"), _class2$l.prototype), _applyDecoratedDescriptor(_class2$l.prototype, "offset", [_dec7$g], Object.getOwnPropertyDescriptor(_class2$l.prototype, "offset"), _class2$l.prototype), _applyDecoratedDescriptor(_class2$l.prototype, "blur", [_dec8$e], Object.getOwnPropertyDescriptor(_class2$l.prototype, "blur"), _class2$l.prototype)), _class2$l)) || _class$r) || _class$r) || _class$r) || _class$r) || _class$r) || _class$r));

            var _dec$s, _dec2$n, _dec3$m, _dec4$l, _dec5$j, _class$s, _class2$m, _descriptor$l, _temp$p;
            let UIOpacity = function (v) { return exports({ UIOpacity: v, UIOpacityComponent: v }), v; }((_dec$s = ccclass('cc.UIOpacity'), _dec2$n = help(), _dec3$m = executionOrder(110), _dec4$l = menu$1(), _dec5$j = tooltip(), _dec$s(_class$s = _dec2$n(_class$s = _dec3$m(_class$s = _dec4$l(_class$s = executeInEditMode(_class$s = (_class2$m = (_temp$p = class UIOpacity extends Component {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "_opacity", _descriptor$l, this);
              }

              get opacity() {
                return this._opacity;
              }

              set opacity(value) {
                if (this._opacity === value) {
                  return;
                }

                value = clampf(value, 0, 255);
                this._opacity = value;
                this.node._uiProps.localOpacity = value / 255;
              }

              onEnable() {
                this.node._uiProps.localOpacity = this._opacity / 255;
              }

              onDisable() {
                this.node._uiProps.localOpacity = 1;
              }

            }, _temp$p), (_applyDecoratedDescriptor(_class2$m.prototype, "opacity", [editable, _dec5$j], Object.getOwnPropertyDescriptor(_class2$m.prototype, "opacity"), _class2$m.prototype), _descriptor$l = _applyDecoratedDescriptor(_class2$m.prototype, "_opacity", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 255;
              }
            })), _class2$m)) || _class$s) || _class$s) || _class$s) || _class$s) || _class$s));

            legacyCC.MaskComponent = Mask;
            js.setClassAlias(Mask, 'cc.MaskComponent');
            legacyCC.LabelComponent = Label;
            js.setClassAlias(Label, 'cc.LabelComponent');
            legacyCC.LabelOutlineComponent = LabelOutline;
            js.setClassAlias(LabelOutline, 'cc.LabelOutlineComponent');
            legacyCC.RichTextComponent = RichText;
            js.setClassAlias(RichText, 'cc.RichTextComponent');
            legacyCC.SpriteComponent = Sprite;
            js.setClassAlias(Sprite, 'cc.SpriteComponent');
            legacyCC.UIModelComponent = UIMeshRenderer;
            js.setClassAlias(UIMeshRenderer, 'cc.UIModelComponent');
            legacyCC.GraphicsComponent = Graphics;
            js.setClassAlias(Graphics, 'cc.GraphicsComponent');
            js.setClassAlias(UIStaticBatch, 'cc.UIStaticBatchComponent');
            js.setClassAlias(UIOpacity, 'cc.UIOpacityComponent');

            class Aim {
              constructor(i, x, y) {
                this.i = void 0;
                this.x = void 0;
                this.y = void 0;
                this.prev = null;
                this.next = null;
                this.z = 0;
                this.prevZ = null;
                this.nextZ = null;
                this.steiner = false;
                this.i = i;
                this.x = x;
                this.y = y;
              }

            }

            function linkedList(datas, start, end, dim, clockwise) {
              let i = 0;
              let last = null;

              if (clockwise === signedArea(datas, start, end, dim) > 0) {
                for (i = start; i < end; i += dim) {
                  last = insertNode(i, datas[i], datas[i + 1], last);
                }
              } else {
                for (i = end - dim; i >= start; i -= dim) {
                  last = insertNode(i, datas[i], datas[i + 1], last);
                }
              }

              if (last && equals(last, last.next)) {
                removeNode(last);
                last = last.next;
              }

              return last;
            }

            function filterPoints(start, end = null) {
              if (!start) {
                return start;
              }

              if (!end) {
                end = start;
              }

              let p = start;
              let again = false;

              do {
                again = false;

                if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
                  removeNode(p);
                  p = end = p.prev;

                  if (p === p.next) {
                    return null;
                  }

                  again = true;
                } else {
                  p = p.next;
                }
              } while (again || p !== end);

              return end;
            }

            function earcutLinked(ear, triangles, dim, minX, minY, size, pass = 0) {
              if (!ear) {
                return;
              }

              if (!pass && size) {
                indexCurve(ear, minX, minY, size);
              }

              let stop = ear;
              let prev = null;
              let next = null;

              while (ear.prev !== ear.next) {
                prev = ear.prev;
                next = ear.next;

                if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {
                  triangles.push(prev.i / dim);
                  triangles.push(ear.i / dim);
                  triangles.push(next.i / dim);
                  removeNode(ear);
                  ear = next.next;
                  stop = next.next;
                  continue;
                }

                ear = next;

                if (ear === stop) {
                  if (!pass) {
                    earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);
                  } else if (pass === 1) {
                    ear = cureLocalIntersections(ear, triangles, dim);
                    earcutLinked(ear, triangles, dim, minX, minY, size, 2);
                  } else if (pass === 2) {
                    splitEarcut(ear, triangles, dim, minX, minY, size);
                  }

                  break;
                }
              }
            }

            function isEar(ear) {
              const a = ear.prev;
              const b = ear;
              const c = ear.next;

              if (area(a, b, c) >= 0) {
                return false;
              }

              let p = ear.next.next;

              while (p !== ear.prev) {
                if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) {
                  return false;
                }

                p = p.next;
              }

              return true;
            }

            function isEarHashed(ear, minX, minY, size) {
              const a = ear.prev;
              const b = ear;
              const c = ear.next;

              if (area(a, b, c) >= 0) {
                return false;
              }

              const minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x;
              const minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y;
              const maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x;
              const maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
              const minZ = zOrder(minTX, minTY, minX, minY, size);
              const maxZ = zOrder(maxTX, maxTY, minX, minY, size);
              let p = ear.nextZ;

              while (p && p.z <= maxZ) {
                if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) {
                  return false;
                }

                p = p.nextZ;
              }

              p = ear.prevZ;

              while (p && p.z >= minZ) {
                if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) {
                  return false;
                }

                p = p.prevZ;
              }

              return true;
            }

            function cureLocalIntersections(start, triangles, dim) {
              let p = start;

              do {
                const a = p.prev;
                const b = p.next.next;

                if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
                  triangles.push(a.i / dim);
                  triangles.push(p.i / dim);
                  triangles.push(b.i / dim);
                  removeNode(p);
                  removeNode(p.next);
                  p = start = b;
                }

                p = p.next;
              } while (p !== start);

              return p;
            }

            function splitEarcut(start, triangles, dim, minX, minY, size) {
              let a = start;

              do {
                let b = a.next.next;

                while (b !== a.prev) {
                  if (a.i !== b.i && isValidDiagonal(a, b)) {
                    let c = splitPolygon(a, b);
                    a = filterPoints(a, a.next);
                    c = filterPoints(c, c.next);
                    earcutLinked(a, triangles, dim, minX, minY, size);
                    earcutLinked(c, triangles, dim, minX, minY, size);
                    return;
                  }

                  b = b.next;
                }

                a = a.next;
              } while (a !== start);
            }

            function eliminateHoles(datas, holeIndices, outerNode, dim) {
              const queue = [];
              let i = 0;
              let len = 0;
              let start = 0;
              let end = 0;
              let list = null;

              for (i = 0, len = holeIndices.length; i < len; i++) {
                start = holeIndices[i] * dim;
                end = i < len - 1 ? holeIndices[i + 1] * dim : datas.length;
                list = linkedList(datas, start, end, dim, false);

                if (!list) {
                  continue;
                }

                if (list === list.next) {
                  list.steiner = true;
                }

                queue.push(getLeftmost(list));
              }

              queue.sort(compareX);

              if (!outerNode) {
                return outerNode;
              }

              for (i = 0; i < queue.length; i++) {
                eliminateHole(queue[i], outerNode);
                outerNode = filterPoints(outerNode, outerNode.next);
              }

              return outerNode;
            }

            function compareX(a, b) {
              return a.x - b.x;
            }

            function eliminateHole(hole, outerNode) {
              outerNode = findHoleBridge(hole, outerNode);

              if (outerNode) {
                const b = splitPolygon(outerNode, hole);
                filterPoints(b, b.next);
              }
            }

            function findHoleBridge(hole, outerNode) {
              let p = outerNode;
              const hx = hole.x;
              const hy = hole.y;
              let qx = -Infinity;
              let m = null;

              do {
                if (hy <= p.y && hy >= p.next.y) {
                  const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);

                  if (x <= hx && x > qx) {
                    qx = x;

                    if (x === hx) {
                      if (hy === p.y) {
                        return p;
                      }

                      if (hy === p.next.y) {
                        return p.next;
                      }
                    }

                    m = p.x < p.next.x ? p : p.next;
                  }
                }

                p = p.next;
              } while (p !== outerNode);

              if (!m) {
                return null;
              }

              if (hx === qx) {
                return m.prev;
              }

              const stop = m;
              const mx = m.x;
              const my = m.y;
              let tanMin = Infinity;
              let tan;
              p = m.next;

              while (p !== stop) {
                if (hx >= p.x && p.x >= mx && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
                  tan = Math.abs(hy - p.y) / (hx - p.x);

                  if ((tan < tanMin || tan === tanMin && p.x > m.x) && locallyInside(p, hole)) {
                    m = p;
                    tanMin = tan;
                  }
                }

                p = p.next;
              }

              return m;
            }

            function indexCurve(start, minX, minY, size) {
              let p = start;

              do {
                if (p.z === null) {
                  p.z = zOrder(p.x, p.y, minX, minY, size);
                }

                p.prevZ = p.prev;
                p.nextZ = p.next;
                p = p.next;
              } while (p !== start);

              p.prevZ.nextZ = null;
              p.prevZ = null;
              sortLinked(p);
            }

            function sortLinked(list) {
              let i = 0;
              let p = null;
              let q = null;
              let e = null;
              let tail = null;
              let numMerges = 0;
              let pSize = 0;
              let qSize = 0;
              let inSize = 1;

              do {
                p = list;
                list = null;
                tail = null;
                numMerges = 0;

                while (p) {
                  numMerges++;
                  q = p;
                  pSize = 0;

                  for (i = 0; i < inSize; i++) {
                    pSize++;
                    q = q.nextZ;

                    if (!q) {
                      break;
                    }
                  }

                  qSize = inSize;

                  while (pSize > 0 || qSize > 0 && q) {
                    if (pSize === 0) {
                      e = q;
                      q = q.nextZ;
                      qSize--;
                    } else if (qSize === 0 || !q) {
                      e = p;
                      p = p.nextZ;
                      pSize--;
                    } else if (p.z <= q.z) {
                      e = p;
                      p = p.nextZ;
                      pSize--;
                    } else {
                      e = q;
                      q = q.nextZ;
                      qSize--;
                    }

                    if (tail) {
                      tail.nextZ = e;
                    } else {
                      list = e;
                    }

                    e.prevZ = tail;
                    tail = e;
                  }

                  p = q;
                }

                tail.nextZ = null;
                inSize *= 2;
              } while (numMerges > 1);

              return list;
            }

            function zOrder(x, y, minX, minY, size) {
              x = 32767 * (x - minX) / size;
              y = 32767 * (y - minY) / size;
              x = (x | x << 8) & 0x00FF00FF;
              x = (x | x << 4) & 0x0F0F0F0F;
              x = (x | x << 2) & 0x33333333;
              x = (x | x << 1) & 0x55555555;
              y = (y | y << 8) & 0x00FF00FF;
              y = (y | y << 4) & 0x0F0F0F0F;
              y = (y | y << 2) & 0x33333333;
              y = (y | y << 1) & 0x55555555;
              return x | y << 1;
            }

            function getLeftmost(start) {
              let p = start;
              let leftmost = start;

              do {
                if (p.x < leftmost.x) {
                  leftmost = p;
                }

                p = p.next;
              } while (p !== start);

              return leftmost;
            }

            function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
              return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
            }

            function isValidDiagonal(a, b) {
              return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
            }

            function area(p, q, r) {
              return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
            }

            function equals(p1, p2) {
              return p1.x === p2.x && p1.y === p2.y;
            }

            function intersects(p1, q1, p2, q2) {
              if (equals(p1, q1) && equals(p2, q2) || equals(p1, q2) && equals(p2, q1)) {
                return true;
              }

              return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 && area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
            }

            function intersectsPolygon(a, b) {
              let p = a;

              do {
                if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) {
                  return true;
                }

                p = p.next;
              } while (p !== a);

              return false;
            }

            function locallyInside(a, b) {
              return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
            }

            function middleInside(a, b) {
              let p = a;
              let inside = false;
              const px = (a.x + b.x) / 2;
              const py = (a.y + b.y) / 2;

              do {
                if (p.y > py !== p.next.y > py && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) {
                  inside = !inside;
                }

                p = p.next;
              } while (p !== a);

              return inside;
            }

            function splitPolygon(a, b) {
              const a2 = new Aim(a.i, a.x, a.y);
              const b2 = new Aim(b.i, b.x, b.y);
              const an = a.next;
              const bp = b.prev;
              a.next = b;
              b.prev = a;
              a2.next = an;
              an.prev = a2;
              b2.next = a2;
              a2.prev = b2;
              bp.next = b2;
              b2.prev = bp;
              return b2;
            }

            function insertNode(i, x, y, last) {
              const p = new Aim(i, x, y);

              if (!last) {
                p.prev = p;
                p.next = p;
              } else {
                p.next = last.next;
                p.prev = last;
                last.next.prev = p;
                last.next = p;
              }

              return p;
            }

            function removeNode(p) {
              p.next.prev = p.prev;
              p.prev.next = p.next;

              if (p.prevZ) {
                p.prevZ.nextZ = p.nextZ;
              }

              if (p.nextZ) {
                p.nextZ.prevZ = p.prevZ;
              }
            }

            function signedArea(datas, start, end, dim) {
              let sum = 0;

              for (let i = start, j = end - dim; i < end; i += dim) {
                sum += (datas[j] - datas[i]) * (datas[i + 1] + datas[j + 1]);
                j = i;
              }

              return sum;
            }

            function earcut(datas, holeIndices, dim) {
              dim = dim || 3;
              const hasHoles = holeIndices ? holeIndices.length : 0;
              const outerLen = hasHoles ? holeIndices[0] * dim : datas.length;
              let outerNode = linkedList(datas, 0, outerLen, dim, true);
              const triangles = [];

              if (!outerNode) {
                return triangles;
              }

              let minX = 0;
              let minY = 0;
              let maxX = 0;
              let maxY = 0;
              let x = 0;
              let y = 0;
              let size = 0;

              if (hasHoles) {
                outerNode = eliminateHoles(datas, holeIndices, outerNode, dim);
              }

              if (datas.length > 80 * dim) {
                minX = maxX = datas[0];
                minY = maxY = datas[1];

                for (let i = dim; i < outerLen; i += dim) {
                  x = datas[i];
                  y = datas[i + 1];

                  if (x < minX) {
                    minX = x;
                  }

                  if (y < minY) {
                    minY = y;
                  }

                  if (x > maxX) {
                    maxX = x;
                  }

                  if (y > maxY) {
                    maxY = y;
                  }
                }

                size = Math.max(maxX - minX, maxY - minY);
              }

              earcutLinked(outerNode, triangles, dim, minX, minY, size);
              return triangles;
            }

            const MAX_VERTEX = 65535;
            const MAX_INDICES = MAX_VERTEX * 2;
            const PI$1 = Math.PI;
            const min$1 = Math.min;
            const max$1 = Math.max;
            const ceil = Math.ceil;
            const acos = Math.acos;
            const cos$1 = Math.cos;
            const sin$1 = Math.sin;
            const atan2 = Math.atan2;
            const attrBytes = 8;
            let _renderData = null;
            let _impl = null;

            const _curColor = new Color$1();

            const vec3_temps = [];

            for (let i = 0; i < 4; i++) {
              vec3_temps.push(new Vec3());
            }

            function curveDivs(r, arc, tol) {
              const da = acos(r / (r + tol)) * 2.0;
              return max$1(2, ceil(arc / da));
            }

            function clamp(v, minNum, maxNum) {
              if (v < minNum) {
                return minNum;
              } else if (v > maxNum) {
                return maxNum;
              }

              return v;
            }

            const graphicsAssembler = {
              useModel: true,

              updateRenderData(graphics) {},

              fillBuffers(graphics, renderer) {},

              renderIA(graphics, renderer) {},

              getRenderData(graphics, vertexCount) {
                if (!_impl) {
                  return null;
                }

                const renderDataList = _impl.getRenderDataList();

                let renderData = renderDataList[_impl.dataOffset];

                if (!renderData) {
                  return null;
                }

                let meshBuffer = renderData;
                const maxVertexCount = meshBuffer ? meshBuffer.vertexStart + vertexCount : 0;

                if (maxVertexCount > MAX_VERTEX || maxVertexCount * 3 > MAX_INDICES) {
                  ++_impl.dataOffset;

                  if (_impl.dataOffset < renderDataList.length) {
                    renderData = renderDataList[_impl.dataOffset];
                  } else {
                    renderData = _impl.requestRenderData();
                    renderDataList[_impl.dataOffset] = renderData;
                  }

                  meshBuffer = renderData;
                }

                if (meshBuffer && meshBuffer.vertexCount < maxVertexCount) {
                  meshBuffer.request(vertexCount, vertexCount * 3);
                }

                return renderData;
              },

              stroke(graphics) {
                Color$1.copy(_curColor, graphics.strokeColor);

                if (!graphics.impl) {
                  return;
                }

                this._flattenPaths(graphics.impl);

                this._expandStroke(graphics);

                graphics.impl.updatePathOffset = true;
                this.end(graphics);
              },

              fill(graphics) {
                Color$1.copy(_curColor, graphics.fillColor);

                this._expandFill(graphics);

                if (graphics.impl) {
                  graphics.impl.updatePathOffset = true;
                }

                this.end(graphics);
              },

              end(graphics) {
                graphics.markForUpdateRenderData();
              },

              _expandStroke(graphics) {
                const w = graphics.lineWidth * 0.5;
                const lineCap = graphics.lineCap;
                const lineJoin = graphics.lineJoin;
                const miterLimit = graphics.miterLimit;
                _impl = graphics.impl;

                if (!_impl) {
                  return;
                }

                const nCap = curveDivs(w, PI$1, _impl.tessTol);

                this._calculateJoins(_impl, w, lineJoin, miterLimit);

                const paths = _impl.paths;
                let vertexCount = 0;

                for (let i = _impl.pathOffset, l = _impl.pathLength; i < l; i++) {
                  const path = paths[i];
                  const pointsLength = path.points.length;

                  if (lineJoin === LineJoin.ROUND) {
                    vertexCount += (pointsLength + path.bevel * (nCap + 2) + 1) * 2;
                  } else {
                    vertexCount += (pointsLength + path.bevel * 5 + 1) * 2;
                  }

                  if (!path.closed) {
                    if (lineCap === LineCap.ROUND) {
                      vertexCount += (nCap * 2 + 2) * 2;
                    } else {
                      vertexCount += (3 + 3) * 2;
                    }
                  }
                }

                const meshBuffer = _renderData = this.getRenderData(graphics, vertexCount);

                if (!meshBuffer) {
                  return;
                }

                const vData = meshBuffer.vData;
                const iData = meshBuffer.iData;

                for (let i = _impl.pathOffset, l = _impl.pathLength; i < l; i++) {
                  const path = paths[i];
                  const pts = path.points;
                  const pointsLength = pts.length;
                  const offset = meshBuffer.vertexStart;
                  let p0;
                  let p1;
                  let start = 0;
                  let end = 0;
                  const loop = path.closed;

                  if (loop) {
                    p0 = pts[pointsLength - 1];
                    p1 = pts[0];
                    start = 0;
                    end = pointsLength;
                  } else {
                    p0 = pts[0];
                    p1 = pts[1];
                    start = 1;
                    end = pointsLength - 1;
                  }

                  p1 = p1 || p0;

                  if (!loop) {
                    const dPos = new Point(p1.x, p1.y);
                    dPos.subtract(p0);
                    dPos.normalize();
                    const dx = dPos.x;
                    const dy = dPos.y;

                    if (lineCap === LineCap.BUTT) {
                      this._buttCapStart(p0, dx, dy, w, 0);
                    } else if (lineCap === LineCap.SQUARE) {
                      this._buttCapStart(p0, dx, dy, w, w);
                    } else if (lineCap === LineCap.ROUND) {
                      this._roundCapStart(p0, dx, dy, w, nCap);
                    }
                  }

                  for (let j = start; j < end; ++j) {
                    if (lineJoin === LineJoin.ROUND) {
                      this._roundJoin(p0, p1, w, w, nCap);
                    } else if ((p1.flags & (PointFlags.PT_BEVEL | PointFlags.PT_INNERBEVEL)) !== 0) {
                      this._bevelJoin(p0, p1, w, w);
                    } else {
                      this._vSet(p1.x + p1.dmx * w, p1.y + p1.dmy * w, 1);

                      this._vSet(p1.x - p1.dmx * w, p1.y - p1.dmy * w, -1);
                    }

                    p0 = p1;
                    p1 = pts[j + 1];
                  }

                  if (loop) {
                    const vDataOffset = offset * attrBytes;

                    this._vSet(vData[vDataOffset], vData[vDataOffset + 1], 1);

                    this._vSet(vData[vDataOffset + attrBytes], vData[vDataOffset + attrBytes + 1], -1);
                  } else {
                    const dPos = new Point(p1.x, p1.y);
                    dPos.subtract(p0);
                    dPos.normalize();
                    const dx = dPos.x;
                    const dy = dPos.y;

                    if (lineCap === LineCap.BUTT) {
                      this._buttCapEnd(p1, dx, dy, w, 0);
                    } else if (lineCap === LineCap.SQUARE) {
                      this._buttCapEnd(p1, dx, dy, w, w);
                    } else if (lineCap === LineCap.ROUND) {
                      this._roundCapEnd(p1, dx, dy, w, nCap);
                    }
                  }

                  let indicesOffset = meshBuffer.indicesStart;

                  for (let begin = offset + 2, over = meshBuffer.vertexStart; begin < over; begin++) {
                    iData[indicesOffset++] = begin - 2;
                    iData[indicesOffset++] = begin - 1;
                    iData[indicesOffset++] = begin;
                  }

                  meshBuffer.indicesStart = indicesOffset;
                }

                _renderData = null;
                _impl = null;
              },

              _expandFill(graphics) {
                _impl = graphics.impl;

                if (!_impl) {
                  return;
                }

                const paths = _impl.paths;
                let vertexCount = 0;

                for (let i = _impl.pathOffset, l = _impl.pathLength; i < l; i++) {
                  const path = paths[i];
                  const pointsLength = path.points.length;
                  vertexCount += pointsLength;
                }

                const renderData = _renderData = this.getRenderData(graphics, vertexCount);

                if (!renderData) {
                  return;
                }

                const meshBuffer = renderData;
                const vData = meshBuffer.vData;
                const iData = meshBuffer.iData;

                for (let i = _impl.pathOffset, l = _impl.pathLength; i < l; i++) {
                  const path = paths[i];
                  const pts = path.points;
                  const pointsLength = pts.length;

                  if (pointsLength === 0) {
                    continue;
                  }

                  const vertexOffset = renderData.vertexStart;

                  for (let j = 0; j < pointsLength; ++j) {
                    this._vSet(pts[j].x, pts[j].y);
                  }

                  let indicesOffset = renderData.indicesStart;

                  if (path.complex) {
                    const earcutData = [];

                    for (let j = vertexOffset, end = renderData.vertexStart; j < end; j++) {
                      let vDataOffset = j * attrBytes;
                      earcutData.push(vData[vDataOffset++]);
                      earcutData.push(vData[vDataOffset++]);
                      earcutData.push(vData[vDataOffset++]);
                    }

                    const newIndices = earcut(earcutData, null, 3);

                    if (!newIndices || newIndices.length === 0) {
                      continue;
                    }

                    for (let j = 0, nIndices = newIndices.length; j < nIndices; j++) {
                      iData[indicesOffset++] = newIndices[j] + vertexOffset;
                    }
                  } else {
                    const first = vertexOffset;

                    for (let start = vertexOffset + 2, end = meshBuffer.vertexStart; start < end; start++) {
                      iData[indicesOffset++] = first;
                      iData[indicesOffset++] = start - 1;
                      iData[indicesOffset++] = start;
                    }
                  }

                  meshBuffer.indicesStart = indicesOffset;
                }

                _renderData = null;
                _impl = null;
              },

              _calculateJoins(impl, w, lineJoin, miterLimit) {
                let iw = 0.0;

                if (w > 0.0) {
                  iw = 1 / w;
                }

                const paths = impl.paths;

                for (let i = impl.pathOffset, l = impl.pathLength; i < l; i++) {
                  const path = paths[i];
                  const pts = path.points;
                  const ptsLength = pts.length;
                  let p0 = pts[ptsLength - 1];
                  let p1 = pts[0];
                  path.bevel = 0;

                  for (let j = 0; j < ptsLength; j++) {
                    let dmr2 = 0;
                    let cross = 0;
                    let limit = 0;
                    const dlx0 = p0.dy;
                    const dly0 = -p0.dx;
                    const dlx1 = p1.dy;
                    const dly1 = -p1.dx;
                    p1.dmx = (dlx0 + dlx1) * 0.5;
                    p1.dmy = (dly0 + dly1) * 0.5;
                    dmr2 = p1.dmx * p1.dmx + p1.dmy * p1.dmy;

                    if (dmr2 > 0.000001) {
                      let scale = 1 / dmr2;

                      if (scale > 600) {
                        scale = 600;
                      }

                      p1.dmx *= scale;
                      p1.dmy *= scale;
                    }

                    cross = p1.dx * p0.dy - p0.dx * p1.dy;

                    if (cross > 0) {
                      p1.flags |= PointFlags.PT_LEFT;
                    }

                    limit = max$1(11, min$1(p0.len, p1.len) * iw);

                    if (dmr2 * limit * limit < 1) {
                      p1.flags |= PointFlags.PT_INNERBEVEL;
                    }

                    if (p1.flags & PointFlags.PT_CORNER) {
                      if (dmr2 * miterLimit * miterLimit < 1 || lineJoin === LineJoin.BEVEL || lineJoin === LineJoin.ROUND) {
                        p1.flags |= PointFlags.PT_BEVEL;
                      }
                    }

                    if ((p1.flags & (PointFlags.PT_BEVEL | PointFlags.PT_INNERBEVEL)) !== 0) {
                      path.bevel++;
                    }

                    p0 = p1;
                    p1 = pts[j + 1];
                  }
                }
              },

              _flattenPaths(impl) {
                const paths = impl.paths;

                for (let i = impl.pathOffset, l = impl.pathLength; i < l; i++) {
                  const path = paths[i];
                  const pts = path.points;
                  let p0 = pts[pts.length - 1];
                  let p1 = pts[0];

                  if (pts.length > 2 && p0.equals(p1)) {
                    path.closed = true;
                    pts.pop();
                    p0 = pts[pts.length - 1];
                  }

                  for (let j = 0, size = pts.length; j < size; j++) {
                    const dPos = new Point(p1.x, p1.y);
                    dPos.subtract(p0);
                    p0.len = dPos.length();

                    if (dPos.x || dPos.y) {
                      dPos.normalize();
                    }

                    p0.dx = dPos.x;
                    p0.dy = dPos.y;
                    p0 = p1;
                    p1 = pts[j + 1];
                  }
                }
              },

              _chooseBevel(bevel, p0, p1, w) {
                const x = p1.x;
                const y = p1.y;
                let x0 = 0;
                let y0 = 0;
                let x1 = 0;
                let y1 = 0;

                if (bevel !== 0) {
                  x0 = x + p0.dy * w;
                  y0 = y - p0.dx * w;
                  x1 = x + p1.dy * w;
                  y1 = y - p1.dx * w;
                } else {
                  x0 = x1 = x + p1.dmx * w;
                  y0 = y1 = y + p1.dmy * w;
                }

                return [x0, y0, x1, y1];
              },

              _buttCapStart(p, dx, dy, w, d) {
                const px = p.x - dx * d;
                const py = p.y - dy * d;
                const dlx = dy;
                const dly = -dx;

                this._vSet(px + dlx * w, py + dly * w, 1);

                this._vSet(px - dlx * w, py - dly * w, -1);
              },

              _buttCapEnd(p, dx, dy, w, d) {
                const px = p.x + dx * d;
                const py = p.y + dy * d;
                const dlx = dy;
                const dly = -dx;

                this._vSet(px + dlx * w, py + dly * w, 1);

                this._vSet(px - dlx * w, py - dly * w, -1);
              },

              _roundCapStart(p, dx, dy, w, nCap) {
                const px = p.x;
                const py = p.y;
                const dlx = dy;
                const dly = -dx;

                for (let i = 0; i < nCap; i++) {
                  const a = i / (nCap - 1) * PI$1;
                  const ax = cos$1(a) * w;
                  const ay = sin$1(a) * w;

                  this._vSet(px - dlx * ax - dx * ay, py - dly * ax - dy * ay, 1);

                  this._vSet(px, py, 0);
                }

                this._vSet(px + dlx * w, py + dly * w, 1);

                this._vSet(px - dlx * w, py - dly * w, -1);
              },

              _roundCapEnd(p, dx, dy, w, nCap) {
                const px = p.x;
                const py = p.y;
                const dlx = dy;
                const dly = -dx;

                this._vSet(px + dlx * w, py + dly * w, 1);

                this._vSet(px - dlx * w, py - dly * w, -1);

                for (let i = 0; i < nCap; i++) {
                  const a = i / (nCap - 1) * PI$1;
                  const ax = cos$1(a) * w;
                  const ay = sin$1(a) * w;

                  this._vSet(px, py, 0);

                  this._vSet(px - dlx * ax + dx * ay, py - dly * ax + dy * ay, 1);
                }
              },

              _roundJoin(p0, p1, lw, rw, nCap) {
                const dlx0 = p0.dy;
                const dly0 = -p0.dx;
                const dlx1 = p1.dy;
                const dly1 = -p1.dx;
                const p1x = p1.x;
                const p1y = p1.y;

                if ((p1.flags & PointFlags.PT_LEFT) !== 0) {
                  const out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, lw);

                  const lx0 = out[0];
                  const ly0 = out[1];
                  const lx1 = out[2];
                  const ly1 = out[3];
                  const a0 = atan2(-dly0, -dlx0);
                  let a1 = atan2(-dly1, -dlx1);

                  if (a1 > a0) {
                    a1 -= PI$1 * 2;
                  }

                  this._vSet(lx0, ly0, 1);

                  this._vSet(p1x - dlx0 * rw, p1.y - dly0 * rw, -1);

                  const n = clamp(ceil((a0 - a1) / PI$1) * nCap, 2, nCap);

                  for (let i = 0; i < n; i++) {
                    const u = i / (n - 1);
                    const a = a0 + u * (a1 - a0);
                    const rx = p1x + cos$1(a) * rw;
                    const ry = p1y + sin$1(a) * rw;

                    this._vSet(p1x, p1y, 0);

                    this._vSet(rx, ry, -1);
                  }

                  this._vSet(lx1, ly1, 1);

                  this._vSet(p1x - dlx1 * rw, p1y - dly1 * rw, -1);
                } else {
                  const out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, -rw);

                  const rx0 = out[0];
                  const ry0 = out[1];
                  const rx1 = out[2];
                  const ry1 = out[3];
                  const a0 = atan2(dly0, dlx0);
                  let a1 = atan2(dly1, dlx1);

                  if (a1 < a0) {
                    a1 += PI$1 * 2;
                  }

                  this._vSet(p1x + dlx0 * rw, p1y + dly0 * rw, 1);

                  this._vSet(rx0, ry0, -1);

                  const n = clamp(ceil((a1 - a0) / PI$1) * nCap, 2, nCap);

                  for (let i = 0; i < n; i++) {
                    const u = i / (n - 1);
                    const a = a0 + u * (a1 - a0);
                    const lx = p1x + cos$1(a) * lw;
                    const ly = p1y + sin$1(a) * lw;

                    this._vSet(lx, ly, 1);

                    this._vSet(p1x, p1y, 0);
                  }

                  this._vSet(p1x + dlx1 * rw, p1y + dly1 * rw, 1);

                  this._vSet(rx1, ry1, -1);
                }
              },

              _bevelJoin(p0, p1, lw, rw) {
                let rx0 = 0;
                let ry0 = 0;
                let rx1 = 0;
                let ry1 = 0;
                let lx0 = 0;
                let ly0 = 0;
                let lx1 = 0;
                let ly1 = 0;
                const dlx0 = p0.dy;
                const dly0 = -p0.dx;
                const dlx1 = p1.dy;
                const dly1 = -p1.dx;

                if (p1.flags & PointFlags.PT_LEFT) {
                  const out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, lw);

                  lx0 = out[0];
                  ly0 = out[1];
                  lx1 = out[2];
                  ly1 = out[3];

                  this._vSet(lx0, ly0, 1);

                  this._vSet(p1.x - dlx0 * rw, p1.y - dly0 * rw, -1);

                  this._vSet(lx1, ly1, 1);

                  this._vSet(p1.x - dlx1 * rw, p1.y - dly1 * rw, -1);
                } else {
                  const out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, -rw);

                  rx0 = out[0];
                  ry0 = out[1];
                  rx1 = out[2];
                  ry1 = out[3];

                  this._vSet(p1.x + dlx0 * lw, p1.y + dly0 * lw, 1);

                  this._vSet(rx0, ry0, -1);

                  this._vSet(p1.x + dlx1 * lw, p1.y + dly1 * lw, 1);

                  this._vSet(rx1, ry1, -1);
                }
              },

              _vSet(x, y, distance = 0) {
                if (!_renderData) {
                  return;
                }

                const meshBuffer = _renderData;
                let dataOffset = meshBuffer.vertexStart * attrBytes;
                const vData = meshBuffer.vData;
                vData[dataOffset++] = x;
                vData[dataOffset++] = y;
                vData[dataOffset++] = 0;
                Color$1.toArray(vData, _curColor, dataOffset);
                dataOffset += 4;
                vData[dataOffset++] = distance;
                meshBuffer.vertexStart++;
              }

            };

            const graphicsAssemblerManager = exports('graphicsAssembler', {
              getAssembler(sprite) {
                return graphicsAssembler;
              }

            });
            Graphics.Assembler = graphicsAssemblerManager;

            class LetterInfo {
              constructor() {
                this.char = '';
                this.valid = true;
                this.x = 0;
                this.y = 0;
                this.line = 0;
                this.hash = '';
              }

            }

            const _tmpRect = new Rect$1();

            let _comp = null;
            let _uiTrans = null;
            const _horizontalKerning = [];
            const _lettersInfo = [];
            const _linesWidth = [];
            const _linesOffsetX = [];

            const _labelDimensions = new Size$1();

            const _contentSize = new Size$1();

            const letterPosition = new Vec2();
            const _lineSpacing = 0;
            let _fntConfig = null;
            let _numberOfLines = 0;
            let _textDesiredHeight = 0;
            let _letterOffsetY = 0;
            let _tailoredTopY = 0;
            let _tailoredBottomY = 0;
            let _bmfontScale = 1.0;
            let _spriteFrame = null;
            let _string = '';
            let _fontSize = 0;
            let _originFontSize = 0;
            let _hAlign = 0;
            let _vAlign = 0;
            let _spacingX = 0;
            let _lineHeight = 0;
            let _overflow = 0;
            let _isWrapText = false;
            let _labelWidth = 0;
            let _labelHeight = 0;
            let _maxLineWidth = 0;
            const bmfontUtils = {
              updateRenderData(comp) {
                if (!comp.renderData) {
                  return;
                }

                if (_comp === comp) {
                  return;
                }

                if (comp.renderData.vertDirty) {
                  _comp = comp;
                  _uiTrans = _comp.node._uiProps.uiTransformComp;

                  this._updateFontFamily(comp);

                  this._updateProperties(comp);

                  this._updateLabelInfo(comp);

                  this._updateContent();

                  _comp.actualFontSize = _fontSize;

                  _uiTrans.setContentSize(_contentSize);

                  _comp.renderData.vertDirty = _comp.renderData.uvDirty = false;

                  _comp.markForUpdateRenderData(false);

                  _comp = null;

                  this._resetProperties();
                }

                if (comp.spriteFrame) {
                  const renderData = comp.renderData;
                  renderData.updateRenderData(comp, comp.spriteFrame);
                }
              },

              _updateFontScale() {
                _bmfontScale = _fontSize / _originFontSize;
              },

              _updateFontFamily(comp) {
                const fontAsset = comp.font;
                _spriteFrame = fontAsset.spriteFrame;
                _fntConfig = fontAsset.fntConfig;
                shareLabelInfo.fontAtlas = fontAsset.fontDefDictionary;
                dynamicAtlasManager.packToDynamicAtlas(comp, _spriteFrame);
              },

              _updateLabelInfo(comp) {
                shareLabelInfo.hash = '';
                shareLabelInfo.margin = 0;
              },

              _updateProperties(comp) {
                _string = comp.string.toString();
                _fontSize = comp.fontSize;
                _originFontSize = _fntConfig ? _fntConfig.fontSize : comp.fontSize;
                _hAlign = comp.horizontalAlign;
                _vAlign = comp.verticalAlign;
                _spacingX = comp.spacingX;
                _overflow = comp.overflow;
                _lineHeight = comp._lineHeight;
                const contentSize = _uiTrans.contentSize;
                _contentSize.width = contentSize.width;
                _contentSize.height = contentSize.height;

                if (_overflow === Overflow.NONE) {
                  _isWrapText = false;
                  _contentSize.width += shareLabelInfo.margin * 2;
                  _contentSize.height += shareLabelInfo.margin * 2;
                } else if (_overflow === Overflow.RESIZE_HEIGHT) {
                  _isWrapText = true;
                  _contentSize.height += shareLabelInfo.margin * 2;
                } else {
                  _isWrapText = comp.enableWrapText;
                }

                shareLabelInfo.lineHeight = _lineHeight;
                shareLabelInfo.fontSize = _fontSize;

                this._setupBMFontOverflowMetrics();
              },

              _resetProperties() {
                _fntConfig = null;
                _spriteFrame = null;
                shareLabelInfo.hash = '';
                shareLabelInfo.margin = 0;
              },

              _updateContent() {
                this._updateFontScale();

                this._computeHorizontalKerningForText();

                this._alignText();
              },

              _computeHorizontalKerningForText() {
                const string = _string;
                const stringLen = string.length;
                const kerningDict = _fntConfig.kerningDict;
                const horizontalKerning = _horizontalKerning;
                let prev = -1;

                for (let i = 0; i < stringLen; ++i) {
                  const key = string.charCodeAt(i);
                  const kerningAmount = kerningDict[prev << 16 | key & 0xffff] || 0;

                  if (i < stringLen - 1) {
                    horizontalKerning[i] = kerningAmount;
                  } else {
                    horizontalKerning[i] = 0;
                  }

                  prev = key;
                }
              },

              _multilineTextWrap(nextTokenFunc) {
                const textLen = _string.length;
                let lineIndex = 0;
                let nextTokenX = 0;
                let nextTokenY = 0;
                let longestLine = 0;
                let letterRight = 0;
                let highestY = 0;
                let lowestY = 0;
                let letterDef = null;

                for (let index = 0; index < textLen;) {
                  let character = _string.charAt(index);

                  if (character === '\n') {
                    _linesWidth.push(letterRight);

                    letterRight = 0;
                    lineIndex++;
                    nextTokenX = 0;
                    nextTokenY -= _lineHeight * this._getFontScale() + _lineSpacing;

                    this._recordPlaceholderInfo(index, character);

                    index++;
                    continue;
                  }

                  const tokenLen = nextTokenFunc(_string, index, textLen);
                  let tokenHighestY = highestY;
                  let tokenLowestY = lowestY;
                  let tokenRight = letterRight;
                  let nextLetterX = nextTokenX;
                  let newLine = false;

                  for (let tmp = 0; tmp < tokenLen; ++tmp) {
                    const letterIndex = index + tmp;
                    character = _string.charAt(letterIndex);

                    if (character === '\r') {
                      this._recordPlaceholderInfo(letterIndex, character);

                      continue;
                    }

                    letterDef = shareLabelInfo.fontAtlas.getLetterDefinitionForChar(character, shareLabelInfo);

                    if (!letterDef) {
                      this._recordPlaceholderInfo(letterIndex, character);

                      console.log(`Can't find letter definition in texture atlas ${_fntConfig.atlasName} for letter:${character}`);
                      continue;
                    }

                    const letterX = nextLetterX + letterDef.offsetX * _bmfontScale - shareLabelInfo.margin;

                    if (_isWrapText && _maxLineWidth > 0 && nextTokenX > 0 && letterX + letterDef.w * _bmfontScale > _maxLineWidth && !isUnicodeSpace(character)) {
                      _linesWidth.push(letterRight);

                      letterRight = 0;
                      lineIndex++;
                      nextTokenX = 0;
                      nextTokenY -= _lineHeight * this._getFontScale() + _lineSpacing;
                      newLine = true;
                      break;
                    } else {
                      letterPosition.x = letterX;
                    }

                    letterPosition.y = nextTokenY - letterDef.offsetY * _bmfontScale;

                    this._recordLetterInfo(letterPosition, character, letterIndex, lineIndex);

                    if (letterIndex + 1 < _horizontalKerning.length && letterIndex < textLen - 1) {
                      nextLetterX += _horizontalKerning[letterIndex + 1];
                    }

                    nextLetterX += letterDef.xAdvance * _bmfontScale + _spacingX;
                    tokenRight = letterPosition.x + letterDef.w * _bmfontScale;

                    if (tokenHighestY < letterPosition.y) {
                      tokenHighestY = letterPosition.y;
                    }

                    if (tokenLowestY > letterPosition.y - letterDef.h * _bmfontScale) {
                      tokenLowestY = letterPosition.y - letterDef.h * _bmfontScale;
                    }
                  }

                  if (newLine) {
                    continue;
                  }

                  nextTokenX = nextLetterX;
                  letterRight = tokenRight;

                  if (highestY < tokenHighestY) {
                    highestY = tokenHighestY;
                  }

                  if (lowestY > tokenLowestY) {
                    lowestY = tokenLowestY;
                  }

                  if (longestLine < letterRight) {
                    longestLine = letterRight;
                  }

                  index += tokenLen;
                }

                _linesWidth.push(letterRight);

                _numberOfLines = lineIndex + 1;
                _textDesiredHeight = _numberOfLines * _lineHeight * this._getFontScale();

                if (_numberOfLines > 1) {
                  _textDesiredHeight += (_numberOfLines - 1) * _lineSpacing;
                }

                _contentSize.width = _labelWidth;
                _contentSize.height = _labelHeight;

                if (_labelWidth <= 0) {
                  _contentSize.width = parseFloat(longestLine.toFixed(2)) + shareLabelInfo.margin * 2;
                }

                if (_labelHeight <= 0) {
                  _contentSize.height = parseFloat(_textDesiredHeight.toFixed(2)) + shareLabelInfo.margin * 2;
                }

                _tailoredTopY = _contentSize.height;
                _tailoredBottomY = 0;

                if (highestY > 0) {
                  _tailoredTopY = _contentSize.height + highestY;
                }

                if (lowestY < -_textDesiredHeight) {
                  _tailoredBottomY = _textDesiredHeight + lowestY;
                }

                return true;
              },

              _getFirstCharLen() {
                return 1;
              },

              _getFontScale() {
                return _overflow === Overflow.SHRINK ? _bmfontScale : 1;
              },

              _getFirstWordLen(text, startIndex, textLen) {
                let character = text.charAt(startIndex);

                if (isUnicodeCJK(character) || character === '\n' || isUnicodeSpace(character)) {
                  return 1;
                }

                let len = 1;
                let letterDef = shareLabelInfo.fontAtlas.getLetterDefinitionForChar(character, shareLabelInfo);

                if (!letterDef) {
                  return len;
                }

                let nextLetterX = letterDef.xAdvance * _bmfontScale + _spacingX;
                let letterX = 0;

                for (let index = startIndex + 1; index < textLen; ++index) {
                  character = text.charAt(index);
                  letterDef = shareLabelInfo.fontAtlas.getLetterDefinitionForChar(character, shareLabelInfo);

                  if (!letterDef) {
                    break;
                  }

                  letterX = nextLetterX + letterDef.offsetX * _bmfontScale;

                  if (letterX + letterDef.w * _bmfontScale > _maxLineWidth && !isUnicodeSpace(character) && _maxLineWidth > 0) {
                    return len;
                  }

                  nextLetterX += letterDef.xAdvance * _bmfontScale + _spacingX;

                  if (character === '\n' || isUnicodeSpace(character) || isUnicodeCJK(character)) {
                    break;
                  }

                  len++;
                }

                return len;
              },

              _multilineTextWrapByWord() {
                return this._multilineTextWrap(this._getFirstWordLen);
              },

              _multilineTextWrapByChar() {
                return this._multilineTextWrap(this._getFirstCharLen);
              },

              _recordPlaceholderInfo(letterIndex, char) {
                if (letterIndex >= _lettersInfo.length) {
                  const tmpInfo = new LetterInfo();

                  _lettersInfo.push(tmpInfo);
                }

                _lettersInfo[letterIndex].char = char;
                _lettersInfo[letterIndex].hash = `${char.charCodeAt(0)}${shareLabelInfo.hash}`;
                _lettersInfo[letterIndex].valid = false;
              },

              _recordLetterInfo(letterPosition, character, letterIndex, lineIndex) {
                if (letterIndex >= _lettersInfo.length) {
                  const tmpInfo = new LetterInfo();

                  _lettersInfo.push(tmpInfo);
                }

                const char = character.charCodeAt(0);
                const key = `${char}${shareLabelInfo.hash}`;
                _lettersInfo[letterIndex].line = lineIndex;
                _lettersInfo[letterIndex].char = character;
                _lettersInfo[letterIndex].hash = key;
                _lettersInfo[letterIndex].valid = shareLabelInfo.fontAtlas.getLetter(key).valid;
                _lettersInfo[letterIndex].x = letterPosition.x;
                _lettersInfo[letterIndex].y = letterPosition.y;
              },

              _alignText() {
                _textDesiredHeight = 0;
                _linesWidth.length = 0;

                {
                  this._multilineTextWrapByWord();
                }

                this._computeAlignmentOffset();

                if (_overflow === Overflow.SHRINK) {
                  if (_fontSize > 0 && this._isVerticalClamp()) {
                    this._shrinkLabelToContentSize(this._isVerticalClamp);
                  }
                }

                if (!this._updateQuads()) {
                  if (_overflow === Overflow.SHRINK) {
                    this._shrinkLabelToContentSize(this._isHorizontalClamp);
                  }
                }
              },

              _scaleFontSizeDown(fontSize) {
                let shouldUpdateContent = true;

                if (!fontSize) {
                  fontSize = 0.1;
                  shouldUpdateContent = false;
                }

                _fontSize = fontSize;

                if (shouldUpdateContent) {
                  this._updateContent();
                }
              },

              _shrinkLabelToContentSize(lambda) {
                const fontSize = _fontSize;
                let left = 0;
                let right = fontSize | 0;
                let mid = 0;

                while (left < right) {
                  mid = left + right + 1 >> 1;
                  const newFontSize = mid;

                  if (newFontSize <= 0) {
                    break;
                  }

                  _bmfontScale = newFontSize / _originFontSize;

                  {
                    this._multilineTextWrapByWord();
                  }

                  this._computeAlignmentOffset();

                  if (lambda()) {
                    right = mid - 1;
                  } else {
                    left = mid;
                  }
                }

                if (left >= 0) {
                  this._scaleFontSizeDown(left);
                }
              },

              _isVerticalClamp() {
                if (_textDesiredHeight > _contentSize.height) {
                  return true;
                } else {
                  return false;
                }
              },

              _isHorizontalClamp() {
                let letterClamp = false;

                for (let ctr = 0, l = _string.length; ctr < l; ++ctr) {
                  const letterInfo = _lettersInfo[ctr];

                  if (letterInfo.valid) {
                    const letterDef = shareLabelInfo.fontAtlas.getLetterDefinitionForChar(letterInfo.char, shareLabelInfo);

                    if (!letterDef) {
                      continue;
                    }

                    const px = letterInfo.x + letterDef.w * _bmfontScale;
                    const lineIndex = letterInfo.line;

                    if (_labelWidth > 0) {
                      if (!_isWrapText) {
                        if (px > _contentSize.width) {
                          letterClamp = true;
                          break;
                        }
                      } else {
                        const wordWidth = _linesWidth[lineIndex];

                        if (wordWidth > _contentSize.width && (px > _contentSize.width || px < 0)) {
                          letterClamp = true;
                          break;
                        }
                      }
                    }
                  }
                }

                return letterClamp;
              },

              _isHorizontalClamped(px, lineIndex) {
                const wordWidth = _linesWidth[lineIndex];
                const letterOverClamp = px > _contentSize.width || px < 0;

                if (!_isWrapText) {
                  return letterOverClamp;
                } else {
                  return wordWidth > _contentSize.width && letterOverClamp;
                }
              },

              _updateQuads() {
                if (!_comp) {
                  return false;
                }

                const texture = _spriteFrame ? _spriteFrame.texture : shareLabelInfo.fontAtlas.getTexture();
                const renderData = _comp.renderData;
                renderData.dataLength = renderData.vertexCount = renderData.indicesCount = 0;
                const anchorPoint = _uiTrans.anchorPoint;
                const contentSize = _contentSize;
                const appX = anchorPoint.x * contentSize.width;
                const appY = anchorPoint.y * contentSize.height;
                let ret = true;

                for (let ctr = 0, l = _string.length; ctr < l; ++ctr) {
                  const letterInfo = _lettersInfo[ctr];

                  if (!letterInfo.valid) {
                    continue;
                  }

                  const letterDef = shareLabelInfo.fontAtlas.getLetter(letterInfo.hash);

                  if (!letterDef) {
                    console.warn('Can\'t find letter in this bitmap-font');
                    continue;
                  }

                  _tmpRect.height = letterDef.h;
                  _tmpRect.width = letterDef.w;
                  _tmpRect.x = letterDef.u;
                  _tmpRect.y = letterDef.v;
                  let py = letterInfo.y + _letterOffsetY;

                  if (_labelHeight > 0) {
                    if (py > _tailoredTopY) {
                      const clipTop = py - _tailoredTopY;
                      _tmpRect.y += clipTop;
                      _tmpRect.height -= clipTop;
                      py -= clipTop;
                    }

                    if (py - letterDef.h * _bmfontScale < _tailoredBottomY && _overflow === Overflow.CLAMP) {
                      _tmpRect.height = py < _tailoredBottomY ? 0 : (py - _tailoredBottomY) / _bmfontScale;
                    }
                  }

                  const lineIndex = letterInfo.line;
                  const px = letterInfo.x + letterDef.w / 2 * _bmfontScale + _linesOffsetX[lineIndex];

                  if (_labelWidth > 0) {
                    if (this._isHorizontalClamped(px, lineIndex)) {
                      if (_overflow === Overflow.CLAMP) {
                        _tmpRect.width = 0;
                      } else if (_overflow === Overflow.SHRINK) {
                        if (_contentSize.width > letterDef.w) {
                          ret = false;
                          break;
                        } else {
                          _tmpRect.width = 0;
                        }
                      }
                    }
                  }

                  if (_tmpRect.height > 0 && _tmpRect.width > 0) {
                    const isRotated = this._determineRect();

                    const letterPositionX = letterInfo.x + _linesOffsetX[letterInfo.line];
                    this.appendQuad(_comp, texture, _tmpRect, isRotated, letterPositionX - appX, py - appY, _bmfontScale);
                  }
                }

                return ret;
              },

              appendQuad(comp, texture, rect, rotated, x, y, scale) {},

              _determineRect() {
                const isRotated = _spriteFrame.isRotated();

                const originalSize = _spriteFrame.getOriginalSize();

                const rect = _spriteFrame.getRect();

                const offset = _spriteFrame.getOffset();

                const trimmedLeft = offset.x + (originalSize.width - rect.width) / 2;
                const trimmedTop = offset.y - (originalSize.height - rect.height) / 2;

                if (!isRotated) {
                  _tmpRect.x += rect.x - trimmedLeft;
                  _tmpRect.y += rect.y + trimmedTop;
                } else {
                  const originalX = _tmpRect.x;
                  _tmpRect.x = rect.x + rect.height - _tmpRect.y - _tmpRect.height - trimmedTop;
                  _tmpRect.y = originalX + rect.y - trimmedLeft;

                  if (_tmpRect.y < 0) {
                    _tmpRect.height += trimmedTop;
                  }
                }

                return isRotated;
              },

              _computeAlignmentOffset() {
                _linesOffsetX.length = 0;

                switch (_hAlign) {
                  case HorizontalTextAlignment.LEFT:
                    for (let i = 0; i < _numberOfLines; ++i) {
                      _linesOffsetX.push(0);
                    }

                    break;

                  case HorizontalTextAlignment.CENTER:
                    for (let i = 0, l = _linesWidth.length; i < l; i++) {
                      _linesOffsetX.push((_contentSize.width - _linesWidth[i]) / 2);
                    }

                    break;

                  case HorizontalTextAlignment.RIGHT:
                    for (let i = 0, l = _linesWidth.length; i < l; i++) {
                      _linesOffsetX.push(_contentSize.width - _linesWidth[i]);
                    }

                    break;
                }

                _letterOffsetY = _contentSize.height;

                if (_vAlign !== VerticalTextAlignment.TOP) {
                  const blank = _contentSize.height - _textDesiredHeight + _lineHeight * this._getFontScale() - _originFontSize * _bmfontScale;

                  if (_vAlign === VerticalTextAlignment.BOTTOM) {
                    _letterOffsetY -= blank;
                  } else {
                    _letterOffsetY -= blank / 2;
                  }
                }
              },

              _setupBMFontOverflowMetrics() {
                let newWidth = _contentSize.width;
                let newHeight = _contentSize.height;

                if (_overflow === Overflow.RESIZE_HEIGHT) {
                  newHeight = 0;
                }

                if (_overflow === Overflow.NONE) {
                  newWidth = 0;
                  newHeight = 0;
                }

                _labelWidth = newWidth;
                _labelHeight = newHeight;
                _labelDimensions.width = newWidth;
                _labelDimensions.height = newHeight;
                _maxLineWidth = newWidth;
              }

            };

            const tempColor = new Color$1(255, 255, 255, 255);
            const bmfont = {
              createData(comp) {
                return comp.requestRenderData();
              },

              fillBuffers(comp, renderer) {
                const node = comp.node;
                tempColor.set(comp.color);
                tempColor.a = node._uiProps.opacity * 255;
                fillMeshVertices3D(node, renderer, comp.renderData, tempColor);
              },

              appendQuad(comp, spriteFrame, rect, rotated, x, y, scale) {
                const renderData = comp.renderData;

                if (!renderData) {
                  return;
                }

                const dataOffset = renderData.dataLength;
                renderData.dataLength += 4;
                renderData.vertexCount = renderData.dataLength;
                renderData.indicesCount = renderData.dataLength / 2 * 3;
                const dataList = renderData.data;
                const texW = spriteFrame.width;
                const texH = spriteFrame.height;
                const rectWidth = rect.width;
                const rectHeight = rect.height;
                let l = 0;
                let b = 0;
                let t = 0;
                let r = 0;

                if (!rotated) {
                  l = rect.x / texW;
                  r = (rect.x + rectWidth) / texW;
                  b = (rect.y + rectHeight) / texH;
                  t = rect.y / texH;
                  dataList[dataOffset].u = l;
                  dataList[dataOffset].v = b;
                  dataList[dataOffset + 1].u = r;
                  dataList[dataOffset + 1].v = b;
                  dataList[dataOffset + 2].u = l;
                  dataList[dataOffset + 2].v = t;
                  dataList[dataOffset + 3].u = r;
                  dataList[dataOffset + 3].v = t;
                } else {
                  l = rect.x / texW;
                  r = (rect.x + rectHeight) / texW;
                  b = (rect.y + rectWidth) / texH;
                  t = rect.y / texH;
                  dataList[dataOffset].u = l;
                  dataList[dataOffset].v = t;
                  dataList[dataOffset + 1].u = l;
                  dataList[dataOffset + 1].v = b;
                  dataList[dataOffset + 2].u = r;
                  dataList[dataOffset + 2].v = t;
                  dataList[dataOffset + 3].u = r;
                  dataList[dataOffset + 3].v = b;
                }

                dataList[dataOffset].x = x;
                dataList[dataOffset].y = y - rectHeight * scale;
                dataList[dataOffset + 1].x = x + rectWidth * scale;
                dataList[dataOffset + 1].y = y - rectHeight * scale;
                dataList[dataOffset + 2].x = x;
                dataList[dataOffset + 2].y = y;
                dataList[dataOffset + 3].x = x + rectWidth * scale;
                dataList[dataOffset + 3].y = y;
              }

            };
            addon(bmfont, bmfontUtils);

            const _atlasWidth = 1024;
            const _atlasHeight = 1024;
            let _shareAtlas = null;
            const letterFont = mixin(bmfontUtils, {
              getAssemblerData() {
                if (!_shareAtlas) {
                  _shareAtlas = new LetterAtlas(_atlasWidth, _atlasHeight);
                }

                return _shareAtlas.getTexture();
              },

              _updateFontFamily(comp) {
                shareLabelInfo.fontAtlas = _shareAtlas;
                shareLabelInfo.fontFamily = this._getFontFamily(comp);
                const outline = comp.getComponent(LabelOutline);

                if (outline && outline.enabled) {
                  shareLabelInfo.isOutlined = true;
                  shareLabelInfo.margin = outline.width;
                  shareLabelInfo.out = outline.color.clone();
                  shareLabelInfo.out.a = outline.color.a * comp.color.a / 255.0;
                } else {
                  shareLabelInfo.isOutlined = false;
                  shareLabelInfo.margin = 0;
                }
              },

              _getFontFamily(comp) {
                let fontFamily = 'Arial';

                if (!comp.useSystemFont) {
                  if (comp.font) {
                    fontFamily = comp.font._nativeAsset || 'Arial';
                  }
                } else {
                  fontFamily = comp.fontFamily || 'Arial';
                }

                return fontFamily;
              },

              _updateLabelInfo(comp) {
                shareLabelInfo.fontDesc = this._getFontDesc();
                shareLabelInfo.color = comp.color;
                shareLabelInfo.hash = computeHash(shareLabelInfo);
              },

              _getFontDesc() {
                let fontDesc = `${shareLabelInfo.fontSize.toString()}px `;
                fontDesc += shareLabelInfo.fontFamily;

                return fontDesc;
              },

              _computeHorizontalKerningForText() {},

              _determineRect(tempRect) {
                return false;
              }

            });

            const WHITE$1 = new Color$1(255, 255, 255, 255);
            const letter = {
              createData(comp) {
                return comp.requestRenderData();
              },

              fillBuffers(comp, renderer) {
                if (!comp.renderData) {
                  return;
                }

                const node = comp.node;
                WHITE$1.a = node._uiProps.opacity * 255;
                fillMeshVertices3D(node, renderer, comp.renderData, WHITE$1);
              },

              appendQuad: bmfont.appendQuad
            };
            addon(letter, letterFont);

            const Overflow$1 = Label.Overflow;
            const MAX_SIZE = 2048;

            const _BASELINE_OFFSET$1 = getBaselineOffset();

            const _invisibleAlpha = (1 / 255).toFixed(3);

            let _context = null;
            let _canvas = null;
            let _texture = null;
            let _fontDesc = '';
            let _string$1 = '';
            let _fontSize$1 = 0;
            let _drawFontsize = 0;
            let _splitStrings = [];

            const _canvasSize = new Size$1();

            let _lineHeight$1 = 0;
            let _hAlign$1 = 0;
            let _vAlign$1 = 0;

            let _color = new Color$1();

            let _alpha = 1;
            let _fontFamily = '';
            let _overflow$1 = Overflow$1.NONE;
            let _isWrapText$1 = false;
            let _outlineComp = null;

            const _outlineColor = Color$1.BLACK.clone();

            let _shadowComp = null;

            const _shadowColor = Color$1.BLACK.clone();

            const _canvasPadding = new Rect$1();

            const _contentSizeExtend = Size$1.ZERO.clone();

            const _nodeContentSize = Size$1.ZERO.clone();

            const _startPosition = Vec2.ZERO.clone();

            const _drawUnderlinePos = Vec2.ZERO.clone();

            let _drawUnderlineWidth = 0;
            let _underlineThickness = 0;
            let _isBold = false;
            let _isItalic = false;
            let _isUnderline = false;
            const Alignment = ['left', 'center', 'right'];
            const ttfUtils = {
              getAssemblerData() {
                const sharedLabelData = Label._canvasPool.get();

                return sharedLabelData;
              },

              resetAssemblerData(assemblerData) {
                if (assemblerData) {
                  Label._canvasPool.put(assemblerData);
                }
              },

              updateRenderData(comp) {
                if (!comp.renderData) {
                  return;
                }

                if (comp.renderData.vertDirty) {
                  const trans = comp.node._uiProps.uiTransformComp;

                  this._updateFontFamily(comp);

                  this._updateProperties(comp, trans);

                  this._calculateLabelFont();

                  this._updateLabelDimensions();

                  this._updateTexture(comp);

                  this.updateOpacity(comp);

                  this._calDynamicAtlas(comp);

                  comp.actualFontSize = _fontSize$1;
                  trans.setContentSize(_canvasSize);
                  this.updateVertexData(comp);
                  this.updateUvs(comp);
                  comp.markForUpdateRenderData(false);
                  _context = null;
                  _canvas = null;
                  _texture = null;
                }

                if (comp.spriteFrame) {
                  const renderData = comp.renderData;
                  renderData.updateRenderData(comp, comp.spriteFrame);
                }
              },

              updateVertexData(comp) {},

              updateUvs(comp) {},

              updateOpacity(comp) {
                const vData = comp.renderData.vData;
                let colorOffset = 5;
                const colorA = comp.node._uiProps.opacity;

                for (let i = 0; i < 4; i++) {
                  vData[colorOffset + 3] = colorA;
                  colorOffset += 9;
                }
              },

              _updateFontFamily(comp) {
                if (!comp.useSystemFont) {
                  if (comp.font) {
                    _fontFamily = comp.font._nativeAsset || 'Arial';
                  } else {
                    _fontFamily = 'Arial';
                  }
                } else {
                  _fontFamily = comp.fontFamily || 'Arial';
                }
              },

              _updateProperties(comp, trans) {
                const assemblerData = comp.assemblerData;

                if (!assemblerData) {
                  return;
                }

                _context = assemblerData.context;
                _canvas = assemblerData.canvas;
                _texture = comp.spriteFrame;
                _string$1 = comp.string.toString();
                _fontSize$1 = comp.fontSize;
                _drawFontsize = _fontSize$1;
                _overflow$1 = comp.overflow;
                _nodeContentSize.width = _canvasSize.width = trans.width;
                _nodeContentSize.height = _canvasSize.height = trans.height;
                _underlineThickness = comp.underlineHeight;
                _lineHeight$1 = comp.lineHeight;
                _hAlign$1 = comp.horizontalAlign;
                _vAlign$1 = comp.verticalAlign;
                _color = comp.color;
                _alpha = comp.node._uiProps.opacity;
                _isBold = comp.isBold;
                _isItalic = comp.isItalic;
                _isUnderline = comp.isUnderline;

                if (_overflow$1 === Overflow$1.NONE) {
                  _isWrapText$1 = false;
                } else if (_overflow$1 === Overflow$1.RESIZE_HEIGHT) {
                  _isWrapText$1 = true;
                } else {
                  _isWrapText$1 = comp.enableWrapText;
                }

                _outlineComp = LabelOutline && comp.getComponent(LabelOutline);
                _outlineComp = _outlineComp && _outlineComp.enabled && _outlineComp.width > 0 ? _outlineComp : null;

                if (_outlineComp) {
                  _outlineColor.set(_outlineComp.color);
                }

                _shadowComp = LabelShadow && comp.getComponent(LabelShadow);
                _shadowComp = _shadowComp && _shadowComp.enabled ? _shadowComp : null;

                if (_shadowComp) {
                  _shadowColor.set(_shadowComp.color);
                }

                this._updatePaddingRect();
              },

              _updatePaddingRect() {
                let top = 0;
                let bottom = 0;
                let left = 0;
                let right = 0;
                let outlineWidth = 0;
                _contentSizeExtend.width = _contentSizeExtend.height = 0;

                if (_outlineComp) {
                  outlineWidth = _outlineComp.width;
                  top = bottom = left = right = outlineWidth;
                  _contentSizeExtend.width = _contentSizeExtend.height = outlineWidth * 2;
                }

                if (_shadowComp) {
                  const shadowWidth = _shadowComp.blur + outlineWidth;
                  const offsetX = _shadowComp.offset.x;
                  const offsetY = _shadowComp.offset.y;
                  left = Math.max(left, -offsetX + shadowWidth);
                  right = Math.max(right, offsetX + shadowWidth);
                  top = Math.max(top, offsetY + shadowWidth);
                  bottom = Math.max(bottom, -offsetY + shadowWidth);
                }

                if (_isItalic) {
                  const offset = _drawFontsize * Math.tan(12 * 0.0174532925);

                  right += offset;
                  _contentSizeExtend.width += offset;
                }

                _canvasPadding.x = left;
                _canvasPadding.y = top;
                _canvasPadding.width = left + right;
                _canvasPadding.height = top + bottom;
              },

              _calculateFillTextStartPosition() {
                let labelX = 0;

                if (_hAlign$1 === HorizontalTextAlignment.RIGHT) {
                  labelX = _canvasSize.width - _canvasPadding.width;
                } else if (_hAlign$1 === HorizontalTextAlignment.CENTER) {
                  labelX = (_canvasSize.width - _canvasPadding.width) / 2;
                }

                const lineHeight = this._getLineHeight();

                const drawStartY = lineHeight * (_splitStrings.length - 1);
                let firstLinelabelY = _fontSize$1 * (1 - BASELINE_RATIO / 2);

                if (_vAlign$1 !== VerticalTextAlignment.TOP) {
                  let blank = drawStartY + _canvasPadding.height + _fontSize$1 - _canvasSize.height;

                  if (_vAlign$1 === VerticalTextAlignment.BOTTOM) {
                    blank += BASELINE_RATIO / 2 * _fontSize$1;
                    firstLinelabelY -= blank;
                  } else {
                    firstLinelabelY -= blank / 2;
                  }
                }

                firstLinelabelY += _BASELINE_OFFSET$1 * _fontSize$1;

                _startPosition.set(labelX + _canvasPadding.x, firstLinelabelY + _canvasPadding.y);
              },

              _updateTexture(comp) {
                if (!_context || !_canvas) {
                  return;
                }

                _context.clearRect(0, 0, _canvas.width, _canvas.height);

                _context.font = _fontDesc;

                this._calculateFillTextStartPosition();

                const lineHeight = this._getLineHeight();

                _context.lineJoin = 'round';

                if (_outlineComp) {
                  _context.fillStyle = `rgba(${_outlineColor.r}, ${_outlineColor.g}, ${_outlineColor.b}, ${_invisibleAlpha})`;

                  _context.fillRect(0, 0, _canvas.width, _canvas.height);
                } else if (comp._srcBlendFactor === BlendFactor.SRC_ALPHA) {
                  _context.fillStyle = `rgba(${_color.r}, ${_color.g}, ${_color.b}, ${_invisibleAlpha})`;

                  _context.fillRect(0, 0, _canvas.width, _canvas.height);
                }

                _context.fillStyle = `rgb(${_color.r}, ${_color.g}, ${_color.b})`;
                const drawTextPosX = _startPosition.x;
                let drawTextPosY = 0;

                this._drawTextEffect(_startPosition, lineHeight);

                for (let i = 0; i < _splitStrings.length; ++i) {
                  drawTextPosY = _startPosition.y + i * lineHeight;

                  if (_outlineComp) {
                    _context.strokeText(_splitStrings[i], drawTextPosX, drawTextPosY);
                  }

                  _context.fillText(_splitStrings[i], drawTextPosX, drawTextPosY);
                }

                if (_shadowComp) {
                  _context.shadowColor = 'transparent';
                }

                this._uploadTexture(comp);
              },

              _uploadTexture(comp) {
                if (comp.cacheMode === Label.CacheMode.BITMAP) {
                  const frame = comp.ttfSpriteFrame;
                  dynamicAtlasManager.deleteAtlasSpriteFrame(frame);

                  frame._resetDynamicAtlasFrame();
                }

                if (_texture && _canvas) {
                  let tex;

                  if (_texture instanceof SpriteFrame) {
                    tex = _texture.texture;
                  } else {
                    tex = _texture;
                  }

                  const uploadAgain = _canvas.width !== 0 && _canvas.height !== 0;

                  if (uploadAgain) {
                    tex.reset({
                      width: _canvas.width,
                      height: _canvas.height,
                      mipmapLevel: 1
                    });
                    tex.uploadData(_canvas);

                    if (_texture instanceof SpriteFrame) {
                      _texture.rect = new Rect$1(0, 0, _canvas.width, _canvas.height);

                      _texture._calculateUV();
                    }

                    if (comp.renderData) {
                      comp.renderData.textureDirty = true;
                    }

                    if (legacyCC.director.root && legacyCC.director.root.batcher2D) {
                      legacyCC.director.root.batcher2D._releaseDescriptorSetCache(tex.getHash());
                    }
                  }
                }
              },

              _calDynamicAtlas(comp) {
                if (comp.cacheMode !== Label.CacheMode.BITMAP) return;
                const frame = comp.ttfSpriteFrame;
                dynamicAtlasManager.packToDynamicAtlas(comp, frame);
                comp.renderData.uvDirty = true;
              },

              _setupOutline() {
                _context.strokeStyle = `rgba(${_outlineColor.r}, ${_outlineColor.g}, ${_outlineColor.b}, ${_outlineColor.a / 255})`;
                _context.lineWidth = _outlineComp.width * 2;
              },

              _setupShadow() {
                _context.shadowColor = `rgba(${_shadowColor.r}, ${_shadowColor.g}, ${_shadowColor.b}, ${_shadowColor.a / 255})`;
                _context.shadowBlur = _shadowComp.blur;
                _context.shadowOffsetX = _shadowComp.offset.x;
                _context.shadowOffsetY = -_shadowComp.offset.y;
              },

              _drawTextEffect(startPosition, lineHeight) {
                if (!_shadowComp && !_outlineComp && !_isUnderline) return;
                const isMultiple = _splitStrings.length > 1 && _shadowComp;

                const measureText = this._measureText(_context, _fontDesc);

                let drawTextPosX = 0;
                let drawTextPosY = 0;

                if (_shadowComp) {
                  this._setupShadow();
                }

                if (_outlineComp) {
                  this._setupOutline();
                }

                for (let i = 0; i < _splitStrings.length; ++i) {
                  drawTextPosX = startPosition.x;
                  drawTextPosY = startPosition.y + i * lineHeight;

                  if (isMultiple) {
                    if (_outlineComp) {
                      _context.strokeText(_splitStrings[i], drawTextPosX, drawTextPosY);
                    }

                    _context.fillText(_splitStrings[i], drawTextPosX, drawTextPosY);
                  }

                  if (_isUnderline) {
                    _drawUnderlineWidth = measureText(_splitStrings[i]);

                    if (_hAlign$1 === HorizontalTextAlignment.RIGHT) {
                      _drawUnderlinePos.x = startPosition.x - _drawUnderlineWidth;
                    } else if (_hAlign$1 === HorizontalTextAlignment.CENTER) {
                      _drawUnderlinePos.x = startPosition.x - _drawUnderlineWidth / 2;
                    } else {
                      _drawUnderlinePos.x = startPosition.x;
                    }

                    _drawUnderlinePos.y = drawTextPosY + _drawFontsize / 8;

                    _context.fillRect(_drawUnderlinePos.x, _drawUnderlinePos.y, _drawUnderlineWidth, _underlineThickness);
                  }
                }

                if (isMultiple) {
                  _context.shadowColor = 'transparent';
                }
              },

              _updateLabelDimensions() {
                _canvasSize.width = Math.min(_canvasSize.width, MAX_SIZE);
                _canvasSize.height = Math.min(_canvasSize.height, MAX_SIZE);
                let recreate = false;

                if (_canvas.width !== _canvasSize.width) {
                  _canvas.width = _canvasSize.width;
                  recreate = true;
                }

                if (_canvas.height !== _canvasSize.height) {
                  _canvas.height = _canvasSize.height;
                  recreate = true;
                }

                if (recreate) _context.font = _fontDesc;
                _context.textAlign = Alignment[_hAlign$1];
                _context.textBaseline = 'alphabetic';
              },

              _getFontDesc() {
                let fontDesc = `${_fontSize$1.toString()}px `;
                fontDesc += _fontFamily;

                if (_isBold) {
                  fontDesc = `bold ${fontDesc}`;
                }

                if (_isItalic) {
                  fontDesc = `italic ${fontDesc}`;
                }

                return fontDesc;
              },

              _getLineHeight() {
                let nodeSpacingY = _lineHeight$1;

                if (nodeSpacingY === 0) {
                  nodeSpacingY = _fontSize$1;
                } else {
                  nodeSpacingY = nodeSpacingY * _fontSize$1 / _drawFontsize;
                }

                return nodeSpacingY | 0;
              },

              _calculateParagraphLength(paragraphedStrings, ctx) {
                const paragraphLength = [];

                for (const para of paragraphedStrings) {
                  const width = safeMeasureText(ctx, para, _fontDesc);
                  paragraphLength.push(width);
                }

                return paragraphLength;
              },

              _measureText(ctx, fontDesc) {
                return string => safeMeasureText(ctx, string, fontDesc);
              },

              _calculateShrinkFont(paragraphedStrings) {
                if (!_context) return;

                const paragraphLength = this._calculateParagraphLength(paragraphedStrings, _context);

                let i = 0;
                let totalHeight = 0;
                let maxLength = 0;

                if (_isWrapText$1) {
                  const canvasWidthNoMargin = _nodeContentSize.width;
                  const canvasHeightNoMargin = _nodeContentSize.height;

                  if (canvasWidthNoMargin < 0 || canvasHeightNoMargin < 0) {
                    return;
                  }

                  totalHeight = canvasHeightNoMargin + 1;
                  const actualFontSize = _fontSize$1 + 1;
                  let textFragment = [];
                  let left = 0;
                  let right = actualFontSize | 0;
                  let mid = 0;

                  while (left < right) {
                    mid = left + right + 1 >> 1;

                    if (mid <= 0) {
                      logID(4003);
                      break;
                    }

                    _fontSize$1 = mid;
                    _fontDesc = this._getFontDesc();
                    _context.font = _fontDesc;

                    const lineHeight = this._getLineHeight();

                    totalHeight = 0;

                    for (i = 0; i < paragraphedStrings.length; ++i) {
                      const allWidth = safeMeasureText(_context, paragraphedStrings[i], _fontDesc);
                      textFragment = fragmentText(paragraphedStrings[i], allWidth, canvasWidthNoMargin, this._measureText(_context, _fontDesc));
                      totalHeight += textFragment.length * lineHeight;
                    }

                    if (totalHeight > canvasHeightNoMargin) {
                      right = mid - 1;
                    } else {
                      left = mid;
                    }
                  }

                  if (left === 0) {
                    logID(4003);
                  } else {
                    _fontSize$1 = left;
                    _fontDesc = this._getFontDesc();
                    _context.font = _fontDesc;
                  }
                } else {
                  totalHeight = paragraphedStrings.length * this._getLineHeight();

                  for (i = 0; i < paragraphedStrings.length; ++i) {
                    if (maxLength < paragraphLength[i]) {
                      maxLength = paragraphLength[i];
                    }
                  }

                  const scaleX = (_canvasSize.width - _canvasPadding.width) / maxLength;
                  const scaleY = _canvasSize.height / totalHeight;
                  _fontSize$1 = _drawFontsize * Math.min(1, scaleX, scaleY) | 0;
                  _fontDesc = this._getFontDesc();
                  _context.font = _fontDesc;
                }
              },

              _calculateWrapText(paragraphedStrings) {
                if (!_isWrapText$1 || !_context) return;
                _splitStrings = [];
                const canvasWidthNoMargin = _nodeContentSize.width;

                for (let i = 0; i < paragraphedStrings.length; ++i) {
                  const allWidth = safeMeasureText(_context, paragraphedStrings[i], _fontDesc);
                  const textFragment = fragmentText(paragraphedStrings[i], allWidth, canvasWidthNoMargin, this._measureText(_context, _fontDesc));
                  _splitStrings = _splitStrings.concat(textFragment);
                }
              },

              _calculateLabelFont() {
                if (!_context) {
                  return;
                }

                const paragraphedStrings = _string$1.split('\n');

                _splitStrings = paragraphedStrings;
                _fontDesc = this._getFontDesc();
                _context.font = _fontDesc;

                switch (_overflow$1) {
                  case Overflow$1.NONE:
                    {
                      let canvasSizeX = 0;
                      let canvasSizeY = 0;

                      for (let i = 0; i < paragraphedStrings.length; ++i) {
                        const paraLength = safeMeasureText(_context, paragraphedStrings[i], _fontDesc);
                        canvasSizeX = canvasSizeX > paraLength ? canvasSizeX : paraLength;
                      }

                      canvasSizeY = (_splitStrings.length + BASELINE_RATIO) * this._getLineHeight();
                      const rawWidth = parseFloat(canvasSizeX.toFixed(2));
                      const rawHeight = parseFloat(canvasSizeY.toFixed(2));
                      _canvasSize.width = rawWidth + _canvasPadding.width;
                      _canvasSize.height = rawHeight + _canvasPadding.height;
                      _nodeContentSize.width = rawWidth + _contentSizeExtend.width;
                      _nodeContentSize.height = rawHeight + _contentSizeExtend.height;
                      break;
                    }

                  case Overflow$1.SHRINK:
                    {
                      this._calculateShrinkFont(paragraphedStrings);

                      this._calculateWrapText(paragraphedStrings);

                      break;
                    }

                  case Overflow$1.CLAMP:
                    {
                      this._calculateWrapText(paragraphedStrings);

                      break;
                    }

                  case Overflow$1.RESIZE_HEIGHT:
                    {
                      this._calculateWrapText(paragraphedStrings);

                      const rawHeight = (_splitStrings.length + BASELINE_RATIO) * this._getLineHeight();

                      _canvasSize.height = rawHeight + _canvasPadding.height;
                      _nodeContentSize.height = rawHeight + _contentSizeExtend.height;
                      break;
                    }
                }
              }

            };

            const WHITE$2 = Color$1.WHITE.clone();
            const ttf = {
              createData(comp) {
                const renderData = comp.requestRenderData();
                renderData.dataLength = 4;
                renderData.vertexCount = 4;
                renderData.indicesCount = 6;
                const vData = renderData.vData = new Float32Array(4 * 9);
                vData[3] = vData[21] = vData[22] = vData[31] = 0;
                vData[4] = vData[12] = vData[13] = vData[30] = 1;
                let offset = 5;

                for (let i = 0; i < 4; i++) {
                  Color$1.toArray(vData, WHITE$2, offset);
                  offset += 9;
                }

                return renderData;
              },

              fillBuffers(comp, renderer) {
                const renderData = comp.renderData;
                const dataList = renderData.data;
                const node = comp.node;
                let buffer = renderer.acquireBufferBatch();
                let vertexOffset = buffer.byteOffset >> 2;
                let indicesOffset = buffer.indicesOffset;
                let vertexId = buffer.vertexOffset;
                const isRecreate = buffer.request();

                if (!isRecreate) {
                  buffer = renderer.currBufferBatch;
                  indicesOffset = 0;
                  vertexId = 0;
                  vertexOffset = 0;
                }

                const vBuf = buffer.vData;
                const iBuf = buffer.iData;
                const vData = renderData.vData;
                const data0 = dataList[0];
                const data3 = dataList[3];
                node.updateWorldTransform();
                const pos = node._pos;
                const rot = node._rot;
                const scale = node._scale;
                const ax = data0.x * scale.x;
                const bx = data3.x * scale.x;
                const ay = data0.y * scale.y;
                const by = data3.y * scale.y;
                const qx = rot.x;
                const qy = rot.y;
                const qz = rot.z;
                const qw = rot.w;
                const qxy = qx * qy;
                const qzw = qz * qw;
                const qxy2 = qx * qx - qy * qy;
                const qzw2 = qw * qw - qz * qz;
                const cx1 = qzw2 + qxy2;
                const cx2 = (qxy - qzw) * 2;
                const cy1 = qzw2 - qxy2;
                const cy2 = (qxy + qzw) * 2;
                const x = pos.x;
                const y = pos.y;
                vData[0] = cx1 * ax + cx2 * ay + x;
                vData[1] = cy1 * ay + cy2 * ax + y;
                vData[9] = cx1 * bx + cx2 * ay + x;
                vData[10] = cy1 * ay + cy2 * bx + y;
                vData[18] = cx1 * ax + cx2 * by + x;
                vData[19] = cy1 * by + cy2 * ax + y;
                vData[27] = cx1 * bx + cx2 * by + x;
                vData[28] = cy1 * by + cy2 * bx + y;
                vBuf.set(vData, vertexOffset);
                iBuf[indicesOffset++] = vertexId;
                iBuf[indicesOffset++] = vertexId + 1;
                iBuf[indicesOffset++] = vertexId + 2;
                iBuf[indicesOffset++] = vertexId + 2;
                iBuf[indicesOffset++] = vertexId + 1;
                iBuf[indicesOffset++] = vertexId + 3;
              },

              updateVertexData(comp) {
                const renderData = comp.renderData;

                if (!renderData) {
                  return;
                }

                const uiTrans = comp.node._uiProps.uiTransformComp;
                const width = uiTrans.width;
                const height = uiTrans.height;
                const appX = uiTrans.anchorX * width;
                const appY = uiTrans.anchorY * height;
                const data = renderData.data;
                data[0].x = -appX;
                data[0].y = -appY;
                data[3].x = width - appX;
                data[3].y = height - appY;
              },

              updateUvs(comp) {
                const renderData = comp.renderData;

                if (!renderData) {
                  return;
                }

                const vData = renderData.vData;

                if (!vData || !renderData.uvDirty) {
                  return;
                }

                const uv = comp.ttfSpriteFrame.uv;
                vData[3] = uv[0];
                vData[4] = uv[1];
                vData[12] = uv[2];
                vData[13] = uv[3];
                vData[21] = uv[4];
                vData[22] = uv[5];
                vData[30] = uv[6];
                vData[31] = uv[7];
                renderData.uvDirty = false;
              }

            };
            addon(ttf, ttfUtils);

            const labelAssembler = exports('labelAssembler', {
              getAssembler(comp) {
                let assembler = ttf;

                if (comp.font instanceof BitmapFont) {
                  assembler = bmfont;
                } else if (comp.cacheMode === Label.CacheMode.CHAR) {
                  assembler = letter;
                }

                return assembler;
              }

            });
            Label.Assembler = labelAssembler;

            const FillType$1 = Sprite.FillType;
            const matrix = new Mat4();
            const tempColor$1 = new Color$1(255, 255, 255, 255);
            const barFilled = {
              useModel: false,

              updateRenderData(sprite) {
                const frame = sprite.spriteFrame;
                dynamicAtlasManager.packToDynamicAtlas(sprite, frame);
                const renderData = sprite.renderData;

                if (renderData && frame) {
                  renderData.updateRenderData(sprite, frame);
                  const uvDirty = renderData.uvDirty;
                  const vertDirty = renderData.vertDirty;

                  if (!uvDirty && !vertDirty) {
                    return;
                  }

                  let fillStart = sprite.fillStart;
                  let fillRange = sprite.fillRange;

                  if (fillRange < 0) {
                    fillStart += fillRange;
                    fillRange = -fillRange;
                  }

                  fillRange = fillStart + fillRange;
                  fillStart = fillStart > 1.0 ? 1.0 : fillStart;
                  fillStart = fillStart < 0.0 ? 0.0 : fillStart;
                  fillRange = fillRange > 1.0 ? 1.0 : fillRange;
                  fillRange = fillRange < 0.0 ? 0.0 : fillRange;
                  fillRange -= fillStart;
                  fillRange = fillRange < 0 ? 0 : fillRange;
                  let fillEnd = fillStart + fillRange;
                  fillEnd = fillEnd > 1 ? 1 : fillEnd;

                  if (uvDirty) {
                    this.updateUVs(sprite, fillStart, fillEnd);
                  }

                  if (vertDirty) {
                    if (this.updateVertexData) {
                      this.updateVertexData(sprite, fillStart, fillEnd);
                    }

                    this.updateWorldVertexData(sprite);
                  }
                }
              },

              updateUVs(sprite, fillStart, fillEnd) {
                const spriteFrame = sprite.spriteFrame;
                const renderData = sprite.renderData;
                const dataList = renderData.data;
                const atlasWidth = spriteFrame.width;
                const atlasHeight = spriteFrame.height;
                const textureRect = spriteFrame.getRect();
                let ul = 0;
                let vb = 0;
                let ur = 0;
                let vt = 0;
                let quadUV0 = 0;
                let quadUV1 = 0;
                let quadUV2 = 0;
                let quadUV3 = 0;
                let quadUV4 = 0;
                let quadUV5 = 0;
                let quadUV6 = 0;
                let quadUV7 = 0;

                if (spriteFrame.isRotated()) {
                  ul = textureRect.x / atlasWidth;
                  vb = (textureRect.y + textureRect.width) / atlasHeight;
                  ur = (textureRect.x + textureRect.height) / atlasWidth;
                  vt = textureRect.y / atlasHeight;
                  quadUV0 = quadUV2 = ul;
                  quadUV4 = quadUV6 = ur;
                  quadUV3 = quadUV7 = vb;
                  quadUV1 = quadUV5 = vt;
                } else {
                  ul = textureRect.x / atlasWidth;
                  vb = (textureRect.y + textureRect.height) / atlasHeight;
                  ur = (textureRect.x + textureRect.width) / atlasWidth;
                  vt = textureRect.y / atlasHeight;
                  quadUV0 = quadUV4 = ul;
                  quadUV2 = quadUV6 = ur;
                  quadUV1 = quadUV3 = vb;
                  quadUV5 = quadUV7 = vt;
                }

                switch (sprite.fillType) {
                  case FillType$1.HORIZONTAL:
                    dataList[0].u = quadUV0 + (quadUV2 - quadUV0) * fillStart;
                    dataList[0].v = quadUV1 + (quadUV3 - quadUV1) * fillStart;
                    dataList[1].u = quadUV0 + (quadUV2 - quadUV0) * fillEnd;
                    dataList[1].v = quadUV1 + (quadUV3 - quadUV1) * fillEnd;
                    dataList[2].u = quadUV4 + (quadUV6 - quadUV4) * fillStart;
                    dataList[2].v = quadUV5 + (quadUV7 - quadUV5) * fillStart;
                    dataList[3].u = quadUV4 + (quadUV6 - quadUV4) * fillEnd;
                    dataList[3].v = quadUV5 + (quadUV7 - quadUV5) * fillEnd;
                    break;

                  case FillType$1.VERTICAL:
                    dataList[0].u = quadUV0 + (quadUV4 - quadUV0) * fillStart;
                    dataList[0].v = quadUV1 + (quadUV5 - quadUV1) * fillStart;
                    dataList[1].u = quadUV2 + (quadUV6 - quadUV2) * fillStart;
                    dataList[1].v = quadUV3 + (quadUV7 - quadUV3) * fillStart;
                    dataList[2].u = quadUV0 + (quadUV4 - quadUV0) * fillEnd;
                    dataList[2].v = quadUV1 + (quadUV5 - quadUV1) * fillEnd;
                    dataList[3].u = quadUV2 + (quadUV6 - quadUV2) * fillEnd;
                    dataList[3].v = quadUV3 + (quadUV7 - quadUV3) * fillEnd;
                    break;

                  default:
                    errorID(2626);
                    break;
                }

                renderData.uvDirty = false;
              },

              updateVertexData(sprite, fillStart, fillEnd) {
                const renderData = sprite.renderData;
                const dataList = renderData.data;
                const uiTrans = sprite.node._uiProps.uiTransformComp;
                const width = uiTrans.width;
                const height = uiTrans.height;
                const appX = uiTrans.anchorX * width;
                const appY = uiTrans.anchorY * height;
                let l = -appX;
                let b = -appY;
                let r = width - appX;
                let t = height - appY;
                let progressStart = 0;
                let progressEnd = 0;

                switch (sprite.fillType) {
                  case FillType$1.HORIZONTAL:
                    progressStart = l + (r - l) * fillStart;
                    progressEnd = l + (r - l) * fillEnd;
                    l = progressStart;
                    r = progressEnd;
                    break;

                  case FillType$1.VERTICAL:
                    progressStart = b + (t - b) * fillStart;
                    progressEnd = b + (t - b) * fillEnd;
                    b = progressStart;
                    t = progressEnd;
                    break;

                  default:
                    errorID(2626);
                    break;
                }

                dataList[4].x = l;
                dataList[4].y = b;
                dataList[5].x = r;
                dataList[5].y = b;
                dataList[6].x = l;
                dataList[6].y = t;
                dataList[7].x = r;
                dataList[7].y = t;
                renderData.vertDirty = false;
              },

              createData(sprite) {
                const renderData = sprite.requestRenderData();
                renderData.dataLength = 8;
                renderData.vertexCount = 4;
                renderData.indicesCount = 6;
                const dataList = renderData.data;

                for (const data of dataList) {
                  data.z = 0;
                }

                return renderData;
              },

              updateWorldVertexData(sprite) {
                const node = sprite.node;
                const dataList = sprite.renderData.data;
                node.getWorldMatrix(matrix);

                for (let i = 0; i < 4; i++) {
                  const local = dataList[i + 4];
                  const world = dataList[i];
                  Vec3.transformMat4(world, local, matrix);
                }
              },

              fillBuffers(sprite, renderer) {
                if (sprite.node.hasChangedFlags) {
                  this.updateWorldVertexData(sprite);
                }

                const node = sprite.node;
                tempColor$1.set(sprite.color);
                tempColor$1.a = node._uiProps.opacity * 255;
                fillVerticesWithoutCalc3D(node, renderer, sprite.renderData, tempColor$1);
              },

              updateColor(sprite) {}

            };

            const PI_2 = Math.PI * 2;
            const EPSILON = 1e-6;
            const tempColor$2 = new Color$1(255, 255, 255, 255);
            const _vertPos = [new Vec2(), new Vec2(), new Vec2(), new Vec2()];

            const _vertices = new Array(4);

            const _uvs = new Array(8);

            const _intersectPoint_1 = [new Vec2(), new Vec2(), new Vec2(), new Vec2()];
            const _intersectPoint_2 = [new Vec2(), new Vec2(), new Vec2(), new Vec2()];

            const _center = new Vec2();

            const _triangles = [new Vec2(), new Vec2(), new Vec2(), new Vec2()];

            function _calcIntersectedPoints(left, right, bottom, top, center, angle, intersectPoints) {
              let sinAngle = Math.sin(angle);
              sinAngle = Math.abs(sinAngle) > EPSILON ? sinAngle : 0;
              let cosAngle = Math.cos(angle);
              cosAngle = Math.abs(cosAngle) > EPSILON ? cosAngle : 0;
              let tanAngle = 0;
              let cotAngle = 0;

              if (cosAngle !== 0) {
                tanAngle = sinAngle / cosAngle;

                if ((left - center.x) * cosAngle > 0) {
                  const yLeft = center.y + tanAngle * (left - center.x);
                  intersectPoints[0].x = left;
                  intersectPoints[0].y = yLeft;
                }

                if ((right - center.x) * cosAngle > 0) {
                  const yRight = center.y + tanAngle * (right - center.x);
                  intersectPoints[2].x = right;
                  intersectPoints[2].y = yRight;
                }
              }

              if (sinAngle !== 0) {
                cotAngle = cosAngle / sinAngle;

                if ((top - center.y) * sinAngle > 0) {
                  const xTop = center.x + cotAngle * (top - center.y);
                  intersectPoints[3].x = xTop;
                  intersectPoints[3].y = top;
                }

                if ((bottom - center.y) * sinAngle > 0) {
                  const xBottom = center.x + cotAngle * (bottom - center.y);
                  intersectPoints[1].x = xBottom;
                  intersectPoints[1].y = bottom;
                }
              }
            }

            function _calculateVertices(sprite) {
              const uiTrans = sprite.node._uiProps.uiTransformComp;
              const width = uiTrans.width;
              const height = uiTrans.height;
              const appX = uiTrans.anchorX * width;
              const appY = uiTrans.anchorY * height;
              const l = -appX;
              const b = -appY;
              const r = width - appX;
              const t = height - appY;
              const vertices = _vertices;
              vertices[0] = l;
              vertices[1] = b;
              vertices[2] = r;
              vertices[3] = t;
              const fillCenter = sprite.fillCenter;
              const cx = _center.x = Math.min(Math.max(0, fillCenter.x), 1) * (r - l) + l;
              const cy = _center.y = Math.min(Math.max(0, fillCenter.y), 1) * (t - b) + b;
              _vertPos[0].x = _vertPos[3].x = l;
              _vertPos[1].x = _vertPos[2].x = r;
              _vertPos[0].y = _vertPos[1].y = b;
              _vertPos[2].y = _vertPos[3].y = t;

              for (const num of _triangles) {
                Vec2.set(num, 0, 0);
              }

              if (cx !== vertices[0]) {
                Vec2.set(_triangles[0], 3, 0);
              }

              if (cx !== vertices[2]) {
                Vec2.set(_triangles[2], 1, 2);
              }

              if (cy !== vertices[1]) {
                Vec2.set(_triangles[1], 0, 1);
              }

              if (cy !== vertices[3]) {
                Vec2.set(_triangles[3], 2, 3);
              }
            }

            function _calculateUVs(spriteFrame) {
              const atlasWidth = spriteFrame.width;
              const atlasHeight = spriteFrame.height;
              const textureRect = spriteFrame.getRect();
              let u0 = 0;
              let u1 = 0;
              let v0 = 0;
              let v1 = 0;
              const uvs = _uvs;

              if (spriteFrame.isRotated()) {
                u0 = textureRect.x / atlasWidth;
                u1 = (textureRect.x + textureRect.height) / atlasWidth;
                v0 = textureRect.y / atlasHeight;
                v1 = (textureRect.y + textureRect.width) / atlasHeight;
                uvs[0] = uvs[2] = u0;
                uvs[4] = uvs[6] = u1;
                uvs[3] = uvs[7] = v1;
                uvs[1] = uvs[5] = v0;
              } else {
                u0 = textureRect.x / atlasWidth;
                u1 = (textureRect.x + textureRect.width) / atlasWidth;
                v0 = textureRect.y / atlasHeight;
                v1 = (textureRect.y + textureRect.height) / atlasHeight;
                uvs[0] = uvs[4] = u0;
                uvs[2] = uvs[6] = u1;
                uvs[1] = uvs[3] = v1;
                uvs[5] = uvs[7] = v0;
              }
            }

            function _getVertAngle(start, end) {
              const placementX = end.x - start.x;
              const placementY = end.y - start.y;

              if (placementX === 0 && placementY === 0) {
                return 0;
              } else if (placementX === 0) {
                if (placementY > 0) {
                  return Math.PI * 0.5;
                } else {
                  return Math.PI * 1.5;
                }
              } else {
                let angle = Math.atan(placementY / placementX);

                if (placementX < 0) {
                  angle += Math.PI;
                }

                return angle;
              }
            }

            function _generateTriangle(dataList, offset, vert0, vert1, vert2) {
              const vertices = _vertices;
              const v0x = vertices[0];
              const v0y = vertices[1];
              const v1x = vertices[2];
              const v1y = vertices[3];
              dataList[offset].x = vert0.x;
              dataList[offset].y = vert0.y;
              dataList[offset + 1].x = vert1.x;
              dataList[offset + 1].y = vert1.y;
              dataList[offset + 2].x = vert2.x;
              dataList[offset + 2].y = vert2.y;
              let progressX = 0;
              let progressY = 0;
              progressX = (vert0.x - v0x) / (v1x - v0x);
              progressY = (vert0.y - v0y) / (v1y - v0y);

              _generateUV(progressX, progressY, dataList, offset);

              progressX = (vert1.x - v0x) / (v1x - v0x);
              progressY = (vert1.y - v0y) / (v1y - v0y);

              _generateUV(progressX, progressY, dataList, offset + 1);

              progressX = (vert2.x - v0x) / (v1x - v0x);
              progressY = (vert2.y - v0y) / (v1y - v0y);

              _generateUV(progressX, progressY, dataList, offset + 2);
            }

            function _generateUV(progressX, progressY, data, offset) {
              const uvs = _uvs;
              const px1 = uvs[0] + (uvs[2] - uvs[0]) * progressX;
              const px2 = uvs[4] + (uvs[6] - uvs[4]) * progressX;
              const py1 = uvs[1] + (uvs[3] - uvs[1]) * progressX;
              const py2 = uvs[5] + (uvs[7] - uvs[5]) * progressX;
              const uv = data[offset];
              uv.u = px1 + (px2 - px1) * progressY;
              uv.v = py1 + (py2 - py1) * progressY;
            }

            const radialFilled = {
              useModel: false,

              createData(sprite) {
                return sprite.requestRenderData();
              },

              updateRenderData(sprite) {
                const frame = sprite.spriteFrame;
                dynamicAtlasManager.packToDynamicAtlas(sprite, frame);
                const renderData = sprite.renderData;

                if (renderData && frame) {
                  if (renderData.vertDirty || renderData.uvDirty) {
                    const dataList = renderData.data;
                    let fillStart = sprite.fillStart;
                    let fillRange = sprite.fillRange;

                    if (fillRange < 0) {
                      fillStart += fillRange;
                      fillRange = -fillRange;
                    }

                    while (fillStart >= 1.0) {
                      fillStart -= 1.0;
                    }

                    while (fillStart < 0.0) {
                      fillStart += 1.0;
                    }

                    fillStart *= PI_2;
                    fillRange *= PI_2;
                    const fillEnd = fillStart + fillRange;

                    _calculateVertices(sprite);

                    _calculateUVs(frame);

                    _calcIntersectedPoints(_vertices[0], _vertices[2], _vertices[1], _vertices[3], _center, fillStart, _intersectPoint_1);

                    _calcIntersectedPoints(_vertices[0], _vertices[2], _vertices[1], _vertices[3], _center, fillStart + fillRange, _intersectPoint_2);

                    let offset = 0;

                    for (let triangleIndex = 0; triangleIndex < 4; ++triangleIndex) {
                      const triangle = _triangles[triangleIndex];

                      if (!triangle) {
                        continue;
                      }

                      if (fillRange >= PI_2) {
                        renderData.dataLength = offset + 3;

                        _generateTriangle(dataList, offset, _center, _vertPos[triangle.x], _vertPos[triangle.y]);

                        offset += 3;
                        continue;
                      }

                      let startAngle = _getVertAngle(_center, _vertPos[triangle.x]);

                      let endAngle = _getVertAngle(_center, _vertPos[triangle.y]);

                      if (endAngle < startAngle) {
                        endAngle += PI_2;
                      }

                      startAngle -= PI_2;
                      endAngle -= PI_2;

                      for (let testIndex = 0; testIndex < 3; ++testIndex) {
                        if (startAngle >= fillEnd) ; else if (startAngle >= fillStart) {
                          renderData.dataLength = offset + 3;

                          if (endAngle >= fillEnd) {
                            _generateTriangle(dataList, offset, _center, _vertPos[triangle.x], _intersectPoint_2[triangleIndex]);
                          } else {
                            _generateTriangle(dataList, offset, _center, _vertPos[triangle.x], _vertPos[triangle.y]);
                          }

                          offset += 3;
                        } else if (endAngle > fillStart) {
                          if (endAngle <= fillEnd) {
                            renderData.dataLength = offset + 3;

                            _generateTriangle(dataList, offset, _center, _intersectPoint_1[triangleIndex], _vertPos[triangle.y]);

                            offset += 3;
                          } else {
                            renderData.dataLength = offset + 3;

                            _generateTriangle(dataList, offset, _center, _intersectPoint_1[triangleIndex], _intersectPoint_2[triangleIndex]);

                            offset += 3;
                          }
                        }

                        startAngle += PI_2;
                        endAngle += PI_2;
                      }
                    }

                    renderData.indicesCount = renderData.vertexCount = offset;
                    renderData.vertDirty = renderData.uvDirty = false;
                  }

                  renderData.updateRenderData(sprite, frame);
                }
              },

              fillBuffers(comp, renderer) {
                const node = comp.node;
                const renderData = comp.renderData;
                tempColor$2.set(comp.color);
                tempColor$2.a = node._uiProps.opacity * 255;
                fillVertices3D(node, renderer, renderData, tempColor$2);
              },

              updateColor(sprite) {}

            };

            const vec3_temps$1 = [];

            for (let i = 0; i < 4; i++) {
              vec3_temps$1.push(new Vec3());
            }

            const simple = {
              createData(sprite) {
                const renderData = sprite.requestRenderData();
                renderData.dataLength = 4;
                renderData.vertexCount = 4;
                renderData.indicesCount = 6;
                renderData.vData = new Float32Array(4 * 9);
                return renderData;
              },

              updateRenderData(sprite) {
                const frame = sprite.spriteFrame;
                dynamicAtlasManager.packToDynamicAtlas(sprite, frame);

                const renderData = sprite.renderData;

                if (renderData && frame) {
                  if (renderData.vertDirty) {
                    this.updateVertexData(sprite);
                  }

                  if (renderData.uvDirty) {
                    this.updateUvs(sprite);
                  }

                  renderData.updateRenderData(sprite, frame);
                }
              },

              updateWorldVerts(sprite, vData) {
                const renderData = sprite.renderData;
                const dataList = renderData.data;
                const node = sprite.node;
                const data0 = dataList[0];
                const data3 = dataList[3];
                const matrix = node.worldMatrix;
                const a = matrix.m00;
                const b = matrix.m01;
                const c = matrix.m04;
                const d = matrix.m05;
                const justTranslate = a === 1 && b === 0 && c === 0 && d === 1;
                const tx = matrix.m12;
                const ty = matrix.m13;
                const vl = data0.x;
                const vr = data3.x;
                const vb = data0.y;
                const vt = data3.y;

                if (justTranslate) {
                  const vltx = vl + tx;
                  const vrtx = vr + tx;
                  const vbty = vb + ty;
                  const vtty = vt + ty;
                  vData[0] = vltx;
                  vData[1] = vbty;
                  vData[9] = vrtx;
                  vData[10] = vbty;
                  vData[18] = vltx;
                  vData[19] = vtty;
                  vData[27] = vrtx;
                  vData[28] = vtty;
                } else {
                  const al = a * vl;
                  const ar = a * vr;
                  const bl = b * vl;
                  const br = b * vr;
                  const cb = c * vb;
                  const ct = c * vt;
                  const db = d * vb;
                  const dt = d * vt;
                  const cbtx = cb + tx;
                  const cttx = ct + tx;
                  const dbty = db + ty;
                  const dtty = dt + ty;
                  vData[0] = al + cbtx;
                  vData[1] = bl + dbty;
                  vData[9] = ar + cbtx;
                  vData[10] = br + dbty;
                  vData[18] = al + cttx;
                  vData[19] = bl + dtty;
                  vData[27] = ar + cttx;
                  vData[28] = br + dtty;
                }
              },

              fillBuffers(sprite, renderer) {
                if (sprite === null) {
                  return;
                }

                const vData = sprite.renderData.vData;

                if (sprite.node.hasChangedFlags) {
                  this.updateWorldVerts(sprite, vData);
                }

                let buffer = renderer.acquireBufferBatch();
                let vertexOffset = buffer.byteOffset >> 2;
                let indicesOffset = buffer.indicesOffset;
                let vertexId = buffer.vertexOffset;
                const bufferUnchanged = buffer.request();

                if (!bufferUnchanged) {
                  buffer = renderer.currBufferBatch;
                  vertexOffset = 0;
                  indicesOffset = 0;
                  vertexId = 0;
                }

                const vBuf = buffer.vData;
                const iBuf = buffer.iData;
                vBuf.set(vData, vertexOffset);
                const index0 = vertexId;
                const index1 = vertexId + 1;
                const index2 = vertexId + 2;
                const index3 = vertexId + 3;
                iBuf[indicesOffset++] = index0;
                iBuf[indicesOffset++] = index1;
                iBuf[indicesOffset++] = index2;
                iBuf[indicesOffset++] = index2;
                iBuf[indicesOffset++] = index1;
                iBuf[indicesOffset++] = index3;
              },

              updateVertexData(sprite) {
                const renderData = sprite.renderData;

                if (!renderData) {
                  return;
                }

                const uiTrans = sprite.node._uiProps.uiTransformComp;
                const dataList = renderData.data;
                const cw = uiTrans.width;
                const ch = uiTrans.height;
                const appX = uiTrans.anchorX * cw;
                const appY = uiTrans.anchorY * ch;
                let l = 0;
                let b = 0;
                let r = 0;
                let t = 0;

                if (sprite.trim) {
                  l = -appX;
                  b = -appY;
                  r = cw - appX;
                  t = ch - appY;
                } else {
                  const frame = sprite.spriteFrame;
                  const originSize = frame.getOriginalSize();
                  const rect = frame.getRect();
                  const ow = originSize.width;
                  const oh = originSize.height;
                  const rw = rect.width;
                  const rh = rect.height;
                  const offset = frame.getOffset();
                  const scaleX = cw / ow;
                  const scaleY = ch / oh;
                  const trimLeft = offset.x + (ow - rw) / 2;
                  const trimRight = offset.x - (ow - rw) / 2;
                  const trimBottom = offset.y + (oh - rh) / 2;
                  const trimTop = offset.y - (oh - rh) / 2;
                  l = trimLeft * scaleX - appX;
                  b = trimBottom * scaleY - appY;
                  r = cw + trimRight * scaleX - appX;
                  t = ch + trimTop * scaleY - appY;
                }

                dataList[0].x = l;
                dataList[0].y = b;
                dataList[3].x = r;
                dataList[3].y = t;
                renderData.vertDirty = false;
                this.updateWorldVerts(sprite, renderData.vData);
              },

              updateUvs(sprite) {
                const renderData = sprite.renderData;
                const vData = renderData.vData;
                const uv = sprite.spriteFrame.uv;
                vData[3] = uv[0];
                vData[4] = uv[1];
                vData[12] = uv[2];
                vData[13] = uv[3];
                vData[21] = uv[4];
                vData[22] = uv[5];
                vData[30] = uv[6];
                vData[31] = uv[7];
                renderData.uvDirty = false;
              },

              updateColor(sprite) {
                const vData = sprite.renderData.vData;
                let colorOffset = 5;
                const color = sprite.color;
                const colorR = color.r / 255;
                const colorG = color.g / 255;
                const colorB = color.b / 255;
                const colorA = sprite.node._uiProps.opacity;

                for (let i = 0; i < 4; i++) {
                  vData[colorOffset] = colorR;
                  vData[colorOffset + 1] = colorG;
                  vData[colorOffset + 2] = colorB;
                  vData[colorOffset + 3] = colorA;
                  colorOffset += 9;
                }
              }

            };

            const vec3_temp$1 = new Vec3();
            const matrix$1 = new Mat4();
            const sliced = {
              useModel: false,

              createData(sprite) {
                const renderData = sprite.requestRenderData();
                renderData.dataLength = 20;
                renderData.vertexCount = 16;
                renderData.indicesCount = 54;
                return renderData;
              },

              updateRenderData(sprite) {
                const frame = sprite.spriteFrame;
                dynamicAtlasManager.packToDynamicAtlas(sprite, frame);
                const renderData = sprite.renderData;

                if (renderData && frame) {
                  const vertDirty = renderData.vertDirty;

                  if (vertDirty) {
                    this.updateVertexData(sprite);
                    this.updateWorldVertexData(sprite);
                  }

                  renderData.updateRenderData(sprite, frame);
                }
              },

              updateVertexData(sprite) {
                const renderData = sprite.renderData;
                const dataList = renderData.data;
                const uiTrans = sprite.node._uiProps.uiTransformComp;
                const width = uiTrans.width;
                const height = uiTrans.height;
                const appX = uiTrans.anchorX * width;
                const appY = uiTrans.anchorY * height;
                const frame = sprite.spriteFrame;
                const leftWidth = frame.insetLeft;
                const rightWidth = frame.insetRight;
                const topHeight = frame.insetTop;
                const bottomHeight = frame.insetBottom;
                let sizableWidth = width - leftWidth - rightWidth;
                let sizableHeight = height - topHeight - bottomHeight;
                let xScale = width / (leftWidth + rightWidth);
                let yScale = height / (topHeight + bottomHeight);
                xScale = Number.isNaN(xScale) || xScale > 1 ? 1 : xScale;
                yScale = Number.isNaN(yScale) || yScale > 1 ? 1 : yScale;
                sizableWidth = sizableWidth < 0 ? 0 : sizableWidth;
                sizableHeight = sizableHeight < 0 ? 0 : sizableHeight;
                dataList[0].x = -appX;
                dataList[0].y = -appY;
                dataList[1].x = leftWidth * xScale - appX;
                dataList[1].y = bottomHeight * yScale - appY;
                dataList[2].x = dataList[1].x + sizableWidth;
                dataList[2].y = dataList[1].y + sizableHeight;
                dataList[3].x = width - appX;
                dataList[3].y = height - appY;
                renderData.vertDirty = false;
              },

              fillBuffers(sprite, renderer) {
                if (sprite.node.hasChangedFlags) {
                  this.updateWorldVertexData(sprite);
                }

                let buffer = renderer.acquireBufferBatch();
                const renderData = sprite.renderData;
                const dataList = renderData.data;
                let vertexOffset = buffer.byteOffset >> 2;
                const vertexCount = renderData.vertexCount;
                let indicesOffset = buffer.indicesOffset;
                let vertexId = buffer.vertexOffset;
                const uvSliced = sprite.spriteFrame.uvSliced;
                const isRecreate = buffer.request(vertexCount, renderData.indicesCount);

                if (!isRecreate) {
                  buffer = renderer.currBufferBatch;
                  vertexOffset = 0;
                  indicesOffset = 0;
                  vertexId = 0;
                }

                const vBuf = buffer.vData;
                const iBuf = buffer.iData;

                for (let i = 4; i < 20; ++i) {
                  const vert = dataList[i];
                  const uvs = uvSliced[i - 4];
                  vBuf[vertexOffset++] = vert.x;
                  vBuf[vertexOffset++] = vert.y;
                  vBuf[vertexOffset++] = vert.z;
                  vBuf[vertexOffset++] = uvs.u;
                  vBuf[vertexOffset++] = uvs.v;
                  Color$1.toArray(vBuf, dataList[i].color, vertexOffset);
                  vertexOffset += 4;
                }

                for (let r = 0; r < 3; ++r) {
                  for (let c = 0; c < 3; ++c) {
                    const start = vertexId + r * 4 + c;
                    iBuf[indicesOffset++] = start;
                    iBuf[indicesOffset++] = start + 1;
                    iBuf[indicesOffset++] = start + 4;
                    iBuf[indicesOffset++] = start + 1;
                    iBuf[indicesOffset++] = start + 5;
                    iBuf[indicesOffset++] = start + 4;
                  }
                }
              },

              updateWorldVertexData(sprite) {
                const node = sprite.node;
                const dataList = sprite.renderData.data;
                node.getWorldMatrix(matrix$1);

                for (let row = 0; row < 4; ++row) {
                  const rowD = dataList[row];

                  for (let col = 0; col < 4; ++col) {
                    const colD = dataList[col];
                    const world = dataList[4 + row * 4 + col];
                    Vec3.set(vec3_temp$1, colD.x, rowD.y, 0);
                    Vec3.transformMat4(world, vec3_temp$1, matrix$1);
                  }
                }
              },

              updateColor(sprite) {
                const datalist = sprite.renderData.data;
                const color = sprite.color;
                const colorR = color.r;
                const colorG = color.g;
                const colorB = color.b;
                const colorA = sprite.node._uiProps.opacity * 255;

                for (let i = 4; i < 20; i++) {
                  datalist[i].color.r = colorR;
                  datalist[i].color.g = colorG;
                  datalist[i].color.b = colorB;
                  datalist[i].color.a = colorA;
                }
              }

            };

            const vec3_temps$2 = [];

            for (let i = 0; i < 4; i++) {
              vec3_temps$2.push(new Vec3());
            }

            const _perVertexLength = 9;
            const tiled = {
              createData(sprite) {
                return sprite.requestRenderData();
              },

              updateRenderData(sprite) {
                const renderData = sprite.renderData;
                const frame = sprite.spriteFrame;

                if (!frame || !renderData) {
                  return;
                }

                renderData.updateRenderData(sprite, frame);

                if (!renderData.uvDirty && !renderData.vertDirty) {
                  return;
                }

                const uiTrans = sprite.node._uiProps.uiTransformComp;
                const contentWidth = Math.abs(uiTrans.width);
                const contentHeight = Math.abs(uiTrans.height);
                const rect = frame.getRect();
                const leftWidth = frame.insetLeft;
                const rightWidth = frame.insetRight;
                const centerWidth = rect.width - leftWidth - rightWidth;
                const topHeight = frame.insetTop;
                const bottomHeight = frame.insetBottom;
                const centerHeight = rect.height - topHeight - bottomHeight;
                let sizableWidth = contentWidth - leftWidth - rightWidth;
                let sizableHeight = contentHeight - topHeight - bottomHeight;
                sizableWidth = sizableWidth > 0 ? sizableWidth : 0;
                sizableHeight = sizableHeight > 0 ? sizableHeight : 0;
                const hRepeat = centerWidth === 0 ? sizableWidth : sizableWidth / centerWidth;
                const vRepeat = centerHeight === 0 ? sizableHeight : sizableHeight / centerHeight;
                const row = Math.ceil(vRepeat + 2);
                const col = Math.ceil(hRepeat + 2);
                renderData.dataLength = Math.max(8, row + 1, col + 1);
                this.updateVerts(sprite, sizableWidth, sizableHeight, row, col);
                renderData.vertexCount = row * col * 4;
                renderData.indicesCount = row * col * 6;
                renderData.uvDirty = false;
                renderData.vertDirty = false;
                this.updateColor(sprite);
              },

              fillBuffers(sprite, renderer) {
                const node = sprite.node;
                const uiTrans = sprite.node._uiProps.uiTransformComp;
                const contentWidth = Math.abs(uiTrans.width);
                const contentHeight = Math.abs(uiTrans.height);
                const renderData = sprite.renderData;
                let buffer = renderer.acquireBufferBatch();
                let indicesOffset = buffer.indicesOffset;
                let vertexOffset = buffer.byteOffset >> 2;
                let vertexId = buffer.vertexOffset;
                const vertexCount = renderData.vertexCount;
                const indicesCount = renderData.indicesCount;
                const vBuf = buffer.vData;
                const iBuf = buffer.iData;
                const isRecreate = buffer.request(vertexCount, indicesCount);

                if (!isRecreate) {
                  buffer = renderer.currBufferBatch;
                  vertexOffset = 0;
                  indicesOffset = 0;
                  vertexId = 0;
                }

                const frame = sprite.spriteFrame;
                const rotated = frame.isRotated();
                const uv = frame.uv;
                const uvSliced = sprite.spriteFrame.uvSliced;
                const rect = frame.getRect();
                const leftWidth = frame.insetLeft;
                const rightWidth = frame.insetRight;
                const centerWidth = rect.width - leftWidth - rightWidth;
                const topHeight = frame.insetTop;
                const bottomHeight = frame.insetBottom;
                const centerHeight = rect.height - topHeight - bottomHeight;
                let sizableWidth = contentWidth - leftWidth - rightWidth;
                let sizableHeight = contentHeight - topHeight - bottomHeight;
                sizableWidth = sizableWidth > 0 ? sizableWidth : 0;
                sizableHeight = sizableHeight > 0 ? sizableHeight : 0;
                const hRepeat = centerWidth === 0 ? sizableWidth : sizableWidth / centerWidth;
                const vRepeat = centerHeight === 0 ? sizableHeight : sizableHeight / centerHeight;
                const row = Math.ceil(vRepeat + 2);
                const col = Math.ceil(hRepeat + 2);
                const matrix = node.worldMatrix;
                const datalist = renderData.data;
                this.fillVertices(vBuf, vertexOffset, matrix, row, col, datalist);
                const offset = _perVertexLength;
                const offset1 = offset;
                const offset2 = offset * 2;
                const offset3 = offset * 3;
                const offset4 = offset * 4;
                let coefU = 0;
                let coefV = 0;
                const tempXVerts = [];
                const tempYVerts = [];

                for (let yIndex = 0, yLength = row; yIndex < yLength; ++yIndex) {
                  if (sizableHeight > centerHeight) {
                    if (sizableHeight >= yIndex * centerHeight) {
                      coefV = 1;
                    } else {
                      coefV = vRepeat % 1;
                    }
                  } else {
                    coefV = vRepeat;
                  }

                  for (let xIndex = 0, xLength = col; xIndex < xLength; ++xIndex) {
                    if (sizableWidth > centerWidth) {
                      if (sizableWidth >= xIndex * centerWidth) {
                        coefU = 1;
                      } else {
                        coefU = hRepeat % 1;
                      }
                    } else {
                      coefU = hRepeat;
                    }

                    const vertexOffsetU = vertexOffset + 3;
                    const vertexOffsetV = vertexOffsetU + 1;

                    if (rotated) {
                      if (yIndex === 0) {
                        tempXVerts[0] = uvSliced[0].u;
                        tempXVerts[1] = uvSliced[0].u;
                        tempXVerts[2] = uvSliced[4].u + (uvSliced[8].u - uvSliced[4].u) * coefV;
                      } else if (yIndex < row - 1) {
                        tempXVerts[0] = uvSliced[4].u;
                        tempXVerts[1] = uvSliced[4].u;
                        tempXVerts[2] = uvSliced[4].u + (uvSliced[8].u - uvSliced[4].u) * coefV;
                      } else if (yIndex === row - 1) {
                        tempXVerts[0] = uvSliced[8].u;
                        tempXVerts[1] = uvSliced[8].u;
                        tempXVerts[2] = uvSliced[12].u;
                      }

                      if (xIndex === 0) {
                        tempYVerts[0] = uvSliced[0].v;
                        tempYVerts[1] = uvSliced[1].v + (uvSliced[2].v - uvSliced[1].v) * coefU;
                        tempYVerts[2] = uvSliced[0].v;
                      } else if (xIndex < col - 1) {
                        tempYVerts[0] = uvSliced[1].v;
                        tempYVerts[1] = uvSliced[1].v + (uvSliced[2].v - uvSliced[1].v) * coefU;
                        tempYVerts[2] = uvSliced[1].v;
                      } else if (xIndex === col - 1) {
                        tempYVerts[0] = uvSliced[2].v;
                        tempYVerts[1] = uvSliced[3].v;
                        tempYVerts[2] = uvSliced[2].v;
                      }

                      tempXVerts[3] = tempXVerts[2];
                      tempYVerts[3] = tempYVerts[1];
                    } else {
                      if (xIndex === 0) {
                        tempXVerts[0] = uvSliced[0].u;
                        tempXVerts[1] = uvSliced[1].u + (uvSliced[2].u - uvSliced[1].u) * coefU;
                        tempXVerts[2] = uv[0];
                      } else if (xIndex < col - 1) {
                        tempXVerts[0] = uvSliced[1].u;
                        tempXVerts[1] = uvSliced[1].u + (uvSliced[2].u - uvSliced[1].u) * coefU;
                        tempXVerts[2] = uvSliced[1].u;
                      } else if (xIndex === col - 1) {
                        tempXVerts[0] = uvSliced[2].u;
                        tempXVerts[1] = uvSliced[3].u;
                        tempXVerts[2] = uvSliced[2].u;
                      }

                      if (yIndex === 0) {
                        tempYVerts[0] = uvSliced[0].v;
                        tempYVerts[1] = uvSliced[0].v;
                        tempYVerts[2] = uvSliced[4].v + (uvSliced[8].v - uvSliced[4].v) * coefV;
                      } else if (yIndex < row - 1) {
                        tempYVerts[0] = uvSliced[4].v;
                        tempYVerts[1] = uvSliced[4].v;
                        tempYVerts[2] = uvSliced[4].v + (uvSliced[8].v - uvSliced[4].v) * coefV;
                      } else if (yIndex === row - 1) {
                        tempYVerts[0] = uvSliced[8].v;
                        tempYVerts[1] = uvSliced[8].v;
                        tempYVerts[2] = uvSliced[12].v;
                      }

                      tempXVerts[3] = tempXVerts[1];
                      tempYVerts[3] = tempYVerts[2];
                    }

                    vBuf[vertexOffsetU] = tempXVerts[0];
                    vBuf[vertexOffsetV] = tempYVerts[0];
                    vBuf[vertexOffsetU + offset1] = tempXVerts[1];
                    vBuf[vertexOffsetV + offset1] = tempYVerts[1];
                    vBuf[vertexOffsetU + offset2] = tempXVerts[2];
                    vBuf[vertexOffsetV + offset2] = tempYVerts[2];
                    vBuf[vertexOffsetU + offset3] = tempXVerts[3];
                    vBuf[vertexOffsetV + offset3] = tempYVerts[3];
                    Color$1.toArray(vBuf, datalist[0].color, vertexOffsetV + 1);
                    Color$1.toArray(vBuf, datalist[0].color, vertexOffsetV + offset1 + 1);
                    Color$1.toArray(vBuf, datalist[0].color, vertexOffsetV + offset2 + 1);
                    Color$1.toArray(vBuf, datalist[0].color, vertexOffsetV + offset3 + 1);
                    vertexOffset += offset4;
                  }
                }

                for (let i = 0; i < indicesCount; i += 6) {
                  iBuf[indicesOffset++] = vertexId;
                  iBuf[indicesOffset++] = vertexId + 1;
                  iBuf[indicesOffset++] = vertexId + 2;
                  iBuf[indicesOffset++] = vertexId + 1;
                  iBuf[indicesOffset++] = vertexId + 3;
                  iBuf[indicesOffset++] = vertexId + 2;
                  vertexId += 4;
                }
              },

              fillVertices(vBuf, vertexOffset, matrix, row, col, dataList) {
                let x = 0;
                let x1 = 0;
                let y = 0;
                let y1 = 0;

                for (let yIndex = 0, yLength = row; yIndex < yLength; ++yIndex) {
                  y = dataList[yIndex].y;
                  y1 = dataList[yIndex + 1].y;

                  for (let xIndex = 0, xLength = col; xIndex < xLength; ++xIndex) {
                    x = dataList[xIndex].x;
                    x1 = dataList[xIndex + 1].x;
                    Vec3.set(vec3_temps$2[0], x, y, 0);
                    Vec3.set(vec3_temps$2[1], x1, y, 0);
                    Vec3.set(vec3_temps$2[2], x, y1, 0);
                    Vec3.set(vec3_temps$2[3], x1, y1, 0);

                    for (let i = 0; i < 4; i++) {
                      const vec3_temp = vec3_temps$2[i];
                      Vec3.transformMat4(vec3_temp, vec3_temp, matrix);
                      const offset = i * _perVertexLength;
                      vBuf[vertexOffset + offset] = vec3_temp.x;
                      vBuf[vertexOffset + offset + 1] = vec3_temp.y;
                      vBuf[vertexOffset + offset + 2] = vec3_temp.z;
                    }

                    vertexOffset += 36;
                  }
                }
              },

              updateVerts(sprite, sizableWidth, sizableHeight, row, col) {
                const uiTrans = sprite.node._uiProps.uiTransformComp;
                const renderData = sprite.renderData;
                const data = renderData.data;
                const frame = sprite.spriteFrame;
                const rect = frame.getRect();
                const contentWidth = Math.abs(uiTrans.width);
                const contentHeight = Math.abs(uiTrans.height);
                const appx = uiTrans.anchorX * contentWidth;
                const appy = uiTrans.anchorY * contentHeight;
                const leftWidth = frame.insetLeft;
                const rightWidth = frame.insetRight;
                const centerWidth = rect.width - leftWidth - rightWidth;
                const topHeight = frame.insetTop;
                const bottomHeight = frame.insetBottom;
                const centerHeight = rect.height - topHeight - bottomHeight;
                const xScale = uiTrans.width / (leftWidth + rightWidth) > 1 ? 1 : uiTrans.width / (leftWidth + rightWidth);
                const yScale = uiTrans.height / (topHeight + bottomHeight) > 1 ? 1 : uiTrans.height / (topHeight + bottomHeight);
                let offsetWidth = 0;
                let offsetHeight = 0;

                if (centerWidth > 0) {
                  offsetWidth = Math.floor(sizableWidth * 1000) / 1000 % centerWidth === 0 ? centerWidth : sizableWidth % centerWidth;
                } else {
                  offsetWidth = sizableWidth;
                }

                if (centerHeight > 0) {
                  offsetHeight = Math.floor(sizableHeight * 1000) / 1000 % centerHeight === 0 ? centerHeight : sizableHeight % centerHeight;
                } else {
                  offsetHeight = sizableHeight;
                }

                for (let i = 0; i <= col; i++) {
                  if (i === 0) {
                    data[i].x = -appx;
                  } else if (i > 0 && i < col) {
                    if (i === 1) {
                      data[i].x = leftWidth * xScale + Math.min(centerWidth, sizableWidth) - appx;
                    } else if (centerWidth > 0) {
                      if (i === col - 1) {
                        data[i].x = leftWidth + offsetWidth + centerWidth * (i - 2) - appx;
                      } else {
                        data[i].x = leftWidth + Math.min(centerWidth, sizableWidth) + centerWidth * (i - 2) - appx;
                      }
                    } else {
                      data[i].x = leftWidth + sizableWidth - appx;
                    }
                  } else if (i === col) {
                    data[i].x = Math.min(leftWidth + sizableWidth + rightWidth, contentWidth) - appx;
                  }
                }

                for (let i = 0; i <= row; i++) {
                  if (i === 0) {
                    data[i].y = -appy;
                  } else if (i > 0 && i < row) {
                    if (i === 1) {
                      data[i].y = bottomHeight * yScale + Math.min(centerHeight, sizableHeight) - appy;
                    } else if (centerHeight > 0) {
                      if (i === row - 1) {
                        data[i].y = bottomHeight + offsetHeight + (i - 2) * centerHeight - appy;
                      } else {
                        data[i].y = bottomHeight + Math.min(centerHeight, sizableHeight) + (i - 2) * centerHeight - appy;
                      }
                    } else {
                      data[i].y = bottomHeight + sizableHeight - appy;
                    }
                  } else if (i === row) {
                    data[i].y = Math.min(bottomHeight + sizableHeight + topHeight, contentHeight) - appy;
                  }
                }
              },

              updateColor(sprite) {
                const datalist = sprite.renderData.data;
                const length = datalist.length;
                if (length === 0) return;
                const color = sprite.color;
                const colorR = color.r;
                const colorG = color.g;
                const colorB = color.b;
                const colorA = sprite.node._uiProps.opacity * 255;

                for (let i = 0; i < length; i++) {
                  datalist[i].color.r = colorR;
                  datalist[i].color.g = colorG;
                  datalist[i].color.b = colorB;
                  datalist[i].color.a = colorA;
                }
              }

            };

            const SpriteType$1 = Sprite.Type;
            const FillType$2 = Sprite.FillType;
            const spriteAssembler = exports('spriteAssembler', {
              getAssembler(spriteComp) {
                let util = simple;
                const comp = spriteComp;

                switch (comp.type) {
                  case SpriteType$1.SLICED:
                    util = sliced;
                    break;

                  case SpriteType$1.TILED:
                    util = tiled;
                    break;

                  case SpriteType$1.FILLED:
                    if (comp.fillType === FillType$2.RADIAL) {
                      util = radialFilled;
                    } else {
                      util = barFilled;
                    }

                    break;
                }

                return util;
              }

            });
            Sprite.Assembler = spriteAssembler;

            const _stencilManager = StencilManager.sharedManager;

            function applyClearMask(mask, renderer) {
              _stencilManager.clear(mask);

              renderer.commitModel(mask, mask._clearModel, mask._clearStencilMtl);
            }

            function applyAreaMask(mask, renderer) {
              _stencilManager.enterLevel(mask);

              if (mask.type === MaskType.IMAGE_STENCIL) {
                simple.fillBuffers(mask, renderer);
                const mat = mask.graphics.getMaterialInstance(0);
                renderer.forceMergeBatches(mat, mask.spriteFrame, mask.graphics);
              } else {
                mask.graphics.updateAssembler(renderer);
              }
            }

            const maskAssembler = {
              createData(mask) {
                const renderData = mask.requestRenderData();
                renderData.dataLength = 4;
                renderData.vertexCount = 4;
                renderData.indicesCount = 6;
                renderData.vData = new Float32Array(4 * 9);
                return renderData;
              },

              updateRenderData(mask) {
                if (mask.type === MaskType.IMAGE_STENCIL) {
                  simple.updateRenderData(mask);
                  simple.updateColor(mask);
                }
              },

              fillBuffers(mask, renderer) {
                if (mask.type !== MaskType.IMAGE_STENCIL || mask.spriteFrame) {
                  _stencilManager.pushMask(mask);

                  renderer.finishMergeBatches();
                  applyClearMask(mask, renderer);
                  applyAreaMask(mask, renderer);

                  _stencilManager.enableMask();
                }
              }

            };
            const maskEndAssembler = {
              fillBuffers(mask, ui) {
                _stencilManager.exitMask();
              }

            };
            const StartAssembler = {
              getAssembler() {
                return maskAssembler;
              }

            };
            const PostAssembler = {
              getAssembler() {
                return maskEndAssembler;
              }

            };
            Mask.Assembler = StartAssembler;
            Mask.PostAssembler = PostAssembler;

            class PointerEventDispatcher {
              constructor() {
                this._isListDirty = false;
                this._inDispatchCount = 0;
                this._pointerEventProcessorList = [];
                this._processorListToAdd = [];
                this._processorListToRemove = [];
                input.on(Input.EventType.MOUSE_DOWN, this.dispatchEventMouse, this);
                input.on(Input.EventType.MOUSE_MOVE, this.dispatchEventMouse, this);
                input.on(Input.EventType.MOUSE_UP, this.dispatchEventMouse, this);
                input.on(Input.EventType.MOUSE_WHEEL, this.dispatchEventMouse, this);
                input.on(Input.EventType.TOUCH_START, this.dispatchEventTouch, this);
                input.on(Input.EventType.TOUCH_MOVE, this.dispatchEventTouch, this);
                input.on(Input.EventType.TOUCH_END, this.dispatchEventTouch, this);
                input.on(Input.EventType.TOUCH_CANCEL, this.dispatchEventTouch, this);
                NodeEventProcessor.callbacksInvoker.on(DispatcherEventType.ADD_POINTER_EVENT_PROCESSOR, this.addPointerEventProcessor, this);
                NodeEventProcessor.callbacksInvoker.on(DispatcherEventType.REMOVE_POINTER_EVENT_PROCESSOR, this.removePointerEventProcessor, this);
              }

              addPointerEventProcessor(pointerEventProcessor) {
                if (this._inDispatchCount === 0) {
                  this._pointerEventProcessorList.push(pointerEventProcessor);

                  this._isListDirty = true;
                } else {
                  this._processorListToAdd.push(pointerEventProcessor);
                }
              }

              removePointerEventProcessor(pointerEventProcessor) {
                if (this._inDispatchCount === 0) {
                  js.array.remove(this._pointerEventProcessorList, pointerEventProcessor);
                  this._isListDirty = true;
                } else {
                  this._processorListToRemove.push(pointerEventProcessor);
                }
              }

              dispatchEventMouse(eventMouse) {
                this._inDispatchCount++;

                this._sortPointerEventProcessorList();

                const pointerEventProcessorList = this._pointerEventProcessorList;
                const length = pointerEventProcessorList.length;
                let shouldDispatchToSystemEvent = true;

                for (let i = 0; i < length; ++i) {
                  const pointerEventProcessor = pointerEventProcessorList[i];

                  if (pointerEventProcessor.isEnabled && pointerEventProcessor.shouldHandleEventMouse && pointerEventProcessor._handleEventMouse(eventMouse)) {
                    shouldDispatchToSystemEvent = false;

                    if (!eventMouse.preventSwallow) {
                      break;
                    }
                  }
                }

                const type = pointerEvent2SystemEvent[eventMouse.type];

                if (shouldDispatchToSystemEvent && type) {
                  input._eventTarget.emit(type, eventMouse);
                }

                if (--this._inDispatchCount <= 0) {
                  this._updatePointerEventProcessorList();
                }
              }

              dispatchEventTouch(eventTouch) {
                this._inDispatchCount++;

                this._sortPointerEventProcessorList();

                const pointerEventProcessorList = this._pointerEventProcessorList;
                const length = pointerEventProcessorList.length;
                const touch = eventTouch.touch;
                let shouldDispatchToSystemEvent = true;

                for (let i = 0; i < length; ++i) {
                  const pointerEventProcessor = pointerEventProcessorList[i];

                  if (pointerEventProcessor.isEnabled && pointerEventProcessor.shouldHandleEventTouch) {
                    if (eventTouch.type === InputEventType.TOUCH_START) {
                      if (pointerEventProcessor._handleEventTouch(eventTouch)) {
                        pointerEventProcessor.claimedTouchIdList.push(touch.getID());
                        shouldDispatchToSystemEvent = false;

                        if (!eventTouch.preventSwallow) {
                          break;
                        }
                      }
                    } else if (pointerEventProcessor.claimedTouchIdList.length > 0) {
                      const index = pointerEventProcessor.claimedTouchIdList.indexOf(touch.getID());

                      if (index !== -1) {
                        pointerEventProcessor._handleEventTouch(eventTouch);

                        if (eventTouch.type === InputEventType.TOUCH_END || eventTouch.type === InputEventType.TOUCH_CANCEL) {
                          js.array.removeAt(pointerEventProcessor.claimedTouchIdList, index);
                        }

                        shouldDispatchToSystemEvent = false;

                        if (!eventTouch.preventSwallow) {
                          break;
                        }
                      }
                    }
                  }
                }

                const type = pointerEvent2SystemEvent[eventTouch.type];

                if (shouldDispatchToSystemEvent && type) {
                  input._eventTarget.emit(type, eventTouch.touch, eventTouch);
                }

                if (--this._inDispatchCount <= 0) {
                  this._updatePointerEventProcessorList();
                }
              }

              _updatePointerEventProcessorList() {
                const listToAdd = this._processorListToAdd;
                const addLength = listToAdd.length;

                for (let i = 0; i < addLength; ++i) {
                  this.addPointerEventProcessor(listToAdd[i]);
                }

                listToAdd.length = 0;
                const listToRemove = this._processorListToRemove;
                const removeLength = listToRemove.length;

                for (let i = 0; i < removeLength; ++i) {
                  this.removePointerEventProcessor(listToRemove[i]);
                }

                listToRemove.length = 0;
              }

              _sortPointerEventProcessorList() {
                if (!this._isListDirty) {
                  return;
                }

                const pointerEventProcessorList = this._pointerEventProcessorList;
                const length = pointerEventProcessorList.length;

                for (let i = 0; i < length; ++i) {
                  const pointerEventProcessor = pointerEventProcessorList[i];
                  const node = pointerEventProcessor.node;
                  const trans = node._uiProps.uiTransformComp;
                  pointerEventProcessor.cachedCameraPriority = trans.cameraPriority;
                }

                pointerEventProcessorList.sort(this._sortByPriority);
                this._isListDirty = false;
              }

              _sortByPriority(p1, p2) {
                const node1 = p1.node;
                const node2 = p2.node;

                if (!p2 || !node2 || !node2.activeInHierarchy || !node2._uiProps.uiTransformComp) {
                  return -1;
                } else if (!p1 || !node1 || !node1.activeInHierarchy || !node1._uiProps.uiTransformComp) {
                  return 1;
                }

                if (p1.cachedCameraPriority !== p2.cachedCameraPriority) {
                  return p2.cachedCameraPriority - p1.cachedCameraPriority;
                }

                let n1 = node1;
                let n2 = node2;
                let ex = false;

                while (((_n1$parent = n1.parent) === null || _n1$parent === void 0 ? void 0 : _n1$parent._id) !== ((_n2$parent = n2.parent) === null || _n2$parent === void 0 ? void 0 : _n2$parent._id)) {
                  var _n1$parent, _n2$parent, _n, _n$parent, _n2, _n2$parent2;

                  n1 = ((_n = n1) === null || _n === void 0 ? void 0 : (_n$parent = _n.parent) === null || _n$parent === void 0 ? void 0 : _n$parent.parent) === null ? (ex = true) && node2 : n1 && n1.parent;
                  n2 = ((_n2 = n2) === null || _n2 === void 0 ? void 0 : (_n2$parent2 = _n2.parent) === null || _n2$parent2 === void 0 ? void 0 : _n2$parent2.parent) === null ? (ex = true) && node1 : n2 && n2.parent;
                }

                if (n1._id === n2._id) {
                  if (n1._id === node2._id) {
                    return -1;
                  }

                  if (n1._id === node1._id) {
                    return 1;
                  }
                }

                const priority1 = n1 ? n1.getSiblingIndex() : 0;
                const priority2 = n2 ? n2.getSiblingIndex() : 0;
                return ex ? priority1 - priority2 : priority2 - priority1;
              }

            }

            const pointerEventDispatcher = new PointerEventDispatcher();

            const _dsInfo = new DescriptorSetInfo(null);

            const m4_1$5 = new Mat4();
            class Batcher2D {
              get currBufferBatch() {
                if (this._currMeshBuffer) return this._currMeshBuffer;
                this._currMeshBuffer = this.acquireBufferBatch();
                return this._currMeshBuffer;
              }

              set currBufferBatch(buffer) {
                if (buffer) {
                  this._currMeshBuffer = buffer;
                }
              }

              get batches() {
                return this._batches;
              }

              acquireBufferBatch(attributes = vfmtPosUvColor) {
                const strideBytes = attributes === vfmtPosUvColor ? 36 : getAttributeStride(attributes);

                if (!this._currMeshBuffer || this._currMeshBuffer.vertexFormatBytes !== strideBytes) {
                  this._requireBufferBatch(attributes);

                  return this._currMeshBuffer;
                }

                return this._currMeshBuffer;
              }

              registerCustomBuffer(attributes, callback) {
                let batch;

                if (attributes instanceof MeshBuffer) {
                  batch = attributes;
                } else {
                  batch = this._bufferBatchPool.add();
                  batch.initialize(attributes, callback || this._recreateMeshBuffer.bind(this, attributes));
                }

                const strideBytes = batch.vertexFormatBytes;

                let buffers = this._customMeshBuffers.get(strideBytes);

                if (!buffers) {
                  buffers = [];

                  this._customMeshBuffers.set(strideBytes, buffers);
                }

                buffers.push(batch);
                return batch;
              }

              unRegisterCustomBuffer(buffer) {
                const buffers = this._customMeshBuffers.get(buffer.vertexFormatBytes);

                if (buffers) {
                  for (let i = 0; i < buffers.length; i++) {
                    if (buffers[i] === buffer) {
                      buffers.splice(i, 1);
                      break;
                    }
                  }
                }

                const idx = this._bufferBatchPool.data.indexOf(buffer);

                if (idx !== -1) {
                  buffer.reset();

                  this._bufferBatchPool.removeAt(idx);
                }
              }

              set currStaticRoot(value) {
                this._currStaticRoot = value;
              }

              set currIsStatic(value) {
                this._currIsStatic = value;
              }

              constructor(_root) {
                this.device = void 0;
                this._screens = [];
                this._bufferBatchPool = new RecyclePool(() => new MeshBuffer(this), 128, obj => obj.destroy());
                this._drawBatchPool = void 0;
                this._meshBuffers = new Map();
                this._customMeshBuffers = new Map();
                this._meshBufferUseCount = new Map();
                this._batches = void 0;
                this._emptyMaterial = new Material();
                this._currScene = null;
                this._currMaterial = this._emptyMaterial;
                this._currTexture = null;
                this._currSampler = null;
                this._currMeshBuffer = null;
                this._currStaticRoot = null;
                this._currComponent = null;
                this._currTransform = null;
                this._currTextureHash = 0;
                this._currSamplerHash = 0;
                this._currBlendTargetHash = 0;
                this._currLayer = 0;
                this._currDepthStencilStateStage = null;
                this._currIsStatic = false;
                this._currHash = 0;
                this._descriptorSetCache = new DescriptorSetCache();
                this._root = _root;
                this.device = _root.device;
                this._batches = new CachedArray(64);
                this._drawBatchPool = new Pool(() => new DrawBatch2D(), 128, obj => obj.destroy(this));
              }

              initialize() {
                return true;
              }

              destroy() {
                for (let i = 0; i < this._batches.length; i++) {
                  if (this._batches.array[i]) {
                    this._batches.array[i].destroy(this);
                  }
                }

                this._batches.destroy();

                for (const size of this._meshBuffers.keys()) {
                  const buffers = this._meshBuffers.get(size);

                  if (buffers) {
                    buffers.forEach(buffer => buffer.destroy());
                  }
                }

                if (this._drawBatchPool) {
                  this._drawBatchPool.destroy();
                }

                this._descriptorSetCache.destroy();

                this._meshBuffers.clear();

                StencilManager.sharedManager.destroy();
              }

              addScreen(comp) {
                this._screens.push(comp);

                this._screens.sort(this._screenSort);
              }

              getFirstRenderCamera(node) {
                if (node.scene && node.scene.renderScene) {
                  const cameras = node.scene.renderScene.cameras;

                  for (let i = 0; i < cameras.length; i++) {
                    const camera = cameras[i];

                    if (camera.visibility & node.layer) {
                      return camera;
                    }
                  }
                }

                return null;
              }

              removeScreen(comp) {
                const idx = this._screens.indexOf(comp);

                if (idx === -1) {
                  return;
                }

                this._screens.splice(idx, 1);
              }

              sortScreens() {
                this._screens.sort(this._screenSort);
              }

              update() {
                const screens = this._screens;

                for (let i = 0; i < screens.length; ++i) {
                  const screen = screens[i];

                  if (!screen.enabledInHierarchy) {
                    continue;
                  }

                  this._recursiveScreenNode(screen.node);
                }

                let batchPriority = 0;

                if (this._batches.length) {
                  for (let i = 0; i < this._batches.length; ++i) {
                    const batch = this._batches.array[i];
                    if (!batch.renderScene) continue;

                    if (batch.model) {
                      const subModels = batch.model.subModels;

                      for (let j = 0; j < subModels.length; j++) {
                        subModels[j].priority = batchPriority++;
                      }
                    } else {
                      batch.descriptorSet = this._descriptorSetCache.getDescriptorSet(batch);
                    }

                    batch.renderScene.addBatch(batch);
                  }
                }
              }

              uploadBuffers() {
                if (this._batches.length > 0) {
                  const buffers = this._meshBuffers;
                  buffers.forEach((value, key) => {
                    value.forEach(bb => {
                      bb.uploadBuffers();
                      bb.reset();
                    });
                  });
                  const customs = this._customMeshBuffers;
                  customs.forEach((value, key) => {
                    value.forEach(bb => {
                      bb.uploadBuffers();
                      bb.reset();
                    });
                  });

                  this._descriptorSetCache.update();
                }
              }

              reset() {
                for (let i = 0; i < this._batches.length; ++i) {
                  const batch = this._batches.array[i];

                  if (batch.isStatic) {
                    continue;
                  }

                  batch.clear();

                  this._drawBatchPool.free(batch);
                }

                this._currHash = 0;
                this._currLayer = 0;
                this._currMaterial = this._emptyMaterial;
                this._currTexture = null;
                this._currSampler = null;
                this._currComponent = null;
                this._currTransform = null;
                this._currScene = null;
                this._currMeshBuffer = null;

                this._meshBufferUseCount.clear();

                this._batches.clear();

                StencilManager.sharedManager.reset();

                this._descriptorSetCache.reset();
              }

              commitComp(comp, frame, assembler, transform) {
                const renderComp = comp;
                const renderData = comp.renderData;
                let dataHash = 0;
                let mat;

                if (renderData) {
                  dataHash = renderData.dataHash;
                  mat = renderData.material;
                }

                renderComp.stencilStage = StencilManager.sharedManager.stage;
                const depthStencilStateStage = renderComp.stencilStage;

                if (this._currHash !== dataHash || dataHash === 0 || this._currMaterial !== mat || this._currDepthStencilStateStage !== depthStencilStateStage) {
                  this.autoMergeBatches(this._currComponent);

                  if (renderData) {
                    this._currHash = renderData.dataHash;
                    this._currScene = renderData.renderScene;
                    this._currComponent = renderComp;
                    this._currTransform = transform;
                    this._currMaterial = renderData.material;
                    this._currBlendTargetHash = renderData.blendHash;
                    this._currDepthStencilStateStage = depthStencilStateStage;
                    this._currLayer = renderData.layer;
                    const frame = renderData.frame;

                    if (frame) {
                      this._currTexture = frame.getGFXTexture();
                      this._currSampler = frame.getGFXSampler();
                      this._currTextureHash = renderData.textureHash;
                      this._currSamplerHash = this._currSampler.hash;
                    } else {
                      this._currTexture = null;
                      this._currSampler = null;
                      this._currTextureHash = 0;
                      this._currSamplerHash = 0;
                    }
                  } else {
                    this._currHash = dataHash;
                    this._currScene = renderComp._getRenderScene();
                    this._currComponent = renderComp;
                    this._currTransform = transform;
                    this._currMaterial = renderComp.getRenderMaterial(0);
                    this._currBlendTargetHash = renderComp.blendHash;
                    this._currDepthStencilStateStage = depthStencilStateStage;
                    this._currLayer = renderComp.node.layer;

                    if (frame) {
                      this._currTexture = frame.getGFXTexture();
                      this._currSampler = frame.getGFXSampler();
                      this._currTextureHash = frame.getHash();
                      this._currSamplerHash = this._currSampler.hash;
                    } else {
                      this._currTexture = null;
                      this._currSampler = null;
                      this._currTextureHash = 0;
                      this._currSamplerHash = 0;
                    }
                  }
                }

                if (assembler) {
                  assembler.fillBuffers(renderComp, this);
                }
              }

              commitModel(comp, model, mat) {
                if (this._currMaterial !== this._emptyMaterial) {
                  this.autoMergeBatches(this._currComponent);
                }

                let depthStencil;
                let dssHash = 0;

                if (mat) {
                  if (comp.stencilStage === Stage.ENABLED || comp.stencilStage === Stage.DISABLED) {
                    comp.stencilStage = StencilManager.sharedManager.stage;
                  }

                  depthStencil = StencilManager.sharedManager.getStencilStage(comp.stencilStage, mat);
                  dssHash = StencilManager.sharedManager.getStencilHash(comp.stencilStage);
                }

                const stamp = legacyCC.director.getTotalFrames();

                if (model) {
                  model.updateTransform(stamp);
                  model.updateUBOs(stamp);
                }

                for (let i = 0; i < model.subModels.length; i++) {
                  const curDrawBatch = this._drawBatchPool.alloc();

                  const subModel = model.subModels[i];
                  curDrawBatch.renderScene = comp._getRenderScene();
                  curDrawBatch.visFlags = comp.node.layer;
                  curDrawBatch.model = model;
                  curDrawBatch.bufferBatch = null;
                  curDrawBatch.texture = null;
                  curDrawBatch.sampler = null;
                  curDrawBatch.useLocalData = null;

                  if (!depthStencil) {
                    depthStencil = null;
                  }

                  curDrawBatch.fillPasses(mat, depthStencil, dssHash, null, 0, subModel.patches, this);
                  curDrawBatch.inputAssembler = subModel.inputAssembler;
                  curDrawBatch.model.visFlags = curDrawBatch.visFlags;
                  curDrawBatch.descriptorSet = subModel.descriptorSet;

                  this._batches.push(curDrawBatch);
                }

                this._currMaterial = this._emptyMaterial;
                this._currScene = null;
                this._currComponent = null;
                this._currTransform = null;
                this._currTexture = null;
                this._currSampler = null;
                this._currTextureHash = 0;
                this._currLayer = 0;
              }

              commitStaticBatch(comp) {
                this._batches.concat(comp.drawBatchList);

                this.finishMergeBatches();
              }

              autoMergeBatches(renderComp) {
                const buffer = this.currBufferBatch;
                const ia = buffer === null || buffer === void 0 ? void 0 : buffer.recordBatch();
                const mat = this._currMaterial;

                if (!ia || !mat || !buffer) {
                  return;
                }

                let blendState;
                let depthStencil;
                let dssHash = 0;
                let bsHash = 0;

                if (renderComp) {
                  blendState = renderComp.blendHash === -1 ? null : renderComp.getBlendState();
                  bsHash = renderComp.blendHash;

                  if (renderComp.customMaterial !== null) {
                    depthStencil = StencilManager.sharedManager.getStencilStage(renderComp.stencilStage, mat);
                  } else {
                    depthStencil = StencilManager.sharedManager.getStencilStage(renderComp.stencilStage);
                  }

                  dssHash = StencilManager.sharedManager.getStencilHash(renderComp.stencilStage);
                }

                const curDrawBatch = this._currStaticRoot ? this._currStaticRoot._requireDrawBatch() : this._drawBatchPool.alloc();
                curDrawBatch.renderScene = this._currScene;
                curDrawBatch.visFlags = this._currLayer;
                curDrawBatch.bufferBatch = buffer;
                curDrawBatch.texture = this._currTexture;
                curDrawBatch.sampler = this._currSampler;
                curDrawBatch.inputAssembler = ia;
                curDrawBatch.useLocalData = this._currTransform;
                curDrawBatch.textureHash = this._currTextureHash;
                curDrawBatch.samplerHash = this._currSamplerHash;
                curDrawBatch.fillPasses(this._currMaterial, depthStencil, dssHash, blendState, bsHash, null, this);

                this._batches.push(curDrawBatch);

                buffer.vertexStart = buffer.vertexOffset;
                buffer.indicesStart = buffer.indicesOffset;
                buffer.byteStart = buffer.byteOffset;

                if (sys.__isWebIOS14OrIPadOS14Env && !this._currIsStatic) {
                  this._currMeshBuffer = null;
                }
              }

              forceMergeBatches(material, frame, renderComp) {
                this._currMaterial = material;

                if (frame) {
                  this._currTexture = frame.getGFXTexture();
                  this._currSampler = frame.getGFXSampler();
                  this._currTextureHash = frame.getHash();
                  this._currSamplerHash = this._currSampler.hash;
                } else {
                  this._currTexture = this._currSampler = null;
                  this._currTextureHash = this._currSamplerHash = 0;
                }

                this._currLayer = renderComp.node.layer;
                this._currScene = renderComp._getRenderScene();
                this.autoMergeBatches(renderComp);
              }

              finishMergeBatches() {
                this.autoMergeBatches();
                this._currMaterial = this._emptyMaterial;
                this._currTexture = null;
                this._currComponent = null;
                this._currTransform = null;
                this._currTextureHash = 0;
                this._currSamplerHash = 0;
                this._currLayer = 0;
              }

              flushMaterial(mat) {
                this._currMaterial = mat;
              }

              walk(node, level = 0) {
                const len = node.children.length;

                this._preProcess(node);

                if (len > 0 && !node._static) {
                  const children = node.children;

                  for (let i = 0; i < children.length; ++i) {
                    const child = children[i];
                    this.walk(child, level);
                  }
                }

                this._postProcess(node);

                level += 1;
              }

              _preProcess(node) {
                if (node._uiProps.opacityDirty) {
                  var _node$parent;

                  let opacity = 1.0;

                  if ((_node$parent = node.parent) === null || _node$parent === void 0 ? void 0 : _node$parent._uiProps) {
                    opacity = node.parent._uiProps.opacity;
                    const render = node._uiProps.uiComp;

                    if (render && render.markColorDirty) {
                      opacity *= render.color.a / 255;
                      render.markColorDirty();
                    }
                  }

                  node._uiProps.opacityDirty = false;

                  node._uiProps.applyOpacity(opacity);
                }

                const render = node._uiProps.uiComp;

                if (!node._uiProps.uiTransformComp) {
                  return;
                }

                if (render && render.enabledInHierarchy) {
                  render.updateAssembler(this);
                }
              }

              _postProcess(node) {
                const render = node._uiProps.uiComp;

                if (render && render.enabledInHierarchy) {
                  render.postUpdateAssembler(this);
                }
              }

              _recursiveScreenNode(screen) {
                this.walk(screen);
                this.autoMergeBatches(this._currComponent);
              }

              _createMeshBuffer(attributes) {
                const batch = this._bufferBatchPool.add();

                batch.initialize(attributes, this._recreateMeshBuffer.bind(this, attributes));
                const strideBytes = getAttributeStride(attributes);

                let buffers = this._meshBuffers.get(strideBytes);

                if (!buffers) {
                  buffers = [];

                  this._meshBuffers.set(strideBytes, buffers);
                }

                buffers.push(batch);
                return batch;
              }

              _recreateMeshBuffer(attributes, vertexCount, indexCount) {
                this.autoMergeBatches();

                this._requireBufferBatch(attributes, vertexCount, indexCount);
              }

              _requireBufferBatch(attributes, vertexCount, indexCount) {
                const strideBytes = getAttributeStride(attributes);

                let buffers = this._meshBuffers.get(strideBytes);

                if (!buffers) {
                  buffers = [];

                  this._meshBuffers.set(strideBytes, buffers);
                }

                let meshBufferUseCount = this._meshBufferUseCount.get(strideBytes) || 0;

                if (vertexCount && indexCount || sys.__isWebIOS14OrIPadOS14Env) {
                  meshBufferUseCount++;
                }

                this._currMeshBuffer = buffers[meshBufferUseCount];

                if (!this._currMeshBuffer) {
                  this._currMeshBuffer = this._createMeshBuffer(attributes);
                }

                this._meshBufferUseCount.set(strideBytes, meshBufferUseCount);

                if (vertexCount && indexCount) {
                  this._currMeshBuffer.request(vertexCount, indexCount);
                }
              }

              _screenSort(a, b) {
                return a.node.getSiblingIndex() - b.node.getSiblingIndex();
              }

              _releaseDescriptorSetCache(textureHash) {
                this._descriptorSetCache.releaseDescriptorSetCache(textureHash);
              }

            } exports('UI', Batcher2D);

            class LocalDescriptorSet {
              get descriptorSet() {
                return this._descriptorSet;
              }

              constructor() {
                this._descriptorSet = null;
                this._transform = null;
                this._textureHash = 0;
                this._samplerHash = 0;
                this._localBuffer = null;
                this._transformUpdate = true;
                const device = legacyCC.director.root.device;
                this._localData = new Float32Array(UBOLocal.COUNT);
                this._localBuffer = device.createBuffer(new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, UBOLocal.SIZE, UBOLocal.SIZE));
              }

              initialize(batch) {
                const device = legacyCC.director.root.device;
                this._transform = batch.useLocalData;
                this._textureHash = batch.textureHash;
                this._samplerHash = batch.samplerHash;
                _dsInfo.layout = batch.passes[0].localSetLayout;
                this._descriptorSet = device.createDescriptorSet(_dsInfo);

                this._descriptorSet.bindBuffer(UBOLocal.BINDING, this._localBuffer);

                const binding = ModelLocalBindings.SAMPLER_SPRITE;

                this._descriptorSet.bindTexture(binding, batch.texture);

                this._descriptorSet.bindSampler(binding, batch.sampler);

                this._descriptorSet.update();

                this._transformUpdate = true;
              }

              updateTransform(transform) {
                if (transform === this._transform) return;
                this._transform = transform;
                this._transformUpdate = true;
                this.uploadLocalData();
              }

              updateLocal() {
                if (!this._transform) return;
                this.uploadLocalData();
              }

              equals(transform, textureHash, samplerHash) {
                return this._transform === transform && this._textureHash === textureHash && this._samplerHash === samplerHash;
              }

              reset() {
                this._transform = null;
                this._textureHash = 0;
                this._samplerHash = 0;
              }

              destroy() {
                if (this._localBuffer) {
                  this._localBuffer.destroy();

                  this._localBuffer = null;
                }

                if (this._descriptorSet) {
                  this._descriptorSet.destroy();

                  this._descriptorSet = null;
                }

                this._localData = null;
              }

              uploadLocalData() {
                const node = this._transform;

                if (node.hasChangedFlags || node._dirtyFlags) {
                  node.updateWorldTransform();
                }

                if (this._transformUpdate) {
                  const worldMatrix = node._mat;
                  Mat4.toArray(this._localData, worldMatrix, UBOLocal.MAT_WORLD_OFFSET);
                  Mat4.inverseTranspose(m4_1$5, worldMatrix);

                  Mat4.toArray(this._localData, m4_1$5, UBOLocal.MAT_WORLD_IT_OFFSET);

                  this._localBuffer.update(this._localData);

                  this._transformUpdate = false;
                }
              }

            }

            class DescriptorSetCache {
              constructor() {
                this._descriptorSetCache = new Map();
                this._dsCacheHashByTexture = new Map();
                this._localDescriptorSetCache = [];
                this._localCachePool = void 0;
                this._localCachePool = new Pool(() => new LocalDescriptorSet(), 16, obj => obj.destroy());
              }

              getDescriptorSet(batch) {
                const root = legacyCC.director.root;
                let hash;

                if (batch.useLocalData) {
                  const caches = this._localDescriptorSetCache;

                  for (let i = 0, len = caches.length; i < len; i++) {
                    const cache = caches[i];

                    if (cache.equals(batch.useLocalData, batch.textureHash, batch.samplerHash)) {
                      return cache.descriptorSet;
                    }
                  }

                  const localDs = this._localCachePool.alloc();

                  localDs.initialize(batch);

                  this._localDescriptorSetCache.push(localDs);

                  return localDs.descriptorSet;
                } else {
                  hash = batch.textureHash ^ batch.samplerHash;

                  if (this._descriptorSetCache.has(hash)) {
                    return this._descriptorSetCache.get(hash);
                  } else {
                    _dsInfo.layout = batch.passes[0].localSetLayout;
                    const descriptorSet = root.device.createDescriptorSet(_dsInfo);
                    const binding = ModelLocalBindings.SAMPLER_SPRITE;
                    descriptorSet.bindTexture(binding, batch.texture);
                    descriptorSet.bindSampler(binding, batch.sampler);
                    descriptorSet.update();

                    this._descriptorSetCache.set(hash, descriptorSet);

                    this._dsCacheHashByTexture.set(batch.textureHash, hash);

                    return descriptorSet;
                  }
                }
              }

              update() {
                const caches = this._localDescriptorSetCache;
                caches.forEach(value => {
                  value.updateLocal();
                });
              }

              reset() {
                const caches = this._localDescriptorSetCache;
                caches.forEach(value => {
                  this._localCachePool.free(value);
                });
                this._localDescriptorSetCache.length = 0;
              }

              releaseDescriptorSetCache(textureHash) {
                const key = this._dsCacheHashByTexture.get(textureHash);

                if (key && this._descriptorSetCache.has(key)) {
                  this._descriptorSetCache.get(key).destroy();

                  this._descriptorSetCache.delete(key);

                  this._dsCacheHashByTexture.delete(textureHash);
                }
              }

              destroy() {
                this._descriptorSetCache.forEach((value, key, map) => {
                  value.destroy();
                });

                this._descriptorSetCache.clear();

                this._dsCacheHashByTexture.clear();

                this._localDescriptorSetCache.length = 0;

                this._localCachePool.destroy();
              }

            }

            legacyCC.internal.Batcher2D = Batcher2D;

            let _canvasContext = null;

            let _intervalId = -1;

            const _testString = 'BES bswy:->@123\u4E01\u3041\u1101';

            const _fontFaces = Object.create(null);

            const _loadingFonts = [];
            const _timeout = 3000;

            const useNativeCheck = (() => {
              let nativeCheck;
              return () => {
                if (nativeCheck === undefined) {
                  if ('FontFace' in window) {
                    const match = /Gecko.*Firefox\/(\d+)/.exec(window.navigator.userAgent);
                    const safari10Match = /OS X.*Version\/10\..*Safari/.exec(window.navigator.userAgent) && /Apple/.exec(window.navigator.vendor);

                    if (match) {
                      nativeCheck = parseInt(match[1], 10) > 42;
                    } else if (safari10Match) {
                      nativeCheck = false;
                    } else {
                      nativeCheck = true;
                    }
                  } else {
                    nativeCheck = false;
                  }
                }

                return nativeCheck;
              };
            })();

            function checkFontLoaded() {
              let allFontsLoaded = true;
              const now = Date.now();

              for (let i = _loadingFonts.length - 1; i >= 0; i--) {
                const fontLoadHandle = _loadingFonts[i];
                const fontFamily = fontLoadHandle.fontFamilyName;

                if (now - fontLoadHandle.startTime > _timeout) {
                  warnID(4933, fontFamily);
                  fontLoadHandle.onComplete(null, fontFamily);

                  _loadingFonts.splice(i, 1);

                  continue;
                }

                const oldWidth = fontLoadHandle.refWidth;
                const fontDesc = `40px ${fontFamily}`;
                _canvasContext.font = fontDesc;
                const newWidth = safeMeasureText(_canvasContext, _testString, fontDesc);

                if (oldWidth !== newWidth) {
                  _loadingFonts.splice(i, 1);

                  fontLoadHandle.onComplete(null, fontFamily);
                } else {
                  allFontsLoaded = false;
                }
              }

              if (allFontsLoaded) {
                clearInterval(_intervalId);
                _intervalId = -1;
              }
            }

            function nativeCheckFontLoaded(start, font, callback) {
              const loader = new Promise((resolve, reject) => {
                const check = () => {
                  const now = Date.now();

                  if (now - start >= _timeout) {
                    reject();
                  } else {
                    document.fonts.load(`40px ${font}`).then(fonts => {
                      if (fonts.length >= 1) {
                        resolve();
                      } else {
                        setTimeout(check, 100);
                      }
                    }, () => {
                      reject();
                    });
                  }
                };

                check();
              });
              let timeoutId = null;
              const timer = new Promise((resolve, reject) => {
                timeoutId = setTimeout(reject, _timeout);
              });
              Promise.race([timer, loader]).then(() => {
                if (timeoutId) {
                  clearTimeout(timeoutId);
                  timeoutId = null;
                }

                callback(null, font);
              }, () => {
                warnID(4933, font);
                callback(null, font);
              });
            }

            function loadFont(url, options, onComplete) {
              const fontFamilyName = getFontFamily(url);

              if (_fontFaces[fontFamilyName]) {
                onComplete(null, fontFamilyName);
                return;
              }

              if (!_canvasContext) {
                const labelCanvas = document.createElement('canvas');
                labelCanvas.width = 100;
                labelCanvas.height = 100;
                _canvasContext = labelCanvas.getContext('2d');
              }

              const fontDesc = `40px ${fontFamilyName}`;
              const refWidth = safeMeasureText(_canvasContext, _testString, fontDesc);
              const fontStyle = document.createElement('style');
              fontStyle.type = 'text/css';
              let fontStr = '';

              if (Number.isNaN(fontFamilyName)) {
                fontStr += `@font-face { font-family:${fontFamilyName}; src:`;
              } else {
                fontStr += `@font-face { font-family:"${fontFamilyName}"; src:`;
              }

              fontStr += `url("${url}");`;
              fontStyle.textContent = `${fontStr}}`;
              document.body.appendChild(fontStyle);
              const preloadDiv = document.createElement('div');
              const divStyle = preloadDiv.style;
              divStyle.fontFamily = fontFamilyName;
              preloadDiv.innerHTML = '.';
              divStyle.position = 'absolute';
              divStyle.left = '-100px';
              divStyle.top = '-100px';
              document.body.appendChild(preloadDiv);

              if (useNativeCheck()) {
                nativeCheckFontLoaded(Date.now(), fontFamilyName, onComplete);
              } else {
                const fontLoadHandle = {
                  fontFamilyName,
                  refWidth,
                  onComplete,
                  startTime: Date.now()
                };

                _loadingFonts.push(fontLoadHandle);

                if (_intervalId === -1) {
                  _intervalId = setInterval(checkFontLoaded, 100);
                }
              }

              _fontFaces[fontFamilyName] = fontStyle;
            }
            function getFontFamily(fontHandle) {
              const ttfIndex = fontHandle.lastIndexOf('.ttf');

              if (ttfIndex === -1) {
                return fontHandle;
              }

              const slashPos = fontHandle.lastIndexOf('/');
              let fontFamilyName;

              if (slashPos === -1) {
                fontFamilyName = `${fontHandle.substring(0, ttfIndex)}_LABEL`;
              } else {
                fontFamilyName = `${fontHandle.substring(slashPos + 1, ttfIndex)}_LABEL`;
              }

              if (fontFamilyName.indexOf(' ') !== -1) {
                fontFamilyName = `"${fontFamilyName}"`;
              }

              return fontFamilyName;
            }

            function createFont(id, data, options, onComplete) {
              const out = new TTFFont();
              out._nativeUrl = id;
              out._nativeAsset = data;
              onComplete(null, out);
            }

            downloader.register({
              '.font': loadFont,
              '.eot': loadFont,
              '.ttf': loadFont,
              '.woff': loadFont,
              '.svg': loadFont,
              '.ttc': loadFont
            });
            factory.register({
              '.font': createFont,
              '.eot': createFont,
              '.ttf': createFont,
              '.woff': createFont,
              '.svg': createFont,
              '.ttc': createFont
            });

            legacyCC.UI = {
              MeshBuffer,
              spriteAssembler,
              graphicsAssembler: graphicsAssemblerManager,
              labelAssembler
            };

            var _dec$t, _dec2$o, _dec3$n, _dec4$m, _dec5$k, _dec6$h, _dec7$h, _dec8$f, _dec9$c, _dec10$b, _dec11$8, _dec12$8, _dec13$7, _dec14$5, _dec15$5, _dec16$5, _dec17$3, _dec18$3, _dec19$3, _dec20$2, _dec21$2, _dec22$2, _dec23$2, _dec24$2, _dec25$2, _dec26$2, _dec27$2, _dec28$2, _dec29$2, _dec30$2, _dec31$1, _dec32$1, _class$t, _class2$n, _descriptor$m, _descriptor2$j, _descriptor3$e, _descriptor4$d, _descriptor5$b, _descriptor6$8, _descriptor7$6, _descriptor8$6, _descriptor9$5, _descriptor10$4, _descriptor11$3, _descriptor12$2, _descriptor13$1, _descriptor14$1, _class3$7, _temp$q;

            const _tempColor = new Color$1();

            var Transition;

            (function (Transition) {
              Transition[Transition["NONE"] = 0] = "NONE";
              Transition[Transition["COLOR"] = 1] = "COLOR";
              Transition[Transition["SPRITE"] = 2] = "SPRITE";
              Transition[Transition["SCALE"] = 3] = "SCALE";
            })(Transition || (Transition = {}));

            ccenum(Transition);
            var State;

            (function (State) {
              State["NORMAL"] = "normal";
              State["HOVER"] = "hover";
              State["PRESSED"] = "pressed";
              State["DISABLED"] = "disabled";
            })(State || (State = {}));

            let EventType$1;

            (function (EventType) {
              EventType["CLICK"] = "click";
            })(EventType$1 || (EventType$1 = {}));

            let Button = function (v) { return exports({ Button: v, ButtonComponent: v }), v; }((_dec$t = ccclass('cc.Button'), _dec2$o = help(), _dec3$n = executionOrder(110), _dec4$m = menu$1(), _dec5$k = requireComponent(UITransform), _dec6$h = type$1(Node), _dec7$h = displayOrder(), _dec8$f = tooltip(), _dec9$c = displayOrder(), _dec10$b = tooltip(), _dec11$8 = type$1(Transition), _dec12$8 = displayOrder(), _dec13$7 = tooltip(), _dec14$5 = tooltip(), _dec15$5 = tooltip(), _dec16$5 = tooltip(), _dec17$3 = tooltip(), _dec18$3 = rangeMin(), _dec19$3 = rangeMax(), _dec20$2 = tooltip(), _dec21$2 = tooltip(), _dec22$2 = type$1(SpriteFrame), _dec23$2 = tooltip(), _dec24$2 = type$1(SpriteFrame), _dec25$2 = tooltip(), _dec26$2 = type$1(SpriteFrame), _dec27$2 = tooltip(), _dec28$2 = type$1(SpriteFrame), _dec29$2 = tooltip(), _dec30$2 = type$1([EventHandler]), _dec31$1 = displayOrder(), _dec32$1 = tooltip(), _dec$t(_class$t = _dec2$o(_class$t = _dec3$n(_class$t = _dec4$m(_class$t = _dec5$k(_class$t = executeInEditMode(_class$t = (_class2$n = (_temp$q = _class3$7 = class Button extends Component {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "clickEvents", _descriptor$m, this);

                _initializerDefineProperty(this, "_interactable", _descriptor2$j, this);

                _initializerDefineProperty(this, "_transition", _descriptor3$e, this);

                _initializerDefineProperty(this, "_normalColor", _descriptor4$d, this);

                _initializerDefineProperty(this, "_hoverColor", _descriptor5$b, this);

                _initializerDefineProperty(this, "_pressedColor", _descriptor6$8, this);

                _initializerDefineProperty(this, "_disabledColor", _descriptor7$6, this);

                _initializerDefineProperty(this, "_normalSprite", _descriptor8$6, this);

                _initializerDefineProperty(this, "_hoverSprite", _descriptor9$5, this);

                _initializerDefineProperty(this, "_pressedSprite", _descriptor10$4, this);

                _initializerDefineProperty(this, "_disabledSprite", _descriptor11$3, this);

                _initializerDefineProperty(this, "_duration", _descriptor12$2, this);

                _initializerDefineProperty(this, "_zoomScale", _descriptor13$1, this);

                _initializerDefineProperty(this, "_target", _descriptor14$1, this);

                this._pressed = false;
                this._hovered = false;
                this._fromColor = new Color$1();
                this._toColor = new Color$1();
                this._time = 0;
                this._transitionFinished = true;
                this._fromScale = new Vec3();
                this._toScale = new Vec3();
                this._originalScale = null;
                this._sprite = null;
                this._targetScale = new Vec3();
              }

              get target() {
                return this._target || this.node;
              }

              set target(value) {
                if (this._target === value) {
                  return;
                }

                if (this._target) {
                  this._unregisterTargetEvent(this._target);
                }

                this._target = value;

                this._applyTarget();
              }

              get interactable() {
                return this._interactable;
              }

              set interactable(value) {
                if (this._interactable === value) {
                  return;
                }

                this._interactable = value;

                this._updateState();

                if (!this._interactable) {
                  this._resetState();
                }
              }

              set _resizeToTarget(value) {
                if (value) {
                  this._resizeNodeToTargetNode();
                }
              }

              get transition() {
                return this._transition;
              }

              set transition(value) {
                if (this._transition === value) {
                  return;
                }

                if (this._transition === Transition.COLOR) {
                  this._updateColorTransition(State.NORMAL);
                } else if (this._transition === Transition.SPRITE) {
                  this._updateSpriteTransition(State.NORMAL);
                }

                this._transition = value;

                this._updateState();
              }

              get normalColor() {
                return this._normalColor;
              }

              set normalColor(value) {
                if (this._normalColor === value) {
                  return;
                }

                this._normalColor.set(value);

                this._updateState();
              }

              get pressedColor() {
                return this._pressedColor;
              }

              set pressedColor(value) {
                if (this._pressedColor === value) {
                  return;
                }

                this._pressedColor.set(value);
              }

              get hoverColor() {
                return this._hoverColor;
              }

              set hoverColor(value) {
                if (this._hoverColor === value) {
                  return;
                }

                this._hoverColor.set(value);
              }

              get disabledColor() {
                return this._disabledColor;
              }

              set disabledColor(value) {
                if (this._disabledColor === value) {
                  return;
                }

                this._disabledColor.set(value);

                this._updateState();
              }

              get duration() {
                return this._duration;
              }

              set duration(value) {
                if (this._duration === value) {
                  return;
                }

                this._duration = value;
              }

              get zoomScale() {
                return this._zoomScale;
              }

              set zoomScale(value) {
                if (this._zoomScale === value) {
                  return;
                }

                this._zoomScale = value;
              }

              get normalSprite() {
                return this._normalSprite;
              }

              set normalSprite(value) {
                if (this._normalSprite === value) {
                  return;
                }

                this._normalSprite = value;
                const sprite = this.node.getComponent(Sprite);

                if (sprite) {
                  sprite.spriteFrame = value;
                }

                this._updateState();
              }

              get pressedSprite() {
                return this._pressedSprite;
              }

              set pressedSprite(value) {
                if (this._pressedSprite === value) {
                  return;
                }

                this._pressedSprite = value;

                this._updateState();
              }

              get hoverSprite() {
                return this._hoverSprite;
              }

              set hoverSprite(value) {
                if (this._hoverSprite === value) {
                  return;
                }

                this._hoverSprite = value;

                this._updateState();
              }

              get disabledSprite() {
                return this._disabledSprite;
              }

              set disabledSprite(value) {
                if (this._disabledSprite === value) {
                  return;
                }

                this._disabledSprite = value;

                this._updateState();
              }

              __preload() {
                if (!this.target) {
                  this.target = this.node;
                }

                const sprite = this.node.getComponent(Sprite);

                if (sprite) {
                  this._normalSprite = sprite.spriteFrame;
                }

                this._applyTarget();

                this._resetState();
              }

              onEnable() {
                {
                  this._registerNodeEvent();
                }
              }

              onDisable() {
                this._resetState();

                {
                  this._unregisterNodeEvent();
                }
              }

              onDestroy() {
                if (this.target.isValid) {
                  this._unregisterTargetEvent(this.target);
                }
              }

              update(dt) {
                const target = this.target;

                if (this._transitionFinished || !target) {
                  return;
                }

                if (this._transition !== Transition.COLOR && this._transition !== Transition.SCALE) {
                  return;
                }

                this._time += dt;
                let ratio = 1.0;

                if (this._duration > 0) {
                  ratio = this._time / this._duration;
                }

                if (ratio >= 1) {
                  ratio = 1;
                }

                if (this._transition === Transition.COLOR) {
                  const renderComp = target._uiProps.uiComp;
                  Color$1.lerp(_tempColor, this._fromColor, this._toColor, ratio);

                  if (renderComp) {
                    renderComp.color = _tempColor;
                  }
                } else if (this.transition === Transition.SCALE) {
                  target.getScale(this._targetScale);
                  this._targetScale.x = lerp(this._fromScale.x, this._toScale.x, ratio);
                  this._targetScale.y = lerp(this._fromScale.y, this._toScale.y, ratio);
                  target.setScale(this._targetScale);
                }

                if (ratio === 1) {
                  this._transitionFinished = true;
                }
              }

              _resizeNodeToTargetNode() {
                if (!this.target) {
                  return;
                }

                const targetTrans = this.target._uiProps.uiTransformComp;
              }

              _resetState() {
                this._pressed = false;
                this._hovered = false;
                const target = this.target;

                if (!target) {
                  return;
                }

                const transition = this._transition;

                if (transition === Transition.COLOR && this._interactable) {
                  const renderComp = target.getComponent(Renderable2D);

                  if (renderComp) {
                    renderComp.color = this._normalColor;
                  }
                } else if (transition === Transition.SCALE && this._originalScale) {
                  target.setScale(this._originalScale);
                }

                this._transitionFinished = true;
              }

              _registerNodeEvent() {
                this.node.on(NodeEventType.TOUCH_START, this._onTouchBegan, this);
                this.node.on(NodeEventType.TOUCH_MOVE, this._onTouchMove, this);
                this.node.on(NodeEventType.TOUCH_END, this._onTouchEnded, this);
                this.node.on(NodeEventType.TOUCH_CANCEL, this._onTouchCancel, this);
                this.node.on(NodeEventType.MOUSE_ENTER, this._onMouseMoveIn, this);
                this.node.on(NodeEventType.MOUSE_LEAVE, this._onMouseMoveOut, this);
              }

              _registerTargetEvent(target) {

                target.on(NodeEventType.TRANSFORM_CHANGED, this._onTargetTransformChanged, this);
              }

              _unregisterNodeEvent() {
                this.node.off(NodeEventType.TOUCH_START, this._onTouchBegan, this);
                this.node.off(NodeEventType.TOUCH_MOVE, this._onTouchMove, this);
                this.node.off(NodeEventType.TOUCH_END, this._onTouchEnded, this);
                this.node.off(NodeEventType.TOUCH_CANCEL, this._onTouchCancel, this);
                this.node.off(NodeEventType.MOUSE_ENTER, this._onMouseMoveIn, this);
                this.node.off(NodeEventType.MOUSE_LEAVE, this._onMouseMoveOut, this);
              }

              _unregisterTargetEvent(target) {

                target.off(NodeEventType.TRANSFORM_CHANGED);
              }

              _getTargetSprite(target) {
                let sprite = null;

                if (target) {
                  sprite = target.getComponent(Sprite);
                }

                return sprite;
              }

              _applyTarget() {
                if (this.target) {
                  this._sprite = this._getTargetSprite(this.target);

                  if (!this._originalScale) {
                    this._originalScale = new Vec3();
                  }

                  Vec3.copy(this._originalScale, this.target.getScale());

                  this._registerTargetEvent(this.target);
                }
              }

              _onTargetSpriteFrameChanged(comp) {
                if (this._transition === Transition.SPRITE) {
                  this._setCurrentStateSpriteFrame(comp.spriteFrame);
                }
              }

              _setCurrentStateSpriteFrame(spriteFrame) {
                if (!spriteFrame) {
                  return;
                }

                switch (this._getButtonState()) {
                  case State.NORMAL:
                    this._normalSprite = spriteFrame;
                    break;

                  case State.HOVER:
                    this._hoverSprite = spriteFrame;
                    break;

                  case State.PRESSED:
                    this._pressedSprite = spriteFrame;
                    break;

                  case State.DISABLED:
                    this._disabledSprite = spriteFrame;
                    break;
                }
              }

              _onTargetColorChanged(color) {
                if (this._transition === Transition.COLOR) {
                  this._setCurrentStateColor(color);
                }
              }

              _setCurrentStateColor(color) {
                switch (this._getButtonState()) {
                  case State.NORMAL:
                    this._normalColor = color;
                    break;

                  case State.HOVER:
                    this._hoverColor = color;
                    break;

                  case State.PRESSED:
                    this._pressedColor = color;
                    break;

                  case State.DISABLED:
                    this._disabledColor = color;
                    break;
                }
              }

              _onTargetTransformChanged(transformBit) {
                if (transformBit & TransformBit.SCALE && this._originalScale && this._transition === Transition.SCALE && this._transitionFinished) {
                  Vec3.copy(this._originalScale, this.target.getScale());
                }
              }

              _onTouchBegan(event) {
                if (!this._interactable || !this.enabledInHierarchy) {
                  return;
                }

                this._pressed = true;

                this._updateState();

                if (event) {
                  event.propagationStopped = true;
                }
              }

              _onTouchMove(event) {
                if (!this._interactable || !this.enabledInHierarchy || !this._pressed) {
                  return;
                }

                if (!event) {
                  return;
                }

                const touch = event.touch;

                if (!touch) {
                  return;
                }

                const hit = this.node._uiProps.uiTransformComp.isHit(touch.getUILocation());

                if (this._transition === Transition.SCALE && this.target && this._originalScale) {
                  if (hit) {
                    Vec3.copy(this._fromScale, this._originalScale);
                    Vec3.multiplyScalar(this._toScale, this._originalScale, this._zoomScale);
                    this._transitionFinished = false;
                  } else {
                    this._time = 0;
                    this._transitionFinished = true;
                    this.target.setScale(this._originalScale);
                  }
                } else {
                  let state;

                  if (hit) {
                    state = State.PRESSED;
                  } else {
                    state = State.NORMAL;
                  }

                  this._applyTransition(state);
                }

                if (event) {
                  event.propagationStopped = true;
                }
              }

              _onTouchEnded(event) {
                if (!this._interactable || !this.enabledInHierarchy) {
                  return;
                }

                if (this._pressed) {
                  EventHandler.emitEvents(this.clickEvents, event);
                  this.node.emit(EventType$1.CLICK, this);
                }

                this._pressed = false;

                this._updateState();

                if (event) {
                  event.propagationStopped = true;
                }
              }

              _onTouchCancel(event) {
                if (!this._interactable || !this.enabledInHierarchy) {
                  return;
                }

                this._pressed = false;

                this._updateState();
              }

              _onMouseMoveIn(event) {
                if (this._pressed || !this.interactable || !this.enabledInHierarchy) {
                  return;
                }

                if (this._transition === Transition.SPRITE && !this._hoverSprite) {
                  return;
                }

                if (!this._hovered) {
                  this._hovered = true;

                  this._updateState();
                }
              }

              _onMouseMoveOut(event) {
                if (this._hovered) {
                  this._hovered = false;

                  this._updateState();
                }
              }

              _updateState() {
                const state = this._getButtonState();

                this._applyTransition(state);
              }

              _getButtonState() {
                let state = State.NORMAL;

                if (!this._interactable) {
                  state = State.DISABLED;
                } else if (this._pressed) {
                  state = State.PRESSED;
                } else if (this._hovered) {
                  state = State.HOVER;
                }

                return state.toString();
              }

              _updateColorTransition(state) {
                var _this$target;

                const color = this[`${state}Color`];
                const renderComp = (_this$target = this.target) === null || _this$target === void 0 ? void 0 : _this$target.getComponent(Renderable2D);

                if (!renderComp) {
                  return;
                }

                if ( state === State.DISABLED) {
                  renderComp.color = color;
                } else {
                  this._fromColor = renderComp.color.clone();
                  this._toColor = color;
                  this._time = 0;
                  this._transitionFinished = false;
                }
              }

              _updateSpriteTransition(state) {
                const sprite = this[`${state}Sprite`];

                if (this._sprite && sprite) {
                  this._sprite.spriteFrame = sprite;
                }
              }

              _updateScaleTransition(state) {
                if (!this._interactable) {
                  return;
                }

                if (state === State.PRESSED) {
                  this._zoomUp();
                } else {
                  this._zoomBack();
                }
              }

              _zoomUp() {
                if (!this._originalScale) {
                  return;
                }

                Vec3.copy(this._fromScale, this._originalScale);
                Vec3.multiplyScalar(this._toScale, this._originalScale, this._zoomScale);
                this._time = 0;
                this._transitionFinished = false;
              }

              _zoomBack() {
                if (!this.target || !this._originalScale) {
                  return;
                }

                Vec3.copy(this._fromScale, this.target.getScale());
                Vec3.copy(this._toScale, this._originalScale);
                this._time = 0;
                this._transitionFinished = false;
              }

              _applyTransition(state) {
                const transition = this._transition;

                if (transition === Transition.COLOR) {
                  this._updateColorTransition(state);
                } else if (transition === Transition.SPRITE) {
                  this._updateSpriteTransition(state);
                } else if (transition === Transition.SCALE) {
                  this._updateScaleTransition(state);
                }
              }

            }, _class3$7.Transition = Transition, _class3$7.EventType = EventType$1, _temp$q), (_applyDecoratedDescriptor(_class2$n.prototype, "target", [_dec6$h, _dec7$h, _dec8$f], Object.getOwnPropertyDescriptor(_class2$n.prototype, "target"), _class2$n.prototype), _applyDecoratedDescriptor(_class2$n.prototype, "interactable", [_dec9$c, _dec10$b], Object.getOwnPropertyDescriptor(_class2$n.prototype, "interactable"), _class2$n.prototype), _applyDecoratedDescriptor(_class2$n.prototype, "transition", [_dec11$8, _dec12$8, _dec13$7], Object.getOwnPropertyDescriptor(_class2$n.prototype, "transition"), _class2$n.prototype), _applyDecoratedDescriptor(_class2$n.prototype, "normalColor", [_dec14$5], Object.getOwnPropertyDescriptor(_class2$n.prototype, "normalColor"), _class2$n.prototype), _applyDecoratedDescriptor(_class2$n.prototype, "pressedColor", [_dec15$5], Object.getOwnPropertyDescriptor(_class2$n.prototype, "pressedColor"), _class2$n.prototype), _applyDecoratedDescriptor(_class2$n.prototype, "hoverColor", [_dec16$5], Object.getOwnPropertyDescriptor(_class2$n.prototype, "hoverColor"), _class2$n.prototype), _applyDecoratedDescriptor(_class2$n.prototype, "disabledColor", [_dec17$3], Object.getOwnPropertyDescriptor(_class2$n.prototype, "disabledColor"), _class2$n.prototype), _applyDecoratedDescriptor(_class2$n.prototype, "duration", [_dec18$3, _dec19$3, _dec20$2], Object.getOwnPropertyDescriptor(_class2$n.prototype, "duration"), _class2$n.prototype), _applyDecoratedDescriptor(_class2$n.prototype, "zoomScale", [_dec21$2], Object.getOwnPropertyDescriptor(_class2$n.prototype, "zoomScale"), _class2$n.prototype), _applyDecoratedDescriptor(_class2$n.prototype, "normalSprite", [_dec22$2, _dec23$2], Object.getOwnPropertyDescriptor(_class2$n.prototype, "normalSprite"), _class2$n.prototype), _applyDecoratedDescriptor(_class2$n.prototype, "pressedSprite", [_dec24$2, _dec25$2], Object.getOwnPropertyDescriptor(_class2$n.prototype, "pressedSprite"), _class2$n.prototype), _applyDecoratedDescriptor(_class2$n.prototype, "hoverSprite", [_dec26$2, _dec27$2], Object.getOwnPropertyDescriptor(_class2$n.prototype, "hoverSprite"), _class2$n.prototype), _applyDecoratedDescriptor(_class2$n.prototype, "disabledSprite", [_dec28$2, _dec29$2], Object.getOwnPropertyDescriptor(_class2$n.prototype, "disabledSprite"), _class2$n.prototype), _descriptor$m = _applyDecoratedDescriptor(_class2$n.prototype, "clickEvents", [_dec30$2, serializable, _dec31$1, _dec32$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor2$j = _applyDecoratedDescriptor(_class2$n.prototype, "_interactable", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _descriptor3$e = _applyDecoratedDescriptor(_class2$n.prototype, "_transition", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Transition.NONE;
              }
            }), _descriptor4$d = _applyDecoratedDescriptor(_class2$n.prototype, "_normalColor", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Color$1.WHITE.clone();
              }
            }), _descriptor5$b = _applyDecoratedDescriptor(_class2$n.prototype, "_hoverColor", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Color$1(211, 211, 211, 255);
              }
            }), _descriptor6$8 = _applyDecoratedDescriptor(_class2$n.prototype, "_pressedColor", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Color$1.WHITE.clone();
              }
            }), _descriptor7$6 = _applyDecoratedDescriptor(_class2$n.prototype, "_disabledColor", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Color$1(124, 124, 124, 255);
              }
            }), _descriptor8$6 = _applyDecoratedDescriptor(_class2$n.prototype, "_normalSprite", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor9$5 = _applyDecoratedDescriptor(_class2$n.prototype, "_hoverSprite", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor10$4 = _applyDecoratedDescriptor(_class2$n.prototype, "_pressedSprite", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor11$3 = _applyDecoratedDescriptor(_class2$n.prototype, "_disabledSprite", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor12$2 = _applyDecoratedDescriptor(_class2$n.prototype, "_duration", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.1;
              }
            }), _descriptor13$1 = _applyDecoratedDescriptor(_class2$n.prototype, "_zoomScale", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1.2;
              }
            }), _descriptor14$1 = _applyDecoratedDescriptor(_class2$n.prototype, "_target", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            })), _class2$n)) || _class$t) || _class$t) || _class$t) || _class$t) || _class$t) || _class$t));

            class tabIndexUtil {
              static add(editBoxImpl) {
                const list = this._tabIndexList;
                const index = list.indexOf(editBoxImpl);

                if (index === -1) {
                  list.push(editBoxImpl);
                }
              }

              static remove(editBoxImpl) {
                const list = this._tabIndexList;
                const index = list.indexOf(editBoxImpl);

                if (index !== -1) {
                  list.splice(index, 1);
                }
              }

              static resort() {
                this._tabIndexList.sort((a, b) => a._delegate.tabIndex - b._delegate.tabIndex);
              }

              static next(editBoxImpl) {
                const list = this._tabIndexList;
                const index = list.indexOf(editBoxImpl);
                editBoxImpl.setFocus(false);

                if (index !== -1) {
                  const nextImpl = list[index + 1];

                  if (nextImpl && nextImpl._delegate.tabIndex >= 0) {
                    nextImpl.setFocus(true);
                  }
                }
              }

            }
            tabIndexUtil._tabIndexList = [];

            let KeyboardReturnType;

            (function (KeyboardReturnType) {
              KeyboardReturnType[KeyboardReturnType["DEFAULT"] = 0] = "DEFAULT";
              KeyboardReturnType[KeyboardReturnType["DONE"] = 1] = "DONE";
              KeyboardReturnType[KeyboardReturnType["SEND"] = 2] = "SEND";
              KeyboardReturnType[KeyboardReturnType["SEARCH"] = 3] = "SEARCH";
              KeyboardReturnType[KeyboardReturnType["GO"] = 4] = "GO";
              KeyboardReturnType[KeyboardReturnType["NEXT"] = 5] = "NEXT";
            })(KeyboardReturnType || (KeyboardReturnType = {}));

            Enum(KeyboardReturnType);
            let InputMode;

            (function (InputMode) {
              InputMode[InputMode["ANY"] = 0] = "ANY";
              InputMode[InputMode["EMAIL_ADDR"] = 1] = "EMAIL_ADDR";
              InputMode[InputMode["NUMERIC"] = 2] = "NUMERIC";
              InputMode[InputMode["PHONE_NUMBER"] = 3] = "PHONE_NUMBER";
              InputMode[InputMode["URL"] = 4] = "URL";
              InputMode[InputMode["DECIMAL"] = 5] = "DECIMAL";
              InputMode[InputMode["SINGLE_LINE"] = 6] = "SINGLE_LINE";
            })(InputMode || (InputMode = {}));

            Enum(InputMode);
            let InputFlag;

            (function (InputFlag) {
              InputFlag[InputFlag["PASSWORD"] = 0] = "PASSWORD";
              InputFlag[InputFlag["SENSITIVE"] = 1] = "SENSITIVE";
              InputFlag[InputFlag["INITIAL_CAPS_WORD"] = 2] = "INITIAL_CAPS_WORD";
              InputFlag[InputFlag["INITIAL_CAPS_SENTENCE"] = 3] = "INITIAL_CAPS_SENTENCE";
              InputFlag[InputFlag["INITIAL_CAPS_ALL_CHARACTERS"] = 4] = "INITIAL_CAPS_ALL_CHARACTERS";
              InputFlag[InputFlag["DEFAULT"] = 5] = "DEFAULT";
            })(InputFlag || (InputFlag = {}));

            Enum(InputFlag);

            class EditBoxImplBase {
              constructor() {
                this._editing = false;
                this._delegate = null;
              }

              init(delegate) {}

              onEnable() {}

              update() {}

              onDisable() {
                if (this._editing) {
                  this.endEditing();
                }
              }

              clear() {
                this._delegate = null;
              }

              setTabIndex(index) {}

              setSize(width, height) {}

              setFocus(value) {
                if (value) {
                  this.beginEditing();
                } else {
                  this.endEditing();
                }
              }

              isFocused() {
                return this._editing;
              }

              beginEditing() {}

              endEditing() {}

            }

            const SCROLLY = 40;
            const LEFT_PADDING = 2;
            const DELAY_TIME = 400;

            const _matrix$1 = new Mat4();

            const _matrix_temp = new Mat4();

            const _vec3 = new Vec3();

            let _currentEditBoxImpl = null;
            let _domCount = 0;
            class EditBoxImpl extends EditBoxImplBase {
              constructor(...args) {
                super(...args);
                this._delegate = null;
                this._inputMode = -1;
                this._inputFlag = -1;
                this._returnType = -1;
                this.__eventListeners = {};
                this.__autoResize = false;
                this.__orientationChanged = void 0;
                this._edTxt = null;
                this._isTextArea = false;
                this._textLabelFont = null;
                this._textLabelFontSize = null;
                this._textLabelFontColor = null;
                this._textLabelAlign = null;
                this._placeholderLabelFont = null;
                this._placeholderLabelFontSize = null;
                this._placeholderLabelFontColor = null;
                this._placeholderLabelAlign = null;
                this._placeholderLineHeight = null;
                this._placeholderStyleSheet = null;
                this._domId = `EditBoxId_${++_domCount}`;
              }

              init(delegate) {
                if (!delegate) {
                  return;
                }

                this._delegate = delegate;

                if (delegate.inputMode === InputMode.ANY) {
                  this._createTextArea();
                } else {
                  this._createInput();
                }

                tabIndexUtil.add(this);
                this.setTabIndex(delegate.tabIndex);

                this._initStyleSheet();

                this._registerEventListeners();

                this._addDomToGameContainer();
              }

              clear() {
                this._removeEventListeners();

                this._removeDomFromGameContainer();

                tabIndexUtil.remove(this);

                if (_currentEditBoxImpl === this) {
                  _currentEditBoxImpl = null;
                }

                this._delegate = null;
              }

              update() {
                this._updateMatrix();
              }

              setTabIndex(index) {
                this._edTxt.tabIndex = index;
                tabIndexUtil.resort();
              }

              setSize(width, height) {
                const elem = this._edTxt;

                if (elem) {
                  elem.style.width = `${width}px`;
                  elem.style.height = `${height}px`;
                }
              }

              beginEditing() {
                if (_currentEditBoxImpl && _currentEditBoxImpl !== this) {
                  _currentEditBoxImpl.setFocus(false);
                }

                this._editing = true;
                _currentEditBoxImpl = this;

                this._delegate._editBoxEditingDidBegan();

                this._showDom();

                this._edTxt.focus();
              }

              endEditing() {
                this._edTxt.blur();
              }

              _createInput() {
                this._isTextArea = false;
                this._edTxt = document.createElement('input');
              }

              _createTextArea() {
                this._isTextArea = true;
                this._edTxt = document.createElement('textarea');
              }

              _addDomToGameContainer() {
                if (legacyCC.GAME_VIEW && this._edTxt) {
                  legacyCC.gameView.container.appendChild(this._edTxt);
                  legacyCC.gameView.head.appendChild(this._placeholderStyleSheet);
                } else if (game.container && this._edTxt) {
                  game.container.appendChild(this._edTxt);
                  document.head.appendChild(this._placeholderStyleSheet);
                }
              }

              _removeDomFromGameContainer() {
                const hasElem = legacyCC.GAME_VIEW ? contains(legacyCC.gameView.container, this._edTxt) : contains(game.container, this._edTxt);

                if (hasElem && this._edTxt) {
                  if (legacyCC.GAME_VIEW) {
                    legacyCC.gameView.container.removeChild(this._edTxt);
                  } else {
                    game.container.removeChild(this._edTxt);
                  }
                }

                const hasStyleSheet = legacyCC.GAME_VIEW ? contains(legacyCC.gameView.head, this._placeholderStyleSheet) : contains(document.head, this._placeholderStyleSheet);

                if (hasStyleSheet) {
                  if (legacyCC.GAME_VIEW) {
                    legacyCC.gameView.head.removeChild(this._placeholderStyleSheet);
                  } else {
                    document.head.removeChild(this._placeholderStyleSheet);
                  }
                }

                this._edTxt = null;
                this._placeholderStyleSheet = null;
              }

              _showDom() {
                this._updateMaxLength();

                this._updateInputType();

                this._updateStyleSheet();

                if (this._edTxt && this._delegate) {
                  this._edTxt.style.display = '';

                  this._delegate._hideLabels();
                }

                if (sys.isMobile) {
                  this._showDomOnMobile();
                }
              }

              _hideDom() {
                const elem = this._edTxt;

                if (elem && this._delegate) {
                  elem.style.display = 'none';

                  this._delegate._showLabels();
                }

                if (sys.isMobile) {
                  this._hideDomOnMobile();
                }
              }

              _showDomOnMobile() {
                if (sys.os !== OS.ANDROID && sys.os !== OS.OHOS) {
                  return;
                }

                screenAdapter.handleResizeEvent = false;

                this._adjustWindowScroll();
              }

              _hideDomOnMobile() {
                if (sys.os === OS.ANDROID || sys.os === OS.OHOS) {
                  screenAdapter.handleResizeEvent = true;
                }

                this._scrollBackWindow();
              }

              _adjustWindowScroll() {
                setTimeout(() => {
                  if (window.scrollY < SCROLLY) {
                    this._edTxt.scrollIntoView({
                      block: 'start',
                      inline: 'nearest',
                      behavior: 'smooth'
                    });
                  }
                }, DELAY_TIME);
              }

              _scrollBackWindow() {
                setTimeout(() => {
                  if (sys.browserType === BrowserType.WECHAT && sys.os === OS.IOS) {
                    if (window.top) {
                      window.top.scrollTo(0, 0);
                    }

                    return;
                  }

                  window.scrollTo(0, 0);
                }, DELAY_TIME);
              }

              _updateMatrix() {
                if (!this._edTxt) {
                  return;
                }

                const node = this._delegate.node;
                let scaleX = view.getScaleX();
                let scaleY = view.getScaleY();
                let widthRatio = 1;
                let heightRatio = 1;

                if (legacyCC.GAME_VIEW) {
                  widthRatio = legacyCC.gameView.canvas.width / legacyCC.game.canvas.width;
                  heightRatio = legacyCC.gameView.canvas.height / legacyCC.game.canvas.height;
                }

                scaleX *= widthRatio;
                scaleY *= heightRatio;
                const viewport = view.getViewportRect();
                const dpr = screenAdapter.devicePixelRatio;
                node.getWorldMatrix(_matrix$1);
                const transform = node._uiProps.uiTransformComp;

                if (transform) {
                  Vec3.set(_vec3, -transform.anchorX * transform.width, -transform.anchorY * transform.height, _vec3.z);
                }

                Mat4.transform(_matrix$1, _matrix$1, _vec3);

                if (!node._uiProps.uiTransformComp) {
                  return;
                }

                const camera = director.root.batcher2D.getFirstRenderCamera(node);
                if (!camera) return;
                camera.node.getWorldRT(_matrix_temp);
                const m12 = _matrix_temp.m12;
                const m13 = _matrix_temp.m13;
                const center = visibleRect.center;
                _matrix_temp.m12 = center.x - (_matrix_temp.m00 * m12 + _matrix_temp.m04 * m13);
                _matrix_temp.m13 = center.y - (_matrix_temp.m01 * m12 + _matrix_temp.m05 * m13);
                Mat4.multiply(_matrix_temp, _matrix_temp, _matrix$1);
                scaleX /= dpr;
                scaleY /= dpr;
                const container = legacyCC.GAME_VIEW ? legacyCC.gameView.container : game.container;
                const a = _matrix_temp.m00 * scaleX;
                const b = _matrix$1.m01;
                const c = _matrix$1.m04;
                const d = _matrix_temp.m05 * scaleY;
                let offsetX = parseInt(container && container.style.paddingLeft || '0');
                offsetX += viewport.x * widthRatio / dpr;
                let offsetY = parseInt(container && container.style.paddingBottom || '0');
                offsetY += viewport.y / dpr;
                const tx = _matrix_temp.m12 * scaleX + offsetX;
                const ty = _matrix_temp.m13 * scaleY + offsetY;
                const matrix = `matrix(${a},${-b},${-c},${d},${tx},${-ty})`;
                this._edTxt.style.transform = matrix;
                this._edTxt.style['-webkit-transform'] = matrix;
                this._edTxt.style['transform-origin'] = '0px 100% 0px';
                this._edTxt.style['-webkit-transform-origin'] = '0px 100% 0px';
              }

              _updateInputType() {
                const delegate = this._delegate;
                const inputMode = delegate.inputMode;
                const inputFlag = delegate.inputFlag;
                const returnType = delegate.returnType;
                let elem = this._edTxt;

                if (this._inputMode === inputMode && this._inputFlag === inputFlag && this._returnType === returnType) {
                  return;
                }

                this._inputMode = inputMode;
                this._inputFlag = inputFlag;
                this._returnType = returnType;

                if (this._isTextArea) {
                  let transform = 'none';

                  if (inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS) {
                    transform = 'uppercase';
                  } else if (inputFlag === InputFlag.INITIAL_CAPS_WORD) {
                    transform = 'capitalize';
                  }

                  elem.style.textTransform = transform;
                  return;
                }

                elem = elem;

                if (inputFlag === InputFlag.PASSWORD) {
                  elem.type = 'password';
                  elem.style.textTransform = 'none';
                  return;
                }

                let type = elem.type;

                if (inputMode === InputMode.EMAIL_ADDR) {
                  type = 'email';
                } else if (inputMode === InputMode.NUMERIC || inputMode === InputMode.DECIMAL) {
                  type = 'number';
                } else if (inputMode === InputMode.PHONE_NUMBER) {
                  type = 'number';
                  elem.pattern = '[0-9]*';
                  elem.addEventListener('wheel', () => false);
                } else if (inputMode === InputMode.URL) {
                  type = 'url';
                } else {
                  type = 'text';

                  if (returnType === KeyboardReturnType.SEARCH) {
                    type = 'search';
                  }
                }

                elem.type = type;
                let textTransform = 'none';

                if (inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS) {
                  textTransform = 'uppercase';
                } else if (inputFlag === InputFlag.INITIAL_CAPS_WORD) {
                  textTransform = 'capitalize';
                }

                elem.style.textTransform = textTransform;
              }

              _updateMaxLength() {
                let maxLength = this._delegate.maxLength;

                if (maxLength < 0) {
                  maxLength = 65535;
                }

                this._edTxt.maxLength = maxLength;
              }

              _initStyleSheet() {
                if (!this._edTxt) {
                  return;
                }

                let elem = this._edTxt;
                elem.style.color = '#000000';
                elem.style.border = '0px';
                elem.style.background = 'transparent';
                elem.style.width = '100%';
                elem.style.height = '100%';
                elem.style.outline = 'medium';
                elem.style.padding = '0';
                elem.style.textTransform = 'none';
                elem.style.display = 'none';
                elem.style.position = 'absolute';
                elem.style.bottom = '0px';
                elem.style.left = `${LEFT_PADDING}px`;
                elem.className = 'cocosEditBox';
                elem.style.fontFamily = 'Arial';
                elem.id = this._domId;

                if (!this._isTextArea) {
                  elem = elem;
                  elem.type = 'text';
                  elem.style['-moz-appearance'] = 'textfield';
                } else {
                  elem.style.resize = 'none';
                  elem.style.overflowY = 'scroll';
                }

                this._placeholderStyleSheet = document.createElement('style');
              }

              _updateStyleSheet() {
                const delegate = this._delegate;
                const elem = this._edTxt;

                if (elem && delegate) {
                  elem.value = delegate.string;
                  elem.placeholder = delegate.placeholder;

                  this._updateTextLabel(delegate.textLabel);

                  this._updatePlaceholderLabel(delegate.placeholderLabel);
                }
              }

              _updateTextLabel(textLabel) {
                if (!textLabel) {
                  return;
                }

                let font = textLabel.font;

                if (font && !(font instanceof BitmapFont)) {
                  font = font._fontFamily;
                } else {
                  font = textLabel.fontFamily;
                }

                const fontSize = textLabel.fontSize * textLabel.node.scale.y;

                if (this._textLabelFont === font && this._textLabelFontSize === fontSize && this._textLabelFontColor === textLabel.fontColor && this._textLabelAlign === textLabel.horizontalAlign) {
                  return;
                }

                this._textLabelFont = font;
                this._textLabelFontSize = fontSize;
                this._textLabelFontColor = textLabel.fontColor;
                this._textLabelAlign = textLabel.horizontalAlign;

                if (!this._edTxt) {
                  return;
                }

                const elem = this._edTxt;
                elem.style.fontSize = `${fontSize}px`;
                elem.style.color = textLabel.color.toCSS();
                elem.style.fontFamily = font;

                switch (textLabel.horizontalAlign) {
                  case Label.HorizontalAlign.LEFT:
                    elem.style.textAlign = 'left';
                    break;

                  case Label.HorizontalAlign.CENTER:
                    elem.style.textAlign = 'center';
                    break;

                  case Label.HorizontalAlign.RIGHT:
                    elem.style.textAlign = 'right';
                    break;
                }
              }

              _updatePlaceholderLabel(placeholderLabel) {
                if (!placeholderLabel) {
                  return;
                }

                let font = placeholderLabel.font;

                if (font && !(font instanceof BitmapFont)) {
                  font = placeholderLabel.font._fontFamily;
                } else {
                  font = placeholderLabel.fontFamily;
                }

                const fontSize = placeholderLabel.fontSize * placeholderLabel.node.scale.y;

                if (this._placeholderLabelFont === font && this._placeholderLabelFontSize === fontSize && this._placeholderLabelFontColor === placeholderLabel.fontColor && this._placeholderLabelAlign === placeholderLabel.horizontalAlign && this._placeholderLineHeight === placeholderLabel.fontSize) {
                  return;
                }

                this._placeholderLabelFont = font;
                this._placeholderLabelFontSize = fontSize;
                this._placeholderLabelFontColor = placeholderLabel.fontColor;
                this._placeholderLabelAlign = placeholderLabel.horizontalAlign;
                this._placeholderLineHeight = placeholderLabel.fontSize;
                const styleEl = this._placeholderStyleSheet;
                const fontColor = placeholderLabel.color.toCSS();
                const lineHeight = placeholderLabel.fontSize;
                let horizontalAlign = '';

                switch (placeholderLabel.horizontalAlign) {
                  case Label.HorizontalAlign.LEFT:
                    horizontalAlign = 'left';
                    break;

                  case Label.HorizontalAlign.CENTER:
                    horizontalAlign = 'center';
                    break;

                  case Label.HorizontalAlign.RIGHT:
                    horizontalAlign = 'right';
                    break;
                }

                styleEl.innerHTML = `#${this._domId}::-webkit-input-placeholder{text-transform: initial;-family: ${font};font-size: ${fontSize}px;color: ${fontColor};line-height: ${lineHeight}px;text-align: ${horizontalAlign};}` + `#${this._domId}::-moz-placeholder{text-transform: initial;-family: ${font};font-size: ${fontSize}px;color: ${fontColor};line-height: ${lineHeight}px;text-align: ${horizontalAlign};}` + `#${this._domId}::-ms-input-placeholder{text-transform: initial;-family: ${font};font-size: ${fontSize}px;color: ${fontColor};line-height: ${lineHeight}px;text-align: ${horizontalAlign};}`;

                if (sys.browserType === BrowserType.EDGE) {
                  styleEl.innerHTML += `#${this._domId}::-ms-clear{display: none;}`;
                }
              }

              _registerEventListeners() {
                if (!this._edTxt) {
                  return;
                }

                const elem = this._edTxt;
                let inputLock = false;
                const cbs = this.__eventListeners;

                cbs.compositionStart = () => {
                  inputLock = true;
                };

                cbs.compositionEnd = () => {
                  inputLock = false;

                  this._delegate._editBoxTextChanged(elem.value);
                };

                cbs.onInput = () => {
                  if (inputLock) {
                    return;
                  }

                  const delegate = this._delegate;
                  const maxLength = delegate.maxLength;

                  if (maxLength >= 0) {
                    elem.value = elem.value.slice(0, maxLength);
                  }

                  delegate._editBoxTextChanged(elem.value);
                };

                cbs.onClick = () => {
                  if (this._editing) {
                    if (sys.isMobile) {
                      this._adjustWindowScroll();
                    }
                  }
                };

                cbs.onKeydown = e => {
                  if (e.keyCode === KeyCode.ENTER) {
                    e.propagationStopped = true;

                    this._delegate._editBoxEditingReturn();

                    if (!this._isTextArea) {
                      elem.blur();
                    }
                  } else if (e.keyCode === KeyCode.TAB) {
                    e.propagationStopped = true;
                    e.preventDefault();
                    tabIndexUtil.next(this);
                  }
                };

                cbs.onBlur = () => {
                  if (sys.isMobile && inputLock) {
                    cbs.compositionEnd();
                  }

                  this._editing = false;
                  _currentEditBoxImpl = null;

                  this._hideDom();

                  this._delegate._editBoxEditingDidEnded();
                };

                elem.addEventListener('compositionstart', cbs.compositionStart);
                elem.addEventListener('compositionend', cbs.compositionEnd);
                elem.addEventListener('input', cbs.onInput);
                elem.addEventListener('keydown', cbs.onKeydown);
                elem.addEventListener('blur', cbs.onBlur);
                elem.addEventListener('touchstart', cbs.onClick);
              }

              _removeEventListeners() {
                if (!this._edTxt) {
                  return;
                }

                const elem = this._edTxt;
                const cbs = this.__eventListeners;
                elem.removeEventListener('compositionstart', cbs.compositionStart);
                elem.removeEventListener('compositionend', cbs.compositionEnd);
                elem.removeEventListener('input', cbs.onInput);
                elem.removeEventListener('keydown', cbs.onKeydown);
                elem.removeEventListener('blur', cbs.onBlur);
                elem.removeEventListener('touchstart', cbs.onClick);
                cbs.compositionStart = null;
                cbs.compositionEnd = null;
                cbs.onInput = null;
                cbs.onKeydown = null;
                cbs.onBlur = null;
                cbs.onClick = null;
              }

            }

            var _dec$u, _dec2$p, _dec3$o, _dec4$n, _dec5$l, _dec6$i, _dec7$i, _dec8$g, _dec9$d, _dec10$c, _dec11$9, _dec12$9, _dec13$8, _dec14$6, _dec15$6, _dec16$6, _dec17$4, _dec18$4, _dec19$4, _dec20$3, _dec21$3, _dec22$3, _dec23$3, _dec24$3, _dec25$3, _dec26$3, _dec27$3, _dec28$3, _dec29$3, _dec30$3, _dec31$2, _dec32$2, _dec33$1, _dec34$1, _dec35$1, _dec36$1, _dec37$1, _dec38$1, _dec39$1, _dec40$1, _dec41$1, _dec42$1, _dec43$1, _class$u, _class2$o, _descriptor$n, _descriptor2$k, _descriptor3$f, _descriptor4$e, _descriptor5$c, _descriptor6$9, _descriptor7$7, _descriptor8$7, _descriptor9$6, _descriptor10$5, _descriptor11$4, _descriptor12$3, _descriptor13$2, _class3$8, _temp$r;
            const LEFT_PADDING$1 = 2;

            function capitalize(str) {
              return str.replace(/(?:^|\s)\S/g, a => a.toUpperCase());
            }

            function capitalizeFirstLetter(str) {
              return str.charAt(0).toUpperCase() + str.slice(1);
            }

            var EventType$2;

            (function (EventType) {
              EventType["EDITING_DID_BEGAN"] = "editing-did-began";
              EventType["EDITING_DID_ENDED"] = "editing-did-ended";
              EventType["TEXT_CHANGED"] = "text-changed";
              EventType["EDITING_RETURN"] = "editing-return";
            })(EventType$2 || (EventType$2 = {}));

            let EditBox = function (v) { return exports({ EditBox: v, EditBoxComponent: v }), v; }((_dec$u = ccclass('cc.EditBox'), _dec2$p = help(), _dec3$o = executionOrder(110), _dec4$n = menu$1(), _dec5$l = requireComponent(UITransform), _dec6$i = displayOrder(), _dec7$i = tooltip(), _dec8$g = displayOrder(), _dec9$d = tooltip(), _dec10$c = type$1(Label), _dec11$9 = displayOrder(), _dec12$9 = tooltip(), _dec13$8 = type$1(Label), _dec14$6 = displayOrder(), _dec15$6 = tooltip(), _dec16$6 = type$1(SpriteFrame), _dec17$4 = displayOrder(), _dec18$4 = tooltip(), _dec19$4 = type$1(InputFlag), _dec20$3 = displayOrder(), _dec21$3 = tooltip(), _dec22$3 = type$1(InputMode), _dec23$3 = displayOrder(), _dec24$3 = tooltip(), _dec25$3 = type$1(KeyboardReturnType), _dec26$3 = displayOrder(), _dec27$3 = tooltip(), _dec28$3 = displayOrder(), _dec29$3 = tooltip(), _dec30$3 = displayOrder(), _dec31$2 = tooltip(), _dec32$2 = type$1([EventHandler]), _dec33$1 = displayOrder(), _dec34$1 = tooltip(), _dec35$1 = type$1([EventHandler]), _dec36$1 = displayOrder(), _dec37$1 = tooltip(), _dec38$1 = type$1([EventHandler]), _dec39$1 = displayOrder(), _dec40$1 = tooltip(), _dec41$1 = type$1([EventHandler]), _dec42$1 = displayOrder(), _dec43$1 = tooltip(), _dec$u(_class$u = _dec2$p(_class$u = _dec3$o(_class$u = _dec4$n(_class$u = _dec5$l(_class$u = executeInEditMode(_class$u = (_class2$o = (_temp$r = _class3$8 = class EditBox extends Component {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "editingDidBegan", _descriptor$n, this);

                _initializerDefineProperty(this, "textChanged", _descriptor2$k, this);

                _initializerDefineProperty(this, "editingDidEnded", _descriptor3$f, this);

                _initializerDefineProperty(this, "editingReturn", _descriptor4$e, this);

                this._impl = null;
                this._background = null;

                _initializerDefineProperty(this, "_textLabel", _descriptor5$c, this);

                _initializerDefineProperty(this, "_placeholderLabel", _descriptor6$9, this);

                _initializerDefineProperty(this, "_returnType", _descriptor7$7, this);

                _initializerDefineProperty(this, "_string", _descriptor8$7, this);

                _initializerDefineProperty(this, "_tabIndex", _descriptor9$6, this);

                _initializerDefineProperty(this, "_backgroundImage", _descriptor10$5, this);

                _initializerDefineProperty(this, "_inputFlag", _descriptor11$4, this);

                _initializerDefineProperty(this, "_inputMode", _descriptor12$3, this);

                _initializerDefineProperty(this, "_maxLength", _descriptor13$2, this);

                this._isLabelVisible = false;
              }

              get string() {
                return this._string;
              }

              set string(value) {
                if (this._maxLength >= 0 && value.length >= this._maxLength) {
                  value = value.slice(0, this._maxLength);
                }

                if (this._string === value) {
                  return;
                }

                this._string = value;

                this._updateString(value);
              }

              get placeholder() {
                if (!this._placeholderLabel) {
                  return '';
                }

                return this._placeholderLabel.string;
              }

              set placeholder(value) {
                if (this._placeholderLabel) {
                  this._placeholderLabel.string = value;
                }
              }

              get textLabel() {
                return this._textLabel;
              }

              set textLabel(oldValue) {
                if (this._textLabel !== oldValue) {
                  this._textLabel = oldValue;

                  if (this._textLabel) {
                    this._updateTextLabel();

                    this._updateLabels();
                  }
                }
              }

              get placeholderLabel() {
                return this._placeholderLabel;
              }

              set placeholderLabel(oldValue) {
                if (this._placeholderLabel !== oldValue) {
                  this._placeholderLabel = oldValue;

                  if (this._placeholderLabel) {
                    this._updatePlaceholderLabel();

                    this._updateLabels();
                  }
                }
              }

              get backgroundImage() {
                return this._backgroundImage;
              }

              set backgroundImage(value) {
                if (this._backgroundImage === value) {
                  return;
                }

                this._backgroundImage = value;

                this._ensureBackgroundSprite();

                this._background.spriteFrame = value;
              }

              get inputFlag() {
                return this._inputFlag;
              }

              set inputFlag(value) {
                if (this._inputFlag === value) {
                  return;
                }

                this._inputFlag = value;

                this._updateString(this._string);
              }

              get inputMode() {
                return this._inputMode;
              }

              set inputMode(oldValue) {
                if (this._inputMode !== oldValue) {
                  this._inputMode = oldValue;

                  this._updateTextLabel();

                  this._updatePlaceholderLabel();
                }
              }

              get returnType() {
                return this._returnType;
              }

              set returnType(value) {
                this._returnType = value;
              }

              get maxLength() {
                return this._maxLength;
              }

              set maxLength(value) {
                this._maxLength = value;
              }

              get tabIndex() {
                return this._tabIndex;
              }

              set tabIndex(value) {
                if (this._tabIndex !== value) {
                  this._tabIndex = value;

                  if (this._impl) {
                    this._impl.setTabIndex(value);
                  }
                }
              }

              __preload() {
                this._init();
              }

              onEnable() {
                {
                  this._registerEvent();
                }

                this._ensureBackgroundSprite();

                if (this._impl) {
                  this._impl.onEnable();
                }
              }

              update() {
                if (this._impl) {
                  this._impl.update();
                }
              }

              onDisable() {
                {
                  this._unregisterEvent();
                }

                this._unregisterBackgroundEvent();

                if (this._impl) {
                  this._impl.onDisable();
                }
              }

              onDestroy() {
                if (this._impl) {
                  this._impl.clear();
                }
              }

              setFocus() {
                if (this._impl) {
                  this._impl.setFocus(true);
                }
              }

              focus() {
                if (this._impl) {
                  this._impl.setFocus(true);
                }
              }

              blur() {
                if (this._impl) {
                  this._impl.setFocus(false);
                }
              }

              isFocused() {
                if (this._impl) {
                  return this._impl.isFocused();
                }

                return false;
              }

              _editBoxEditingDidBegan() {
                EventHandler.emitEvents(this.editingDidBegan, this);
                this.node.emit(EventType$2.EDITING_DID_BEGAN, this);
              }

              _editBoxEditingDidEnded() {
                EventHandler.emitEvents(this.editingDidEnded, this);
                this.node.emit(EventType$2.EDITING_DID_ENDED, this);
              }

              _editBoxTextChanged(text) {
                text = this._updateLabelStringStyle(text, true);
                this.string = text;
                EventHandler.emitEvents(this.textChanged, text, this);
                this.node.emit(EventType$2.TEXT_CHANGED, this);
              }

              _editBoxEditingReturn() {
                EventHandler.emitEvents(this.editingReturn, this);
                this.node.emit(EventType$2.EDITING_RETURN, this);
              }

              _showLabels() {
                this._isLabelVisible = true;

                this._updateLabels();
              }

              _hideLabels() {
                this._isLabelVisible = false;

                if (this._textLabel) {
                  this._textLabel.node.active = false;
                }

                if (this._placeholderLabel) {
                  this._placeholderLabel.node.active = false;
                }
              }

              _onTouchBegan(event) {
                event.propagationStopped = true;
              }

              _onTouchCancel(event) {
                event.propagationStopped = true;
              }

              _onTouchEnded(event) {
                if (this._impl) {
                  this._impl.beginEditing();
                }

                event.propagationStopped = true;
              }

              _init() {
                this._updatePlaceholderLabel();

                this._updateTextLabel();

                this._isLabelVisible = true;
                this.node.on(NodeEventType.SIZE_CHANGED, this._resizeChildNodes, this);
                const impl = this._impl = new EditBox._EditBoxImpl();
                impl.init(this);

                this._updateString(this._string);

                this._syncSize();
              }

              _ensureBackgroundSprite() {
                if (!this._background) {
                  let background = this.node.getComponent(Sprite);

                  if (!background) {
                    background = this.node.addComponent(Sprite);
                  }

                  if (background !== this._background) {
                    background.type = Sprite.Type.SLICED;
                    background.spriteFrame = this._backgroundImage;
                    this._background = background;

                    this._registerBackgroundEvent();
                  }
                }
              }

              _updateTextLabel() {
                let textLabel = this._textLabel;

                if (!textLabel) {
                  let node = this.node.getChildByName('TEXT_LABEL');

                  if (!node) {
                    node = new Node('TEXT_LABEL');
                  }

                  textLabel = node.getComponent(Label);

                  if (!textLabel) {
                    textLabel = node.addComponent(Label);
                  }

                  node.parent = this.node;
                  this._textLabel = textLabel;
                }

                const transformComp = this._textLabel.node._uiProps.uiTransformComp;
                transformComp.setAnchorPoint(0, 1);
                textLabel.overflow = Label.Overflow.CLAMP;

                if (this._inputMode === InputMode.ANY) {
                  textLabel.verticalAlign = VerticalTextAlignment.TOP;
                  textLabel.enableWrapText = true;
                } else {
                  textLabel.enableWrapText = false;
                }

                textLabel.string = this._updateLabelStringStyle(this._string);
              }

              _updatePlaceholderLabel() {
                let placeholderLabel = this._placeholderLabel;

                if (!placeholderLabel) {
                  let node = this.node.getChildByName('PLACEHOLDER_LABEL');

                  if (!node) {
                    node = new Node('PLACEHOLDER_LABEL');
                  }

                  placeholderLabel = node.getComponent(Label);

                  if (!placeholderLabel) {
                    placeholderLabel = node.addComponent(Label);
                  }

                  node.parent = this.node;
                  this._placeholderLabel = placeholderLabel;
                }

                const transform = this._placeholderLabel.node._uiProps.uiTransformComp;
                transform.setAnchorPoint(0, 1);
                placeholderLabel.overflow = Label.Overflow.CLAMP;

                if (this._inputMode === InputMode.ANY) {
                  placeholderLabel.verticalAlign = VerticalTextAlignment.TOP;
                  placeholderLabel.enableWrapText = true;
                } else {
                  placeholderLabel.enableWrapText = false;
                }

                placeholderLabel.string = this.placeholder;
              }

              _syncSize() {
                const trans = this.node._uiProps.uiTransformComp;
                const size = trans.contentSize;

                if (this._background) {
                  const bgTrans = this._background.node._uiProps.uiTransformComp;
                  bgTrans.anchorPoint = trans.anchorPoint;
                  bgTrans.setContentSize(size);
                }

                this._updateLabelPosition(size);

                if (this._impl) {
                  this._impl.setSize(size.width, size.height);
                }
              }

              _updateLabels() {
                if (this._isLabelVisible) {
                  const content = this._string;

                  if (this._textLabel) {
                    this._textLabel.node.active = content !== '';
                  }

                  if (this._placeholderLabel) {
                    this._placeholderLabel.node.active = content === '';
                  }
                }
              }

              _updateString(text) {
                const textLabel = this._textLabel;

                if (!textLabel) {
                  return;
                }

                let displayText = text;

                if (displayText) {
                  displayText = this._updateLabelStringStyle(displayText);
                }

                textLabel.string = displayText;

                this._updateLabels();
              }

              _updateLabelStringStyle(text, ignorePassword = false) {
                const inputFlag = this._inputFlag;

                if (!ignorePassword && inputFlag === InputFlag.PASSWORD) {
                  let passwordString = '';
                  const len = text.length;

                  for (let i = 0; i < len; ++i) {
                    passwordString += '\u25CF';
                  }

                  text = passwordString;
                } else if (inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS) {
                  text = text.toUpperCase();
                } else if (inputFlag === InputFlag.INITIAL_CAPS_WORD) {
                  text = capitalize(text);
                } else if (inputFlag === InputFlag.INITIAL_CAPS_SENTENCE) {
                  text = capitalizeFirstLetter(text);
                }

                return text;
              }

              _registerEvent() {
                this.node.on(NodeEventType.TOUCH_START, this._onTouchBegan, this);
                this.node.on(NodeEventType.TOUCH_END, this._onTouchEnded, this);
              }

              _unregisterEvent() {
                this.node.off(NodeEventType.TOUCH_START, this._onTouchBegan, this);
                this.node.off(NodeEventType.TOUCH_END, this._onTouchEnded, this);
              }

              _onBackgroundSpriteFrameChanged() {
                if (!this._background) {
                  return;
                }

                this.backgroundImage = this._background.spriteFrame;
              }

              _registerBackgroundEvent() {
                const node = this._background && this._background.node;
                node === null || node === void 0 ? void 0 : node.on(Sprite.EventType.SPRITE_FRAME_CHANGED, this._onBackgroundSpriteFrameChanged, this);
              }

              _unregisterBackgroundEvent() {
                const node = this._background && this._background.node;
                node === null || node === void 0 ? void 0 : node.off(Sprite.EventType.SPRITE_FRAME_CHANGED, this._onBackgroundSpriteFrameChanged, this);
              }

              _updateLabelPosition(size) {
                const trans = this.node._uiProps.uiTransformComp;
                const offX = -trans.anchorX * trans.width;
                const offY = -trans.anchorY * trans.height;
                const placeholderLabel = this._placeholderLabel;
                const textLabel = this._textLabel;

                if (textLabel) {
                  textLabel.node._uiProps.uiTransformComp.setContentSize(size.width - LEFT_PADDING$1, size.height);

                  textLabel.node.setPosition(offX + LEFT_PADDING$1, offY + size.height, textLabel.node.position.z);

                  if (this._inputMode === InputMode.ANY) {
                    textLabel.verticalAlign = VerticalTextAlignment.TOP;
                  }

                  textLabel.enableWrapText = this._inputMode === InputMode.ANY;
                }

                if (placeholderLabel) {
                  placeholderLabel.node._uiProps.uiTransformComp.setContentSize(size.width - LEFT_PADDING$1, size.height);

                  placeholderLabel.lineHeight = size.height;
                  placeholderLabel.node.setPosition(offX + LEFT_PADDING$1, offY + size.height, placeholderLabel.node.position.z);

                  if (this._inputMode === InputMode.ANY) {
                    placeholderLabel.verticalAlign = VerticalTextAlignment.TOP;
                  }

                  placeholderLabel.enableWrapText = this._inputMode === InputMode.ANY;
                }
              }

              _resizeChildNodes() {
                const trans = this.node._uiProps.uiTransformComp;
                const textLabelNode = this._textLabel && this._textLabel.node;

                if (textLabelNode) {
                  textLabelNode.setPosition(-trans.width / 2, trans.height / 2, textLabelNode.position.z);

                  textLabelNode._uiProps.uiTransformComp.setContentSize(trans.contentSize);
                }

                const placeholderLabelNode = this._placeholderLabel && this._placeholderLabel.node;

                if (placeholderLabelNode) {
                  placeholderLabelNode.setPosition(-trans.width / 2, trans.height / 2, placeholderLabelNode.position.z);

                  placeholderLabelNode._uiProps.uiTransformComp.setContentSize(trans.contentSize);
                }

                const backgroundNode = this._background && this._background.node;

                if (backgroundNode) {
                  backgroundNode._uiProps.uiTransformComp.setContentSize(trans.contentSize);
                }
              }

            }, _class3$8._EditBoxImpl = EditBoxImplBase, _class3$8.KeyboardReturnType = KeyboardReturnType, _class3$8.InputFlag = InputFlag, _class3$8.InputMode = InputMode, _class3$8.EventType = EventType$2, _temp$r), (_applyDecoratedDescriptor(_class2$o.prototype, "string", [_dec6$i, _dec7$i], Object.getOwnPropertyDescriptor(_class2$o.prototype, "string"), _class2$o.prototype), _applyDecoratedDescriptor(_class2$o.prototype, "placeholder", [_dec8$g, _dec9$d], Object.getOwnPropertyDescriptor(_class2$o.prototype, "placeholder"), _class2$o.prototype), _applyDecoratedDescriptor(_class2$o.prototype, "textLabel", [_dec10$c, _dec11$9, _dec12$9], Object.getOwnPropertyDescriptor(_class2$o.prototype, "textLabel"), _class2$o.prototype), _applyDecoratedDescriptor(_class2$o.prototype, "placeholderLabel", [_dec13$8, _dec14$6, _dec15$6], Object.getOwnPropertyDescriptor(_class2$o.prototype, "placeholderLabel"), _class2$o.prototype), _applyDecoratedDescriptor(_class2$o.prototype, "backgroundImage", [_dec16$6, _dec17$4, _dec18$4], Object.getOwnPropertyDescriptor(_class2$o.prototype, "backgroundImage"), _class2$o.prototype), _applyDecoratedDescriptor(_class2$o.prototype, "inputFlag", [_dec19$4, _dec20$3, _dec21$3], Object.getOwnPropertyDescriptor(_class2$o.prototype, "inputFlag"), _class2$o.prototype), _applyDecoratedDescriptor(_class2$o.prototype, "inputMode", [_dec22$3, _dec23$3, _dec24$3], Object.getOwnPropertyDescriptor(_class2$o.prototype, "inputMode"), _class2$o.prototype), _applyDecoratedDescriptor(_class2$o.prototype, "returnType", [_dec25$3, _dec26$3, _dec27$3], Object.getOwnPropertyDescriptor(_class2$o.prototype, "returnType"), _class2$o.prototype), _applyDecoratedDescriptor(_class2$o.prototype, "maxLength", [_dec28$3, _dec29$3], Object.getOwnPropertyDescriptor(_class2$o.prototype, "maxLength"), _class2$o.prototype), _applyDecoratedDescriptor(_class2$o.prototype, "tabIndex", [_dec30$3, _dec31$2], Object.getOwnPropertyDescriptor(_class2$o.prototype, "tabIndex"), _class2$o.prototype), _descriptor$n = _applyDecoratedDescriptor(_class2$o.prototype, "editingDidBegan", [_dec32$2, serializable, _dec33$1, _dec34$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor2$k = _applyDecoratedDescriptor(_class2$o.prototype, "textChanged", [_dec35$1, serializable, _dec36$1, _dec37$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor3$f = _applyDecoratedDescriptor(_class2$o.prototype, "editingDidEnded", [_dec38$1, serializable, _dec39$1, _dec40$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor4$e = _applyDecoratedDescriptor(_class2$o.prototype, "editingReturn", [_dec41$1, serializable, _dec42$1, _dec43$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor5$c = _applyDecoratedDescriptor(_class2$o.prototype, "_textLabel", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor6$9 = _applyDecoratedDescriptor(_class2$o.prototype, "_placeholderLabel", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor7$7 = _applyDecoratedDescriptor(_class2$o.prototype, "_returnType", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return KeyboardReturnType.DEFAULT;
              }
            }), _descriptor8$7 = _applyDecoratedDescriptor(_class2$o.prototype, "_string", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            }), _descriptor9$6 = _applyDecoratedDescriptor(_class2$o.prototype, "_tabIndex", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor10$5 = _applyDecoratedDescriptor(_class2$o.prototype, "_backgroundImage", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor11$4 = _applyDecoratedDescriptor(_class2$o.prototype, "_inputFlag", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return InputFlag.DEFAULT;
              }
            }), _descriptor12$3 = _applyDecoratedDescriptor(_class2$o.prototype, "_inputMode", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return InputMode.ANY;
              }
            }), _descriptor13$2 = _applyDecoratedDescriptor(_class2$o.prototype, "_maxLength", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 20;
              }
            })), _class2$o)) || _class$u) || _class$u) || _class$u) || _class$u) || _class$u) || _class$u));

            if (typeof window === 'object' && typeof document === 'object' && !MINIGAME && !( OPEN_HARMONY) && !RUNTIME_BASED) {
              EditBox._EditBoxImpl = EditBoxImpl;
            }

            var _dec$v, _dec2$q, _dec3$p, _dec4$o, _dec5$m, _dec6$j, _dec7$j, _dec8$h, _dec9$e, _dec10$d, _dec11$a, _dec12$a, _dec13$9, _dec14$7, _dec15$7, _dec16$7, _dec17$5, _dec18$5, _dec19$5, _dec20$4, _dec21$4, _dec22$4, _dec23$4, _dec24$4, _dec25$4, _dec26$4, _dec27$4, _dec28$4, _dec29$4, _dec30$4, _dec31$3, _dec32$3, _dec33$2, _dec34$2, _class$v, _class2$p, _descriptor$o, _descriptor2$l, _descriptor3$g, _descriptor4$f, _descriptor5$d, _descriptor6$a, _descriptor7$8, _descriptor8$8, _descriptor9$7, _descriptor10$6, _descriptor11$5, _descriptor12$4, _descriptor13$3, _descriptor14$2, _descriptor15$1, _descriptor16$1, _class3$9, _temp$s;
            var Type;

            (function (Type) {
              Type[Type["NONE"] = 0] = "NONE";
              Type[Type["HORIZONTAL"] = 1] = "HORIZONTAL";
              Type[Type["VERTICAL"] = 2] = "VERTICAL";
              Type[Type["GRID"] = 3] = "GRID";
            })(Type || (Type = {}));

            ccenum(Type);
            var ResizeMode;

            (function (ResizeMode) {
              ResizeMode[ResizeMode["NONE"] = 0] = "NONE";
              ResizeMode[ResizeMode["CONTAINER"] = 1] = "CONTAINER";
              ResizeMode[ResizeMode["CHILDREN"] = 2] = "CHILDREN";
            })(ResizeMode || (ResizeMode = {}));

            ccenum(ResizeMode);
            var AxisDirection;

            (function (AxisDirection) {
              AxisDirection[AxisDirection["HORIZONTAL"] = 0] = "HORIZONTAL";
              AxisDirection[AxisDirection["VERTICAL"] = 1] = "VERTICAL";
            })(AxisDirection || (AxisDirection = {}));

            ccenum(AxisDirection);
            var VerticalDirection;

            (function (VerticalDirection) {
              VerticalDirection[VerticalDirection["BOTTOM_TO_TOP"] = 0] = "BOTTOM_TO_TOP";
              VerticalDirection[VerticalDirection["TOP_TO_BOTTOM"] = 1] = "TOP_TO_BOTTOM";
            })(VerticalDirection || (VerticalDirection = {}));

            ccenum(VerticalDirection);
            var HorizontalDirection;

            (function (HorizontalDirection) {
              HorizontalDirection[HorizontalDirection["LEFT_TO_RIGHT"] = 0] = "LEFT_TO_RIGHT";
              HorizontalDirection[HorizontalDirection["RIGHT_TO_LEFT"] = 1] = "RIGHT_TO_LEFT";
            })(HorizontalDirection || (HorizontalDirection = {}));

            ccenum(HorizontalDirection);
            var Constraint;

            (function (Constraint) {
              Constraint[Constraint["NONE"] = 0] = "NONE";
              Constraint[Constraint["FIXED_ROW"] = 1] = "FIXED_ROW";
              Constraint[Constraint["FIXED_COL"] = 2] = "FIXED_COL";
            })(Constraint || (Constraint = {}));

            ccenum(Constraint);

            const _tempVec3 = new Vec3();

            let Layout = function (v) { return exports({ Layout: v, LayoutComponent: v }), v; }((_dec$v = ccclass('cc.Layout'), _dec2$q = help(), _dec3$p = executionOrder(110), _dec4$o = menu$1(), _dec5$m = requireComponent(UITransform), _dec6$j = visible(), _dec7$j = tooltip(), _dec8$h = visible(), _dec9$e = tooltip(), _dec10$d = type$1(Type), _dec11$a = tooltip(), _dec12$a = type$1(ResizeMode), _dec13$9 = visible(), _dec14$7 = tooltip(), _dec15$7 = visible(), _dec16$7 = tooltip(), _dec17$5 = type$1(AxisDirection), _dec18$5 = tooltip(), _dec19$5 = tooltip(), _dec20$4 = tooltip(), _dec21$4 = tooltip(), _dec22$4 = tooltip(), _dec23$4 = tooltip(), _dec24$4 = tooltip(), _dec25$4 = type$1(VerticalDirection), _dec26$4 = tooltip(), _dec27$4 = type$1(HorizontalDirection), _dec28$4 = tooltip(), _dec29$4 = type$1(Constraint), _dec30$4 = visible(), _dec31$3 = tooltip(), _dec32$3 = visible(), _dec33$2 = tooltip(), _dec34$2 = tooltip(), _dec$v(_class$v = _dec2$q(_class$v = _dec3$p(_class$v = _dec4$o(_class$v = _dec5$m(_class$v = executeInEditMode(_class$v = (_class2$p = (_temp$s = _class3$9 = class Layout extends Component {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "_resizeMode", _descriptor$o, this);

                _initializerDefineProperty(this, "_layoutType", _descriptor2$l, this);

                _initializerDefineProperty(this, "_cellSize", _descriptor3$g, this);

                _initializerDefineProperty(this, "_startAxis", _descriptor4$f, this);

                _initializerDefineProperty(this, "_paddingLeft", _descriptor5$d, this);

                _initializerDefineProperty(this, "_paddingRight", _descriptor6$a, this);

                _initializerDefineProperty(this, "_paddingTop", _descriptor7$8, this);

                _initializerDefineProperty(this, "_paddingBottom", _descriptor8$8, this);

                _initializerDefineProperty(this, "_spacingX", _descriptor9$7, this);

                _initializerDefineProperty(this, "_spacingY", _descriptor10$6, this);

                _initializerDefineProperty(this, "_verticalDirection", _descriptor11$5, this);

                _initializerDefineProperty(this, "_horizontalDirection", _descriptor12$4, this);

                _initializerDefineProperty(this, "_constraint", _descriptor13$3, this);

                _initializerDefineProperty(this, "_constraintNum", _descriptor14$2, this);

                _initializerDefineProperty(this, "_affectedByScale", _descriptor15$1, this);

                _initializerDefineProperty(this, "_isAlign", _descriptor16$1, this);

                this._layoutSize = new Size$1(300, 200);
                this._layoutDirty = true;
                this._childrenDirty = false;
                this._usefulLayoutObj = [];
                this._init = false;
              }

              get alignHorizontal() {
                return this._isAlign;
              }

              set alignHorizontal(value) {
                if (this._layoutType !== Type.HORIZONTAL) {
                  return;
                }

                this._isAlign = value;

                this._doLayoutDirty();
              }

              get alignVertical() {
                return this._isAlign;
              }

              set alignVertical(value) {
                if (this._layoutType !== Type.VERTICAL) {
                  return;
                }

                this._isAlign = value;

                this._doLayoutDirty();
              }

              get type() {
                return this._layoutType;
              }

              set type(value) {
                this._layoutType = value;

                this._doLayoutDirty();
              }

              get resizeMode() {
                return this._resizeMode;
              }

              set resizeMode(value) {
                if (this._layoutType === Type.NONE) {
                  return;
                }

                this._resizeMode = value;

                this._doLayoutDirty();
              }

              get cellSize() {
                return this._cellSize;
              }

              set cellSize(value) {
                if (this._cellSize === value) {
                  return;
                }

                this._cellSize.set(value);

                this._doLayoutDirty();
              }

              get startAxis() {
                return this._startAxis;
              }

              set startAxis(value) {
                if (this._startAxis === value) {
                  return;
                }

                this._startAxis = value;

                this._doLayoutDirty();
              }

              get paddingLeft() {
                return this._paddingLeft;
              }

              set paddingLeft(value) {
                if (this._paddingLeft === value) {
                  return;
                }

                this._paddingLeft = value;

                this._doLayoutDirty();
              }

              get paddingRight() {
                return this._paddingRight;
              }

              set paddingRight(value) {
                if (this._paddingRight === value) {
                  return;
                }

                this._paddingRight = value;

                this._doLayoutDirty();
              }

              get paddingTop() {
                return this._paddingTop;
              }

              set paddingTop(value) {
                if (this._paddingTop === value) {
                  return;
                }

                this._paddingTop = value;

                this._doLayoutDirty();
              }

              get paddingBottom() {
                return this._paddingBottom;
              }

              set paddingBottom(value) {
                if (this._paddingBottom === value) {
                  return;
                }

                this._paddingBottom = value;

                this._doLayoutDirty();
              }

              get spacingX() {
                return this._spacingX;
              }

              set spacingX(value) {
                if (this._spacingX === value) {
                  return;
                }

                this._spacingX = value;

                this._doLayoutDirty();
              }

              get spacingY() {
                return this._spacingY;
              }

              set spacingY(value) {
                if (this._spacingY === value) {
                  return;
                }

                this._spacingY = value;

                this._doLayoutDirty();
              }

              get verticalDirection() {
                return this._verticalDirection;
              }

              set verticalDirection(value) {
                if (this._verticalDirection === value) {
                  return;
                }

                this._verticalDirection = value;

                this._doLayoutDirty();
              }

              get horizontalDirection() {
                return this._horizontalDirection;
              }

              set horizontalDirection(value) {
                if (this._horizontalDirection === value) {
                  return;
                }

                this._horizontalDirection = value;

                this._doLayoutDirty();
              }

              get padding() {
                return this._paddingLeft;
              }

              set padding(value) {
                if (this.paddingLeft !== value || this._paddingRight !== value || this._paddingTop !== value || this._paddingBottom !== value) {
                  this._paddingLeft = this._paddingRight = this._paddingTop = this._paddingBottom = value;

                  this._doLayoutDirty();
                }
              }

              get constraint() {
                return this._constraint;
              }

              set constraint(value) {
                if (this._layoutType === Type.NONE || this._constraint === value) {
                  return;
                }

                this._constraint = value;

                this._doLayoutDirty();
              }

              get constraintNum() {
                return this._constraintNum;
              }

              set constraintNum(value) {
                if (this._constraint === Constraint.NONE || this._constraintNum === value) {
                  return;
                }

                if (value <= 0) {
                  warn('Limit values to be greater than 0');
                }

                this._constraintNum = value;

                this._doLayoutDirty();
              }

              get affectedByScale() {
                return this._affectedByScale;
              }

              set affectedByScale(value) {
                this._affectedByScale = value;

                this._doLayoutDirty();
              }

              updateLayout(force = false) {
                if ((this._layoutDirty || force) && this.node.children.length > 0) {
                  this._doLayout();

                  this._layoutDirty = false;
                }
              }

              onEnable() {
                this._addEventListeners();

                const trans = this.node._uiProps.uiTransformComp;

                if (trans.contentSize.equals(Size$1.ZERO)) {
                  trans.setContentSize(this._layoutSize);
                }

                this._childrenChanged();
              }

              onDisable() {
                this._usefulLayoutObj.length = 0;

                this._removeEventListeners();
              }

              _checkUsefulObj() {
                this._usefulLayoutObj.length = 0;
                const children = this.node.children;

                for (let i = 0; i < children.length; ++i) {
                  const child = children[i];
                  const uiTrans = child._uiProps.uiTransformComp;

                  if (child.activeInHierarchy && uiTrans) {
                    this._usefulLayoutObj.push(uiTrans);
                  }
                }
              }

              _addEventListeners() {
                director.on(Director.EVENT_AFTER_UPDATE, this.updateLayout, this);
                this.node.on(NodeEventType.SIZE_CHANGED, this._resized, this);
                this.node.on(NodeEventType.ANCHOR_CHANGED, this._doLayoutDirty, this);
                this.node.on(NodeEventType.CHILD_ADDED, this._childAdded, this);
                this.node.on(NodeEventType.CHILD_REMOVED, this._childRemoved, this);
                this.node.on(NodeEventType.SIBLING_ORDER_CHANGED, this._childrenChanged, this);
                this.node.on('childrenSiblingOrderChanged', this.updateLayout, this);

                this._addChildrenEventListeners();
              }

              _removeEventListeners() {
                director.off(Director.EVENT_AFTER_UPDATE, this.updateLayout, this);
                this.node.off(NodeEventType.SIZE_CHANGED, this._resized, this);
                this.node.off(NodeEventType.ANCHOR_CHANGED, this._doLayoutDirty, this);
                this.node.off(NodeEventType.CHILD_ADDED, this._childAdded, this);
                this.node.off(NodeEventType.CHILD_REMOVED, this._childRemoved, this);
                this.node.off(NodeEventType.SIBLING_ORDER_CHANGED, this._childrenChanged, this);
                this.node.off('childrenSiblingOrderChanged', this.updateLayout, this);

                this._removeChildrenEventListeners();
              }

              _addChildrenEventListeners() {
                const children = this.node.children;

                for (let i = 0; i < children.length; ++i) {
                  const child = children[i];
                  child.on(NodeEventType.SIZE_CHANGED, this._doLayoutDirty, this);
                  child.on(NodeEventType.TRANSFORM_CHANGED, this._transformDirty, this);
                  child.on(NodeEventType.ANCHOR_CHANGED, this._doLayoutDirty, this);
                  child.on(NodeEventType.ACTIVE_IN_HIERARCHY_CHANGED, this._childrenChanged, this);
                }
              }

              _removeChildrenEventListeners() {
                const children = this.node.children;

                for (let i = 0; i < children.length; ++i) {
                  const child = children[i];
                  child.off(NodeEventType.SIZE_CHANGED, this._doLayoutDirty, this);
                  child.off(NodeEventType.TRANSFORM_CHANGED, this._transformDirty, this);
                  child.off(NodeEventType.ANCHOR_CHANGED, this._doLayoutDirty, this);
                  child.off(NodeEventType.ACTIVE_IN_HIERARCHY_CHANGED, this._childrenChanged, this);
                }
              }

              _childAdded(child) {
                child.on(NodeEventType.SIZE_CHANGED, this._doLayoutDirty, this);
                child.on(NodeEventType.TRANSFORM_CHANGED, this._transformDirty, this);
                child.on(NodeEventType.ANCHOR_CHANGED, this._doLayoutDirty, this);
                child.on(NodeEventType.ACTIVE_IN_HIERARCHY_CHANGED, this._childrenChanged, this);

                this._childrenChanged();
              }

              _childRemoved(child) {
                child.off(NodeEventType.SIZE_CHANGED, this._doLayoutDirty, this);
                child.off(NodeEventType.TRANSFORM_CHANGED, this._transformDirty, this);
                child.off(NodeEventType.ANCHOR_CHANGED, this._doLayoutDirty, this);
                child.off(NodeEventType.ACTIVE_IN_HIERARCHY_CHANGED, this._childrenChanged, this);

                this._childrenChanged();
              }

              _resized() {
                this._layoutSize.set(this.node._uiProps.uiTransformComp.contentSize);

                this._doLayoutDirty();
              }

              _doLayoutHorizontally(baseWidth, rowBreak, fnPositionY, applyChildren) {
                const trans = this.node._uiProps.uiTransformComp;
                const layoutAnchor = trans.anchorPoint;

                const limit = this._getFixedBreakingNum();

                let sign = 1;
                let paddingX = this._paddingLeft;

                if (this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
                  sign = -1;
                  paddingX = this._paddingRight;
                }

                const startPos = (this._horizontalDirection - layoutAnchor.x) * baseWidth + sign * paddingX;
                let nextX = startPos - sign * this._spacingX;
                let totalHeight = 0;
                let rowMaxHeight = 0;
                let tempMaxHeight = 0;
                let maxHeight = 0;
                let isBreak = false;
                const activeChildCount = this._usefulLayoutObj.length;
                let newChildWidth = this._cellSize.width;

                const paddingH = this._getPaddingH();

                if (this._layoutType !== Type.GRID && this._resizeMode === ResizeMode.CHILDREN) {
                  newChildWidth = (baseWidth - paddingH - (activeChildCount - 1) * this._spacingX) / activeChildCount;
                }

                const children = this._usefulLayoutObj;

                for (let i = 0; i < children.length; ++i) {
                  const childTrans = children[i];
                  const child = childTrans.node;
                  const scale = child.scale;

                  const childScaleX = this._getUsedScaleValue(scale.x);

                  const childScaleY = this._getUsedScaleValue(scale.y);

                  if (this._resizeMode === ResizeMode.CHILDREN) {
                    childTrans.width = newChildWidth / childScaleX;

                    if (this._layoutType === Type.GRID) {
                      childTrans.height = this._cellSize.height / childScaleY;
                    }
                  }

                  const anchorX = Math.abs(this._horizontalDirection - childTrans.anchorX);
                  const childBoundingBoxWidth = childTrans.width * childScaleX;
                  const childBoundingBoxHeight = childTrans.height * childScaleY;

                  if (childBoundingBoxHeight > tempMaxHeight) {
                    maxHeight = Math.max(tempMaxHeight, maxHeight);
                    rowMaxHeight = tempMaxHeight || childBoundingBoxHeight;
                    tempMaxHeight = childBoundingBoxHeight;
                  }

                  nextX += sign * (anchorX * childBoundingBoxWidth + this._spacingX);
                  const rightBoundaryOfChild = sign * (1 - anchorX) * childBoundingBoxWidth;

                  if (rowBreak) {
                    if (limit > 0) {
                      isBreak = i / limit > 0 && i % limit === 0;

                      if (isBreak) {
                        rowMaxHeight = tempMaxHeight > childBoundingBoxHeight ? tempMaxHeight : rowMaxHeight;
                      }
                    } else if (childBoundingBoxWidth > baseWidth - paddingH) {
                      if (nextX > startPos + sign * (anchorX * childBoundingBoxWidth)) {
                        isBreak = true;
                      }
                    } else {
                      const boundary = (1 - this._horizontalDirection - layoutAnchor.x) * baseWidth;
                      const rowBreakBoundary = nextX + rightBoundaryOfChild + sign * (sign > 0 ? this._paddingRight : this._paddingLeft);
                      isBreak = Math.abs(rowBreakBoundary) > Math.abs(boundary);
                    }

                    if (isBreak) {
                      nextX = startPos + sign * (anchorX * childBoundingBoxWidth);

                      if (childBoundingBoxHeight !== tempMaxHeight) {
                        rowMaxHeight = tempMaxHeight;
                      }

                      totalHeight += rowMaxHeight + this._spacingY;
                      rowMaxHeight = tempMaxHeight = childBoundingBoxHeight;
                    }
                  }

                  const finalPositionY = fnPositionY(child, childTrans, totalHeight);

                  if (applyChildren) {
                    child.setPosition(nextX, finalPositionY);
                  }

                  nextX += rightBoundaryOfChild;
                }

                rowMaxHeight = Math.max(rowMaxHeight, tempMaxHeight);

                const containerResizeBoundary = Math.max(maxHeight, totalHeight + rowMaxHeight) + this._getPaddingV();

                return containerResizeBoundary;
              }

              _doLayoutVertically(baseHeight, columnBreak, fnPositionX, applyChildren) {
                const trans = this.node._uiProps.uiTransformComp;
                const layoutAnchor = trans.anchorPoint;

                const limit = this._getFixedBreakingNum();

                let sign = 1;
                let paddingY = this._paddingBottom;

                if (this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
                  sign = -1;
                  paddingY = this._paddingTop;
                }

                const startPos = (this._verticalDirection - layoutAnchor.y) * baseHeight + sign * paddingY;
                let nextY = startPos - sign * this._spacingY;
                let tempMaxWidth = 0;
                let maxWidth = 0;
                let colMaxWidth = 0;
                let totalWidth = 0;
                let isBreak = false;
                const activeChildCount = this._usefulLayoutObj.length;
                let newChildHeight = this._cellSize.height;

                const paddingV = this._getPaddingV();

                if (this._layoutType !== Type.GRID && this._resizeMode === ResizeMode.CHILDREN) {
                  newChildHeight = (baseHeight - paddingV - (activeChildCount - 1) * this._spacingY) / activeChildCount;
                }

                const children = this._usefulLayoutObj;

                for (let i = 0; i < children.length; ++i) {
                  const childTrans = children[i];
                  const child = childTrans.node;
                  const scale = child.scale;

                  const childScaleX = this._getUsedScaleValue(scale.x);

                  const childScaleY = this._getUsedScaleValue(scale.y);

                  if (this._resizeMode === ResizeMode.CHILDREN) {
                    childTrans.height = newChildHeight / childScaleY;

                    if (this._layoutType === Type.GRID) {
                      childTrans.width = this._cellSize.width / childScaleX;
                    }
                  }

                  const anchorY = Math.abs(this._verticalDirection - childTrans.anchorY);
                  const childBoundingBoxWidth = childTrans.width * childScaleX;
                  const childBoundingBoxHeight = childTrans.height * childScaleY;

                  if (childBoundingBoxWidth > tempMaxWidth) {
                    maxWidth = Math.max(tempMaxWidth, maxWidth);
                    colMaxWidth = tempMaxWidth || childBoundingBoxWidth;
                    tempMaxWidth = childBoundingBoxWidth;
                  }

                  nextY += sign * (anchorY * childBoundingBoxHeight + this._spacingY);
                  const topBoundaryOfChild = sign * (1 - anchorY) * childBoundingBoxHeight;

                  if (columnBreak) {
                    if (limit > 0) {
                      isBreak = i / limit > 0 && i % limit === 0;

                      if (isBreak) {
                        colMaxWidth = tempMaxWidth > childBoundingBoxHeight ? tempMaxWidth : colMaxWidth;
                      }
                    } else if (childBoundingBoxHeight > baseHeight - paddingV) {
                      if (nextY > startPos + sign * (anchorY * childBoundingBoxHeight)) {
                        isBreak = true;
                      }
                    } else {
                      const boundary = (1 - this._verticalDirection - layoutAnchor.y) * baseHeight;
                      const columnBreakBoundary = nextY + topBoundaryOfChild + sign * (sign > 0 ? this._paddingTop : this._paddingBottom);
                      isBreak = Math.abs(columnBreakBoundary) > Math.abs(boundary);
                    }

                    if (isBreak) {
                      nextY = startPos + sign * (anchorY * childBoundingBoxHeight);

                      if (childBoundingBoxWidth !== tempMaxWidth) {
                        colMaxWidth = tempMaxWidth;
                      }

                      totalWidth += colMaxWidth + this._spacingX;
                      colMaxWidth = tempMaxWidth = childBoundingBoxWidth;
                    }
                  }

                  const finalPositionX = fnPositionX(child, childTrans, totalWidth);

                  if (applyChildren) {
                    child.getPosition(_tempVec3);
                    child.setPosition(finalPositionX, nextY, _tempVec3.z);
                  }

                  nextY += topBoundaryOfChild;
                }

                colMaxWidth = Math.max(colMaxWidth, tempMaxWidth);

                const containerResizeBoundary = Math.max(maxWidth, totalWidth + colMaxWidth) + this._getPaddingH();

                return containerResizeBoundary;
              }

              _doLayoutGridAxisHorizontal(layoutAnchor, layoutSize) {
                const baseWidth = layoutSize.width;
                let sign = 1;
                let bottomBoundaryOfLayout = -layoutAnchor.y * layoutSize.height;
                let paddingY = this._paddingBottom;

                if (this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
                  sign = -1;
                  bottomBoundaryOfLayout = (1 - layoutAnchor.y) * layoutSize.height;
                  paddingY = this._paddingTop;
                }

                const fnPositionY = (child, childTrans, topOffset) => bottomBoundaryOfLayout + sign * (topOffset + (1 - childTrans.anchorY) * childTrans.height * this._getUsedScaleValue(child.scale.y) + paddingY);

                let newHeight = 0;

                if (this._resizeMode === ResizeMode.CONTAINER) {
                  newHeight = this._doLayoutHorizontally(baseWidth, true, fnPositionY, false);
                  bottomBoundaryOfLayout = -layoutAnchor.y * newHeight;

                  if (this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
                    sign = -1;
                    bottomBoundaryOfLayout = (1 - layoutAnchor.y) * newHeight;
                  }
                }

                this._doLayoutHorizontally(baseWidth, true, fnPositionY, true);

                if (this._resizeMode === ResizeMode.CONTAINER) {
                  this.node._uiProps.uiTransformComp.setContentSize(baseWidth, newHeight);
                }
              }

              _doLayoutGridAxisVertical(layoutAnchor, layoutSize) {
                const baseHeight = layoutSize.height;
                let sign = 1;
                let leftBoundaryOfLayout = -layoutAnchor.x * layoutSize.width;
                let paddingX = this._paddingLeft;

                if (this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
                  sign = -1;
                  leftBoundaryOfLayout = (1 - layoutAnchor.x) * layoutSize.width;
                  paddingX = this._paddingRight;
                }

                const fnPositionX = (child, childTrans, leftOffset) => leftBoundaryOfLayout + sign * (leftOffset + (1 - childTrans.anchorX) * childTrans.width * this._getUsedScaleValue(child.scale.x) + paddingX);

                let newWidth = 0;

                if (this._resizeMode === ResizeMode.CONTAINER) {
                  newWidth = this._doLayoutVertically(baseHeight, true, fnPositionX, false);
                  leftBoundaryOfLayout = -layoutAnchor.x * newWidth;

                  if (this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
                    sign = -1;
                    leftBoundaryOfLayout = (1 - layoutAnchor.x) * newWidth;
                  }
                }

                this._doLayoutVertically(baseHeight, true, fnPositionX, true);

                if (this._resizeMode === ResizeMode.CONTAINER) {
                  this.node._uiProps.uiTransformComp.setContentSize(newWidth, baseHeight);
                }
              }

              _doLayoutGrid() {
                const trans = this.node._uiProps.uiTransformComp;
                const layoutAnchor = trans.anchorPoint;
                const layoutSize = trans.contentSize;

                if (this.startAxis === AxisDirection.HORIZONTAL) {
                  this._doLayoutGridAxisHorizontal(layoutAnchor, layoutSize);
                } else if (this.startAxis === AxisDirection.VERTICAL) {
                  this._doLayoutGridAxisVertical(layoutAnchor, layoutSize);
                }
              }

              _getHorizontalBaseWidth(horizontal = true) {
                const children = this._usefulLayoutObj;
                let baseSize = 0;
                const activeChildCount = children.length;

                if (this._resizeMode === ResizeMode.CONTAINER) {
                  for (let i = 0; i < children.length; ++i) {
                    const childTrans = children[i];
                    const child = childTrans.node;
                    const scale = child.scale;
                    baseSize += childTrans.width * this._getUsedScaleValue(scale.x);
                  }

                  baseSize += (activeChildCount - 1) * this._spacingX + this._getPaddingH();
                } else {
                  baseSize = this.node._uiProps.uiTransformComp.width;
                }

                return baseSize;
              }

              _getVerticalBaseHeight() {
                const children = this._usefulLayoutObj;
                let baseSize = 0;
                const activeChildCount = children.length;

                if (this._resizeMode === ResizeMode.CONTAINER) {
                  for (let i = 0; i < children.length; ++i) {
                    const childTrans = children[i];
                    const child = childTrans.node;
                    const scale = child.scale;
                    baseSize += childTrans.height * this._getUsedScaleValue(scale.y);
                  }

                  baseSize += (activeChildCount - 1) * this._spacingY + this._getPaddingV();
                } else {
                  baseSize = this.node._uiProps.uiTransformComp.height;
                }

                return baseSize;
              }

              _doLayout() {
                if (!this._init || this._childrenDirty) {
                  this._checkUsefulObj();

                  this._init = true;
                  this._childrenDirty = false;
                }

                if (this._layoutType === Type.HORIZONTAL) {
                  const newWidth = this._getHorizontalBaseWidth();

                  const fnPositionY = child => {
                    const pos = this._isAlign ? Vec3.ZERO : child.position;
                    return pos.y;
                  };

                  this._doLayoutHorizontally(newWidth, false, fnPositionY, true);

                  this.node._uiProps.uiTransformComp.width = newWidth;
                } else if (this._layoutType === Type.VERTICAL) {
                  const newHeight = this._getVerticalBaseHeight();

                  const fnPositionX = child => {
                    const pos = this._isAlign ? Vec3.ZERO : child.position;
                    return pos.x;
                  };

                  this._doLayoutVertically(newHeight, false, fnPositionX, true);

                  this.node._uiProps.uiTransformComp.height = newHeight;
                } else if (this._layoutType === Type.GRID) {
                  this._doLayoutGrid();
                }
              }

              _getUsedScaleValue(value) {
                return this._affectedByScale ? Math.abs(value) : 1;
              }

              _transformDirty(type) {
                if (!(type & TransformBit.SCALE) || !(type & TransformBit.POSITION) || !this._affectedByScale) {
                  return;
                }

                this._doLayoutDirty();
              }

              _doLayoutDirty() {
                this._layoutDirty = true;
              }

              _childrenChanged() {
                this._childrenDirty = true;

                this._doLayoutDirty();
              }

              _getPaddingH() {
                return this._paddingLeft + this._paddingRight;
              }

              _getPaddingV() {
                return this._paddingTop + this._paddingBottom;
              }

              _getFixedBreakingNum() {
                if (this._layoutType !== Type.GRID || this._constraint === Constraint.NONE || this._constraintNum <= 0) {
                  return 0;
                }

                let num = this._constraint === Constraint.FIXED_ROW ? Math.ceil(this._usefulLayoutObj.length / this._constraintNum) : this._constraintNum;

                if (this._startAxis === AxisDirection.VERTICAL) {
                  num = this._constraint === Constraint.FIXED_COL ? Math.ceil(this._usefulLayoutObj.length / this._constraintNum) : this._constraintNum;
                }

                return num;
              }

            }, _class3$9.Type = Type, _class3$9.VerticalDirection = VerticalDirection, _class3$9.HorizontalDirection = HorizontalDirection, _class3$9.ResizeMode = ResizeMode, _class3$9.AxisDirection = AxisDirection, _class3$9.Constraint = Constraint, _temp$s), (_applyDecoratedDescriptor(_class2$p.prototype, "alignHorizontal", [_dec6$j, _dec7$j], Object.getOwnPropertyDescriptor(_class2$p.prototype, "alignHorizontal"), _class2$p.prototype), _applyDecoratedDescriptor(_class2$p.prototype, "alignVertical", [_dec8$h, _dec9$e], Object.getOwnPropertyDescriptor(_class2$p.prototype, "alignVertical"), _class2$p.prototype), _applyDecoratedDescriptor(_class2$p.prototype, "type", [_dec10$d, _dec11$a], Object.getOwnPropertyDescriptor(_class2$p.prototype, "type"), _class2$p.prototype), _applyDecoratedDescriptor(_class2$p.prototype, "resizeMode", [_dec12$a, _dec13$9, _dec14$7], Object.getOwnPropertyDescriptor(_class2$p.prototype, "resizeMode"), _class2$p.prototype), _applyDecoratedDescriptor(_class2$p.prototype, "cellSize", [_dec15$7, _dec16$7], Object.getOwnPropertyDescriptor(_class2$p.prototype, "cellSize"), _class2$p.prototype), _applyDecoratedDescriptor(_class2$p.prototype, "startAxis", [_dec17$5, _dec18$5], Object.getOwnPropertyDescriptor(_class2$p.prototype, "startAxis"), _class2$p.prototype), _applyDecoratedDescriptor(_class2$p.prototype, "paddingLeft", [_dec19$5], Object.getOwnPropertyDescriptor(_class2$p.prototype, "paddingLeft"), _class2$p.prototype), _applyDecoratedDescriptor(_class2$p.prototype, "paddingRight", [_dec20$4], Object.getOwnPropertyDescriptor(_class2$p.prototype, "paddingRight"), _class2$p.prototype), _applyDecoratedDescriptor(_class2$p.prototype, "paddingTop", [_dec21$4], Object.getOwnPropertyDescriptor(_class2$p.prototype, "paddingTop"), _class2$p.prototype), _applyDecoratedDescriptor(_class2$p.prototype, "paddingBottom", [_dec22$4], Object.getOwnPropertyDescriptor(_class2$p.prototype, "paddingBottom"), _class2$p.prototype), _applyDecoratedDescriptor(_class2$p.prototype, "spacingX", [_dec23$4], Object.getOwnPropertyDescriptor(_class2$p.prototype, "spacingX"), _class2$p.prototype), _applyDecoratedDescriptor(_class2$p.prototype, "spacingY", [_dec24$4], Object.getOwnPropertyDescriptor(_class2$p.prototype, "spacingY"), _class2$p.prototype), _applyDecoratedDescriptor(_class2$p.prototype, "verticalDirection", [_dec25$4, _dec26$4], Object.getOwnPropertyDescriptor(_class2$p.prototype, "verticalDirection"), _class2$p.prototype), _applyDecoratedDescriptor(_class2$p.prototype, "horizontalDirection", [_dec27$4, _dec28$4], Object.getOwnPropertyDescriptor(_class2$p.prototype, "horizontalDirection"), _class2$p.prototype), _applyDecoratedDescriptor(_class2$p.prototype, "constraint", [_dec29$4, _dec30$4, _dec31$3], Object.getOwnPropertyDescriptor(_class2$p.prototype, "constraint"), _class2$p.prototype), _applyDecoratedDescriptor(_class2$p.prototype, "constraintNum", [_dec32$3, _dec33$2], Object.getOwnPropertyDescriptor(_class2$p.prototype, "constraintNum"), _class2$p.prototype), _applyDecoratedDescriptor(_class2$p.prototype, "affectedByScale", [_dec34$2], Object.getOwnPropertyDescriptor(_class2$p.prototype, "affectedByScale"), _class2$p.prototype), _descriptor$o = _applyDecoratedDescriptor(_class2$p.prototype, "_resizeMode", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return ResizeMode.NONE;
              }
            }), _descriptor2$l = _applyDecoratedDescriptor(_class2$p.prototype, "_layoutType", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Type.NONE;
              }
            }), _descriptor3$g = _applyDecoratedDescriptor(_class2$p.prototype, "_cellSize", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Size$1(40, 40);
              }
            }), _descriptor4$f = _applyDecoratedDescriptor(_class2$p.prototype, "_startAxis", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return AxisDirection.HORIZONTAL;
              }
            }), _descriptor5$d = _applyDecoratedDescriptor(_class2$p.prototype, "_paddingLeft", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor6$a = _applyDecoratedDescriptor(_class2$p.prototype, "_paddingRight", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor7$8 = _applyDecoratedDescriptor(_class2$p.prototype, "_paddingTop", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor8$8 = _applyDecoratedDescriptor(_class2$p.prototype, "_paddingBottom", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor9$7 = _applyDecoratedDescriptor(_class2$p.prototype, "_spacingX", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor10$6 = _applyDecoratedDescriptor(_class2$p.prototype, "_spacingY", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor11$5 = _applyDecoratedDescriptor(_class2$p.prototype, "_verticalDirection", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return VerticalDirection.TOP_TO_BOTTOM;
              }
            }), _descriptor12$4 = _applyDecoratedDescriptor(_class2$p.prototype, "_horizontalDirection", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return HorizontalDirection.LEFT_TO_RIGHT;
              }
            }), _descriptor13$3 = _applyDecoratedDescriptor(_class2$p.prototype, "_constraint", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Constraint.NONE;
              }
            }), _descriptor14$2 = _applyDecoratedDescriptor(_class2$p.prototype, "_constraintNum", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 2;
              }
            }), _descriptor15$1 = _applyDecoratedDescriptor(_class2$p.prototype, "_affectedByScale", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor16$1 = _applyDecoratedDescriptor(_class2$p.prototype, "_isAlign", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            })), _class2$p)) || _class$v) || _class$v) || _class$v) || _class$v) || _class$v) || _class$v));

            var _dec$w, _dec2$r, _dec3$q, _dec4$p, _dec5$n, _dec6$k, _dec7$k, _dec8$i, _dec9$f, _dec10$e, _dec11$b, _dec12$b, _dec13$a, _class$w, _class2$q, _descriptor$p, _descriptor2$m, _descriptor3$h, _descriptor4$g, _descriptor5$e, _class3$a, _temp$t;
            var Mode;

            (function (Mode) {
              Mode[Mode["HORIZONTAL"] = 0] = "HORIZONTAL";
              Mode[Mode["VERTICAL"] = 1] = "VERTICAL";
              Mode[Mode["FILLED"] = 2] = "FILLED";
            })(Mode || (Mode = {}));

            Enum(Mode);
            let ProgressBar = function (v) { return exports({ ProgressBar: v, ProgressBarComponent: v }), v; }((_dec$w = ccclass('cc.ProgressBar'), _dec2$r = help(), _dec3$q = executionOrder(110), _dec4$p = menu$1(), _dec5$n = requireComponent(UITransform), _dec6$k = type$1(Sprite), _dec7$k = tooltip(), _dec8$i = type$1(Mode), _dec9$f = tooltip(), _dec10$e = tooltip(), _dec11$b = range(), _dec12$b = tooltip(), _dec13$a = tooltip(), _dec$w(_class$w = _dec2$r(_class$w = _dec3$q(_class$w = _dec4$p(_class$w = _dec5$n(_class$w = (_class2$q = (_temp$t = _class3$a = class ProgressBar extends Component {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "_barSprite", _descriptor$p, this);

                _initializerDefineProperty(this, "_mode", _descriptor2$m, this);

                _initializerDefineProperty(this, "_totalLength", _descriptor3$h, this);

                _initializerDefineProperty(this, "_progress", _descriptor4$g, this);

                _initializerDefineProperty(this, "_reverse", _descriptor5$e, this);
              }

              get barSprite() {
                return this._barSprite;
              }

              set barSprite(value) {
                if (this._barSprite === value) {
                  return;
                }

                this._barSprite = value;

                this._initBarSprite();
              }

              get mode() {
                return this._mode;
              }

              set mode(value) {
                if (this._mode === value) {
                  return;
                }

                this._mode = value;

                if (this._barSprite) {
                  const entity = this._barSprite.node;

                  if (!entity) {
                    return;
                  }

                  const entitySize = entity._uiProps.uiTransformComp.contentSize;

                  if (this._mode === Mode.HORIZONTAL) {
                    this.totalLength = entitySize.width;
                  } else if (this._mode === Mode.VERTICAL) {
                    this.totalLength = entitySize.height;
                  } else if (this._mode === Mode.FILLED) {
                    this.totalLength = this._barSprite.fillRange;
                  }
                }
              }

              get totalLength() {
                return this._totalLength;
              }

              set totalLength(value) {
                if (this._mode === Mode.FILLED) {
                  value = clamp01(value);
                }

                if (this._totalLength === value) {
                  return;
                }

                this._totalLength = value;

                this._updateBarStatus();
              }

              get progress() {
                return this._progress;
              }

              set progress(value) {
                if (this._progress === value) {
                  return;
                }

                this._progress = value;

                this._updateBarStatus();
              }

              get reverse() {
                return this._reverse;
              }

              set reverse(value) {
                if (this._reverse === value) {
                  return;
                }

                this._reverse = value;

                if (this._barSprite) {
                  this._barSprite.fillStart = 1 - this._barSprite.fillStart;
                }

                this._updateBarStatus();
              }

              _initBarSprite() {
                if (this._barSprite) {
                  const entity = this._barSprite.node;

                  if (!entity) {
                    return;
                  }

                  const trans = this.node._uiProps.uiTransformComp;
                  const nodeSize = trans.contentSize;
                  const nodeAnchor = trans.anchorPoint;
                  const barSpriteSize = entity._uiProps.uiTransformComp.contentSize;

                  if (this._barSprite.fillType === Sprite.FillType.RADIAL) {
                    this._mode = Mode.FILLED;
                  }

                  if (this._mode === Mode.HORIZONTAL) {
                    this.totalLength = barSpriteSize.width;
                  } else if (this._mode === Mode.VERTICAL) {
                    this.totalLength = barSpriteSize.height;
                  } else {
                    this.totalLength = this._barSprite.fillRange;
                  }

                  if (entity.parent === this.node) {
                    const x = -nodeSize.width * nodeAnchor.x;
                    entity.setPosition(x, 0, 0);
                  }
                }
              }

              _updateBarStatus() {
                if (this._barSprite) {
                  const entity = this._barSprite.node;

                  if (!entity) {
                    return;
                  }

                  const entTrans = entity._uiProps.uiTransformComp;
                  const entityAnchorPoint = entTrans.anchorPoint;
                  const entitySize = entTrans.contentSize;
                  const entityPosition = entity.getPosition();
                  let anchorPoint = new Vec2(0, 0.5);
                  const progress = clamp01(this._progress);
                  let actualLenth = this._totalLength * progress;
                  let finalContentSize = entitySize;
                  let totalWidth = 0;
                  let totalHeight = 0;

                  switch (this._mode) {
                    case Mode.HORIZONTAL:
                      if (this._reverse) {
                        anchorPoint = new Vec2(1, 0.5);
                      }

                      finalContentSize = new Size$1(actualLenth, entitySize.height);
                      totalWidth = this._totalLength;
                      totalHeight = entitySize.height;
                      break;

                    case Mode.VERTICAL:
                      if (this._reverse) {
                        anchorPoint = new Vec2(0.5, 1);
                      } else {
                        anchorPoint = new Vec2(0.5, 0);
                      }

                      finalContentSize = new Size$1(entitySize.width, actualLenth);
                      totalWidth = entitySize.width;
                      totalHeight = this._totalLength;
                      break;
                  }

                  if (this._mode === Mode.FILLED) {
                    if (this._barSprite.type !== Sprite.Type.FILLED) {
                      warn('ProgressBar FILLED mode only works when barSprite\'s Type is FILLED!');
                    } else {
                      if (this._reverse) {
                        actualLenth *= -1;
                      }

                      this._barSprite.fillRange = actualLenth;
                    }
                  } else if (this._barSprite.type !== Sprite.Type.FILLED) {
                    const anchorOffsetX = anchorPoint.x - entityAnchorPoint.x;
                    const anchorOffsetY = anchorPoint.y - entityAnchorPoint.y;
                    const finalPosition = new Vec3(totalWidth * anchorOffsetX, totalHeight * anchorOffsetY, 0);
                    entity.setPosition(entityPosition.x + finalPosition.x, entityPosition.y + finalPosition.y, entityPosition.z);
                    entTrans.setAnchorPoint(anchorPoint);
                    entTrans.setContentSize(finalContentSize);
                  } else {
                    warn('ProgressBar non-FILLED mode only works when barSprite\'s Type is non-FILLED!');
                  }
                }
              }

            }, _class3$a.Mode = Mode, _temp$t), (_applyDecoratedDescriptor(_class2$q.prototype, "barSprite", [_dec6$k, _dec7$k], Object.getOwnPropertyDescriptor(_class2$q.prototype, "barSprite"), _class2$q.prototype), _applyDecoratedDescriptor(_class2$q.prototype, "mode", [_dec8$i, _dec9$f], Object.getOwnPropertyDescriptor(_class2$q.prototype, "mode"), _class2$q.prototype), _applyDecoratedDescriptor(_class2$q.prototype, "totalLength", [_dec10$e], Object.getOwnPropertyDescriptor(_class2$q.prototype, "totalLength"), _class2$q.prototype), _applyDecoratedDescriptor(_class2$q.prototype, "progress", [_dec11$b, slide, _dec12$b], Object.getOwnPropertyDescriptor(_class2$q.prototype, "progress"), _class2$q.prototype), _applyDecoratedDescriptor(_class2$q.prototype, "reverse", [_dec13$a], Object.getOwnPropertyDescriptor(_class2$q.prototype, "reverse"), _class2$q.prototype), _descriptor$p = _applyDecoratedDescriptor(_class2$q.prototype, "_barSprite", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor2$m = _applyDecoratedDescriptor(_class2$q.prototype, "_mode", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Mode.HORIZONTAL;
              }
            }), _descriptor3$h = _applyDecoratedDescriptor(_class2$q.prototype, "_totalLength", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            }), _descriptor4$g = _applyDecoratedDescriptor(_class2$q.prototype, "_progress", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.1;
              }
            }), _descriptor5$e = _applyDecoratedDescriptor(_class2$q.prototype, "_reverse", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            })), _class2$q)) || _class$w) || _class$w) || _class$w) || _class$w) || _class$w));

            var _dec$x, _dec2$s, _dec3$r, _dec4$q, _dec5$o, _dec6$l, _dec7$l, _dec8$j, _dec9$g, _dec10$f, _dec11$c, _dec12$c, _dec13$b, _dec14$8, _dec15$8, _class$x, _class2$r, _descriptor$q, _descriptor2$n, _descriptor3$i, _descriptor4$h, _descriptor5$f, _class3$b, _temp$u;
            const GETTING_SHORTER_FACTOR = 20;

            const _tempPos_1 = new Vec3();

            const _tempPos_2 = new Vec3();

            const _tempVec3$1 = new Vec3();

            const defaultAnchor = new Vec2();

            const _tempColor$1 = new Color$1();

            const _tempVec2 = new Vec2();

            var Direction;

            (function (Direction) {
              Direction[Direction["HORIZONTAL"] = 0] = "HORIZONTAL";
              Direction[Direction["VERTICAL"] = 1] = "VERTICAL";
            })(Direction || (Direction = {}));

            ccenum(Direction);
            let ScrollBar = function (v) { return exports({ ScrollBar: v, ScrollBarComponent: v }), v; }((_dec$x = ccclass('cc.ScrollBar'), _dec2$s = help(), _dec3$r = executionOrder(110), _dec4$q = menu$1(), _dec5$o = requireComponent(UITransform), _dec6$l = type$1(Sprite), _dec7$l = displayOrder(), _dec8$j = tooltip(), _dec9$g = type$1(Direction), _dec10$f = displayOrder(), _dec11$c = tooltip(), _dec12$c = displayOrder(), _dec13$b = tooltip(), _dec14$8 = displayOrder(), _dec15$8 = tooltip(), _dec$x(_class$x = _dec2$s(_class$x = _dec3$r(_class$x = _dec4$q(_class$x = _dec5$o(_class$x = (_class2$r = (_temp$u = _class3$b = class ScrollBar extends Component {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "_scrollView", _descriptor$q, this);

                _initializerDefineProperty(this, "_handle", _descriptor2$n, this);

                _initializerDefineProperty(this, "_direction", _descriptor3$i, this);

                _initializerDefineProperty(this, "_enableAutoHide", _descriptor4$h, this);

                _initializerDefineProperty(this, "_autoHideTime", _descriptor5$f, this);

                this._touching = false;
                this._opacity = 255;
                this._autoHideRemainingTime = 0;
              }

              get handle() {
                return this._handle;
              }

              set handle(value) {
                if (this._handle === value) {
                  return;
                }

                this._handle = value;
                this.onScroll(Vec2.ZERO);
              }

              get direction() {
                return this._direction;
              }

              set direction(value) {
                if (this._direction === value) {
                  return;
                }

                this._direction = value;
                this.onScroll(Vec2.ZERO);
              }

              get enableAutoHide() {
                return this._enableAutoHide;
              }

              set enableAutoHide(value) {
                if (this._enableAutoHide === value) {
                  return;
                }

                this._enableAutoHide = value;

                if (this._enableAutoHide) {
                  this._setOpacity(0);
                }
              }

              get autoHideTime() {
                return this._autoHideTime;
              }

              set autoHideTime(value) {
                if (this._autoHideTime === value) {
                  return;
                }

                this._autoHideTime = value;
              }

              hide() {
                this._autoHideRemainingTime = 0;

                this._setOpacity(0);
              }

              show() {
                this._autoHideRemainingTime = this._autoHideTime;

                this._setOpacity(this._opacity);
              }

              onScroll(outOfBoundary) {
                if (!this._scrollView) {
                  return;
                }

                const content = this._scrollView.content;

                if (!content) {
                  return;
                }

                const contentSize = content._uiProps.uiTransformComp.contentSize;
                const scrollViewSize = this._scrollView.node._uiProps.uiTransformComp.contentSize;
                const barSize = this.node._uiProps.uiTransformComp.contentSize;

                if (this._conditionalDisableScrollBar(contentSize, scrollViewSize)) {
                  return;
                }

                if (this._enableAutoHide) {
                  this._autoHideRemainingTime = this._autoHideTime;

                  this._setOpacity(this._opacity);
                }

                let contentMeasure = 0;
                let scrollViewMeasure = 0;
                let outOfBoundaryValue = 0;
                let contentPosition = 0;
                let handleNodeMeasure = 0;
                const outOfContentPosition = _tempVec2;
                outOfContentPosition.set(0, 0);

                if (this._direction === Direction.HORIZONTAL) {
                  contentMeasure = contentSize.width;
                  scrollViewMeasure = scrollViewSize.width;
                  handleNodeMeasure = barSize.width;
                  outOfBoundaryValue = outOfBoundary.x;

                  this._convertToScrollViewSpace(outOfContentPosition, content);

                  contentPosition = -outOfContentPosition.x;
                } else if (this._direction === Direction.VERTICAL) {
                  contentMeasure = contentSize.height;
                  scrollViewMeasure = scrollViewSize.height;
                  handleNodeMeasure = barSize.height;
                  outOfBoundaryValue = outOfBoundary.y;

                  this._convertToScrollViewSpace(outOfContentPosition, content);

                  contentPosition = -outOfContentPosition.y;
                }

                const length = this._calculateLength(contentMeasure, scrollViewMeasure, handleNodeMeasure, outOfBoundaryValue);

                const position = _tempVec2;

                this._calculatePosition(position, contentMeasure, scrollViewMeasure, handleNodeMeasure, contentPosition, outOfBoundaryValue, length);

                this._updateLength(length);

                this._updateHandlerPosition(position);
              }

              setScrollView(scrollView) {
                this._scrollView = scrollView;
              }

              onTouchBegan() {
                if (!this._enableAutoHide) {
                  return;
                }

                this._touching = true;
              }

              onTouchEnded() {
                if (!this._enableAutoHide) {
                  return;
                }

                this._touching = false;

                if (this._autoHideTime <= 0) {
                  return;
                }

                if (this._scrollView) {
                  const content = this._scrollView.content;

                  if (content) {
                    const contentSize = content._uiProps.uiTransformComp.contentSize;
                    const scrollViewSize = this._scrollView.node._uiProps.uiTransformComp.contentSize;

                    if (this._conditionalDisableScrollBar(contentSize, scrollViewSize)) {
                      return;
                    }
                  }
                }

                this._autoHideRemainingTime = this._autoHideTime;
              }

              onEnable() {
                const renderComp = this.node.getComponent(Sprite);

                if (renderComp) {
                  this._opacity = renderComp.color.a;
                }
              }

              start() {
                if (this._enableAutoHide) {
                  this._setOpacity(0);
                }
              }

              update(dt) {
                this._processAutoHide(dt);
              }

              _convertToScrollViewSpace(out, content) {
                const scrollTrans = this._scrollView && this._scrollView.node._uiProps.uiTransformComp;
                const contentTrans = content._uiProps.uiTransformComp;

                if (!scrollTrans || !contentTrans) {
                  out.set(Vec2.ZERO);
                } else {
                  _tempPos_1.set(-contentTrans.anchorX * contentTrans.width, -contentTrans.anchorY * contentTrans.height, 0);

                  contentTrans.convertToWorldSpaceAR(_tempPos_1, _tempPos_2);
                  const scrollViewSpacePos = scrollTrans.convertToNodeSpaceAR(_tempPos_2);
                  scrollViewSpacePos.x += scrollTrans.anchorX * scrollTrans.width;
                  scrollViewSpacePos.y += scrollTrans.anchorY * scrollTrans.height;
                  out.set(scrollViewSpacePos.x, scrollViewSpacePos.y);
                }
              }

              _setOpacity(opacity) {
                if (this._handle) {
                  let renderComp = this.node.getComponent(Sprite);

                  if (renderComp) {
                    _tempColor$1.set(renderComp.color);

                    _tempColor$1.a = opacity;
                    renderComp.color = _tempColor$1;
                  }

                  renderComp = this._handle.getComponent(Sprite);

                  if (renderComp) {
                    _tempColor$1.set(renderComp.color);

                    _tempColor$1.a = opacity;
                    renderComp.color = _tempColor$1;
                  }
                }
              }

              _updateHandlerPosition(position) {
                if (this._handle) {
                  const oldPosition = _tempVec3$1;

                  this._fixupHandlerPosition(oldPosition);

                  this._handle.node.setPosition(position.x + oldPosition.x, position.y + oldPosition.y, oldPosition.z);
                }
              }

              _fixupHandlerPosition(out) {
                const uiTrans = this.node._uiProps.uiTransformComp;
                const barSize = uiTrans.contentSize;
                const barAnchor = uiTrans.anchorPoint;
                const handleSize = this.handle.node._uiProps.uiTransformComp.contentSize;
                const handleParent = this.handle.node.parent;
                Vec3.set(_tempPos_1, -barSize.width * barAnchor.x, -barSize.height * barAnchor.y, 0);

                const leftBottomWorldPosition = this.node._uiProps.uiTransformComp.convertToWorldSpaceAR(_tempPos_1, _tempPos_2);

                const fixupPosition = out;
                fixupPosition.set(0, 0, 0);

                handleParent._uiProps.uiTransformComp.convertToNodeSpaceAR(leftBottomWorldPosition, fixupPosition);

                if (this.direction === Direction.HORIZONTAL) {
                  fixupPosition.set(fixupPosition.x, fixupPosition.y + (barSize.height - handleSize.height) / 2, fixupPosition.z);
                } else if (this.direction === Direction.VERTICAL) {
                  fixupPosition.set(fixupPosition.x + (barSize.width - handleSize.width) / 2, fixupPosition.y, fixupPosition.z);
                }

                this.handle.node.setPosition(fixupPosition);
              }

              _conditionalDisableScrollBar(contentSize, scrollViewSize) {
                if (contentSize.width <= scrollViewSize.width && this._direction === Direction.HORIZONTAL) {
                  return true;
                }

                if (contentSize.height <= scrollViewSize.height && this._direction === Direction.VERTICAL) {
                  return true;
                }

                return false;
              }

              _calculateLength(contentMeasure, scrollViewMeasure, handleNodeMeasure, outOfBoundary) {
                let denominatorValue = contentMeasure;

                if (outOfBoundary) {
                  denominatorValue += (outOfBoundary > 0 ? outOfBoundary : -outOfBoundary) * GETTING_SHORTER_FACTOR;
                }

                const lengthRation = scrollViewMeasure / denominatorValue;
                return handleNodeMeasure * lengthRation;
              }

              _calculatePosition(out, contentMeasure, scrollViewMeasure, handleNodeMeasure, contentPosition, outOfBoundary, actualLenth) {
                let denominatorValue = contentMeasure - scrollViewMeasure;

                if (outOfBoundary) {
                  denominatorValue += Math.abs(outOfBoundary);
                }

                let positionRatio = 0;

                if (denominatorValue) {
                  positionRatio = contentPosition / denominatorValue;
                  positionRatio = clamp01(positionRatio);
                }

                const position = (handleNodeMeasure - actualLenth) * positionRatio;

                if (this._direction === Direction.VERTICAL) {
                  out.set(0, position);
                } else {
                  out.set(position, 0);
                }
              }

              _updateLength(length) {
                if (this._handle) {
                  const handleNode = this._handle.node;
                  const handleTrans = handleNode._uiProps.uiTransformComp;
                  const handleNodeSize = handleTrans.contentSize;
                  const anchor = handleTrans.anchorPoint;

                  if (anchor.x !== defaultAnchor.x || anchor.y !== defaultAnchor.y) {
                    handleTrans.setAnchorPoint(defaultAnchor);
                  }

                  if (this._direction === Direction.HORIZONTAL) {
                    handleTrans.setContentSize(length, handleNodeSize.height);
                  } else {
                    handleTrans.setContentSize(handleNodeSize.width, length);
                  }
                }
              }

              _processAutoHide(deltaTime) {
                if (!this._enableAutoHide || this._autoHideRemainingTime <= 0) {
                  return;
                } else if (this._touching) {
                  return;
                }

                this._autoHideRemainingTime -= deltaTime;

                if (this._autoHideRemainingTime <= this._autoHideTime) {
                  this._autoHideRemainingTime = Math.max(0, this._autoHideRemainingTime);
                  const opacity = this._opacity * (this._autoHideRemainingTime / this._autoHideTime);

                  this._setOpacity(opacity);
                }
              }

            }, _class3$b.Direction = Direction, _temp$u), (_applyDecoratedDescriptor(_class2$r.prototype, "handle", [_dec6$l, _dec7$l, _dec8$j], Object.getOwnPropertyDescriptor(_class2$r.prototype, "handle"), _class2$r.prototype), _applyDecoratedDescriptor(_class2$r.prototype, "direction", [_dec9$g, _dec10$f, _dec11$c], Object.getOwnPropertyDescriptor(_class2$r.prototype, "direction"), _class2$r.prototype), _applyDecoratedDescriptor(_class2$r.prototype, "enableAutoHide", [_dec12$c, _dec13$b], Object.getOwnPropertyDescriptor(_class2$r.prototype, "enableAutoHide"), _class2$r.prototype), _applyDecoratedDescriptor(_class2$r.prototype, "autoHideTime", [_dec14$8, _dec15$8], Object.getOwnPropertyDescriptor(_class2$r.prototype, "autoHideTime"), _class2$r.prototype), _descriptor$q = _applyDecoratedDescriptor(_class2$r.prototype, "_scrollView", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor2$n = _applyDecoratedDescriptor(_class2$r.prototype, "_handle", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor3$i = _applyDecoratedDescriptor(_class2$r.prototype, "_direction", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Direction.HORIZONTAL;
              }
            }), _descriptor4$h = _applyDecoratedDescriptor(_class2$r.prototype, "_enableAutoHide", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor5$f = _applyDecoratedDescriptor(_class2$r.prototype, "_autoHideTime", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1.0;
              }
            })), _class2$r)) || _class$x) || _class$x) || _class$x) || _class$x) || _class$x));

            var _dec$y, _dec2$t, _class$y;
            let ViewGroup = exports('ViewGroup', (_dec$y = ccclass('cc.ViewGroup'), _dec2$t = executionOrder(110), _dec$y(_class$y = _dec2$t(_class$y = class ViewGroup extends Component {}) || _class$y) || _class$y));
            legacyCC.ViewGroup = ViewGroup;

            var _dec$z, _dec2$u, _dec3$s, _dec4$r, _dec5$p, _dec6$m, _dec7$m, _dec8$k, _dec9$h, _dec10$g, _dec11$d, _dec12$d, _dec13$c, _dec14$9, _dec15$9, _dec16$8, _dec17$6, _dec18$6, _dec19$6, _dec20$5, _dec21$5, _dec22$5, _dec23$5, _dec24$5, _dec25$5, _dec26$5, _dec27$5, _dec28$5, _dec29$5, _dec30$5, _dec31$4, _dec32$4, _dec33$3, _class$z, _class2$s, _descriptor$r, _descriptor2$o, _descriptor3$j, _descriptor4$i, _descriptor5$g, _descriptor6$b, _descriptor7$9, _descriptor8$9, _descriptor9$8, _descriptor10$7, _descriptor11$6, _class3$c, _temp$v;
            const NUMBER_OF_GATHERED_TOUCHES_FOR_MOVE_SPEED = 5;
            const OUT_OF_BOUNDARY_BREAKING_FACTOR = 0.05;
            const EPSILON$1 = 1e-4;
            const TOLERANCE = 1e4;
            const MOVEMENT_FACTOR = 0.7;

            const _tempVec3$2 = new Vec3();

            const _tempVec3_1 = new Vec3();

            const _tempVec2$1 = new Vec2();

            const _tempVec2_1 = new Vec2();

            const quintEaseOut = time => {
              time -= 1;
              return time * time * time * time * time + 1;
            };

            const getTimeInMilliseconds = () => {
              const currentTime = new Date();
              return currentTime.getMilliseconds();
            };

            const eventMap = {
              'scroll-to-top': 0,
              'scroll-to-bottom': 1,
              'scroll-to-left': 2,
              'scroll-to-right': 3,
              scrolling: 4,
              'bounce-bottom': 6,
              'bounce-left': 7,
              'bounce-right': 8,
              'bounce-top': 5,
              'scroll-ended': 9,
              'touch-up': 10,
              'scroll-ended-with-threshold': 11,
              'scroll-began': 12
            };
            let EventType$3;

            (function (EventType) {
              EventType["SCROLL_TO_TOP"] = "scroll-to-top";
              EventType["SCROLL_TO_BOTTOM"] = "scroll-to-bottom";
              EventType["SCROLL_TO_LEFT"] = "scroll-to-left";
              EventType["SCROLL_TO_RIGHT"] = "scroll-to-right";
              EventType["SCROLL_BEGAN"] = "scroll-began";
              EventType["SCROLL_ENDED"] = "scroll-ended";
              EventType["BOUNCE_TOP"] = "bounce-top";
              EventType["BOUNCE_BOTTOM"] = "bounce-bottom";
              EventType["BOUNCE_LEFT"] = "bounce-left";
              EventType["BOUNCE_RIGHT"] = "bounce-right";
              EventType["SCROLLING"] = "scrolling";
              EventType["SCROLL_ENG_WITH_THRESHOLD"] = "scroll-ended-with-threshold";
              EventType["TOUCH_UP"] = "touch-up";
            })(EventType$3 || (EventType$3 = {}));

            let ScrollView = function (v) { return exports({ ScrollView: v, ScrollViewComponent: v }), v; }((_dec$z = ccclass('cc.ScrollView'), _dec2$u = help(), _dec3$s = executionOrder(110), _dec4$r = menu$1(), _dec5$p = requireComponent(UITransform), _dec6$m = range(), _dec7$m = displayOrder(), _dec8$k = tooltip(), _dec9$h = range(), _dec10$g = displayOrder(), _dec11$d = tooltip(), _dec12$d = displayOrder(), _dec13$c = tooltip(), _dec14$9 = displayOrder(), _dec15$9 = tooltip(), _dec16$8 = type$1(Node), _dec17$6 = displayOrder(), _dec18$6 = tooltip(), _dec19$6 = displayOrder(), _dec20$5 = tooltip(), _dec21$5 = type$1(ScrollBar), _dec22$5 = displayOrder(), _dec23$5 = tooltip(), _dec24$5 = displayOrder(), _dec25$5 = tooltip(), _dec26$5 = type$1(ScrollBar), _dec27$5 = displayOrder(), _dec28$5 = tooltip(), _dec29$5 = displayOrder(), _dec30$5 = tooltip(), _dec31$4 = type$1([EventHandler]), _dec32$4 = displayOrder(), _dec33$3 = tooltip(), _dec$z(_class$z = _dec2$u(_class$z = _dec3$s(_class$z = _dec4$r(_class$z = _dec5$p(_class$z = (_class2$s = (_temp$v = _class3$c = class ScrollView extends ViewGroup {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "bounceDuration", _descriptor$r, this);

                _initializerDefineProperty(this, "brake", _descriptor2$o, this);

                _initializerDefineProperty(this, "elastic", _descriptor3$j, this);

                _initializerDefineProperty(this, "inertia", _descriptor4$i, this);

                _initializerDefineProperty(this, "horizontal", _descriptor5$g, this);

                _initializerDefineProperty(this, "vertical", _descriptor6$b, this);

                _initializerDefineProperty(this, "cancelInnerEvents", _descriptor7$9, this);

                _initializerDefineProperty(this, "scrollEvents", _descriptor8$9, this);

                this._autoScrolling = false;
                this._scrolling = false;

                _initializerDefineProperty(this, "_content", _descriptor9$8, this);

                _initializerDefineProperty(this, "_horizontalScrollBar", _descriptor10$7, this);

                _initializerDefineProperty(this, "_verticalScrollBar", _descriptor11$6, this);

                this._topBoundary = 0;
                this._bottomBoundary = 0;
                this._leftBoundary = 0;
                this._rightBoundary = 0;
                this._touchMoveDisplacements = [];
                this._touchMoveTimeDeltas = [];
                this._touchMovePreviousTimestamp = 0;
                this._touchMoved = false;
                this._autoScrollAttenuate = false;
                this._autoScrollStartPosition = new Vec3();
                this._autoScrollTargetDelta = new Vec3();
                this._autoScrollTotalTime = 0;
                this._autoScrollAccumulatedTime = 0;
                this._autoScrollCurrentlyOutOfBoundary = false;
                this._autoScrollBraking = false;
                this._autoScrollBrakingStartPosition = new Vec3();
                this._outOfBoundaryAmount = new Vec3();
                this._outOfBoundaryAmountDirty = true;
                this._stopMouseWheel = false;
                this._mouseWheelEventElapsedTime = 0.0;
                this._isScrollEndedWithThresholdEventFired = false;
                this._scrollEventEmitMask = 0;
                this._isBouncing = false;
                this._contentPos = new Vec3();
                this._deltaPos = new Vec3();
              }

              get content() {
                return this._content;
              }

              set content(value) {
                if (this._content === value) {
                  return;
                }

                const viewTrans = value && value.parent && value.parent._uiProps.uiTransformComp;

                if (value && (!value || !viewTrans)) {
                  logID(4302);
                  return;
                }

                this._content = value;

                this._calculateBoundary();
              }

              get horizontalScrollBar() {
                return this._horizontalScrollBar;
              }

              set horizontalScrollBar(value) {
                if (this._horizontalScrollBar === value) {
                  return;
                }

                this._horizontalScrollBar = value;

                if (this._horizontalScrollBar) {
                  this._horizontalScrollBar.setScrollView(this);

                  this._updateScrollBar(Vec2.ZERO);
                }
              }

              get verticalScrollBar() {
                return this._verticalScrollBar;
              }

              set verticalScrollBar(value) {
                if (this._verticalScrollBar === value) {
                  return;
                }

                this._verticalScrollBar = value;

                if (this._verticalScrollBar) {
                  this._verticalScrollBar.setScrollView(this);

                  this._updateScrollBar(Vec2.ZERO);
                }
              }

              get view() {
                const parent = this._content && this._content.parent;

                if (!parent) {
                  return null;
                }

                return parent._uiProps.uiTransformComp;
              }

              scrollToBottom(timeInSecond, attenuated = true) {
                const moveDelta = this._calculateMovePercentDelta({
                  anchor: new Vec2(0, 0),
                  applyToHorizontal: false,
                  applyToVertical: true
                });

                if (timeInSecond) {
                  this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
                } else {
                  this._moveContent(moveDelta, true);
                }
              }

              scrollToTop(timeInSecond, attenuated = true) {
                const moveDelta = this._calculateMovePercentDelta({
                  anchor: new Vec2(0, 1),
                  applyToHorizontal: false,
                  applyToVertical: true
                });

                if (timeInSecond) {
                  this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
                } else {
                  this._moveContent(moveDelta);
                }
              }

              scrollToLeft(timeInSecond, attenuated = true) {
                const moveDelta = this._calculateMovePercentDelta({
                  anchor: new Vec2(0, 0),
                  applyToHorizontal: true,
                  applyToVertical: false
                });

                if (timeInSecond) {
                  this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
                } else {
                  this._moveContent(moveDelta);
                }
              }

              scrollToRight(timeInSecond, attenuated = true) {
                const moveDelta = this._calculateMovePercentDelta({
                  anchor: new Vec2(1, 0),
                  applyToHorizontal: true,
                  applyToVertical: false
                });

                if (timeInSecond) {
                  this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
                } else {
                  this._moveContent(moveDelta);
                }
              }

              scrollToTopLeft(timeInSecond, attenuated = true) {
                const moveDelta = this._calculateMovePercentDelta({
                  anchor: new Vec2(0, 1),
                  applyToHorizontal: true,
                  applyToVertical: true
                });

                if (timeInSecond) {
                  this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
                } else {
                  this._moveContent(moveDelta);
                }
              }

              scrollToTopRight(timeInSecond, attenuated = true) {
                const moveDelta = this._calculateMovePercentDelta({
                  anchor: new Vec2(1, 1),
                  applyToHorizontal: true,
                  applyToVertical: true
                });

                if (timeInSecond) {
                  this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
                } else {
                  this._moveContent(moveDelta);
                }
              }

              scrollToBottomLeft(timeInSecond, attenuated = true) {
                const moveDelta = this._calculateMovePercentDelta({
                  anchor: new Vec2(0, 0),
                  applyToHorizontal: true,
                  applyToVertical: true
                });

                if (timeInSecond) {
                  this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
                } else {
                  this._moveContent(moveDelta);
                }
              }

              scrollToBottomRight(timeInSecond, attenuated = true) {
                const moveDelta = this._calculateMovePercentDelta({
                  anchor: new Vec2(1, 0),
                  applyToHorizontal: true,
                  applyToVertical: true
                });

                if (timeInSecond) {
                  this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
                } else {
                  this._moveContent(moveDelta);
                }
              }

              scrollToOffset(offset, timeInSecond, attenuated = true) {
                const maxScrollOffset = this.getMaxScrollOffset();
                const anchor = new Vec2(0, 0);

                if (maxScrollOffset.x === 0) {
                  anchor.x = 0;
                } else {
                  anchor.x = offset.x / maxScrollOffset.x;
                }

                if (maxScrollOffset.y === 0) {
                  anchor.y = 1;
                } else {
                  anchor.y = (maxScrollOffset.y - offset.y) / maxScrollOffset.y;
                }

                this.scrollTo(anchor, timeInSecond, attenuated);
              }

              getScrollOffset() {
                const topDelta = this._getContentTopBoundary() - this._topBoundary;

                const leftDelta = this._getContentLeftBoundary() - this._leftBoundary;

                return new Vec2(leftDelta, topDelta);
              }

              getMaxScrollOffset() {
                if (!this._content || !this.view) {
                  return Vec2.ZERO;
                }

                const contentSize = this._content._uiProps.uiTransformComp.contentSize;
                let horizontalMaximizeOffset = contentSize.width - this.view.width;
                let verticalMaximizeOffset = contentSize.height - this.view.height;
                horizontalMaximizeOffset = horizontalMaximizeOffset >= 0 ? horizontalMaximizeOffset : 0;
                verticalMaximizeOffset = verticalMaximizeOffset >= 0 ? verticalMaximizeOffset : 0;
                return new Vec2(horizontalMaximizeOffset, verticalMaximizeOffset);
              }

              scrollToPercentHorizontal(percent, timeInSecond, attenuated) {
                const moveDelta = this._calculateMovePercentDelta({
                  anchor: new Vec2(percent, 0),
                  applyToHorizontal: true,
                  applyToVertical: false
                });

                if (timeInSecond) {
                  this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
                } else {
                  this._moveContent(moveDelta);
                }
              }

              scrollTo(anchor, timeInSecond, attenuated) {
                const moveDelta = this._calculateMovePercentDelta({
                  anchor: new Vec2(anchor),
                  applyToHorizontal: true,
                  applyToVertical: true
                });

                if (timeInSecond) {
                  this._startAutoScroll(moveDelta, timeInSecond, attenuated);
                } else {
                  this._moveContent(moveDelta);
                }
              }

              scrollToPercentVertical(percent, timeInSecond, attenuated) {
                const moveDelta = this._calculateMovePercentDelta({
                  anchor: new Vec2(0, percent),
                  applyToHorizontal: false,
                  applyToVertical: true
                });

                if (timeInSecond) {
                  this._startAutoScroll(moveDelta, timeInSecond, attenuated);
                } else {
                  this._moveContent(moveDelta);
                }
              }

              stopAutoScroll() {
                this._autoScrolling = false;
                this._autoScrollAccumulatedTime = this._autoScrollTotalTime;
              }

              setContentPosition(position) {
                this._setContentPosition(position);
              }

              _setContentPosition(position) {
                if (!this._content) {
                  return;
                }

                const contentPos = this._getContentPosition();

                if (Math.abs(position.x - contentPos.x) < EPSILON$1 && Math.abs(position.y - contentPos.y) < EPSILON$1) {
                  return;
                }

                this._content.setPosition(position);

                this._outOfBoundaryAmountDirty = true;
              }

              getContentPosition() {
                return this._getContentPosition();
              }

              _getContentPosition() {
                if (!this._content) {
                  return Vec3.ZERO.clone();
                }

                this._contentPos.set(this._content.position);

                return this._contentPos;
              }

              isScrolling() {
                return this._scrolling;
              }

              isAutoScrolling() {
                return this._autoScrolling;
              }

              getScrollEndedEventTiming() {
                return EPSILON$1;
              }

              start() {
                this._calculateBoundary();

                if (this._content) {
                  director.once(Director.EVENT_BEFORE_DRAW, this._adjustContentOutOfBoundary, this);
                }
              }

              onEnable() {
                {
                  this._registerEvent();

                  if (this._content) {
                    this._content.on(NodeEventType.SIZE_CHANGED, this._calculateBoundary, this);

                    this._content.on(NodeEventType.TRANSFORM_CHANGED, this._scaleChanged, this);

                    if (this.view) {
                      this.view.node.on(NodeEventType.TRANSFORM_CHANGED, this._scaleChanged, this);
                      this.view.node.on(NodeEventType.SIZE_CHANGED, this._calculateBoundary, this);
                    }
                  }

                  this._calculateBoundary();
                }

                this._updateScrollBarState();
              }

              update(dt) {
                if (this._autoScrolling) {
                  this._processAutoScrolling(dt);
                }
              }

              onDisable() {
                {
                  this._unregisterEvent();

                  if (this._content) {
                    this._content.off(NodeEventType.SIZE_CHANGED, this._calculateBoundary, this);

                    this._content.off(NodeEventType.TRANSFORM_CHANGED, this._scaleChanged, this);

                    if (this.view) {
                      this.view.node.off(NodeEventType.TRANSFORM_CHANGED, this._scaleChanged, this);
                      this.view.node.off(NodeEventType.SIZE_CHANGED, this._calculateBoundary, this);
                    }
                  }
                }

                this._hideScrollBar();

                this.stopAutoScroll();
              }

              _registerEvent() {
                this.node.on(NodeEventType.TOUCH_START, this._onTouchBegan, this, true);
                this.node.on(NodeEventType.TOUCH_MOVE, this._onTouchMoved, this, true);
                this.node.on(NodeEventType.TOUCH_END, this._onTouchEnded, this, true);
                this.node.on(NodeEventType.TOUCH_CANCEL, this._onTouchCancelled, this, true);
                this.node.on(NodeEventType.MOUSE_WHEEL, this._onMouseWheel, this, true);
              }

              _unregisterEvent() {
                this.node.off(NodeEventType.TOUCH_START, this._onTouchBegan, this, true);
                this.node.off(NodeEventType.TOUCH_MOVE, this._onTouchMoved, this, true);
                this.node.off(NodeEventType.TOUCH_END, this._onTouchEnded, this, true);
                this.node.off(NodeEventType.TOUCH_CANCEL, this._onTouchCancelled, this, true);
                this.node.off(NodeEventType.MOUSE_WHEEL, this._onMouseWheel, this, true);
              }

              _onMouseWheel(event, captureListeners) {
                if (!this.enabledInHierarchy) {
                  return;
                }

                if (this._hasNestedViewGroup(event, captureListeners)) {
                  return;
                }

                const deltaMove = new Vec3();
                const wheelPrecision = -0.1;
                const scrollY = event.getScrollY();

                if (this.vertical) {
                  deltaMove.set(0, scrollY * wheelPrecision, 0);
                } else if (this.horizontal) {
                  deltaMove.set(scrollY * wheelPrecision, 0, 0);
                }

                this._mouseWheelEventElapsedTime = 0;

                this._processDeltaMove(deltaMove);

                if (!this._stopMouseWheel) {
                  this._handlePressLogic();

                  this.schedule(this._checkMouseWheel, 1.0 / 60, NaN, 0);
                  this._stopMouseWheel = true;
                }

                this._stopPropagationIfTargetIsMe(event);
              }

              _onTouchBegan(event, captureListeners) {
                if (!this.enabledInHierarchy || !this._content) {
                  return;
                }

                if (this._hasNestedViewGroup(event, captureListeners)) {
                  return;
                }

                this._handlePressLogic();

                this._touchMoved = false;

                this._stopPropagationIfTargetIsMe(event);
              }

              _onTouchMoved(event, captureListeners) {
                if (!this.enabledInHierarchy || !this._content) {
                  return;
                }

                if (this._hasNestedViewGroup(event, captureListeners)) {
                  return;
                }

                const touch = event.touch;

                this._handleMoveLogic(touch);

                if (!this.cancelInnerEvents) {
                  return;
                }

                const deltaMove = touch.getUILocation(_tempVec2$1);
                deltaMove.subtract(touch.getUIStartLocation(_tempVec2_1));

                if (deltaMove.length() > 7) {
                  if (!this._touchMoved && event.target !== this.node) {
                    const cancelEvent = new EventTouch(event.getTouches(), event.bubbles, SystemEventType.TOUCH_CANCEL);
                    cancelEvent.touch = event.touch;
                    cancelEvent.simulate = true;
                    event.target.dispatchEvent(cancelEvent);
                    this._touchMoved = true;
                  }
                }

                this._stopPropagationIfTargetIsMe(event);
              }

              _onTouchEnded(event, captureListeners) {
                if (!this.enabledInHierarchy || !this._content || !event) {
                  return;
                }

                if (this._hasNestedViewGroup(event, captureListeners)) {
                  return;
                }

                this._dispatchEvent(EventType$3.TOUCH_UP);

                const touch = event.touch;

                this._handleReleaseLogic(touch);

                if (this._touchMoved) {
                  event.propagationStopped = true;
                } else {
                  this._stopPropagationIfTargetIsMe(event);
                }
              }

              _onTouchCancelled(event, captureListeners) {
                if (!this.enabledInHierarchy || !this._content) {
                  return;
                }

                if (this._hasNestedViewGroup(event, captureListeners)) {
                  return;
                }

                if (event && !event.simulate) {
                  const touch = event.touch;

                  this._handleReleaseLogic(touch);
                }

                this._stopPropagationIfTargetIsMe(event);
              }

              _calculateBoundary() {
                if (this._content && this.view) {
                  const layout = this._content.getComponent(Layout);

                  if (layout && layout.enabledInHierarchy) {
                    layout.updateLayout();
                  }

                  const viewTrans = this.view;
                  const anchorX = viewTrans.width * viewTrans.anchorX;
                  const anchorY = viewTrans.height * viewTrans.anchorY;
                  this._leftBoundary = -anchorX;
                  this._bottomBoundary = -anchorY;
                  this._rightBoundary = this._leftBoundary + viewTrans.width;
                  this._topBoundary = this._bottomBoundary + viewTrans.height;

                  this._moveContentToTopLeft(viewTrans.contentSize);
                }
              }

              _hasNestedViewGroup(event, captureListeners) {
                if (!event || event.eventPhase !== Event.CAPTURING_PHASE) {
                  return false;
                }

                if (captureListeners) {
                  for (const listener of captureListeners) {
                    const item = listener;

                    if (this.node === item) {
                      if (event.target && event.target.getComponent(ViewGroup)) {
                        return true;
                      }

                      return false;
                    }

                    if (item.getComponent(ViewGroup)) {
                      return true;
                    }
                  }
                }

                return false;
              }

              _startInertiaScroll(touchMoveVelocity) {
                const inertiaTotalMovement = new Vec3(touchMoveVelocity);
                inertiaTotalMovement.multiplyScalar(MOVEMENT_FACTOR);

                this._startAttenuatingAutoScroll(inertiaTotalMovement, touchMoveVelocity);
              }

              _calculateAttenuatedFactor(distance) {
                if (this.brake <= 0) {
                  return 1 - this.brake;
                }

                return (1 - this.brake) * (1 / (1 + distance * 0.000014 + distance * distance * 0.000000008));
              }

              _startAttenuatingAutoScroll(deltaMove, initialVelocity) {
                const targetDelta = deltaMove.clone();
                targetDelta.normalize();

                if (this._content && this.view) {
                  const contentSize = this._content._uiProps.uiTransformComp.contentSize;
                  const scrollViewSize = this.view.contentSize;
                  const totalMoveWidth = contentSize.width - scrollViewSize.width;
                  const totalMoveHeight = contentSize.height - scrollViewSize.height;

                  const attenuatedFactorX = this._calculateAttenuatedFactor(totalMoveWidth);

                  const attenuatedFactorY = this._calculateAttenuatedFactor(totalMoveHeight);

                  targetDelta.x = targetDelta.x * totalMoveWidth * (1 - this.brake) * attenuatedFactorX;
                  targetDelta.y = targetDelta.y * totalMoveHeight * attenuatedFactorY * (1 - this.brake);
                  targetDelta.z = 0;
                }

                const originalMoveLength = deltaMove.length();
                let factor = targetDelta.length() / originalMoveLength;
                targetDelta.add(deltaMove);

                if (this.brake > 0 && factor > 7) {
                  factor = Math.sqrt(factor);
                  const clonedDeltaMove = deltaMove.clone();
                  clonedDeltaMove.multiplyScalar(factor);
                  targetDelta.set(clonedDeltaMove);
                  targetDelta.add(deltaMove);
                }

                let time = this._calculateAutoScrollTimeByInitialSpeed(initialVelocity.length());

                if (this.brake > 0 && factor > 3) {
                  factor = 3;
                  time *= factor;
                }

                if (this.brake === 0 && factor > 1) {
                  time *= factor;
                }

                this._startAutoScroll(targetDelta, time, true);
              }

              _calculateAutoScrollTimeByInitialSpeed(initialSpeed) {
                return Math.sqrt(Math.sqrt(initialSpeed / 5));
              }

              _startAutoScroll(deltaMove, timeInSecond, attenuated = false) {
                const adjustedDeltaMove = this._flattenVectorByDirection(deltaMove);

                this._autoScrolling = true;
                this._autoScrollTargetDelta = adjustedDeltaMove;
                this._autoScrollAttenuate = attenuated;
                Vec3.copy(this._autoScrollStartPosition, this._getContentPosition());
                this._autoScrollTotalTime = timeInSecond;
                this._autoScrollAccumulatedTime = 0;
                this._autoScrollBraking = false;
                this._isScrollEndedWithThresholdEventFired = false;

                this._autoScrollBrakingStartPosition.set(0, 0, 0);

                const currentOutOfBoundary = this._getHowMuchOutOfBoundary();

                if (!currentOutOfBoundary.equals(Vec3.ZERO, EPSILON$1)) {
                  this._autoScrollCurrentlyOutOfBoundary = true;
                }
              }

              _calculateTouchMoveVelocity() {
                const out = new Vec3();
                let totalTime = 0;
                totalTime = this._touchMoveTimeDeltas.reduce((a, b) => a + b, totalTime);

                if (totalTime <= 0 || totalTime >= 0.5) {
                  out.set(Vec3.ZERO);
                } else {
                  let totalMovement = new Vec3();
                  totalMovement = this._touchMoveDisplacements.reduce((a, b) => {
                    a.add(b);
                    return a;
                  }, totalMovement);
                  out.set(totalMovement.x * (1 - this.brake) / totalTime, totalMovement.y * (1 - this.brake) / totalTime, totalMovement.z);
                }

                return out;
              }

              _flattenVectorByDirection(vector) {
                const result = vector;
                result.x = this.horizontal ? result.x : 0;
                result.y = this.vertical ? result.y : 0;
                return result;
              }

              _moveContent(deltaMove, canStartBounceBack) {
                const adjustedMove = this._flattenVectorByDirection(deltaMove);

                _tempVec3$2.set(this._getContentPosition());

                _tempVec3$2.add(adjustedMove);

                _tempVec3$2.set(Math.round(_tempVec3$2.x * TOLERANCE) * EPSILON$1, Math.round(_tempVec3$2.y * TOLERANCE) * EPSILON$1, _tempVec3$2.z);

                this._setContentPosition(_tempVec3$2);

                const outOfBoundary = this._getHowMuchOutOfBoundary();

                _tempVec2$1.set(outOfBoundary.x, outOfBoundary.y);

                this._updateScrollBar(_tempVec2$1);

                if (this.elastic && canStartBounceBack) {
                  this._startBounceBackIfNeeded();
                }
              }

              _getContentLeftBoundary() {
                if (!this._content) {
                  return -1;
                }

                const contentPos = this._getContentPosition();

                const uiTrans = this._content._uiProps.uiTransformComp;
                return contentPos.x - uiTrans.anchorX * uiTrans.width;
              }

              _getContentRightBoundary() {
                if (!this._content) {
                  return -1;
                }

                const uiTrans = this._content._uiProps.uiTransformComp;
                return this._getContentLeftBoundary() + uiTrans.width;
              }

              _getContentTopBoundary() {
                if (!this._content) {
                  return -1;
                }

                const uiTrans = this._content._uiProps.uiTransformComp;
                return this._getContentBottomBoundary() + uiTrans.height;
              }

              _getContentBottomBoundary() {
                if (!this._content) {
                  return -1;
                }

                const contentPos = this._getContentPosition();

                const uiTrans = this._content._uiProps.uiTransformComp;
                return contentPos.y - uiTrans.anchorY * uiTrans.height;
              }

              _getHowMuchOutOfBoundary(addition) {
                addition = addition || new Vec3();

                if (addition.equals(Vec3.ZERO, EPSILON$1) && !this._outOfBoundaryAmountDirty) {
                  return this._outOfBoundaryAmount;
                }

                const outOfBoundaryAmount = new Vec3();

                const tempLeftBoundary = this._getContentLeftBoundary();

                const tempRightBoundary = this._getContentRightBoundary();

                if (tempLeftBoundary + addition.x > this._leftBoundary) {
                  outOfBoundaryAmount.x = this._leftBoundary - (tempLeftBoundary + addition.x);
                } else if (tempRightBoundary + addition.x < this._rightBoundary) {
                  outOfBoundaryAmount.x = this._rightBoundary - (tempRightBoundary + addition.x);
                }

                const tempTopBoundary = this._getContentTopBoundary();

                const tempBottomBoundary = this._getContentBottomBoundary();

                if (tempTopBoundary + addition.y < this._topBoundary) {
                  outOfBoundaryAmount.y = this._topBoundary - (tempTopBoundary + addition.y);
                } else if (tempBottomBoundary + addition.y > this._bottomBoundary) {
                  outOfBoundaryAmount.y = this._bottomBoundary - (tempBottomBoundary + addition.y);
                }

                if (addition.equals(Vec3.ZERO, EPSILON$1)) {
                  this._outOfBoundaryAmount = outOfBoundaryAmount;
                  this._outOfBoundaryAmountDirty = false;
                }

                this._clampDelta(outOfBoundaryAmount);

                return outOfBoundaryAmount;
              }

              _updateScrollBar(outOfBoundary) {
                if (this._horizontalScrollBar) {
                  this._horizontalScrollBar.onScroll(outOfBoundary);
                }

                if (this.verticalScrollBar) {
                  this.verticalScrollBar.onScroll(outOfBoundary);
                }
              }

              _onScrollBarTouchBegan() {
                if (this._horizontalScrollBar) {
                  this._horizontalScrollBar.onTouchBegan();
                }

                if (this.verticalScrollBar) {
                  this.verticalScrollBar.onTouchBegan();
                }
              }

              _onScrollBarTouchEnded() {
                if (this._horizontalScrollBar) {
                  this._horizontalScrollBar.onTouchEnded();
                }

                if (this.verticalScrollBar) {
                  this.verticalScrollBar.onTouchEnded();
                }
              }

              _dispatchEvent(event) {
                if (event === EventType$3.SCROLL_ENDED) {
                  this._scrollEventEmitMask = 0;
                } else if (event === EventType$3.SCROLL_TO_TOP || event === EventType$3.SCROLL_TO_BOTTOM || event === EventType$3.SCROLL_TO_LEFT || event === EventType$3.SCROLL_TO_RIGHT) {
                  const flag = 1 << eventMap[event];

                  if (this._scrollEventEmitMask & flag) {
                    return;
                  } else {
                    this._scrollEventEmitMask |= flag;
                  }
                }

                EventHandler.emitEvents(this.scrollEvents, this, eventMap[event]);
                this.node.emit(event, this);
              }

              _adjustContentOutOfBoundary() {
                if (!this._content) {
                  return;
                }

                this._outOfBoundaryAmountDirty = true;

                if (this._isOutOfBoundary()) {
                  const outOfBoundary = this._getHowMuchOutOfBoundary();

                  _tempVec3$2.set(this._getContentPosition());

                  _tempVec3$2.add(outOfBoundary);

                  this._content.setPosition(_tempVec3$2);

                  this._updateScrollBar(Vec2.ZERO);
                }
              }

              _hideScrollBar() {
                if (this._horizontalScrollBar) {
                  this._horizontalScrollBar.hide();
                }

                if (this._verticalScrollBar) {
                  this._verticalScrollBar.hide();
                }
              }

              _updateScrollBarState() {
                if (!this._content || !this.view) {
                  return;
                }

                const viewTrans = this.view;
                const uiTrans = this._content._uiProps.uiTransformComp;

                if (this.verticalScrollBar) {
                  if (uiTrans.height < viewTrans.height) {
                    this.verticalScrollBar.hide();
                  } else {
                    this.verticalScrollBar.show();
                  }
                }

                if (this.horizontalScrollBar) {
                  if (uiTrans.width < viewTrans.width) {
                    this.horizontalScrollBar.hide();
                  } else {
                    this.horizontalScrollBar.show();
                  }
                }
              }

              _stopPropagationIfTargetIsMe(event) {
                if (event.eventPhase === Event.AT_TARGET && event.target === this.node) {
                  event.propagationStopped = true;
                }
              }

              _processDeltaMove(deltaMove) {
                this._scrollChildren(deltaMove);

                this._gatherTouchMove(deltaMove);
              }

              _handleMoveLogic(touch) {
                this._getLocalAxisAlignDelta(this._deltaPos, touch);

                this._processDeltaMove(this._deltaPos);
              }

              _handleReleaseLogic(touch) {
                this._getLocalAxisAlignDelta(this._deltaPos, touch);

                this._gatherTouchMove(this._deltaPos);

                this._processInertiaScroll();

                if (this._scrolling) {
                  this._scrolling = false;

                  if (!this._autoScrolling) {
                    this._dispatchEvent(EventType$3.SCROLL_ENDED);
                  }
                }
              }

              _getLocalAxisAlignDelta(out, touch) {
                const uiTransformComp = this.node._uiProps.uiTransformComp;
                const vec = new Vec3();

                if (uiTransformComp) {
                  touch.getUILocation(_tempVec2$1);
                  touch.getUIPreviousLocation(_tempVec2_1);

                  _tempVec3$2.set(_tempVec2$1.x, _tempVec2$1.y, 0);

                  _tempVec3_1.set(_tempVec2_1.x, _tempVec2_1.y, 0);

                  uiTransformComp.convertToNodeSpaceAR(_tempVec3$2, _tempVec3$2);
                  uiTransformComp.convertToNodeSpaceAR(_tempVec3_1, _tempVec3_1);
                  Vec3.subtract(vec, _tempVec3$2, _tempVec3_1);
                }

                out.set(vec);
              }

              _scrollChildren(deltaMove) {
                this._clampDelta(deltaMove);

                const realMove = deltaMove;
                let outOfBoundary;

                if (this.elastic) {
                  outOfBoundary = this._getHowMuchOutOfBoundary();
                  realMove.x *= outOfBoundary.x === 0 ? 1 : 0.5;
                  realMove.y *= outOfBoundary.y === 0 ? 1 : 0.5;
                }

                if (!this.elastic) {
                  outOfBoundary = this._getHowMuchOutOfBoundary(realMove);
                  realMove.add(outOfBoundary);
                }

                let verticalScrollEventType = '';
                let horizontalScrollEventType = '';

                if (this._content) {
                  const {
                    anchorX,
                    anchorY,
                    width,
                    height
                  } = this._content._uiProps.uiTransformComp;
                  const pos = this._content.position || Vec3.ZERO;

                  if (this.vertical) {
                    if (realMove.y > 0) {
                      const icBottomPos = pos.y - anchorY * height;

                      if (icBottomPos + realMove.y >= this._bottomBoundary) {
                        verticalScrollEventType = EventType$3.SCROLL_TO_BOTTOM;
                      }
                    } else if (realMove.y < 0) {
                      const icTopPos = pos.y - anchorY * height + height;

                      if (icTopPos + realMove.y <= this._topBoundary) {
                        verticalScrollEventType = EventType$3.SCROLL_TO_TOP;
                      }
                    }
                  }

                  if (this.horizontal) {
                    if (realMove.x < 0) {
                      const icRightPos = pos.x - anchorX * width + width;

                      if (icRightPos + realMove.x <= this._rightBoundary) {
                        horizontalScrollEventType = EventType$3.SCROLL_TO_RIGHT;
                      }
                    } else if (realMove.x > 0) {
                      const icLeftPos = pos.x - anchorX * width;

                      if (icLeftPos + realMove.x >= this._leftBoundary) {
                        horizontalScrollEventType = EventType$3.SCROLL_TO_LEFT;
                      }
                    }
                  }
                }

                this._moveContent(realMove, false);

                if (this.horizontal && realMove.x !== 0 || this.vertical && realMove.y !== 0) {
                  if (!this._scrolling) {
                    this._scrolling = true;

                    this._dispatchEvent(EventType$3.SCROLL_BEGAN);
                  }

                  this._dispatchEvent(EventType$3.SCROLLING);
                }

                if (verticalScrollEventType !== '') {
                  this._dispatchEvent(verticalScrollEventType);
                }

                if (horizontalScrollEventType !== '') {
                  this._dispatchEvent(horizontalScrollEventType);
                }
              }

              _handlePressLogic() {
                if (this._autoScrolling) {
                  this._dispatchEvent(EventType$3.SCROLL_ENDED);
                }

                this._autoScrolling = false;
                this._isBouncing = false;
                this._touchMovePreviousTimestamp = getTimeInMilliseconds();
                this._touchMoveDisplacements.length = 0;
                this._touchMoveTimeDeltas.length = 0;

                this._onScrollBarTouchBegan();
              }

              _clampDelta(out) {
                if (this._content && this.view) {
                  const scrollViewSize = this.view.contentSize;
                  const uiTrans = this._content._uiProps.uiTransformComp;

                  if (uiTrans.width < scrollViewSize.width) {
                    out.x = 0;
                  }

                  if (uiTrans.height < scrollViewSize.height) {
                    out.y = 0;
                  }
                }
              }

              _gatherTouchMove(delta) {
                const clampDt = delta.clone();

                this._clampDelta(clampDt);

                while (this._touchMoveDisplacements.length >= NUMBER_OF_GATHERED_TOUCHES_FOR_MOVE_SPEED) {
                  this._touchMoveDisplacements.shift();

                  this._touchMoveTimeDeltas.shift();
                }

                this._touchMoveDisplacements.push(clampDt);

                const timeStamp = getTimeInMilliseconds();

                this._touchMoveTimeDeltas.push((timeStamp - this._touchMovePreviousTimestamp) / 1000);

                this._touchMovePreviousTimestamp = timeStamp;
              }

              _startBounceBackIfNeeded() {
                if (!this.elastic) {
                  return false;
                }

                const bounceBackAmount = this._getHowMuchOutOfBoundary();

                this._clampDelta(bounceBackAmount);

                if (bounceBackAmount.equals(Vec3.ZERO, EPSILON$1)) {
                  return false;
                }

                const bounceBackTime = Math.max(this.bounceDuration, 0);

                this._startAutoScroll(bounceBackAmount, bounceBackTime, true);

                if (!this._isBouncing) {
                  if (bounceBackAmount.y > 0) {
                    this._dispatchEvent(EventType$3.BOUNCE_TOP);
                  }

                  if (bounceBackAmount.y < 0) {
                    this._dispatchEvent(EventType$3.BOUNCE_BOTTOM);
                  }

                  if (bounceBackAmount.x > 0) {
                    this._dispatchEvent(EventType$3.BOUNCE_RIGHT);
                  }

                  if (bounceBackAmount.x < 0) {
                    this._dispatchEvent(EventType$3.BOUNCE_LEFT);
                  }

                  this._isBouncing = true;
                }

                return true;
              }

              _processInertiaScroll() {
                const bounceBackStarted = this._startBounceBackIfNeeded();

                if (!bounceBackStarted && this.inertia) {
                  const touchMoveVelocity = this._calculateTouchMoveVelocity();

                  if (!touchMoveVelocity.equals(_tempVec3$2, EPSILON$1) && this.brake < 1) {
                    this._startInertiaScroll(touchMoveVelocity);
                  }
                }

                this._onScrollBarTouchEnded();
              }

              _isOutOfBoundary() {
                const outOfBoundary = this._getHowMuchOutOfBoundary();

                return !outOfBoundary.equals(Vec3.ZERO, EPSILON$1);
              }

              _isNecessaryAutoScrollBrake() {
                if (this._autoScrollBraking) {
                  return true;
                }

                if (this._isOutOfBoundary()) {
                  if (!this._autoScrollCurrentlyOutOfBoundary) {
                    this._autoScrollCurrentlyOutOfBoundary = true;
                    this._autoScrollBraking = true;
                    this._autoScrollBrakingStartPosition = this._getContentPosition();
                    return true;
                  }
                } else {
                  this._autoScrollCurrentlyOutOfBoundary = false;
                }

                return false;
              }

              _processAutoScrolling(dt) {
                const isAutoScrollBrake = this._isNecessaryAutoScrollBrake();

                const brakingFactor = isAutoScrollBrake ? OUT_OF_BOUNDARY_BREAKING_FACTOR : 1;
                this._autoScrollAccumulatedTime += dt * (1 / brakingFactor);
                let percentage = Math.min(1, this._autoScrollAccumulatedTime / this._autoScrollTotalTime);

                if (this._autoScrollAttenuate) {
                  percentage = quintEaseOut(percentage);
                }

                const clonedAutoScrollTargetDelta = this._autoScrollTargetDelta.clone();

                clonedAutoScrollTargetDelta.multiplyScalar(percentage);

                const clonedAutoScrollStartPosition = this._autoScrollStartPosition.clone();

                clonedAutoScrollStartPosition.add(clonedAutoScrollTargetDelta);
                let reachedEnd = Math.abs(percentage - 1) <= EPSILON$1;
                const fireEvent = Math.abs(percentage - 1) <= this.getScrollEndedEventTiming();

                if (fireEvent && !this._isScrollEndedWithThresholdEventFired) {
                  this._dispatchEvent(EventType$3.SCROLL_ENG_WITH_THRESHOLD);

                  this._isScrollEndedWithThresholdEventFired = true;
                }

                if (this.elastic) {
                  const brakeOffsetPosition = clonedAutoScrollStartPosition.clone();
                  brakeOffsetPosition.subtract(this._autoScrollBrakingStartPosition);

                  if (isAutoScrollBrake) {
                    brakeOffsetPosition.multiplyScalar(brakingFactor);
                  }

                  clonedAutoScrollStartPosition.set(this._autoScrollBrakingStartPosition);
                  clonedAutoScrollStartPosition.add(brakeOffsetPosition);
                } else {
                  const moveDelta = clonedAutoScrollStartPosition.clone();
                  moveDelta.subtract(this.getContentPosition());

                  const outOfBoundary = this._getHowMuchOutOfBoundary(moveDelta);

                  if (!outOfBoundary.equals(Vec3.ZERO, EPSILON$1)) {
                    clonedAutoScrollStartPosition.add(outOfBoundary);
                    reachedEnd = true;
                  }
                }

                if (reachedEnd) {
                  this._autoScrolling = false;
                }

                const deltaMove = clonedAutoScrollStartPosition.clone();
                deltaMove.subtract(this._getContentPosition());

                this._clampDelta(deltaMove);

                this._moveContent(deltaMove, reachedEnd);

                this._dispatchEvent(EventType$3.SCROLLING);

                if (!this._autoScrolling) {
                  this._isBouncing = false;
                  this._scrolling = false;

                  this._dispatchEvent(EventType$3.SCROLL_ENDED);
                }
              }

              _checkMouseWheel(dt) {
                const currentOutOfBoundary = this._getHowMuchOutOfBoundary();

                const maxElapsedTime = 0.1;

                if (!currentOutOfBoundary.equals(Vec3.ZERO, EPSILON$1)) {
                  this._processInertiaScroll();

                  this.unschedule(this._checkMouseWheel);

                  this._dispatchEvent(EventType$3.SCROLL_ENDED);

                  this._stopMouseWheel = false;
                  return;
                }

                this._mouseWheelEventElapsedTime += dt;

                if (this._mouseWheelEventElapsedTime > maxElapsedTime) {
                  this._onScrollBarTouchEnded();

                  this.unschedule(this._checkMouseWheel);

                  this._dispatchEvent(EventType$3.SCROLL_ENDED);

                  this._stopMouseWheel = false;
                }
              }

              _calculateMovePercentDelta(options) {
                const anchor = options.anchor;
                const applyToHorizontal = options.applyToHorizontal;
                const applyToVertical = options.applyToVertical;

                this._calculateBoundary();

                anchor.clampf(Vec2.ZERO, Vec2.ONE);

                let bottomDelta = this._getContentBottomBoundary() - this._bottomBoundary;

                bottomDelta = -bottomDelta;

                let leftDelta = this._getContentLeftBoundary() - this._leftBoundary;

                leftDelta = -leftDelta;
                const moveDelta = new Vec3();

                if (this._content && this.view) {
                  let totalScrollDelta = 0;
                  const uiTrans = this._content._uiProps.uiTransformComp;
                  const contentSize = uiTrans.contentSize;
                  const scrollSize = this.view.contentSize;

                  if (applyToHorizontal) {
                    totalScrollDelta = contentSize.width - scrollSize.width;
                    moveDelta.x = leftDelta - totalScrollDelta * anchor.x;
                  }

                  if (applyToVertical) {
                    totalScrollDelta = contentSize.height - scrollSize.height;
                    moveDelta.y = bottomDelta - totalScrollDelta * anchor.y;
                  }
                }

                return moveDelta;
              }

              _moveContentToTopLeft(scrollViewSize) {
                let bottomDelta = this._getContentBottomBoundary() - this._bottomBoundary;

                bottomDelta = -bottomDelta;
                const moveDelta = new Vec3();
                let totalScrollDelta = 0;

                let leftDelta = this._getContentLeftBoundary() - this._leftBoundary;

                leftDelta = -leftDelta;

                if (this._content) {
                  const uiTrans = this._content._uiProps.uiTransformComp;
                  const contentSize = uiTrans.contentSize;

                  if (contentSize.height < scrollViewSize.height) {
                    totalScrollDelta = contentSize.height - scrollViewSize.height;
                    moveDelta.y = bottomDelta - totalScrollDelta;
                  }

                  if (contentSize.width < scrollViewSize.width) {
                    totalScrollDelta = contentSize.width - scrollViewSize.width;
                    moveDelta.x = leftDelta;
                  }
                }

                this._updateScrollBarState();

                this._moveContent(moveDelta);

                this._adjustContentOutOfBoundary();
              }

              _scaleChanged(value) {
                if (value === TransformBit.SCALE) {
                  this._calculateBoundary();
                }
              }

            }, _class3$c.EventType = EventType$3, _temp$v), (_descriptor$r = _applyDecoratedDescriptor(_class2$s.prototype, "bounceDuration", [serializable, _dec6$m, _dec7$m, _dec8$k], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            }), _descriptor2$o = _applyDecoratedDescriptor(_class2$s.prototype, "brake", [serializable, _dec9$h, _dec10$g, _dec11$d], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.5;
              }
            }), _descriptor3$j = _applyDecoratedDescriptor(_class2$s.prototype, "elastic", [serializable, _dec12$d, _dec13$c], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _descriptor4$i = _applyDecoratedDescriptor(_class2$s.prototype, "inertia", [serializable, _dec14$9, _dec15$9], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _applyDecoratedDescriptor(_class2$s.prototype, "content", [_dec16$8, _dec17$6, _dec18$6], Object.getOwnPropertyDescriptor(_class2$s.prototype, "content"), _class2$s.prototype), _descriptor5$g = _applyDecoratedDescriptor(_class2$s.prototype, "horizontal", [serializable, _dec19$6, _dec20$5], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _applyDecoratedDescriptor(_class2$s.prototype, "horizontalScrollBar", [_dec21$5, _dec22$5, _dec23$5], Object.getOwnPropertyDescriptor(_class2$s.prototype, "horizontalScrollBar"), _class2$s.prototype), _descriptor6$b = _applyDecoratedDescriptor(_class2$s.prototype, "vertical", [serializable, _dec24$5, _dec25$5], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _applyDecoratedDescriptor(_class2$s.prototype, "verticalScrollBar", [_dec26$5, _dec27$5, _dec28$5], Object.getOwnPropertyDescriptor(_class2$s.prototype, "verticalScrollBar"), _class2$s.prototype), _descriptor7$9 = _applyDecoratedDescriptor(_class2$s.prototype, "cancelInnerEvents", [serializable, _dec29$5, _dec30$5], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _descriptor8$9 = _applyDecoratedDescriptor(_class2$s.prototype, "scrollEvents", [_dec31$4, serializable, _dec32$4, _dec33$3], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor9$8 = _applyDecoratedDescriptor(_class2$s.prototype, "_content", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor10$7 = _applyDecoratedDescriptor(_class2$s.prototype, "_horizontalScrollBar", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor11$6 = _applyDecoratedDescriptor(_class2$s.prototype, "_verticalScrollBar", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            })), _class2$s)) || _class$z) || _class$z) || _class$z) || _class$z) || _class$z));

            var _dec$A, _dec2$v, _dec3$t, _dec4$s, _dec5$q, _dec6$n, _dec7$n, _dec8$l, _dec9$i, _dec10$h, _dec11$e, _dec12$e, _dec13$d, _class$A, _class2$t, _descriptor$s, _descriptor2$p, _descriptor3$k, _descriptor4$j, _class3$d, _temp$w;

            const _tempPos = new Vec3();

            var Direction$1;

            (function (Direction) {
              Direction[Direction["Horizontal"] = 0] = "Horizontal";
              Direction[Direction["Vertical"] = 1] = "Vertical";
            })(Direction$1 || (Direction$1 = {}));

            ccenum(Direction$1);
            let Slider = function (v) { return exports({ Slider: v, SliderComponent: v }), v; }((_dec$A = ccclass('cc.Slider'), _dec2$v = help(), _dec3$t = executionOrder(110), _dec4$s = menu$1(), _dec5$q = requireComponent(UITransform), _dec6$n = type$1(Sprite), _dec7$n = tooltip(), _dec8$l = type$1(Direction$1), _dec9$i = tooltip(), _dec10$h = range(), _dec11$e = tooltip(), _dec12$e = type$1([EventHandler]), _dec13$d = tooltip(), _dec$A(_class$A = _dec2$v(_class$A = _dec3$t(_class$A = _dec4$s(_class$A = _dec5$q(_class$A = (_class2$t = (_temp$w = _class3$d = class Slider extends Component {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "slideEvents", _descriptor$s, this);

                _initializerDefineProperty(this, "_handle", _descriptor2$p, this);

                _initializerDefineProperty(this, "_direction", _descriptor3$k, this);

                _initializerDefineProperty(this, "_progress", _descriptor4$j, this);

                this._offset = new Vec3();
                this._dragging = false;
                this._touchHandle = false;
                this._handleLocalPos = new Vec3();
                this._touchPos = new Vec3();
              }

              get handle() {
                return this._handle;
              }

              set handle(value) {
                if (this._handle === value) {
                  return;
                }

                this._handle = value;
              }

              get direction() {
                return this._direction;
              }

              set direction(value) {
                if (this._direction === value) {
                  return;
                }

                this._direction = value;

                this._changeLayout();
              }

              get progress() {
                return this._progress;
              }

              set progress(value) {
                if (this._progress === value) {
                  return;
                }

                this._progress = value;

                this._updateHandlePosition();
              }

              __preload() {
                this._updateHandlePosition();
              }

              onEnable() {
                this._updateHandlePosition();

                this.node.on(NodeEventType.TOUCH_START, this._onTouchBegan, this);
                this.node.on(NodeEventType.TOUCH_MOVE, this._onTouchMoved, this);
                this.node.on(NodeEventType.TOUCH_END, this._onTouchEnded, this);
                this.node.on(NodeEventType.TOUCH_CANCEL, this._onTouchCancelled, this);

                if (this._handle && this._handle.isValid) {
                  this._handle.node.on(NodeEventType.TOUCH_START, this._onHandleDragStart, this);

                  this._handle.node.on(NodeEventType.TOUCH_MOVE, this._onTouchMoved, this);

                  this._handle.node.on(NodeEventType.TOUCH_END, this._onTouchEnded, this);
                }
              }

              onDisable() {
                this.node.off(NodeEventType.TOUCH_START, this._onTouchBegan, this);
                this.node.off(NodeEventType.TOUCH_MOVE, this._onTouchMoved, this);
                this.node.off(NodeEventType.TOUCH_END, this._onTouchEnded, this);
                this.node.off(NodeEventType.TOUCH_CANCEL, this._onTouchCancelled, this);

                if (this._handle && this._handle.isValid) {
                  this._handle.node.off(NodeEventType.TOUCH_START, this._onHandleDragStart, this);

                  this._handle.node.off(NodeEventType.TOUCH_MOVE, this._onTouchMoved, this);

                  this._handle.node.off(NodeEventType.TOUCH_END, this._onTouchEnded, this);
                }
              }

              _onHandleDragStart(event) {
                if (!event || !this._handle || !this._handle.node._uiProps.uiTransformComp) {
                  return;
                }

                this._dragging = true;
                this._touchHandle = true;
                const touhPos = event.touch.getUILocation();
                Vec3.set(this._touchPos, touhPos.x, touhPos.y, 0);

                this._handle.node._uiProps.uiTransformComp.convertToNodeSpaceAR(this._touchPos, this._offset);

                event.propagationStopped = true;
              }

              _onTouchBegan(event) {
                if (!this._handle || !event) {
                  return;
                }

                this._dragging = true;

                if (!this._touchHandle) {
                  this._handleSliderLogic(event.touch);
                }

                event.propagationStopped = true;
              }

              _onTouchMoved(event) {
                if (!this._dragging || !event) {
                  return;
                }

                this._handleSliderLogic(event.touch);

                event.propagationStopped = true;
              }

              _onTouchEnded(event) {
                this._dragging = false;
                this._touchHandle = false;
                this._offset = new Vec3();

                if (event) {
                  event.propagationStopped = true;
                }
              }

              _onTouchCancelled(event) {
                this._dragging = false;

                if (event) {
                  event.propagationStopped = true;
                }
              }

              _handleSliderLogic(touch) {
                this._updateProgress(touch);

                this._emitSlideEvent();
              }

              _emitSlideEvent() {
                EventHandler.emitEvents(this.slideEvents, this);
                this.node.emit('slide', this);
              }

              _updateProgress(touch) {
                if (!this._handle || !touch) {
                  return;
                }

                const touchPos = touch.getUILocation();
                Vec3.set(this._touchPos, touchPos.x, touchPos.y, 0);
                const uiTrans = this.node._uiProps.uiTransformComp;
                const localTouchPos = uiTrans.convertToNodeSpaceAR(this._touchPos, _tempPos);

                if (this.direction === Direction$1.Horizontal) {
                  this.progress = clamp01(0.5 + (localTouchPos.x - this._offset.x) / uiTrans.width);
                } else {
                  this.progress = clamp01(0.5 + (localTouchPos.y - this._offset.y) / uiTrans.height);
                }
              }

              _updateHandlePosition() {
                if (!this._handle) {
                  return;
                }

                this._handleLocalPos.set(this._handle.node.getPosition());

                const uiTrans = this.node._uiProps.uiTransformComp;

                if (this._direction === Direction$1.Horizontal) {
                  this._handleLocalPos.x = -uiTrans.width * uiTrans.anchorX + this.progress * uiTrans.width;
                } else {
                  this._handleLocalPos.y = -uiTrans.height * uiTrans.anchorY + this.progress * uiTrans.height;
                }

                this._handle.node.setPosition(this._handleLocalPos);
              }

              _changeLayout() {
                const uiTrans = this.node._uiProps.uiTransformComp;
                const contentSize = uiTrans.contentSize;
                uiTrans.setContentSize(contentSize.height, contentSize.width);

                if (this._handle) {
                  const pos = this._handle.node.position;

                  if (this._direction === Direction$1.Horizontal) {
                    this._handle.node.setPosition(pos.x, 0, pos.z);
                  } else {
                    this._handle.node.setPosition(0, pos.y, pos.z);
                  }

                  this._updateHandlePosition();
                }
              }

            }, _class3$d.Direction = Direction$1, _temp$w), (_applyDecoratedDescriptor(_class2$t.prototype, "handle", [_dec6$n, _dec7$n], Object.getOwnPropertyDescriptor(_class2$t.prototype, "handle"), _class2$t.prototype), _applyDecoratedDescriptor(_class2$t.prototype, "direction", [_dec8$l, _dec9$i], Object.getOwnPropertyDescriptor(_class2$t.prototype, "direction"), _class2$t.prototype), _applyDecoratedDescriptor(_class2$t.prototype, "progress", [slide, _dec10$h, _dec11$e], Object.getOwnPropertyDescriptor(_class2$t.prototype, "progress"), _class2$t.prototype), _descriptor$s = _applyDecoratedDescriptor(_class2$t.prototype, "slideEvents", [_dec12$e, serializable, _dec13$d], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor2$p = _applyDecoratedDescriptor(_class2$t.prototype, "_handle", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor3$k = _applyDecoratedDescriptor(_class2$t.prototype, "_direction", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Direction$1.Horizontal;
              }
            }), _descriptor4$j = _applyDecoratedDescriptor(_class2$t.prototype, "_progress", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.1;
              }
            })), _class2$t)) || _class$A) || _class$A) || _class$A) || _class$A) || _class$A));

            function extendsEnum(...enums) {

              return Object.assign({}, ...enums);
            }

            var _dec$B, _dec2$w, _dec3$u, _dec4$t, _dec5$r, _dec6$o, _dec7$o, _dec8$m, _dec9$j, _dec10$i, _dec11$f, _dec12$f, _class$B, _class2$u, _descriptor$t, _descriptor2$q, _descriptor3$l, _class3$e, _temp$x;
            var EventType$4;

            (function (EventType) {
              EventType["TOGGLE"] = "toggle";
            })(EventType$4 || (EventType$4 = {}));

            let Toggle = function (v) { return exports({ Toggle: v, ToggleComponent: v }), v; }((_dec$B = ccclass('cc.Toggle'), _dec2$w = help(), _dec3$u = executionOrder(110), _dec4$t = menu$1(), _dec5$r = requireComponent(UITransform), _dec6$o = displayOrder(), _dec7$o = tooltip(), _dec8$m = type$1(Sprite), _dec9$j = displayOrder(), _dec10$i = tooltip(), _dec11$f = type$1([EventHandler]), _dec12$f = tooltip(), _dec$B(_class$B = _dec2$w(_class$B = _dec3$u(_class$B = _dec4$t(_class$B = _dec5$r(_class$B = (_class2$u = (_temp$x = _class3$e = class Toggle extends Button {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "checkEvents", _descriptor$t, this);

                _initializerDefineProperty(this, "_isChecked", _descriptor2$q, this);

                _initializerDefineProperty(this, "_checkMark", _descriptor3$l, this);
              }

              get isChecked() {
                return this._isChecked;
              }

              set isChecked(value) {
                this._set(value);
              }

              get checkMark() {
                return this._checkMark;
              }

              set checkMark(value) {
                if (this._checkMark === value) {
                  return;
                }

                this._checkMark = value;
              }

              set _resizeToTarget(value) {
                if (value) {
                  this._resizeNodeToTargetNode();
                }
              }

              get _toggleContainer() {
                const parent = this.node.parent;

                if (legacyCC.Node.isNode(parent)) {
                  return parent.getComponent('cc.ToggleContainer');
                }

                return null;
              }

              _internalToggle() {
                this.isChecked = !this.isChecked;
              }

              _set(value, emitEvent = true) {
                if (this._isChecked == value) return;
                this._isChecked = value;
                const group = this._toggleContainer;

                if (group && group.enabled && this.enabled) {
                  if (value || !group.anyTogglesChecked() && !group.allowSwitchOff) {
                    this._isChecked = true;
                    group.notifyToggleCheck(this, emitEvent);
                  }
                }

                this.playEffect();

                if (emitEvent) {
                  this._emitToggleEvents();
                }
              }

              playEffect() {
                if (this._checkMark) {
                  this._checkMark.node.active = this._isChecked;
                }
              }

              setIsCheckedWithoutNotify(value) {
                this._set(value, false);
              }

              onEnable() {
                super.onEnable();
                this.playEffect();

                {
                  this.node.on(Toggle.EventType.CLICK, this._internalToggle, this);
                }
              }

              onDisable() {
                super.onDisable();

                {
                  this.node.off(Toggle.EventType.CLICK, this._internalToggle, this);
                }
              }

              OnDestroy() {
                const group = this._toggleContainer;

                if (group) {
                  group.ensureValidState();
                }
              }

              _emitToggleEvents() {
                this.node.emit(Toggle.EventType.TOGGLE, this);

                if (this.checkEvents) {
                  EventHandler.emitEvents(this.checkEvents, this);
                }
              }

            }, _class3$e.EventType = extendsEnum(EventType$4, EventType$1), _temp$x), (_applyDecoratedDescriptor(_class2$u.prototype, "isChecked", [_dec6$o, _dec7$o], Object.getOwnPropertyDescriptor(_class2$u.prototype, "isChecked"), _class2$u.prototype), _applyDecoratedDescriptor(_class2$u.prototype, "checkMark", [_dec8$m, _dec9$j, _dec10$i], Object.getOwnPropertyDescriptor(_class2$u.prototype, "checkMark"), _class2$u.prototype), _descriptor$t = _applyDecoratedDescriptor(_class2$u.prototype, "checkEvents", [_dec11$f, serializable, _dec12$f], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor2$q = _applyDecoratedDescriptor(_class2$u.prototype, "_isChecked", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _descriptor3$l = _applyDecoratedDescriptor(_class2$u.prototype, "_checkMark", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            })), _class2$u)) || _class$B) || _class$B) || _class$B) || _class$B) || _class$B));

            var _dec$C, _dec2$x, _dec3$v, _dec4$u, _dec5$s, _dec6$p, _dec7$p, _class$C, _class2$v, _descriptor$u, _descriptor2$r, _temp$y;
            let ToggleContainer = function (v) { return exports({ ToggleContainer: v, ToggleContainerComponent: v }), v; }((_dec$C = ccclass('cc.ToggleContainer'), _dec2$x = help(), _dec3$v = executionOrder(110), _dec4$u = menu$1(), _dec5$s = tooltip(), _dec6$p = type$1([EventHandler]), _dec7$p = tooltip(), _dec$C(_class$C = _dec2$x(_class$C = _dec3$v(_class$C = _dec4$u(_class$C = executeInEditMode(_class$C = (_class2$v = (_temp$y = class ToggleContainer extends Component {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "_allowSwitchOff", _descriptor$u, this);

                _initializerDefineProperty(this, "checkEvents", _descriptor2$r, this);
              }

              get allowSwitchOff() {
                return this._allowSwitchOff;
              }

              set allowSwitchOff(value) {
                this._allowSwitchOff = value;
              }

              get toggleItems() {
                return this.node.children.map(item => {
                  const toggle = item.getComponent('cc.Toggle');

                  if (toggle && toggle.enabled) {
                    return toggle;
                  }

                  return null;
                }).filter(Boolean);
              }

              onEnable() {
                this.ensureValidState();
                this.node.on(NodeEventType.CHILD_ADDED, this.ensureValidState, this);
                this.node.on(NodeEventType.CHILD_REMOVED, this.ensureValidState, this);
              }

              onDisable() {
                this.node.off(NodeEventType.CHILD_ADDED, this.ensureValidState, this);
                this.node.off(NodeEventType.CHILD_REMOVED, this.ensureValidState, this);
              }

              activeToggles() {
                return this.toggleItems.filter(x => x.isChecked);
              }

              anyTogglesChecked() {
                return !!this.toggleItems.find(x => x.isChecked);
              }

              notifyToggleCheck(toggle, emitEvent = true) {
                if (!this.enabledInHierarchy) {
                  return;
                }

                for (let i = 0; i < this.toggleItems.length; i++) {
                  const item = this.toggleItems[i];

                  if (item === toggle) {
                    continue;
                  }

                  if (emitEvent) {
                    item.isChecked = false;
                  } else {
                    item.setIsCheckedWithoutNotify(false);
                  }
                }

                if (this.checkEvents) {
                  legacyCC.Component.EventHandler.emitEvents(this.checkEvents, toggle);
                }
              }

              ensureValidState() {
                const toggles = this.toggleItems;

                if (!this._allowSwitchOff && !this.anyTogglesChecked() && toggles.length !== 0) {
                  const toggle = toggles[0];
                  toggle.isChecked = true;
                  this.notifyToggleCheck(toggle);
                }

                const activeToggles = this.activeToggles();

                if (activeToggles.length > 1) {
                  const firstToggle = activeToggles[0];

                  for (let i = 0; i < activeToggles.length; ++i) {
                    const toggle = activeToggles[i];

                    if (toggle === firstToggle) {
                      continue;
                    }

                    toggle.isChecked = false;
                  }
                }
              }

            }, _temp$y), (_descriptor$u = _applyDecoratedDescriptor(_class2$v.prototype, "_allowSwitchOff", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _applyDecoratedDescriptor(_class2$v.prototype, "allowSwitchOff", [_dec5$s], Object.getOwnPropertyDescriptor(_class2$v.prototype, "allowSwitchOff"), _class2$v.prototype), _descriptor2$r = _applyDecoratedDescriptor(_class2$v.prototype, "checkEvents", [_dec6$p, serializable, _dec7$p], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            })), _class2$v)) || _class$C) || _class$C) || _class$C) || _class$C) || _class$C));

            var _dec$D, _dec2$y, _dec3$w, _dec4$v, _dec5$t, _dec6$q, _dec7$q, _dec8$n, _dec9$k, _dec10$j, _dec11$g, _dec12$g, _dec13$e, _dec14$a, _dec15$a, _dec16$9, _dec17$7, _dec18$7, _dec19$7, _dec20$6, _dec21$6, _dec22$6, _dec23$6, _class$D, _class2$w, _descriptor$v, _descriptor2$s, _descriptor3$m, _descriptor4$k, _descriptor5$h, _descriptor6$c, _descriptor7$a, _descriptor8$a, _descriptor9$9, _descriptor10$8, _descriptor11$7, _descriptor12$5, _descriptor13$4, _descriptor14$3, _descriptor15$2, _descriptor16$2, _descriptor17$1, _descriptor18, _class3$f, _temp$z;

            const _tempScale = new Vec2();

            function getReadonlyNodeSize(parent) {
              if (parent instanceof Scene) {

                return visibleRect;
              } else if (parent._uiProps.uiTransformComp) {
                return parent._uiProps.uiTransformComp.contentSize;
              } else {
                return Size$1.ZERO;
              }
            }
            function computeInverseTransForTarget(widgetNode, target, out_inverseTranslate, out_inverseScale) {
              if (widgetNode.parent) {
                _tempScale.set(widgetNode.parent.getScale().x, widgetNode.parent.getScale().y);
              } else {
                _tempScale.set(0, 0);
              }

              let scaleX = _tempScale.x;
              let scaleY = _tempScale.y;
              let translateX = 0;
              let translateY = 0;

              for (let node = widgetNode.parent;;) {
                if (!node) {
                  out_inverseTranslate.x = out_inverseTranslate.y = 0;
                  out_inverseScale.x = out_inverseScale.y = 1;
                  return;
                }

                const pos = node.getPosition();
                translateX += pos.x;
                translateY += pos.y;
                node = node.parent;

                if (node !== target) {
                  if (node) {
                    _tempScale.set(node.getScale().x, node.getScale().y);
                  } else {
                    _tempScale.set(0, 0);
                  }

                  const sx = _tempScale.x;
                  const sy = _tempScale.y;
                  translateX *= sx;
                  translateY *= sy;
                  scaleX *= sx;
                  scaleY *= sy;
                } else {
                  break;
                }
              }

              out_inverseScale.x = scaleX !== 0 ? 1 / scaleX : 1;
              out_inverseScale.y = scaleY !== 0 ? 1 / scaleY : 1;
              out_inverseTranslate.x = -translateX;
              out_inverseTranslate.y = -translateY;
            }
            let AlignMode;

            (function (AlignMode) {
              AlignMode[AlignMode["ONCE"] = 0] = "ONCE";
              AlignMode[AlignMode["ALWAYS"] = 1] = "ALWAYS";
              AlignMode[AlignMode["ON_WINDOW_RESIZE"] = 2] = "ON_WINDOW_RESIZE";
            })(AlignMode || (AlignMode = {}));

            ccenum(AlignMode);
            let AlignFlags;

            (function (AlignFlags) {
              AlignFlags[AlignFlags["TOP"] = 1] = "TOP";
              AlignFlags[AlignFlags["MID"] = 2] = "MID";
              AlignFlags[AlignFlags["BOT"] = 4] = "BOT";
              AlignFlags[AlignFlags["LEFT"] = 8] = "LEFT";
              AlignFlags[AlignFlags["CENTER"] = 16] = "CENTER";
              AlignFlags[AlignFlags["RIGHT"] = 32] = "RIGHT";
              AlignFlags[AlignFlags["HORIZONTAL"] = 56] = "HORIZONTAL";
              AlignFlags[AlignFlags["VERTICAL"] = 7] = "VERTICAL";
            })(AlignFlags || (AlignFlags = {}));

            const TOP_BOT = AlignFlags.TOP | AlignFlags.BOT;
            const LEFT_RIGHT = AlignFlags.LEFT | AlignFlags.RIGHT;
            let Widget = function (v) { return exports({ Widget: v, WidgetComponent: v }), v; }((_dec$D = ccclass('cc.Widget'), _dec2$y = help(), _dec3$w = executionOrder(110), _dec4$v = menu$1(), _dec5$t = requireComponent(UITransform), _dec6$q = type$1(Node), _dec7$q = tooltip(), _dec8$n = tooltip(), _dec9$k = tooltip(), _dec10$j = tooltip(), _dec11$g = tooltip(), _dec12$g = tooltip(), _dec13$e = tooltip(), _dec14$a = visible(), _dec15$a = visible(), _dec16$9 = tooltip(), _dec17$7 = tooltip(), _dec18$7 = tooltip(), _dec19$7 = tooltip(), _dec20$6 = tooltip(), _dec21$6 = tooltip(), _dec22$6 = type$1(AlignMode), _dec23$6 = tooltip(), _dec$D(_class$D = _dec2$y(_class$D = _dec3$w(_class$D = _dec4$v(_class$D = _dec5$t(_class$D = executeInEditMode(_class$D = (_class2$w = (_temp$z = _class3$f = class Widget extends Component {
              constructor(...args) {
                super(...args);
                this._lastPos = new Vec3();
                this._lastSize = new Size$1();
                this._dirty = true;
                this._hadAlignOnce = false;

                _initializerDefineProperty(this, "_alignFlags", _descriptor$v, this);

                _initializerDefineProperty(this, "_target", _descriptor2$s, this);

                _initializerDefineProperty(this, "_left", _descriptor3$m, this);

                _initializerDefineProperty(this, "_right", _descriptor4$k, this);

                _initializerDefineProperty(this, "_top", _descriptor5$h, this);

                _initializerDefineProperty(this, "_bottom", _descriptor6$c, this);

                _initializerDefineProperty(this, "_horizontalCenter", _descriptor7$a, this);

                _initializerDefineProperty(this, "_verticalCenter", _descriptor8$a, this);

                _initializerDefineProperty(this, "_isAbsLeft", _descriptor9$9, this);

                _initializerDefineProperty(this, "_isAbsRight", _descriptor10$8, this);

                _initializerDefineProperty(this, "_isAbsTop", _descriptor11$7, this);

                _initializerDefineProperty(this, "_isAbsBottom", _descriptor12$5, this);

                _initializerDefineProperty(this, "_isAbsHorizontalCenter", _descriptor13$4, this);

                _initializerDefineProperty(this, "_isAbsVerticalCenter", _descriptor14$3, this);

                _initializerDefineProperty(this, "_originalWidth", _descriptor15$2, this);

                _initializerDefineProperty(this, "_originalHeight", _descriptor16$2, this);

                _initializerDefineProperty(this, "_alignMode", _descriptor17$1, this);

                _initializerDefineProperty(this, "_lockFlags", _descriptor18, this);
              }

              get target() {
                return this._target;
              }

              set target(value) {
                if (this._target === value) {
                  return;
                }

                this._unregisterTargetEvents();

                this._target = value;

                this._registerTargetEvents();

                this._validateTargetInDEV();

                this._recursiveDirty();
              }

              get isAlignTop() {
                return (this._alignFlags & AlignFlags.TOP) > 0;
              }

              set isAlignTop(value) {
                this._setAlign(AlignFlags.TOP, value);

                this._recursiveDirty();
              }

              get isAlignBottom() {
                return (this._alignFlags & AlignFlags.BOT) > 0;
              }

              set isAlignBottom(value) {
                this._setAlign(AlignFlags.BOT, value);

                this._recursiveDirty();
              }

              get isAlignLeft() {
                return (this._alignFlags & AlignFlags.LEFT) > 0;
              }

              set isAlignLeft(value) {
                this._setAlign(AlignFlags.LEFT, value);

                this._recursiveDirty();
              }

              get isAlignRight() {
                return (this._alignFlags & AlignFlags.RIGHT) > 0;
              }

              set isAlignRight(value) {
                this._setAlign(AlignFlags.RIGHT, value);

                this._recursiveDirty();
              }

              get isAlignVerticalCenter() {
                return (this._alignFlags & AlignFlags.MID) > 0;
              }

              set isAlignVerticalCenter(value) {
                if (value) {
                  this.isAlignTop = false;
                  this.isAlignBottom = false;
                  this._alignFlags |= AlignFlags.MID;
                } else {
                  this._alignFlags &= ~AlignFlags.MID;
                }

                this._recursiveDirty();
              }

              get isAlignHorizontalCenter() {
                return (this._alignFlags & AlignFlags.CENTER) > 0;
              }

              set isAlignHorizontalCenter(value) {
                if (value) {
                  this.isAlignLeft = false;
                  this.isAlignRight = false;
                  this._alignFlags |= AlignFlags.CENTER;
                } else {
                  this._alignFlags &= ~AlignFlags.CENTER;
                }

                this._recursiveDirty();
              }

              get isStretchWidth() {
                return (this._alignFlags & LEFT_RIGHT) === LEFT_RIGHT;
              }

              get isStretchHeight() {
                return (this._alignFlags & TOP_BOT) === TOP_BOT;
              }

              get top() {
                return this._top;
              }

              set top(value) {
                this._top = value;

                this._recursiveDirty();
              }

              get editorTop() {
                return this._isAbsTop ? this._top : this._top * 100;
              }

              set editorTop(value) {
                this._top = this._isAbsTop ? value : value / 100;

                this._recursiveDirty();
              }

              get bottom() {
                return this._bottom;
              }

              set bottom(value) {
                this._bottom = value;

                this._recursiveDirty();
              }

              get editorBottom() {
                return this._isAbsBottom ? this._bottom : this._bottom * 100;
              }

              set editorBottom(value) {
                this._bottom = this._isAbsBottom ? value : value / 100;

                this._recursiveDirty();
              }

              get left() {
                return this._left;
              }

              set left(value) {
                this._left = value;

                this._recursiveDirty();
              }

              get editorLeft() {
                return this._isAbsLeft ? this._left : this._left * 100;
              }

              set editorLeft(value) {
                this._left = this._isAbsLeft ? value : value / 100;

                this._recursiveDirty();
              }

              get right() {
                return this._right;
              }

              set right(value) {
                this._right = value;

                this._recursiveDirty();
              }

              get editorRight() {
                return this._isAbsRight ? this._right : this._right * 100;
              }

              set editorRight(value) {
                this._right = this._isAbsRight ? value : value / 100;

                this._recursiveDirty();
              }

              get horizontalCenter() {
                return this._horizontalCenter;
              }

              set horizontalCenter(value) {
                this._horizontalCenter = value;

                this._recursiveDirty();
              }

              get editorHorizontalCenter() {
                return this._isAbsHorizontalCenter ? this._horizontalCenter : this._horizontalCenter * 100;
              }

              set editorHorizontalCenter(value) {
                this._horizontalCenter = this._isAbsHorizontalCenter ? value : value / 100;

                this._recursiveDirty();
              }

              get verticalCenter() {
                return this._verticalCenter;
              }

              set verticalCenter(value) {
                this._verticalCenter = value;

                this._recursiveDirty();
              }

              get editorVerticalCenter() {
                return this._isAbsVerticalCenter ? this._verticalCenter : this._verticalCenter * 100;
              }

              set editorVerticalCenter(value) {
                this._verticalCenter = this._isAbsVerticalCenter ? value : value / 100;

                this._recursiveDirty();
              }

              get isAbsoluteTop() {
                return this._isAbsTop;
              }

              set isAbsoluteTop(value) {
                if (this._isAbsTop === value) {
                  return;
                }

                this._isAbsTop = value;

                this._autoChangedValue(AlignFlags.TOP, this._isAbsTop);
              }

              get isAbsoluteBottom() {
                return this._isAbsBottom;
              }

              set isAbsoluteBottom(value) {
                if (this._isAbsBottom === value) {
                  return;
                }

                this._isAbsBottom = value;

                this._autoChangedValue(AlignFlags.BOT, this._isAbsBottom);
              }

              get isAbsoluteLeft() {
                return this._isAbsLeft;
              }

              set isAbsoluteLeft(value) {
                if (this._isAbsLeft === value) {
                  return;
                }

                this._isAbsLeft = value;

                this._autoChangedValue(AlignFlags.LEFT, this._isAbsLeft);
              }

              get isAbsoluteRight() {
                return this._isAbsRight;
              }

              set isAbsoluteRight(value) {
                if (this._isAbsRight === value) {
                  return;
                }

                this._isAbsRight = value;

                this._autoChangedValue(AlignFlags.RIGHT, this._isAbsRight);
              }

              get isAbsoluteHorizontalCenter() {
                return this._isAbsHorizontalCenter;
              }

              set isAbsoluteHorizontalCenter(value) {
                if (this._isAbsHorizontalCenter === value) {
                  return;
                }

                this._isAbsHorizontalCenter = value;

                this._autoChangedValue(AlignFlags.CENTER, this._isAbsHorizontalCenter);
              }

              get isAbsoluteVerticalCenter() {
                return this._isAbsVerticalCenter;
              }

              set isAbsoluteVerticalCenter(value) {
                if (this._isAbsVerticalCenter === value) {
                  return;
                }

                this._isAbsVerticalCenter = value;

                this._autoChangedValue(AlignFlags.MID, this._isAbsVerticalCenter);
              }

              get alignMode() {
                return this._alignMode;
              }

              set alignMode(value) {
                this._alignMode = value;

                this._recursiveDirty();
              }

              get alignFlags() {
                return this._alignFlags;
              }

              set alignFlags(value) {
                if (this._alignFlags === value) {
                  return;
                }

                this._alignFlags = value;

                this._recursiveDirty();
              }

              updateAlignment() {
                legacyCC._widgetManager.updateAlignment(this.node);
              }

              _validateTargetInDEV() {
                {
                  return;
                }
              }

              setDirty() {
                this._recursiveDirty();
              }

              onEnable() {
                this.node.getPosition(this._lastPos);

                this._lastSize.set(this.node._uiProps.uiTransformComp.contentSize);

                legacyCC._widgetManager.add(this);

                this._hadAlignOnce = false;

                this._registerEvent();

                this._registerTargetEvents();
              }

              onDisable() {
                legacyCC._widgetManager.remove(this);

                this._unregisterEvent();

                this._unregisterTargetEvents();
              }

              onDestroy() {
                this._removeParentEvent();
              }

              _adjustWidgetToAllowMovingInEditor(eventType) {}

              _adjustWidgetToAllowResizingInEditor() {}

              _adjustWidgetToAnchorChanged() {
                this.setDirty();
              }

              _adjustTargetToParentChanged(oldParent) {
                if (oldParent) {
                  this._unregisterOldParentEvents(oldParent);
                }

                if (this.node.getParent()) {
                  this._registerTargetEvents();
                }

                this._setDirtyByMode();
              }

              _registerEvent() {
                {
                  this.node.on(NodeEventType.TRANSFORM_CHANGED, this._setDirtyByMode, this);
                  this.node.on(NodeEventType.SIZE_CHANGED, this._setDirtyByMode, this);
                }

                this.node.on(NodeEventType.ANCHOR_CHANGED, this._adjustWidgetToAnchorChanged, this);
                this.node.on(NodeEventType.PARENT_CHANGED, this._adjustTargetToParentChanged, this);
              }

              _unregisterEvent() {
                {
                  this.node.off(NodeEventType.TRANSFORM_CHANGED, this._setDirtyByMode, this);
                  this.node.off(NodeEventType.SIZE_CHANGED, this._setDirtyByMode, this);
                }

                this.node.off(NodeEventType.ANCHOR_CHANGED, this._adjustWidgetToAnchorChanged, this);
              }

              _removeParentEvent() {
                this.node.off(NodeEventType.PARENT_CHANGED, this._adjustTargetToParentChanged, this);
              }

              _autoChangedValue(flag, isAbs) {
                const current = (this._alignFlags & flag) > 0;

                if (!current) {
                  return;
                }

                const parentUiProps = this.node.parent && this.node.parent._uiProps;
                const parentTrans = parentUiProps && parentUiProps.uiTransformComp;
                const size = parentTrans ? parentTrans.contentSize : visibleRect;

                if (this.isAlignLeft && flag === AlignFlags.LEFT) {
                  this._left = isAbs ? this._left * size.width : this._left / size.width;
                } else if (this.isAlignRight && flag === AlignFlags.RIGHT) {
                  this._right = isAbs ? this._right * size.width : this._right / size.width;
                } else if (this.isAlignHorizontalCenter && flag === AlignFlags.CENTER) {
                  this._horizontalCenter = isAbs ? this._horizontalCenter * size.width : this._horizontalCenter / size.width;
                } else if (this.isAlignTop && flag === AlignFlags.TOP) {
                  this._top = isAbs ? this._top * size.height : this._top / size.height;
                } else if (this.isAlignBottom && flag === AlignFlags.BOT) {
                  this._bottom = isAbs ? this._bottom * size.height : this._bottom / size.height;
                } else if (this.isAbsoluteVerticalCenter && flag === AlignFlags.MID) {
                  this._verticalCenter = isAbs ? this._verticalCenter / size.height : this._verticalCenter / size.height;
                }

                this._recursiveDirty();
              }

              _registerTargetEvents() {
                const target = this._target || this.node.parent;

                if (target) {
                  if (target.getComponent(UITransform)) {
                    target.on(NodeEventType.TRANSFORM_CHANGED, this._setDirtyByMode, this);
                    target.on(NodeEventType.SIZE_CHANGED, this._setDirtyByMode, this);
                    target.on(NodeEventType.ANCHOR_CHANGED, this._setDirtyByMode, this);
                  }
                }
              }

              _unregisterTargetEvents() {
                const target = this._target || this.node.parent;

                if (target) {
                  target.off(NodeEventType.TRANSFORM_CHANGED, this._setDirtyByMode, this);
                  target.off(NodeEventType.SIZE_CHANGED, this._setDirtyByMode, this);
                  target.off(NodeEventType.ANCHOR_CHANGED, this._setDirtyByMode, this);
                }
              }

              _unregisterOldParentEvents(oldParent) {
                const target = this._target || oldParent;

                if (target) {
                  target.off(NodeEventType.TRANSFORM_CHANGED, this._setDirtyByMode, this);
                  target.off(NodeEventType.SIZE_CHANGED, this._setDirtyByMode, this);
                }
              }

              _setDirtyByMode() {
                if (this.alignMode === AlignMode.ALWAYS || EDITOR) {
                  this._recursiveDirty();
                }
              }

              _setAlign(flag, isAlign) {
                const current = (this._alignFlags & flag) > 0;

                if (isAlign === current) {
                  return;
                }

                const isHorizontal = (flag & LEFT_RIGHT) > 0;
                const trans = this.node._uiProps.uiTransformComp;

                if (isAlign) {
                  this._alignFlags |= flag;

                  if (isHorizontal) {
                    this.isAlignHorizontalCenter = false;

                    if (this.isStretchWidth) {
                      this._originalWidth = trans.width;
                    }
                  } else {
                    this.isAlignVerticalCenter = false;

                    if (this.isStretchHeight) {
                      this._originalHeight = trans.height;
                    }
                  }
                } else {
                  if (isHorizontal) {
                    if (this.isStretchWidth) {
                      trans.width = this._originalWidth;
                    }
                  } else if (this.isStretchHeight) {
                    trans.height = this._originalHeight;
                  }

                  this._alignFlags &= ~flag;
                }
              }

              _recursiveDirty() {
                if (this._dirty) {
                  return;
                }

                this._dirty = true;
              }

            }, _class3$f.AlignMode = AlignMode, _temp$z), (_applyDecoratedDescriptor(_class2$w.prototype, "target", [_dec6$q, _dec7$q], Object.getOwnPropertyDescriptor(_class2$w.prototype, "target"), _class2$w.prototype), _applyDecoratedDescriptor(_class2$w.prototype, "isAlignTop", [_dec8$n], Object.getOwnPropertyDescriptor(_class2$w.prototype, "isAlignTop"), _class2$w.prototype), _applyDecoratedDescriptor(_class2$w.prototype, "isAlignBottom", [_dec9$k], Object.getOwnPropertyDescriptor(_class2$w.prototype, "isAlignBottom"), _class2$w.prototype), _applyDecoratedDescriptor(_class2$w.prototype, "isAlignLeft", [_dec10$j], Object.getOwnPropertyDescriptor(_class2$w.prototype, "isAlignLeft"), _class2$w.prototype), _applyDecoratedDescriptor(_class2$w.prototype, "isAlignRight", [_dec11$g], Object.getOwnPropertyDescriptor(_class2$w.prototype, "isAlignRight"), _class2$w.prototype), _applyDecoratedDescriptor(_class2$w.prototype, "isAlignVerticalCenter", [_dec12$g], Object.getOwnPropertyDescriptor(_class2$w.prototype, "isAlignVerticalCenter"), _class2$w.prototype), _applyDecoratedDescriptor(_class2$w.prototype, "isAlignHorizontalCenter", [_dec13$e], Object.getOwnPropertyDescriptor(_class2$w.prototype, "isAlignHorizontalCenter"), _class2$w.prototype), _applyDecoratedDescriptor(_class2$w.prototype, "isStretchWidth", [_dec14$a], Object.getOwnPropertyDescriptor(_class2$w.prototype, "isStretchWidth"), _class2$w.prototype), _applyDecoratedDescriptor(_class2$w.prototype, "isStretchHeight", [_dec15$a], Object.getOwnPropertyDescriptor(_class2$w.prototype, "isStretchHeight"), _class2$w.prototype), _applyDecoratedDescriptor(_class2$w.prototype, "top", [_dec16$9], Object.getOwnPropertyDescriptor(_class2$w.prototype, "top"), _class2$w.prototype), _applyDecoratedDescriptor(_class2$w.prototype, "editorTop", [editable], Object.getOwnPropertyDescriptor(_class2$w.prototype, "editorTop"), _class2$w.prototype), _applyDecoratedDescriptor(_class2$w.prototype, "bottom", [_dec17$7], Object.getOwnPropertyDescriptor(_class2$w.prototype, "bottom"), _class2$w.prototype), _applyDecoratedDescriptor(_class2$w.prototype, "editorBottom", [editable], Object.getOwnPropertyDescriptor(_class2$w.prototype, "editorBottom"), _class2$w.prototype), _applyDecoratedDescriptor(_class2$w.prototype, "left", [_dec18$7], Object.getOwnPropertyDescriptor(_class2$w.prototype, "left"), _class2$w.prototype), _applyDecoratedDescriptor(_class2$w.prototype, "editorLeft", [editable], Object.getOwnPropertyDescriptor(_class2$w.prototype, "editorLeft"), _class2$w.prototype), _applyDecoratedDescriptor(_class2$w.prototype, "right", [_dec19$7], Object.getOwnPropertyDescriptor(_class2$w.prototype, "right"), _class2$w.prototype), _applyDecoratedDescriptor(_class2$w.prototype, "editorRight", [editable], Object.getOwnPropertyDescriptor(_class2$w.prototype, "editorRight"), _class2$w.prototype), _applyDecoratedDescriptor(_class2$w.prototype, "horizontalCenter", [_dec20$6], Object.getOwnPropertyDescriptor(_class2$w.prototype, "horizontalCenter"), _class2$w.prototype), _applyDecoratedDescriptor(_class2$w.prototype, "editorHorizontalCenter", [editable], Object.getOwnPropertyDescriptor(_class2$w.prototype, "editorHorizontalCenter"), _class2$w.prototype), _applyDecoratedDescriptor(_class2$w.prototype, "verticalCenter", [_dec21$6], Object.getOwnPropertyDescriptor(_class2$w.prototype, "verticalCenter"), _class2$w.prototype), _applyDecoratedDescriptor(_class2$w.prototype, "editorVerticalCenter", [editable], Object.getOwnPropertyDescriptor(_class2$w.prototype, "editorVerticalCenter"), _class2$w.prototype), _applyDecoratedDescriptor(_class2$w.prototype, "isAbsoluteTop", [editable], Object.getOwnPropertyDescriptor(_class2$w.prototype, "isAbsoluteTop"), _class2$w.prototype), _applyDecoratedDescriptor(_class2$w.prototype, "isAbsoluteBottom", [editable], Object.getOwnPropertyDescriptor(_class2$w.prototype, "isAbsoluteBottom"), _class2$w.prototype), _applyDecoratedDescriptor(_class2$w.prototype, "isAbsoluteLeft", [editable], Object.getOwnPropertyDescriptor(_class2$w.prototype, "isAbsoluteLeft"), _class2$w.prototype), _applyDecoratedDescriptor(_class2$w.prototype, "isAbsoluteRight", [editable], Object.getOwnPropertyDescriptor(_class2$w.prototype, "isAbsoluteRight"), _class2$w.prototype), _applyDecoratedDescriptor(_class2$w.prototype, "isAbsoluteHorizontalCenter", [editable], Object.getOwnPropertyDescriptor(_class2$w.prototype, "isAbsoluteHorizontalCenter"), _class2$w.prototype), _applyDecoratedDescriptor(_class2$w.prototype, "isAbsoluteVerticalCenter", [editable], Object.getOwnPropertyDescriptor(_class2$w.prototype, "isAbsoluteVerticalCenter"), _class2$w.prototype), _applyDecoratedDescriptor(_class2$w.prototype, "alignMode", [_dec22$6, _dec23$6], Object.getOwnPropertyDescriptor(_class2$w.prototype, "alignMode"), _class2$w.prototype), _applyDecoratedDescriptor(_class2$w.prototype, "alignFlags", [editable], Object.getOwnPropertyDescriptor(_class2$w.prototype, "alignFlags"), _class2$w.prototype), _descriptor$v = _applyDecoratedDescriptor(_class2$w.prototype, "_alignFlags", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor2$s = _applyDecoratedDescriptor(_class2$w.prototype, "_target", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor3$m = _applyDecoratedDescriptor(_class2$w.prototype, "_left", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor4$k = _applyDecoratedDescriptor(_class2$w.prototype, "_right", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor5$h = _applyDecoratedDescriptor(_class2$w.prototype, "_top", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor6$c = _applyDecoratedDescriptor(_class2$w.prototype, "_bottom", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor7$a = _applyDecoratedDescriptor(_class2$w.prototype, "_horizontalCenter", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor8$a = _applyDecoratedDescriptor(_class2$w.prototype, "_verticalCenter", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor9$9 = _applyDecoratedDescriptor(_class2$w.prototype, "_isAbsLeft", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _descriptor10$8 = _applyDecoratedDescriptor(_class2$w.prototype, "_isAbsRight", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _descriptor11$7 = _applyDecoratedDescriptor(_class2$w.prototype, "_isAbsTop", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _descriptor12$5 = _applyDecoratedDescriptor(_class2$w.prototype, "_isAbsBottom", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _descriptor13$4 = _applyDecoratedDescriptor(_class2$w.prototype, "_isAbsHorizontalCenter", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _descriptor14$3 = _applyDecoratedDescriptor(_class2$w.prototype, "_isAbsVerticalCenter", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _descriptor15$2 = _applyDecoratedDescriptor(_class2$w.prototype, "_originalWidth", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor16$2 = _applyDecoratedDescriptor(_class2$w.prototype, "_originalHeight", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor17$1 = _applyDecoratedDescriptor(_class2$w.prototype, "_alignMode", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return AlignMode.ON_WINDOW_RESIZE;
              }
            }), _descriptor18 = _applyDecoratedDescriptor(_class2$w.prototype, "_lockFlags", [serializable, editorOnly], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            })), _class2$w)) || _class$D) || _class$D) || _class$D) || _class$D) || _class$D) || _class$D));
            legacyCC.internal.computeInverseTransForTarget = computeInverseTransForTarget;
            legacyCC.internal.getReadonlyNodeSize = getReadonlyNodeSize;

            var _dec$E, _dec2$z, _dec3$x, _dec4$w, _dec5$u, _dec6$r, _dec7$r, _dec8$o, _dec9$l, _dec10$k, _dec11$h, _class$E, _class2$x, _descriptor$w, _descriptor2$t, _descriptor3$n, _descriptor4$l, _class3$g, _temp$A;

            const _color$1 = new Color$1();

            var Direction$2;

            (function (Direction) {
              Direction[Direction["HORIZONTAL"] = 0] = "HORIZONTAL";
              Direction[Direction["VERTICAL"] = 1] = "VERTICAL";
            })(Direction$2 || (Direction$2 = {}));

            ccenum(Direction$2);
            let PageViewIndicator = function (v) { return exports({ PageViewIndicator: v, PageViewIndicatorComponent: v }), v; }((_dec$E = ccclass('cc.PageViewIndicator'), _dec2$z = help(), _dec3$x = executionOrder(110), _dec4$w = menu$1(), _dec5$u = type$1(SpriteFrame), _dec6$r = tooltip(), _dec7$r = type$1(Direction$2), _dec8$o = tooltip(), _dec9$l = type$1(Size$1), _dec10$k = tooltip(), _dec11$h = tooltip(), _dec$E(_class$E = _dec2$z(_class$E = _dec3$x(_class$E = _dec4$w(_class$E = (_class2$x = (_temp$A = _class3$g = class PageViewIndicator extends Component {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "spacing", _descriptor$w, this);

                _initializerDefineProperty(this, "_spriteFrame", _descriptor2$t, this);

                _initializerDefineProperty(this, "_direction", _descriptor3$n, this);

                _initializerDefineProperty(this, "_cellSize", _descriptor4$l, this);

                this._layout = null;
                this._pageView = null;
                this._indicators = [];
              }

              get spriteFrame() {
                return this._spriteFrame;
              }

              set spriteFrame(value) {
                if (this._spriteFrame === value) {
                  return;
                }

                this._spriteFrame = value;
              }

              get direction() {
                return this._direction;
              }

              set direction(value) {
                if (this._direction === value) {
                  return;
                }

                this._direction = value;
              }

              get cellSize() {
                return this._cellSize;
              }

              set cellSize(value) {
                if (this._cellSize === value) {
                  return;
                }

                this._cellSize = value;
              }

              onLoad() {
                this._updateLayout();
              }

              setPageView(target) {
                this._pageView = target;

                this._refresh();
              }

              _updateLayout() {
                this._layout = this.getComponent(Layout);

                if (!this._layout) {
                  this._layout = this.addComponent(Layout);
                }

                const layout = this._layout;

                if (this.direction === Direction$2.HORIZONTAL) {
                  layout.type = Layout.Type.HORIZONTAL;
                  layout.spacingX = this.spacing;
                } else if (this.direction === Direction$2.VERTICAL) {
                  layout.type = Layout.Type.VERTICAL;
                  layout.spacingY = this.spacing;
                }

                layout.resizeMode = Layout.ResizeMode.CONTAINER;
              }

              _createIndicator() {
                const node = new Node();
                node.layer = this.node.layer;
                const sprite = node.addComponent(Sprite);
                sprite.spriteFrame = this.spriteFrame;
                sprite.sizeMode = Sprite.SizeMode.CUSTOM;
                node.parent = this.node;

                node._uiProps.uiTransformComp.setContentSize(this._cellSize);

                return node;
              }

              _changedState() {
                const indicators = this._indicators;

                if (indicators.length === 0 || !this._pageView) {
                  return;
                }

                const idx = this._pageView.curPageIdx;

                if (idx >= indicators.length) {
                  return;
                }

                for (let i = 0; i < indicators.length; ++i) {
                  const node = indicators[i];

                  if (!node._uiProps.uiComp) {
                    continue;
                  }

                  const uiComp = node._uiProps.uiComp;

                  _color$1.set(uiComp.color);

                  _color$1.a = 255 / 2;
                  uiComp.color = _color$1;
                }

                if (indicators[idx]._uiProps.uiComp) {
                  const comp = indicators[idx]._uiProps.uiComp;

                  _color$1.set(comp.color);

                  _color$1.a = 255;
                  comp.color = _color$1;
                }
              }

              _refresh() {
                if (!this._pageView) {
                  return;
                }

                const indicators = this._indicators;

                const pages = this._pageView.getPages();

                if (pages.length === indicators.length) {
                  return;
                }

                let i = 0;

                if (pages.length > indicators.length) {
                  for (i = 0; i < pages.length; ++i) {
                    if (!indicators[i]) {
                      indicators[i] = this._createIndicator();
                    }
                  }
                } else {
                  const count = indicators.length - pages.length;

                  for (i = count; i > 0; --i) {
                    const node = indicators[i - 1];
                    this.node.removeChild(node);
                    indicators.splice(i - 1, 1);
                  }
                }

                if (this._layout && this._layout.enabledInHierarchy) {
                  this._layout.updateLayout();
                }

                this._changedState();
              }

            }, _class3$g.Direction = Direction$2, _temp$A), (_applyDecoratedDescriptor(_class2$x.prototype, "spriteFrame", [_dec5$u, _dec6$r], Object.getOwnPropertyDescriptor(_class2$x.prototype, "spriteFrame"), _class2$x.prototype), _applyDecoratedDescriptor(_class2$x.prototype, "direction", [_dec7$r, _dec8$o], Object.getOwnPropertyDescriptor(_class2$x.prototype, "direction"), _class2$x.prototype), _applyDecoratedDescriptor(_class2$x.prototype, "cellSize", [_dec9$l, _dec10$k], Object.getOwnPropertyDescriptor(_class2$x.prototype, "cellSize"), _class2$x.prototype), _descriptor$w = _applyDecoratedDescriptor(_class2$x.prototype, "spacing", [serializable, _dec11$h], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor2$t = _applyDecoratedDescriptor(_class2$x.prototype, "_spriteFrame", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor3$n = _applyDecoratedDescriptor(_class2$x.prototype, "_direction", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Direction$2.HORIZONTAL;
              }
            }), _descriptor4$l = _applyDecoratedDescriptor(_class2$x.prototype, "_cellSize", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Size$1(20, 20);
              }
            })), _class2$x)) || _class$E) || _class$E) || _class$E) || _class$E));

            var _dec$F, _dec2$A, _dec3$y, _dec4$x, _dec5$v, _dec6$s, _dec7$s, _dec8$p, _dec9$m, _dec10$l, _dec11$i, _dec12$h, _dec13$f, _dec14$b, _dec15$b, _dec16$a, _dec17$8, _dec18$8, _dec19$8, _dec20$7, _dec21$7, _dec22$7, _dec23$7, _dec24$6, _dec25$6, _dec26$6, _dec27$6, _class$F, _class2$y, _descriptor$x, _descriptor2$u, _descriptor3$o, _descriptor4$m, _descriptor5$i, _descriptor6$d, _descriptor7$b, _descriptor8$b, _descriptor9$a, _descriptor10$9, _descriptor11$8, _descriptor12$6, _class3$h, _temp$B;

            const _tempVec2$2 = new Vec2();

            var SizeMode$1;

            (function (SizeMode) {
              SizeMode[SizeMode["Unified"] = 0] = "Unified";
              SizeMode[SizeMode["Free"] = 1] = "Free";
            })(SizeMode$1 || (SizeMode$1 = {}));

            ccenum(SizeMode$1);
            var Direction$3;

            (function (Direction) {
              Direction[Direction["Horizontal"] = 0] = "Horizontal";
              Direction[Direction["Vertical"] = 1] = "Vertical";
            })(Direction$3 || (Direction$3 = {}));

            ccenum(Direction$3);
            var EventType$5;

            (function (EventType) {
              EventType["PAGE_TURNING"] = "page-turning";
            })(EventType$5 || (EventType$5 = {}));

            let PageView = function (v) { return exports({ PageView: v, PageViewComponent: v }), v; }((_dec$F = ccclass('cc.PageView'), _dec2$A = help(), _dec3$y = executionOrder(110), _dec4$x = menu$1(), _dec5$v = type$1(SizeMode$1), _dec6$s = tooltip(), _dec7$s = type$1(Direction$3), _dec8$p = tooltip(), _dec9$m = range(), _dec10$l = tooltip(), _dec11$i = range(), _dec12$h = tooltip(), _dec13$f = type$1(PageViewIndicator), _dec14$b = tooltip(), _dec15$b = tooltip(), _dec16$a = type$1(ScrollBar), _dec17$8 = visible(), _dec18$8 = type$1(ScrollBar), _dec19$8 = visible(), _dec20$7 = visible(), _dec21$7 = visible(), _dec22$7 = visible(), _dec23$7 = type$1([EventHandler]), _dec24$6 = visible(), _dec25$6 = tooltip(), _dec26$6 = type$1([EventHandler]), _dec27$6 = tooltip(), _dec$F(_class$F = _dec2$A(_class$F = _dec3$y(_class$F = _dec4$x(_class$F = (_class2$y = (_temp$B = _class3$h = class PageView extends ScrollView {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "autoPageTurningThreshold", _descriptor$x, this);

                _initializerDefineProperty(this, "horizontal", _descriptor2$u, this);

                _initializerDefineProperty(this, "vertical", _descriptor3$o, this);

                _initializerDefineProperty(this, "cancelInnerEvents", _descriptor4$m, this);

                _initializerDefineProperty(this, "scrollEvents", _descriptor5$i, this);

                _initializerDefineProperty(this, "pageTurningSpeed", _descriptor6$d, this);

                _initializerDefineProperty(this, "pageEvents", _descriptor7$b, this);

                _initializerDefineProperty(this, "_sizeMode", _descriptor8$b, this);

                _initializerDefineProperty(this, "_direction", _descriptor9$a, this);

                _initializerDefineProperty(this, "_scrollThreshold", _descriptor10$9, this);

                _initializerDefineProperty(this, "_pageTurningEventTiming", _descriptor11$8, this);

                _initializerDefineProperty(this, "_indicator", _descriptor12$6, this);

                this._curPageIdx = 0;
                this._lastPageIdx = 0;
                this._pages = [];
                this._initContentPos = new Vec3();
                this._scrollCenterOffsetX = [];
                this._scrollCenterOffsetY = [];
                this._touchBeganPosition = new Vec2();
                this._touchEndPosition = new Vec2();
              }

              get sizeMode() {
                return this._sizeMode;
              }

              set sizeMode(value) {
                if (this._sizeMode === value) {
                  return;
                }

                this._sizeMode = value;

                this._syncSizeMode();
              }

              get direction() {
                return this._direction;
              }

              set direction(value) {
                if (this._direction === value) {
                  return;
                }

                this._direction = value;

                this._syncScrollDirection();
              }

              get scrollThreshold() {
                return this._scrollThreshold;
              }

              set scrollThreshold(value) {
                if (this._scrollThreshold === value) {
                  return;
                }

                this._scrollThreshold = value;
              }

              get pageTurningEventTiming() {
                return this._pageTurningEventTiming;
              }

              set pageTurningEventTiming(value) {
                if (this._pageTurningEventTiming === value) {
                  return;
                }

                this._pageTurningEventTiming = value;
              }

              get indicator() {
                return this._indicator;
              }

              set indicator(value) {
                if (this._indicator === value) {
                  return;
                }

                this._indicator = value;

                if (this.indicator) {
                  this.indicator.setPageView(this);
                }
              }

              get curPageIdx() {
                return this._curPageIdx;
              }

              get verticalScrollBar() {
                return super.verticalScrollBar;
              }

              set verticalScrollBar(value) {
                super.verticalScrollBar = value;
              }

              get horizontalScrollBar() {
                return super.horizontalScrollBar;
              }

              set horizontalScrollBar(value) {
                super.horizontalScrollBar = value;
              }

              onEnable() {
                super.onEnable();
                this.node.on(NodeEventType.SIZE_CHANGED, this._updateAllPagesSize, this);

                {
                  this.node.on(PageView.EventType.SCROLL_ENG_WITH_THRESHOLD, this._dispatchPageTurningEvent, this);
                }
              }

              onDisable() {
                super.onDisable();
                this.node.off(NodeEventType.SIZE_CHANGED, this._updateAllPagesSize, this);

                {
                  this.node.off(PageView.EventType.SCROLL_ENG_WITH_THRESHOLD, this._dispatchPageTurningEvent, this);
                }
              }

              onLoad() {
                this._initPages();

                if (this.indicator) {
                  this.indicator.setPageView(this);
                }
              }

              getCurrentPageIndex() {
                return this._curPageIdx;
              }

              setCurrentPageIndex(index) {
                this.scrollToPage(index, 1);
              }

              getPages() {
                return this._pages;
              }

              addPage(page) {
                if (!page || this._pages.indexOf(page) !== -1 || !this.content) {
                  return;
                }

                if (!page._uiProps.uiTransformComp) {
                  logID(4301);
                  return;
                }

                this.content.addChild(page);

                this._pages.push(page);

                this._updatePageView();
              }

              insertPage(page, index) {
                if (index < 0 || !page || this._pages.indexOf(page) !== -1 || !this.content) {
                  return;
                }

                const pageCount = this._pages.length;

                if (index >= pageCount) {
                  this.addPage(page);
                } else {
                  if (!page._uiProps.uiTransformComp) {
                    logID(4301);
                    return;
                  }

                  this._pages.splice(index, 0, page);

                  this.content.insertChild(page, index);

                  this._updatePageView();
                }
              }

              removePage(page) {
                if (!page || !this.content) {
                  return;
                }

                const index = this._pages.indexOf(page);

                if (index === -1) {
                  warnID(4300, page.name);
                  return;
                }

                this.removePageAtIndex(index);
              }

              removePageAtIndex(index) {
                const pageList = this._pages;

                if (index < 0 || index >= pageList.length) {
                  return;
                }

                const page = pageList[index];

                if (!page || !this.content) {
                  return;
                }

                this.content.removeChild(page);
                pageList.splice(index, 1);

                this._updatePageView();
              }

              removeAllPages() {
                if (!this.content) {
                  return;
                }

                const locPages = this._pages;

                for (let i = 0, len = locPages.length; i < len; i++) {
                  this.content.removeChild(locPages[i]);
                }

                this._pages.length = 0;

                this._updatePageView();
              }

              scrollToPage(idx, timeInSecond = 0.3) {
                if (idx < 0 || idx >= this._pages.length) {
                  return;
                }

                this._curPageIdx = idx;
                this.scrollToOffset(this._moveOffsetValue(idx), timeInSecond, true);

                if (this.indicator) {
                  this.indicator._changedState();
                }
              }

              getScrollEndedEventTiming() {
                return this.pageTurningEventTiming;
              }

              _updatePageView() {
                if (!this.content) {
                  return;
                }

                const layout = this.content.getComponent(Layout);

                if (layout && layout.enabled) {
                  layout.updateLayout();
                }

                const pageCount = this._pages.length;

                if (this._curPageIdx >= pageCount) {
                  this._curPageIdx = pageCount === 0 ? 0 : pageCount - 1;
                  this._lastPageIdx = this._curPageIdx;
                }

                const contentPos = this._initContentPos;

                for (let i = 0; i < pageCount; ++i) {
                  const page = this._pages[i];
                  const pos = page.position;

                  if (this.direction === Direction$3.Horizontal) {
                    this._scrollCenterOffsetX[i] = Math.abs(contentPos.x + pos.x);
                  } else {
                    this._scrollCenterOffsetY[i] = Math.abs(contentPos.y + pos.y);
                  }
                }

                if (this.indicator) {
                  this.indicator._refresh();
                }
              }

              _updateAllPagesSize() {
                const viewTrans = this.view;

                if (!this.content || !viewTrans) {
                  return;
                }

                if (this._sizeMode !== SizeMode$1.Unified) {
                  return;
                }

                const locPages =  this._pages;
                const selfSize = viewTrans.contentSize;

                for (let i = 0, len = locPages.length; i < len; i++) {
                  locPages[i]._uiProps.uiTransformComp.setContentSize(selfSize);
                }
              }

              _handleReleaseLogic() {
                this._autoScrollToPage();

                if (this._scrolling) {
                  this._scrolling = false;

                  if (!this._autoScrolling) {
                    this._dispatchEvent(PageView.EventType.SCROLL_ENDED);
                  }
                }
              }

              _onTouchBegan(event, captureListeners) {
                event.touch.getUILocation(_tempVec2$2);
                Vec2.set(this._touchBeganPosition, _tempVec2$2.x, _tempVec2$2.y);

                super._onTouchBegan(event, captureListeners);
              }

              _onTouchMoved(event, captureListeners) {
                super._onTouchMoved(event, captureListeners);
              }

              _onTouchEnded(event, captureListeners) {
                event.touch.getUILocation(_tempVec2$2);
                Vec2.set(this._touchEndPosition, _tempVec2$2.x, _tempVec2$2.y);

                super._onTouchEnded(event, captureListeners);
              }

              _onTouchCancelled(event, captureListeners) {
                event.touch.getUILocation(_tempVec2$2);
                Vec2.set(this._touchEndPosition, _tempVec2$2.x, _tempVec2$2.y);

                super._onTouchCancelled(event, captureListeners);
              }

              _onMouseWheel() {}

              _syncScrollDirection() {
                this.horizontal = this.direction === Direction$3.Horizontal;
                this.vertical = this.direction === Direction$3.Vertical;
              }

              _syncSizeMode() {
                const viewTrans = this.view;

                if (!this.content || !viewTrans) {
                  return;
                }

                const layout = this.content.getComponent(Layout);

                if (layout) {
                  if (this._sizeMode === SizeMode$1.Free && this._pages.length > 0) {
                    const firstPageTrans = this._pages[0]._uiProps.uiTransformComp;
                    const lastPageTrans = this._pages[this._pages.length - 1]._uiProps.uiTransformComp;

                    if (this.direction === Direction$3.Horizontal) {
                      layout.paddingLeft = (viewTrans.width - firstPageTrans.width) / 2;
                      layout.paddingRight = (viewTrans.width - lastPageTrans.width) / 2;
                    } else if (this.direction === Direction$3.Vertical) {
                      layout.paddingTop = (viewTrans.height - firstPageTrans.height) / 2;
                      layout.paddingBottom = (viewTrans.height - lastPageTrans.height) / 2;
                    }
                  }

                  layout.updateLayout();
                }
              }

              _initPages() {
                if (!this.content) {
                  return;
                }

                this._initContentPos = this.content.position;
                const children = this.content.children;

                for (let i = 0; i < children.length; ++i) {
                  const page = children[i];

                  if (this._pages.indexOf(page) >= 0) {
                    continue;
                  }

                  this._pages.push(page);
                }

                this._syncScrollDirection();

                this._syncSizeMode();

                this._updatePageView();
              }

              _dispatchPageTurningEvent() {
                if (this._lastPageIdx === this._curPageIdx) {
                  return;
                }

                this._lastPageIdx = this._curPageIdx;
                EventHandler.emitEvents(this.pageEvents, this, EventType$5.PAGE_TURNING);
                this.node.emit(EventType$5.PAGE_TURNING, this);
              }

              _isQuicklyScrollable(touchMoveVelocity) {
                if (this.direction === Direction$3.Horizontal) {
                  if (Math.abs(touchMoveVelocity.x) > this.autoPageTurningThreshold) {
                    return true;
                  }
                } else if (this.direction === Direction$3.Vertical) {
                  if (Math.abs(touchMoveVelocity.y) > this.autoPageTurningThreshold) {
                    return true;
                  }
                }

                return false;
              }

              _moveOffsetValue(idx) {
                const offset = new Vec2();

                if (this._sizeMode === SizeMode$1.Free) {
                  if (this.direction === Direction$3.Horizontal) {
                    offset.x = this._scrollCenterOffsetX[idx];
                  } else if (this.direction === Direction$3.Vertical) {
                    offset.y = this._scrollCenterOffsetY[idx];
                  }
                } else {
                  const viewTrans = this.view;

                  if (!viewTrans) {
                    return offset;
                  }

                  if (this.direction === Direction$3.Horizontal) {
                    offset.x = idx * viewTrans.width;
                  } else if (this.direction === Direction$3.Vertical) {
                    offset.y = idx * viewTrans.height;
                  }
                }

                return offset;
              }

              _getDragDirection(moveOffset) {
                if (this._direction === Direction$3.Horizontal) {
                  if (moveOffset.x === 0) {
                    return 0;
                  }

                  return moveOffset.x > 0 ? 1 : -1;
                } else {
                  if (moveOffset.y === 0) {
                    return 0;
                  }

                  return moveOffset.y < 0 ? 1 : -1;
                }
              }

              _isScrollable(offset, index, nextIndex) {
                if (this._sizeMode === SizeMode$1.Free) {
                  let curPageCenter = 0;
                  let nextPageCenter = 0;

                  if (this.direction === Direction$3.Horizontal) {
                    curPageCenter = this._scrollCenterOffsetX[index];
                    nextPageCenter = this._scrollCenterOffsetX[nextIndex];
                    return Math.abs(offset.x) >= Math.abs(curPageCenter - nextPageCenter) * this.scrollThreshold;
                  } else if (this.direction === Direction$3.Vertical) {
                    curPageCenter = this._scrollCenterOffsetY[index];
                    nextPageCenter = this._scrollCenterOffsetY[nextIndex];
                    return Math.abs(offset.y) >= Math.abs(curPageCenter - nextPageCenter) * this.scrollThreshold;
                  }
                } else {
                  const viewTrans = this.view;

                  if (!viewTrans) {
                    return false;
                  }

                  if (this.direction === Direction$3.Horizontal) {
                    return Math.abs(offset.x) >= viewTrans.width * this.scrollThreshold;
                  } else if (this.direction === Direction$3.Vertical) {
                    return Math.abs(offset.y) >= viewTrans.height * this.scrollThreshold;
                  }
                }

                return false;
              }

              _autoScrollToPage() {
                const bounceBackStarted = this._startBounceBackIfNeeded();

                if (bounceBackStarted) {
                  const bounceBackAmount = this._getHowMuchOutOfBoundary();

                  this._clampDelta(bounceBackAmount);

                  if (bounceBackAmount.x > 0 || bounceBackAmount.y < 0) {
                    this._curPageIdx = this._pages.length === 0 ? 0 : this._pages.length - 1;
                  }

                  if (bounceBackAmount.x < 0 || bounceBackAmount.y > 0) {
                    this._curPageIdx = 0;
                  }

                  if (this.indicator) {
                    this.indicator._changedState();
                  }
                } else {
                  const moveOffset = new Vec2();
                  Vec2.subtract(moveOffset, this._touchBeganPosition, this._touchEndPosition);
                  const index = this._curPageIdx;

                  const nextIndex = index + this._getDragDirection(moveOffset);

                  const timeInSecond = this.pageTurningSpeed * Math.abs(index - nextIndex);

                  if (nextIndex < this._pages.length) {
                    if (this._isScrollable(moveOffset, index, nextIndex)) {
                      this.scrollToPage(nextIndex, timeInSecond);
                      return;
                    } else {
                      const touchMoveVelocity = this._calculateTouchMoveVelocity();

                      if (this._isQuicklyScrollable(touchMoveVelocity)) {
                        this.scrollToPage(nextIndex, timeInSecond);
                        return;
                      }
                    }
                  }

                  this.scrollToPage(index, timeInSecond);
                }
              }

            }, _class3$h.SizeMode = SizeMode$1, _class3$h.Direction = Direction$3, _class3$h.EventType = extendsEnum(EventType$5, EventType$3), _temp$B), (_applyDecoratedDescriptor(_class2$y.prototype, "sizeMode", [_dec5$v, _dec6$s], Object.getOwnPropertyDescriptor(_class2$y.prototype, "sizeMode"), _class2$y.prototype), _applyDecoratedDescriptor(_class2$y.prototype, "direction", [_dec7$s, _dec8$p], Object.getOwnPropertyDescriptor(_class2$y.prototype, "direction"), _class2$y.prototype), _applyDecoratedDescriptor(_class2$y.prototype, "scrollThreshold", [slide, _dec9$m, _dec10$l], Object.getOwnPropertyDescriptor(_class2$y.prototype, "scrollThreshold"), _class2$y.prototype), _applyDecoratedDescriptor(_class2$y.prototype, "pageTurningEventTiming", [slide, _dec11$i, _dec12$h], Object.getOwnPropertyDescriptor(_class2$y.prototype, "pageTurningEventTiming"), _class2$y.prototype), _applyDecoratedDescriptor(_class2$y.prototype, "indicator", [_dec13$f, _dec14$b], Object.getOwnPropertyDescriptor(_class2$y.prototype, "indicator"), _class2$y.prototype), _descriptor$x = _applyDecoratedDescriptor(_class2$y.prototype, "autoPageTurningThreshold", [serializable, _dec15$b], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 100;
              }
            }), _applyDecoratedDescriptor(_class2$y.prototype, "verticalScrollBar", [_dec16$a, override, _dec17$8], Object.getOwnPropertyDescriptor(_class2$y.prototype, "verticalScrollBar"), _class2$y.prototype), _applyDecoratedDescriptor(_class2$y.prototype, "horizontalScrollBar", [_dec18$8, override, _dec19$8], Object.getOwnPropertyDescriptor(_class2$y.prototype, "horizontalScrollBar"), _class2$y.prototype), _descriptor2$u = _applyDecoratedDescriptor(_class2$y.prototype, "horizontal", [override, serializable, _dec20$7], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _descriptor3$o = _applyDecoratedDescriptor(_class2$y.prototype, "vertical", [override, serializable, _dec21$7], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _descriptor4$m = _applyDecoratedDescriptor(_class2$y.prototype, "cancelInnerEvents", [override, serializable, _dec22$7], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _descriptor5$i = _applyDecoratedDescriptor(_class2$y.prototype, "scrollEvents", [_dec23$7, serializable, override, _dec24$6], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor6$d = _applyDecoratedDescriptor(_class2$y.prototype, "pageTurningSpeed", [serializable, editable, _dec25$6], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.3;
              }
            }), _descriptor7$b = _applyDecoratedDescriptor(_class2$y.prototype, "pageEvents", [_dec26$6, serializable, _dec27$6], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor8$b = _applyDecoratedDescriptor(_class2$y.prototype, "_sizeMode", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return SizeMode$1.Unified;
              }
            }), _descriptor9$a = _applyDecoratedDescriptor(_class2$y.prototype, "_direction", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Direction$3.Horizontal;
              }
            }), _descriptor10$9 = _applyDecoratedDescriptor(_class2$y.prototype, "_scrollThreshold", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.5;
              }
            }), _descriptor11$8 = _applyDecoratedDescriptor(_class2$y.prototype, "_pageTurningEventTiming", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.1;
              }
            }), _descriptor12$6 = _applyDecoratedDescriptor(_class2$y.prototype, "_indicator", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            })), _class2$y)) || _class$F) || _class$F) || _class$F) || _class$F));

            const _tempPos$1 = new Vec3();

            const _defaultAnchor = new Vec2();

            const tInverseTranslate = new Vec2();
            const tInverseScale = new Vec2(1, 1);

            const _tempVec2_1$1 = new Vec2();

            const _tempVec2_2 = new Vec2();

            function align(node, widget) {
              if (widget._hadAlignOnce) return;

              if ( widget.alignMode === AlignMode.ONCE) {
                widget._hadAlignOnce = true;
              }

              const hasTarget = widget.target;
              let target;
              const inverseTranslate = tInverseTranslate;
              const inverseScale = tInverseScale;

              if (hasTarget) {
                target = hasTarget;
                computeInverseTransForTarget(node, target, inverseTranslate, inverseScale);
              } else {
                target = node.parent;
              }

              const targetSize = getReadonlyNodeSize(target);
              const useGlobal = target instanceof Scene || !target.getComponent(UITransform);
              const targetAnchor = useGlobal ? _defaultAnchor : target.getComponent(UITransform).anchorPoint;
              const isRoot =  useGlobal;
              node.getPosition(_tempPos$1);
              const uiTrans = node._uiProps.uiTransformComp;
              let x = _tempPos$1.x;
              let y = _tempPos$1.y;
              const anchor = uiTrans.anchorPoint;
              const scale = node.getScale();

              if (widget.alignFlags & AlignFlags.HORIZONTAL) {
                let localLeft = 0;
                let localRight = 0;
                const targetWidth = targetSize.width;

                if (isRoot) {
                  localLeft = visibleRect.left.x;
                  localRight = visibleRect.right.x;
                } else {
                  localLeft = -targetAnchor.x * targetWidth;
                  localRight = localLeft + targetWidth;
                }

                localLeft += widget.isAbsoluteLeft ? widget.left : widget.left * targetWidth;
                localRight -= widget.isAbsoluteRight ? widget.right : widget.right * targetWidth;

                if (hasTarget) {
                  localLeft += inverseTranslate.x;
                  localLeft *= inverseScale.x;
                  localRight += inverseTranslate.x;
                  localRight *= inverseScale.x;
                }

                let width = 0;
                let anchorX = anchor.x;
                let scaleX = scale.x;

                if (scaleX < 0) {
                  anchorX = 1.0 - anchorX;
                  scaleX = -scaleX;
                }

                if (widget.isStretchWidth) {
                  width = localRight - localLeft;

                  if (scaleX !== 0) {
                    uiTrans.width = width / scaleX;
                  }

                  x = localLeft + anchorX * width;
                } else {
                  width = uiTrans.width * scaleX;

                  if (widget.isAlignHorizontalCenter) {
                    let localHorizontalCenter = widget.isAbsoluteHorizontalCenter ? widget.horizontalCenter : widget.horizontalCenter * targetWidth;
                    let targetCenter = (0.5 - targetAnchor.x) * targetSize.width;

                    if (hasTarget) {
                      localHorizontalCenter *= inverseScale.x;
                      targetCenter += inverseTranslate.x;
                      targetCenter *= inverseScale.x;
                    }

                    x = targetCenter + (anchorX - 0.5) * width + localHorizontalCenter;
                  } else if (widget.isAlignLeft) {
                    x = localLeft + anchorX * width;
                  } else {
                    x = localRight + (anchorX - 1) * width;
                  }
                }

                widget._lastSize.width = width;
              }

              if (widget.alignFlags & AlignFlags.VERTICAL) {
                let localTop = 0;
                let localBottom = 0;
                const targetHeight = targetSize.height;

                if (isRoot) {
                  localBottom = visibleRect.bottom.y;
                  localTop = visibleRect.top.y;
                } else {
                  localBottom = -targetAnchor.y * targetHeight;
                  localTop = localBottom + targetHeight;
                }

                localBottom += widget.isAbsoluteBottom ? widget.bottom : widget.bottom * targetHeight;
                localTop -= widget.isAbsoluteTop ? widget.top : widget.top * targetHeight;

                if (hasTarget) {
                  localBottom += inverseTranslate.y;
                  localBottom *= inverseScale.y;
                  localTop += inverseTranslate.y;
                  localTop *= inverseScale.y;
                }

                let height = 0;
                let anchorY = anchor.y;
                let scaleY = scale.y;

                if (scaleY < 0) {
                  anchorY = 1.0 - anchorY;
                  scaleY = -scaleY;
                }

                if (widget.isStretchHeight) {
                  height = localTop - localBottom;

                  if (scaleY !== 0) {
                    uiTrans.height = height / scaleY;
                  }

                  y = localBottom + anchorY * height;
                } else {
                  height = uiTrans.height * scaleY;

                  if (widget.isAlignVerticalCenter) {
                    let localVerticalCenter = widget.isAbsoluteVerticalCenter ? widget.verticalCenter : widget.verticalCenter * targetHeight;
                    let targetMiddle = (0.5 - targetAnchor.y) * targetSize.height;

                    if (hasTarget) {
                      localVerticalCenter *= inverseScale.y;
                      targetMiddle += inverseTranslate.y;
                      targetMiddle *= inverseScale.y;
                    }

                    y = targetMiddle + (anchorY - 0.5) * height + localVerticalCenter;
                  } else if (widget.isAlignBottom) {
                    y = localBottom + anchorY * height;
                  } else {
                    y = localTop + (anchorY - 1) * height;
                  }
                }

                widget._lastSize.height = height;
              }

              node.setPosition(x, y, _tempPos$1.z);
              Vec3.set(widget._lastPos, x, y, _tempPos$1.z);
            }

            function visitNode(node) {
              const widget = node.getComponent(Widget);

              if (widget && widget.enabled) {

                if (!legacyCC.isValid(node, true)) {
                  return;
                }

                activeWidgets.push(widget);
              }

              const children = node.children;

              for (const child of children) {
                if (child.active) {
                  visitNode(child);
                }
              }
            }

            function refreshScene() {
              const scene = director.getScene();

              if (scene) {
                widgetManager.isAligning = true;

                if (widgetManager._nodesOrderDirty) {
                  activeWidgets.length = 0;
                  visitNode(scene);
                  widgetManager._nodesOrderDirty = false;
                }
                let widget = null;
                const iterator = widgetManager._activeWidgetsIterator;

                for (iterator.i = 0; iterator.i < activeWidgets.length; ++iterator.i) {
                  widget = activeWidgets[iterator.i];

                  if (widget._dirty) {
                    align(widget.node, widget);
                    widget._dirty = false;
                  }
                }

                widgetManager.isAligning = false;
              }
            }

            const activeWidgets = [];

            function updateAlignment(node) {
              const parent = node.parent;

              if (parent && Node.isNode(parent)) {
                updateAlignment(parent);
              }

              const widget = node.getComponent(Widget);

              if (widget && parent) {
                align(node, widget);
              }
            }

            const widgetManager = exports('widgetManager', legacyCC._widgetManager = {
              isAligning: false,
              _nodesOrderDirty: false,
              _activeWidgetsIterator: new array.MutableForwardIterator(activeWidgets),
              animationState:  null,

              init() {
                director.on(Director.EVENT_AFTER_SCENE_LAUNCH, refreshScene);
                director.on(Director.EVENT_AFTER_UPDATE, refreshScene);
                View.instance.on('design-resolution-changed', this.onResized, this);

                {
                  const thisOnResized = this.onResized.bind(this);
                  View.instance.on('canvas-resize', thisOnResized);
                  screenAdapter.on('orientation-change', thisOnResized);
                }
              },

              add(widget) {
                this._nodesOrderDirty = true;
              },

              remove(widget) {
                this._activeWidgetsIterator.remove(widget);
              },

              onResized() {
                const scene = director.getScene();

                if (scene) {
                  this.refreshWidgetOnResized(scene);
                }
              },

              refreshWidgetOnResized(node) {
                const widget = Node.isNode(node) && node.getComponent(Widget);

                if (widget && widget.enabled && (widget.alignMode === AlignMode.ON_WINDOW_RESIZE || widget.alignMode === AlignMode.ALWAYS)) {
                  widget.setDirty();
                }

                const children = node.children;

                for (const child of children) {
                  this.refreshWidgetOnResized(child);
                }
              },

              updateOffsetsToStayPut(widget, e) {
                function i(t, c) {
                  return Math.abs(t - c) > 1e-10 ? c : t;
                }

                const widgetNode = widget.node;
                let widgetParent = widgetNode.parent;

                if (widgetParent) {
                  const zero = _tempVec2_1$1;
                  zero.set(0, 0);
                  const one = _tempVec2_2;
                  one.set(1, 1);

                  if (widget.target) {
                    widgetParent = widget.target;
                    computeInverseTransForTarget(widgetNode, widgetParent, zero, one);
                  }

                  if (!e) {
                    return;
                  }

                  const parentTrans = widgetParent._uiProps && widgetParent._uiProps.uiTransformComp;
                  const parentAP = parentTrans ? parentTrans.anchorPoint : _defaultAnchor;
                  const trans = widgetNode._uiProps.uiTransformComp;
                  const matchSize = getReadonlyNodeSize(widgetParent);
                  const myAP = trans.anchorPoint;
                  const pos = widgetNode.getPosition();
                  const alignFlags = AlignFlags;
                  const widgetNodeScale = widgetNode.getScale();
                  let temp = 0;

                  if (e & alignFlags.LEFT) {
                    let l = -parentAP.x * matchSize.width;
                    l += zero.x;
                    l *= one.x;
                    temp = pos.x - myAP.x * trans.width * widgetNodeScale.x - l;

                    if (!widget.isAbsoluteLeft) {
                      temp /= matchSize.width;
                    }

                    temp /= one.x;
                    widget.left = i(widget.left, temp);
                  }

                  if (e & alignFlags.RIGHT) {
                    let r = (1 - parentAP.x) * matchSize.width;
                    r += zero.x;
                    temp = (r *= one.x) - (pos.x + (1 - myAP.x) * trans.width * widgetNodeScale.x);

                    if (!widget.isAbsoluteRight) {
                      temp /= matchSize.width;
                    }

                    temp /= one.x;
                    widget.right = i(widget.right, temp);
                  }

                  if (e & alignFlags.TOP) {
                    let t = (1 - parentAP.y) * matchSize.height;
                    t += zero.y;
                    temp = (t *= one.y) - (pos.y + (1 - myAP.y) * trans.height * widgetNodeScale.y);

                    if (!widget.isAbsoluteTop) {
                      temp /= matchSize.height;
                    }

                    temp /= one.y;
                    widget.top = i(widget.top, temp);
                  }

                  if (e & alignFlags.BOT) {
                    let b = -parentAP.y * matchSize.height;
                    b += zero.y;
                    b *= one.y;
                    temp = pos.y - myAP.y * trans.height * widgetNodeScale.y - b;

                    if (!widget.isAbsoluteBottom) {
                      temp /= matchSize.height;
                    }

                    temp /= one.y;
                    widget.bottom = i(widget.bottom, temp);
                  }
                }
              },

              updateAlignment,
              AlignMode,
              AlignFlags
            });
            director.on(Director.EVENT_INIT, () => {
              widgetManager.init();
            });

            var _dec$G, _dec2$B, _dec3$z, _dec4$y, _dec5$w, _class$G;
            let SafeArea = function (v) { return exports({ SafeArea: v, SafeAreaComponent: v }), v; }((_dec$G = ccclass('cc.SafeArea'), _dec2$B = help(), _dec3$z = executionOrder(110), _dec4$y = menu$1(), _dec5$w = requireComponent(Widget), _dec$G(_class$G = _dec2$B(_class$G = _dec3$z(_class$G = executeInEditMode(_class$G = _dec4$y(_class$G = _dec5$w(_class$G = class SafeArea extends Component {
              onEnable() {
                this.updateArea();
                screenAdapter.on('window-resize', this.updateArea, this);
                screenAdapter.on('orientation-change', this.updateArea, this);
              }

              onDisable() {
                screenAdapter.off('window-resize', this.updateArea, this);
                screenAdapter.off('orientation-change', this.updateArea, this);
              }

              updateArea() {
                const widget = this.node.getComponent(Widget);
                const uiTransComp = this.node.getComponent(UITransform);

                if (!widget || !uiTransComp) {
                  return;
                }

                widget.updateAlignment();
                const lastPos = this.node.position.clone();
                const lastAnchorPoint = uiTransComp.anchorPoint.clone();
                widget.isAlignTop = widget.isAlignBottom = widget.isAlignLeft = widget.isAlignRight = true;
                const visibleSize = view.getVisibleSize();
                const screenWidth = visibleSize.width;
                const screenHeight = visibleSize.height;
                const safeArea = sys.getSafeAreaRect();
                widget.top = screenHeight - safeArea.y - safeArea.height;
                widget.bottom = safeArea.y;
                widget.left = safeArea.x;
                widget.right = screenWidth - safeArea.x - safeArea.width;
                widget.updateAlignment();
                const curPos = this.node.position.clone();
                const anchorX = lastAnchorPoint.x - (curPos.x - lastPos.x) / uiTransComp.width;
                const anchorY = lastAnchorPoint.y - (curPos.y - lastPos.y) / uiTransComp.height;
                uiTransComp.setAnchorPoint(anchorX, anchorY);
                widgetManager.add(widget);
              }

            }) || _class$G) || _class$G) || _class$G) || _class$G) || _class$G) || _class$G));

            var _dec$H, _dec2$C, _dec3$A, _dec4$z, _dec5$x, _dec6$t, _dec7$t, _dec8$q, _dec9$n, _dec10$m, _dec11$j, _dec12$i, _class$H, _class2$z, _descriptor$y, _descriptor2$v, _descriptor3$p, _descriptor4$n, _descriptor5$j, _temp$C;
            let UICoordinateTracker = function (v) { return exports({ UICoordinateTracker: v, UICoordinateTrackerComponent: v }), v; }((_dec$H = ccclass('cc.UICoordinateTracker'), _dec2$C = help(), _dec3$A = menu$1(), _dec4$z = executionOrder(110), _dec5$x = type$1(Node), _dec6$t = tooltip(), _dec7$t = type$1(Camera$1), _dec8$q = tooltip(), _dec9$n = tooltip(), _dec10$m = tooltip(), _dec11$j = type$1([EventHandler]), _dec12$i = tooltip(), _dec$H(_class$H = _dec2$C(_class$H = _dec3$A(_class$H = _dec4$z(_class$H = (_class2$z = (_temp$C = class UICoordinateTracker extends Component {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "syncEvents", _descriptor$y, this);

                _initializerDefineProperty(this, "_target", _descriptor2$v, this);

                _initializerDefineProperty(this, "_camera", _descriptor3$p, this);

                _initializerDefineProperty(this, "_useScale", _descriptor4$n, this);

                _initializerDefineProperty(this, "_distance", _descriptor5$j, this);

                this._transformPos = new Vec3();
                this._viewPos = new Vec3();
                this._canMove = true;
                this._lastWPos = new Vec3();
                this._lastCameraPos = new Vec3();
              }

              get target() {
                return this._target;
              }

              set target(value) {
                if (this._target === value) {
                  return;
                }

                this._target = value;

                this._checkCanMove();
              }

              get camera() {
                return this._camera;
              }

              set camera(value) {
                if (this._camera === value) {
                  return;
                }

                this._camera = value;

                this._checkCanMove();
              }

              get useScale() {
                return this._useScale;
              }

              set useScale(value) {
                if (this._useScale === value) {
                  return;
                }

                this._useScale = value;
              }

              get distance() {
                return this._distance;
              }

              set distance(value) {
                if (this._distance === value) {
                  return;
                }

                this._distance = value;
              }

              onEnable() {
                this._checkCanMove();
              }

              update() {
                const wPos = this.node.worldPosition;
                const camera = this._camera;

                if (!this._canMove || !camera || !camera.camera || this._lastWPos.equals(wPos) && this._lastCameraPos.equals(camera.node.worldPosition)) {
                  return;
                }

                this._lastWPos.set(wPos);

                this._lastCameraPos.set(camera.node.worldPosition);

                camera.camera.update();
                camera.convertToUINode(wPos, this._target, this._transformPos);

                if (this._useScale) {
                  Vec3.transformMat4(this._viewPos, this.node.worldPosition, camera.camera.matView);
                }

                if (this.syncEvents.length > 0) {
                  const data = this._distance / Math.abs(this._viewPos.z);
                  EventHandler.emitEvents(this.syncEvents, this._transformPos, data);
                }
              }

              _checkCanMove() {
                this._canMove = !!(this._camera && this._target);
              }

            }, _temp$C), (_applyDecoratedDescriptor(_class2$z.prototype, "target", [_dec5$x, _dec6$t], Object.getOwnPropertyDescriptor(_class2$z.prototype, "target"), _class2$z.prototype), _applyDecoratedDescriptor(_class2$z.prototype, "camera", [_dec7$t, _dec8$q], Object.getOwnPropertyDescriptor(_class2$z.prototype, "camera"), _class2$z.prototype), _applyDecoratedDescriptor(_class2$z.prototype, "useScale", [_dec9$n], Object.getOwnPropertyDescriptor(_class2$z.prototype, "useScale"), _class2$z.prototype), _applyDecoratedDescriptor(_class2$z.prototype, "distance", [_dec10$m], Object.getOwnPropertyDescriptor(_class2$z.prototype, "distance"), _class2$z.prototype), _descriptor$y = _applyDecoratedDescriptor(_class2$z.prototype, "syncEvents", [_dec11$j, serializable, _dec12$i], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor2$v = _applyDecoratedDescriptor(_class2$z.prototype, "_target", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor3$p = _applyDecoratedDescriptor(_class2$z.prototype, "_camera", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor4$n = _applyDecoratedDescriptor(_class2$z.prototype, "_useScale", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _descriptor5$j = _applyDecoratedDescriptor(_class2$z.prototype, "_distance", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            })), _class2$z)) || _class$H) || _class$H) || _class$H) || _class$H));

            var _dec$I, _dec2$D, _dec3$B, _class$I;
            const BlockEvents = [NodeEventType.TOUCH_START, NodeEventType.TOUCH_END, NodeEventType.TOUCH_MOVE, NodeEventType.MOUSE_DOWN, NodeEventType.MOUSE_MOVE, NodeEventType.MOUSE_UP, NodeEventType.MOUSE_ENTER, NodeEventType.MOUSE_LEAVE, NodeEventType.MOUSE_WHEEL];

            function stopPropagation(event) {
              event.propagationStopped = true;
            }

            let BlockInputEvents = function (v) { return exports({ BlockInputEvents: v, BlockInputEventsComponent: v }), v; }((_dec$I = ccclass('cc.BlockInputEvents'), _dec2$D = help(), _dec3$B = menu$1(), _dec$I(_class$I = _dec2$D(_class$I = _dec3$B(_class$I = class BlockInputEvents extends Component {
              onEnable() {
                for (let i = 0; i < BlockEvents.length; i++) {
                  this.node.on(BlockEvents[i], stopPropagation, this);
                }
              }

              onDisable() {
                for (let i = 0; i < BlockEvents.length; i++) {
                  this.node.off(BlockEvents[i], stopPropagation, this);
                }
              }

            }) || _class$I) || _class$I) || _class$I));

            const minigame = {};

            var _dec$J, _dec2$E, _dec3$C, _dec4$A, _dec5$y, _dec6$u, _dec7$u, _class$J, _class2$A, _descriptor$z, _descriptor2$w, _temp$D;
            let SubContextView = exports('SubContextView', (_dec$J = ccclass('cc.SubContextView'), _dec2$E = help(), _dec3$C = executionOrder(110), _dec4$A = requireComponent(UITransform), _dec5$y = menu$1(), _dec6$u = tooltip(), _dec7$u = tooltip(), _dec$J(_class$J = _dec2$E(_class$J = _dec3$C(_class$J = _dec4$A(_class$J = _dec5$y(_class$J = (_class2$A = (_temp$D = class SubContextView extends Component {
              get designResolutionSize() {
                return this._designResolutionSize;
              }

              set designResolutionSize(value) {
                {
                  return;
                }
              }

              get fps() {
                return this._fps;
              }

              set fps(value) {
                if (this._fps === value) {
                  return;
                }

                this._fps = value;
                this._updateInterval = 1000 / value;
              }

              constructor() {
                super();

                _initializerDefineProperty(this, "_fps", _descriptor$z, this);

                this._sprite = void 0;
                this._imageAsset = void 0;
                this._texture = void 0;
                this._updatedTime = 0;
                this._updateInterval = 0;
                this._openDataContext = void 0;
                this._content = void 0;

                _initializerDefineProperty(this, "_designResolutionSize", _descriptor2$w, this);

                this._content = new Node('content');
                this._content.hideFlags |= CCObject.Flags.DontSave | CCObject.Flags.HideInHierarchy;
                this._sprite = null;
                this._imageAsset = new ImageAsset();
                this._openDataContext = null;
                this._updatedTime = performance.now();
                this._texture = new Texture2D();
              }

              onLoad() {
                if (minigame.getOpenDataContext) {
                  this._updateInterval = 1000 / this._fps;
                  this._openDataContext = minigame.getOpenDataContext();

                  this._initSharedCanvas();

                  this._initContentNode();

                  this._updateSubContextView();

                  this._updateContentLayer();
                } else {
                  this.enabled = false;
                }
              }

              onEnable() {
                this._registerNodeEvent();
              }

              onDisable() {
                this._unregisterNodeEvent();
              }

              _initSharedCanvas() {
                if (this._openDataContext) {
                  const sharedCanvas = this._openDataContext.canvas;
                  sharedCanvas.width = this._designResolutionSize.width;
                  sharedCanvas.height = this._designResolutionSize.height;
                }
              }

              _initContentNode() {
                if (this._openDataContext) {
                  const sharedCanvas = this._openDataContext.canvas;
                  const image = this._imageAsset;
                  image.reset(sharedCanvas);
                  this._texture.image = image;

                  this._texture.create(sharedCanvas.width, sharedCanvas.height);

                  this._sprite = this._content.getComponent(Sprite);

                  if (!this._sprite) {
                    this._sprite = this._content.addComponent(Sprite);
                  }

                  if (this._sprite.spriteFrame) {
                    this._sprite.spriteFrame.texture = this._texture;
                  } else {
                    const sp = new SpriteFrame();
                    sp.texture = this._texture;
                    this._sprite.spriteFrame = sp;
                  }

                  this._content.parent = this.node;
                }
              }

              _updateSubContextView() {
                if (!this._openDataContext) {
                  return;
                }

                const nodeTrans = this.node.getComponent(UITransform);

                const contentTrans = this._content.getComponent(UITransform);

                const scaleX = nodeTrans.width / contentTrans.width;
                const scaleY = nodeTrans.height / contentTrans.height;
                const scale = scaleX > scaleY ? scaleY : scaleX;
                contentTrans.width *= scale;
                contentTrans.height *= scale;
                const viewportRect = view.getViewportRect();
                const box = contentTrans.getBoundingBoxToWorld();
                const visibleSize = view.getVisibleSize();
                const dpr = screenAdapter.devicePixelRatio;
                const x = (viewportRect.width * (box.x / visibleSize.width) + viewportRect.x) / dpr;
                const y = (viewportRect.height * (box.y / visibleSize.height) + viewportRect.y) / dpr;
                const width = viewportRect.width * (box.width / visibleSize.width) / dpr;
                const height = viewportRect.height * (box.height / visibleSize.height) / dpr;

                this._openDataContext.postMessage({
                  fromEngine: true,
                  type: 'engine',
                  event: 'viewport',
                  x,
                  y,
                  width,
                  height
                });
              }

              _updateSubContextTexture() {
                const img = this._imageAsset;

                if (!img || !this._openDataContext) {
                  return;
                }

                if (img.width <= 0 || img.height <= 0) {
                  return;
                }

                const sharedCanvas = this._openDataContext.canvas;
                img.reset(sharedCanvas);

                if (sharedCanvas.width > img.width || sharedCanvas.height > img.height) {
                  this._texture.create(sharedCanvas.width, sharedCanvas.height);
                }

                this._texture.uploadData(sharedCanvas);
              }

              _registerNodeEvent() {
                this.node.on(NodeEventType.TRANSFORM_CHANGED, this._updateSubContextView, this);
                this.node.on(NodeEventType.SIZE_CHANGED, this._updateSubContextView, this);
                this.node.on(NodeEventType.LAYER_CHANGED, this._updateContentLayer, this);
              }

              _unregisterNodeEvent() {
                this.node.off(NodeEventType.TRANSFORM_CHANGED, this._updateSubContextView, this);
                this.node.off(NodeEventType.SIZE_CHANGED, this._updateSubContextView, this);
                this.node.off(NodeEventType.LAYER_CHANGED, this._updateContentLayer, this);
              }

              _updateContentLayer() {
                this._content.layer = this.node.layer;
              }

              update(dt) {
                const calledUpdateManually = dt === undefined;

                if (calledUpdateManually) {
                  this._updateSubContextTexture();

                  return;
                }

                const now = performance.now();
                const deltaTime = now - this._updatedTime;

                if (deltaTime >= this._updateInterval) {
                  this._updatedTime += this._updateInterval;

                  this._updateSubContextTexture();
                }
              }

              onDestroy() {
                this._content.destroy();

                this._texture.destroy();

                if (this._sprite) {
                  this._sprite.destroy();
                }

                this._imageAsset.destroy();

                this._openDataContext = null;
              }

            }, _temp$D), (_applyDecoratedDescriptor(_class2$A.prototype, "designResolutionSize", [_dec6$u], Object.getOwnPropertyDescriptor(_class2$A.prototype, "designResolutionSize"), _class2$A.prototype), _applyDecoratedDescriptor(_class2$A.prototype, "fps", [_dec7$u], Object.getOwnPropertyDescriptor(_class2$A.prototype, "fps"), _class2$A.prototype), _descriptor$z = _applyDecoratedDescriptor(_class2$A.prototype, "_fps", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 60;
              }
            }), _descriptor2$w = _applyDecoratedDescriptor(_class2$A.prototype, "_designResolutionSize", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Size$1(640, 960);
              }
            })), _class2$A)) || _class$J) || _class$J) || _class$J) || _class$J) || _class$J));
            legacyCC.SubContextView = SubContextView;

            var _dec$K, _class$K;
            let UIReorderComponent = exports('UIReorderComponent', (_dec$K = ccclass('cc.UIReorderComponent'), _dec$K(_class$K = class UIReorderComponent {
              constructor() {
                warnID(1408, 'UIReorderComponent');
              }

            }) || _class$K));
            legacyCC.UIReorderComponent = UIReorderComponent;
            legacyCC.ButtonComponent = Button;
            js.setClassAlias(Button, 'cc.ButtonComponent');
            legacyCC.EditBoxComponent = EditBox;
            js.setClassAlias(EditBox, 'cc.EditBoxComponent');
            legacyCC.LayoutComponent = Layout;
            js.setClassAlias(Layout, 'cc.LayoutComponent');
            legacyCC.ProgressBarComponent = ProgressBar;
            js.setClassAlias(ProgressBar, 'cc.ProgressBarComponent');
            legacyCC.ScrollViewComponent = ScrollView;
            js.setClassAlias(ScrollView, 'cc.ScrollViewComponent');
            legacyCC.ScrollBarComponent = ScrollBar;
            js.setClassAlias(ScrollBar, 'cc.ScrollBarComponent');
            legacyCC.SliderComponent = Slider;
            js.setClassAlias(Slider, 'cc.SliderComponent');
            legacyCC.ToggleComponent = Toggle;
            js.setClassAlias(Toggle, 'cc.ToggleComponent');
            legacyCC.ToggleContainerComponent = ToggleContainer;
            js.setClassAlias(ToggleContainer, 'cc.ToggleContainerComponent');
            legacyCC.WidgetComponent = Widget;
            js.setClassAlias(Widget, 'cc.WidgetComponent');
            legacyCC.PageViewComponent = PageView;
            js.setClassAlias(PageView, 'cc.PageViewComponent');
            legacyCC.PageViewIndicatorComponent = PageViewIndicator;
            js.setClassAlias(PageViewIndicator, 'cc.PageViewIndicatorComponent');
            legacyCC.SafeAreaComponent = SafeArea;
            js.setClassAlias(SafeArea, 'cc.SafeAreaComponent');
            js.setClassAlias(UICoordinateTracker, 'cc.UICoordinateTrackerComponent');
            legacyCC.BlockInputEventsComponent = BlockInputEvents;
            js.setClassAlias(BlockInputEvents, 'cc.BlockInputEventsComponent');

            var _dec$L, _dec2$F, _dec3$D, _dec4$B, _dec5$z, _dec6$v, _dec7$v, _dec8$r, _dec9$o, _class$L, _class2$B, _descriptor$A, _descriptor2$x, _descriptor3$q, _descriptor4$o, _temp$E;
            let Billboard = function (v) { return exports({ Billboard: v, BillboardComponent: v }), v; }((_dec$L = ccclass('cc.Billboard'), _dec2$F = help(), _dec3$D = menu$1(), _dec4$B = type$1(Texture2D), _dec5$z = type$1(Texture2D), _dec6$v = tooltip(), _dec7$v = tooltip(), _dec8$r = tooltip(), _dec9$o = tooltip(), _dec$L(_class$L = _dec2$F(_class$L = _dec3$D(_class$L = executeInEditMode(_class$L = (_class2$B = (_temp$E = class Billboard extends Component {
              get texture() {
                return this._texture;
              }

              set texture(val) {
                this._texture = val;

                if (this._material) {
                  this._material.setProperty('mainTexture', val);
                }
              }

              get height() {
                return this._height;
              }

              set height(val) {
                this._height = val;

                if (this._material) {
                  this._uniform.y = val;

                  this._material.setProperty('cc_size_rotation', this._uniform);
                }
              }

              get width() {
                return this._width;
              }

              set width(val) {
                this._width = val;

                if (this._material) {
                  this._uniform.x = val;

                  this._material.setProperty('cc_size_rotation', this._uniform);
                }
              }

              get rotation() {
                return Math.round(toDegree(this._rotation) * 100) / 100;
              }

              set rotation(val) {
                this._rotation = toRadian(val);

                if (this._material) {
                  this._uniform.z = this._rotation;

                  this._material.setProperty('cc_size_rotation', this._uniform);
                }
              }

              constructor() {
                super();

                _initializerDefineProperty(this, "_texture", _descriptor$A, this);

                _initializerDefineProperty(this, "_height", _descriptor2$x, this);

                _initializerDefineProperty(this, "_width", _descriptor3$q, this);

                _initializerDefineProperty(this, "_rotation", _descriptor4$o, this);

                this._model = null;
                this._mesh = null;
                this._material = null;
                this._uniform = new Vec4(1, 1, 0, 0);
              }

              onLoad() {
                this.createModel();
              }

              onEnable() {
                this.attachToScene();
                this._model.enabled = true;
                this.width = this._width;
                this.height = this._height;
                this.rotation = this.rotation;
                this.texture = this.texture;
              }

              onDisable() {
                this.detachFromScene();
              }

              attachToScene() {
                if (this._model && this.node && this.node.scene) {
                  if (this._model.scene) {
                    this.detachFromScene();
                  }

                  this._getRenderScene().addModel(this._model);
                }
              }

              detachFromScene() {
                if (this._model && this._model.scene) {
                  this._model.scene.removeModel(this._model);
                }
              }

              createModel() {
                this._mesh = createMesh({
                  primitiveMode: PrimitiveMode.TRIANGLE_LIST,
                  positions: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  uvs: [0, 0, 1, 0, 0, 1, 1, 1],
                  colors: [Color$1.WHITE.r, Color$1.WHITE.g, Color$1.WHITE.b, Color$1.WHITE.a, Color$1.WHITE.r, Color$1.WHITE.g, Color$1.WHITE.b, Color$1.WHITE.a, Color$1.WHITE.r, Color$1.WHITE.g, Color$1.WHITE.b, Color$1.WHITE.a, Color$1.WHITE.r, Color$1.WHITE.g, Color$1.WHITE.b, Color$1.WHITE.a],
                  attributes: [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA8UI, true)],
                  indices: [0, 1, 2, 1, 2, 3]
                }, undefined, {
                  calculateBounds: false
                });
                const model = this._model = legacyCC.director.root.createModel(Model, this.node);
                model.node = model.transform = this.node;

                if (this._material == null) {
                  this._material = new Material();

                  this._material.copy(builtinResMgr.get('default-billboard-material'));
                }

                model.initSubModel(0, this._mesh.renderingSubMeshes[0], this._material);
              }

            }, _temp$E), (_descriptor$A = _applyDecoratedDescriptor(_class2$B.prototype, "_texture", [_dec4$B], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _applyDecoratedDescriptor(_class2$B.prototype, "texture", [_dec5$z, _dec6$v], Object.getOwnPropertyDescriptor(_class2$B.prototype, "texture"), _class2$B.prototype), _descriptor2$x = _applyDecoratedDescriptor(_class2$B.prototype, "_height", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _applyDecoratedDescriptor(_class2$B.prototype, "height", [_dec7$v], Object.getOwnPropertyDescriptor(_class2$B.prototype, "height"), _class2$B.prototype), _descriptor3$q = _applyDecoratedDescriptor(_class2$B.prototype, "_width", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _applyDecoratedDescriptor(_class2$B.prototype, "width", [_dec8$r], Object.getOwnPropertyDescriptor(_class2$B.prototype, "width"), _class2$B.prototype), _descriptor4$o = _applyDecoratedDescriptor(_class2$B.prototype, "_rotation", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _applyDecoratedDescriptor(_class2$B.prototype, "rotation", [_dec9$o], Object.getOwnPropertyDescriptor(_class2$B.prototype, "rotation"), _class2$B.prototype)), _class2$B)) || _class$L) || _class$L) || _class$L) || _class$L));

            const _vertex_attrs = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RGBA32F), new Attribute(AttributeName.ATTR_TEX_COORD1, Format.RGB32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA8, true)];

            const _temp_v1 = new Vec3();

            const _temp_v2 = new Vec3();

            class LineModel extends Model {
              constructor() {
                super();
                this._capacity = void 0;
                this._vertSize = 0;
                this._vBuffer = null;
                this._vertAttrsFloatCount = 0;
                this._vdataF32 = null;
                this._vdataUint32 = null;
                this._iaInfo = void 0;
                this._iaInfoBuffer = void 0;
                this._subMeshData = null;
                this._vertCount = 0;
                this._indexCount = 0;
                this._material = null;
                this.type = ModelType.LINE;
                this._capacity = 100;
                this._iaInfo = new IndirectBuffer([new DrawInfo()]);
                this._iaInfoBuffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.INDIRECT, MemoryUsageBit.DEVICE, DRAW_INFO_SIZE, DRAW_INFO_SIZE));
              }

              setCapacity(capacity) {
                this._capacity = capacity;
                this.createBuffer();
              }

              createBuffer() {
                this._vertSize = 0;

                for (const a of _vertex_attrs) {
                  a.offset = this._vertSize;
                  this._vertSize += FormatInfos[a.format].size;
                }

                this._vertAttrsFloatCount = this._vertSize / 4;
                this._vBuffer = this.createSubMeshData();
                this._vdataF32 = new Float32Array(this._vBuffer);
                this._vdataUint32 = new Uint32Array(this._vBuffer);
              }

              updateMaterial(mat) {
                this._material = mat;
                super.setSubModelMaterial(0, mat);
              }

              createSubMeshData() {
                if (this._subMeshData) {
                  this.destroySubMeshData();
                }

                this._vertCount = 2;
                this._indexCount = 6;

                const vertexBuffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, this._vertSize * this._capacity * this._vertCount, this._vertSize));

                const vBuffer = new ArrayBuffer(this._vertSize * this._capacity * this._vertCount);
                vertexBuffer.update(vBuffer);
                const indices = new Uint16Array((this._capacity - 1) * this._indexCount);
                let dst = 0;

                for (let i = 0; i < this._capacity - 1; ++i) {
                  const baseIdx = 2 * i;
                  indices[dst++] = baseIdx;
                  indices[dst++] = baseIdx + 1;
                  indices[dst++] = baseIdx + 2;
                  indices[dst++] = baseIdx + 3;
                  indices[dst++] = baseIdx + 2;
                  indices[dst++] = baseIdx + 1;
                }

                const indexBuffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, (this._capacity - 1) * this._indexCount * Uint16Array.BYTES_PER_ELEMENT, Uint16Array.BYTES_PER_ELEMENT));

                indexBuffer.update(indices);
                this._iaInfo.drawInfos[0].vertexCount = this._capacity * this._vertCount;
                this._iaInfo.drawInfos[0].indexCount = (this._capacity - 1) * this._indexCount;

                this._iaInfoBuffer.update(this._iaInfo);

                this._subMeshData = new RenderingSubMesh([vertexBuffer], _vertex_attrs, PrimitiveMode.TRIANGLE_LIST, indexBuffer, this._iaInfoBuffer);
                this.initSubModel(0, this._subMeshData, this._material);
                return vBuffer;
              }

              addLineVertexData(positions, width, color) {
                if (positions.length > 1) {
                  let offset = 0;
                  Vec3.subtract(_temp_v1, positions[1], positions[0]);
                  this._vdataF32[offset++] = positions[0].x;
                  this._vdataF32[offset++] = positions[0].y;
                  this._vdataF32[offset++] = positions[0].z;
                  this._vdataF32[offset++] = 0;
                  this._vdataF32[offset++] = width.evaluate(0, 1);
                  this._vdataF32[offset++] = 0;
                  this._vdataF32[offset++] = 0;
                  this._vdataF32[offset++] = _temp_v1.x;
                  this._vdataF32[offset++] = _temp_v1.y;
                  this._vdataF32[offset++] = _temp_v1.z;
                  this._vdataUint32[offset++] = color.evaluate(0, 1)._val;
                  this._vdataF32[offset++] = positions[0].x;
                  this._vdataF32[offset++] = positions[0].y;
                  this._vdataF32[offset++] = positions[0].z;
                  this._vdataF32[offset++] = 1;
                  this._vdataF32[offset++] = width.evaluate(0, 1);
                  this._vdataF32[offset++] = 0;
                  this._vdataF32[offset++] = 1;
                  this._vdataF32[offset++] = _temp_v1.x;
                  this._vdataF32[offset++] = _temp_v1.y;
                  this._vdataF32[offset++] = _temp_v1.z;
                  this._vdataUint32[offset++] = color.evaluate(0, 1)._val;

                  for (let i = 1; i < positions.length - 1; i++) {
                    Vec3.subtract(_temp_v1, positions[i - 1], positions[i]);
                    Vec3.subtract(_temp_v2, positions[i + 1], positions[i]);
                    Vec3.subtract(_temp_v2, _temp_v2, _temp_v1);
                    const seg = i / positions.length;
                    this._vdataF32[offset++] = positions[i].x;
                    this._vdataF32[offset++] = positions[i].y;
                    this._vdataF32[offset++] = positions[i].z;
                    this._vdataF32[offset++] = 0;
                    this._vdataF32[offset++] = width.evaluate(seg, 1);
                    this._vdataF32[offset++] = seg;
                    this._vdataF32[offset++] = 0;
                    this._vdataF32[offset++] = _temp_v2.x;
                    this._vdataF32[offset++] = _temp_v2.y;
                    this._vdataF32[offset++] = _temp_v2.z;
                    this._vdataUint32[offset++] = color.evaluate(seg, 1)._val;
                    this._vdataF32[offset++] = positions[i].x;
                    this._vdataF32[offset++] = positions[i].y;
                    this._vdataF32[offset++] = positions[i].z;
                    this._vdataF32[offset++] = 1;
                    this._vdataF32[offset++] = width.evaluate(seg, 1);
                    this._vdataF32[offset++] = seg;
                    this._vdataF32[offset++] = 1;
                    this._vdataF32[offset++] = _temp_v2.x;
                    this._vdataF32[offset++] = _temp_v2.y;
                    this._vdataF32[offset++] = _temp_v2.z;
                    this._vdataUint32[offset++] = color.evaluate(seg, 1)._val;
                  }

                  Vec3.subtract(_temp_v1, positions[positions.length - 1], positions[positions.length - 2]);
                  this._vdataF32[offset++] = positions[positions.length - 1].x;
                  this._vdataF32[offset++] = positions[positions.length - 1].y;
                  this._vdataF32[offset++] = positions[positions.length - 1].z;
                  this._vdataF32[offset++] = 0;
                  this._vdataF32[offset++] = width.evaluate(1, 1);
                  this._vdataF32[offset++] = 1;
                  this._vdataF32[offset++] = 0;
                  this._vdataF32[offset++] = _temp_v1.x;
                  this._vdataF32[offset++] = _temp_v1.y;
                  this._vdataF32[offset++] = _temp_v1.z;
                  this._vdataUint32[offset++] = color.evaluate(1, 1)._val;
                  this._vdataF32[offset++] = positions[positions.length - 1].x;
                  this._vdataF32[offset++] = positions[positions.length - 1].y;
                  this._vdataF32[offset++] = positions[positions.length - 1].z;
                  this._vdataF32[offset++] = 1;
                  this._vdataF32[offset++] = width.evaluate(1, 1);
                  this._vdataF32[offset++] = 1;
                  this._vdataF32[offset++] = 1;
                  this._vdataF32[offset++] = _temp_v1.x;
                  this._vdataF32[offset++] = _temp_v1.y;
                  this._vdataF32[offset++] = _temp_v1.z;
                  this._vdataUint32[offset++] = color.evaluate(1, 1)._val;
                }

                this.updateIA(Math.max(0, positions.length - 1));
              }

              updateIA(count) {
                const ia = this._subModels[0].inputAssembler;
                ia.vertexBuffers[0].update(this._vdataF32);
                this._iaInfo.drawInfos[0].firstIndex = 0;
                this._iaInfo.drawInfos[0].indexCount = this._indexCount * count;

                this._iaInfoBuffer.update(this._iaInfo);
              }

              destroySubMeshData() {
                if (this._subMeshData) {
                  this._subMeshData.destroy();

                  this._subMeshData = null;
                }
              }

            }

            var _dec$M, _dec2$G, _dec3$E, _dec4$C, _dec5$A, _class$M, _class2$C, _descriptor$B, _descriptor2$y, _descriptor3$r, _descriptor4$p, _descriptor5$k, _descriptor6$e, _descriptor7$c, _descriptor8$c, _class3$i, _temp$F;
            const SerializableTable = [['mode', 'constant', 'multiplier'], ['mode', 'spline', 'multiplier'], ['mode', 'splineMin', 'splineMax', 'multiplier'], ['mode', 'constantMin', 'constantMax', 'multiplier']];
            const Mode$1 = Enum({
              Constant: 0,
              Curve: 1,
              TwoCurves: 2,
              TwoConstants: 3
            });
            let CurveRange = exports('CurveRange', (_dec$M = ccclass('cc.CurveRange'), _dec2$G = type$1(Mode$1), _dec3$E = type$1(RealCurve), _dec4$C = type$1(RealCurve), _dec5$A = type$1(RealCurve), _dec$M(_class$M = (_class2$C = (_temp$F = _class3$i = class CurveRange {
              get curve() {
                return this._curve;
              }

              set curve(value) {
                this._curve = value;
                this.spline = value._internalCurve;
              }

              get curveMin() {
                return this._curveMin;
              }

              set curveMin(value) {
                this._curveMin = value;
                this.splineMin = value._internalCurve;
              }

              get curveMax() {
                return this._curveMax;
              }

              set curveMax(value) {
                this._curveMax = value;
                this.splineMax = value._internalCurve;
              }

              constructor() {
                _initializerDefineProperty(this, "mode", _descriptor$B, this);

                _initializerDefineProperty(this, "spline", _descriptor2$y, this);

                _initializerDefineProperty(this, "splineMin", _descriptor3$r, this);

                _initializerDefineProperty(this, "splineMax", _descriptor4$p, this);

                _initializerDefineProperty(this, "constant", _descriptor5$k, this);

                _initializerDefineProperty(this, "constantMin", _descriptor6$e, this);

                _initializerDefineProperty(this, "constantMax", _descriptor7$c, this);

                _initializerDefineProperty(this, "multiplier", _descriptor8$c, this);

                this._curve = new AnimationCurve(this.spline);
                this._curveMin = new AnimationCurve(this.splineMin);
                this._curveMax = new AnimationCurve(this.splineMax);
              }

              evaluate(time, rndRatio) {
                switch (this.mode) {
                  default:
                  case Mode$1.Constant:
                    return this.constant;

                  case Mode$1.Curve:
                    return this.spline.evaluate(time) * this.multiplier;

                  case Mode$1.TwoCurves:
                    return lerp(this.splineMin.evaluate(time), this.splineMax.evaluate(time), rndRatio) * this.multiplier;

                  case Mode$1.TwoConstants:
                    return lerp(this.constantMin, this.constantMax, rndRatio);
                }
              }

              getMax() {
                switch (this.mode) {
                  default:
                  case Mode$1.Constant:
                    return this.constant;

                  case Mode$1.Curve:
                    return this.multiplier;

                  case Mode$1.TwoConstants:
                    return this.constantMax;

                  case Mode$1.TwoCurves:
                    return this.multiplier;
                }
              }

              _onBeforeSerialize(props) {
                return SerializableTable[this.mode];
              }

            }, _class3$i.Mode = Mode$1, _temp$F), (_descriptor$B = _applyDecoratedDescriptor(_class2$C.prototype, "mode", [_dec2$G], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Mode$1.Constant;
              }
            }), _descriptor2$y = _applyDecoratedDescriptor(_class2$C.prototype, "spline", [_dec3$E], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return constructLegacyCurveAndConvert();
              }
            }), _descriptor3$r = _applyDecoratedDescriptor(_class2$C.prototype, "splineMin", [_dec4$C], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return constructLegacyCurveAndConvert();
              }
            }), _descriptor4$p = _applyDecoratedDescriptor(_class2$C.prototype, "splineMax", [_dec5$A], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return constructLegacyCurveAndConvert();
              }
            }), _descriptor5$k = _applyDecoratedDescriptor(_class2$C.prototype, "constant", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor6$e = _applyDecoratedDescriptor(_class2$C.prototype, "constantMin", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor7$c = _applyDecoratedDescriptor(_class2$C.prototype, "constantMax", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor8$c = _applyDecoratedDescriptor(_class2$C.prototype, "multiplier", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            })), _class2$C)) || _class$M));

            function evaluateCurve(cr, time, index) {
              switch (cr.mode) {
                case Mode$1.Constant:
                  return cr.constant;

                case Mode$1.Curve:
                  return cr.spline.evaluate(time) * cr.multiplier;

                case Mode$1.TwoCurves:
                  return index === 0 ? cr.splineMin.evaluate(time) * cr.multiplier : cr.splineMax.evaluate(time) * cr.multiplier;

                case Mode$1.TwoConstants:
                  return index === 0 ? cr.constantMin : cr.constantMax;

                default:
                  return 0;
              }
            }

            function evaluateHeight(cr) {
              switch (cr.mode) {
                case Mode$1.TwoConstants:
                  return 2;

                case Mode$1.TwoCurves:
                  return 2;

                default:
                  return 1;
              }
            }

            function packTexture(data, width, height) {
              const image = new ImageAsset({
                width,
                height,
                _data: data,
                _compressed: false,
                format: PixelFormat.RGBA32F
              });
              const texture = new Texture2D();
              texture.setFilters(Filter$1.NEAREST, Filter$1.NEAREST);
              texture.setMipFilter(Filter$1.NONE);
              texture.setWrapMode(WrapMode.CLAMP_TO_EDGE, WrapMode.CLAMP_TO_EDGE, WrapMode.CLAMP_TO_EDGE);
              texture.image = image;
              return texture;
            }

            function packCurveRangeZ(samples, cr, discrete) {
              const height = evaluateHeight(cr);
              const data = new Float32Array(samples * height * 4);
              const interval = 1.0 / (samples - 1);
              let offset = 0;

              for (let h = 0; h < height; h++) {

                for (let j = 0; j < samples; j++) {
                  const value = evaluateCurve(cr, interval * j, h);

                  data[offset + 2] = value;
                  offset += 4;
                }
              }

              return packTexture(data, samples, height);
            }
            function packCurveRangeN(samples, cr, discrete) {
              const height = evaluateHeight(cr);
              const data = new Float32Array(samples * height * 4);
              const interval = 1.0 / (samples - 1);
              let sum = 0;
              let average = 0;
              let offset = 0;

              for (let h = 0; h < height; h++) {
                sum = 0;

                for (let j = 0; j < samples; j++) {
                  const value = evaluateCurve(cr, interval * j, h);

                  if (discrete) {
                    average = value;
                  } else {
                    sum += value;
                    average = sum / (j + 1);
                  }

                  data[offset] = average;
                  data[offset + 1] = average;
                  data[offset + 2] = average;
                  offset += 4;
                }
              }

              return packTexture(data, samples, height);
            }
            function packCurveRangeXY(samples, x, y, discrete) {
              const height = Math.max(evaluateHeight(x), evaluateHeight(y));
              const data = new Float32Array(samples * height * 4);
              const curves = [x, y];
              const interval = 1.0 / (samples - 1);

              for (let h = 0; h < height; h++) {
                for (let i = 0; i < 2; i++) {
                  const cr = curves[i];
                  let sum = 0;
                  let average = 0;

                  for (let j = 0; j < samples; j++) {
                    const value = evaluateCurve(cr, interval * j, h);

                    if (discrete) {
                      average = value;
                    } else {
                      sum += value;
                      average = sum / (j + 1);
                    }

                    data[j * 4 + i] = average;
                  }
                }
              }

              return packTexture(data, samples, height);
            }
            function packCurveRangeXYZ(samples, x, y, z, discrete) {
              const height = Math.max(evaluateHeight(x), evaluateHeight(y), evaluateHeight(z));
              const data = new Float32Array(samples * height * 4);
              const curves = [x, y, z];
              const interval = 1.0 / (samples - 1);

              for (let h = 0; h < height; h++) {
                for (let i = 0; i < 3; i++) {
                  const cr = curves[i];
                  let sum = 0;
                  let average = 0;

                  for (let j = 0; j < samples; j++) {
                    const value = evaluateCurve(cr, interval * j, h);

                    if (discrete) {
                      average = value;
                    } else {
                      sum += value;
                      average = sum / (j + 1);
                    }

                    data[j * 4 + i] = average;
                  }
                }
              }

              return packTexture(data, samples, height);
            }
            function packCurveRangeXYZW(samples, x, y, z, w, discrete) {
              const height = Math.max(evaluateHeight(x), evaluateHeight(y), evaluateHeight(z), evaluateHeight(w));
              const data = new Float32Array(samples * height * 4);
              const curves = [x, y, z, w];
              const interval = 1.0 / (samples - 1);

              for (let h = 0; h < height; h++) {
                for (let i = 0; i < 4; i++) {
                  const cr = curves[i];
                  let sum = 0;
                  let average = 0;

                  for (let j = 0; j < samples; j++) {
                    const value = evaluateCurve(cr, interval * j, h);

                    if (discrete) {
                      average = value;
                    } else {
                      sum += value;
                      average = sum / (j + 1);
                    }

                    data[j * 4 + i] = average;
                  }
                }
              }

              return packTexture(data, samples, height);
            }

            var _dec$N, _class$N, _class2$D, _descriptor$C, _descriptor2$z, _temp$G, _dec2$H, _class4$4, _class5$4, _descriptor3$s, _descriptor4$q, _temp2$4, _dec3$F, _class7, _class8, _descriptor5$l, _descriptor6$f, _descriptor7$d, _class9, _temp3;
            const Mode$2 = Enum({
              Blend: 0,
              Fixed: 1
            });
            let ColorKey = exports('ColorKey', (_dec$N = ccclass('cc.ColorKey'), _dec$N(_class$N = (_class2$D = (_temp$G = class ColorKey {
              constructor() {
                _initializerDefineProperty(this, "color", _descriptor$C, this);

                _initializerDefineProperty(this, "time", _descriptor2$z, this);
              }

            }, _temp$G), (_descriptor$C = _applyDecoratedDescriptor(_class2$D.prototype, "color", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Color$1.WHITE.clone();
              }
            }), _descriptor2$z = _applyDecoratedDescriptor(_class2$D.prototype, "time", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            })), _class2$D)) || _class$N));
            let AlphaKey = exports('AlphaKey', (_dec2$H = ccclass('cc.AlphaKey'), _dec2$H(_class4$4 = (_class5$4 = (_temp2$4 = class AlphaKey {
              constructor() {
                _initializerDefineProperty(this, "alpha", _descriptor3$s, this);

                _initializerDefineProperty(this, "time", _descriptor4$q, this);
              }

            }, _temp2$4), (_descriptor3$s = _applyDecoratedDescriptor(_class5$4.prototype, "alpha", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            }), _descriptor4$q = _applyDecoratedDescriptor(_class5$4.prototype, "time", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            })), _class5$4)) || _class4$4));
            let Gradient = exports('Gradient', (_dec3$F = ccclass('cc.Gradient'), _dec3$F(_class7 = (_class8 = (_temp3 = _class9 = class Gradient {
              constructor() {
                _initializerDefineProperty(this, "colorKeys", _descriptor5$l, this);

                _initializerDefineProperty(this, "alphaKeys", _descriptor6$f, this);

                _initializerDefineProperty(this, "mode", _descriptor7$d, this);

                this._color = void 0;
                this._color = Color$1.WHITE.clone();
              }

              setKeys(colorKeys, alphaKeys) {
                this.colorKeys = colorKeys;
                this.alphaKeys = alphaKeys;
              }

              sortKeys() {
                if (this.colorKeys.length > 1) {
                  this.colorKeys.sort((a, b) => a.time - b.time);
                }

                if (this.alphaKeys.length > 1) {
                  this.alphaKeys.sort((a, b) => a.time - b.time);
                }
              }

              evaluate(time) {
                this.getRGB(time);

                this._color._set_a_unsafe(this.getAlpha(time));

                return this._color;
              }

              randomColor() {
                const c = this.colorKeys[Math.trunc(Math.random() * this.colorKeys.length)];
                const a = this.alphaKeys[Math.trunc(Math.random() * this.alphaKeys.length)];

                this._color.set(c.color);

                this._color._set_a_unsafe(a.alpha);

                return this._color;
              }

              getRGB(time) {
                if (this.colorKeys.length > 1) {
                  time = repeat$2(time, 1);

                  for (let i = 1; i < this.colorKeys.length; ++i) {
                    const preTime = this.colorKeys[i - 1].time;
                    const curTime = this.colorKeys[i].time;

                    if (time >= preTime && time < curTime) {
                      if (this.mode === Mode$2.Fixed) {
                        return this.colorKeys[i].color;
                      }

                      const factor = (time - preTime) / (curTime - preTime);
                      Color$1.lerp(this._color, this.colorKeys[i - 1].color, this.colorKeys[i].color, factor);
                      return this._color;
                    }
                  }

                  const lastIndex = this.colorKeys.length - 1;

                  if (time < this.colorKeys[0].time) {
                    Color$1.lerp(this._color, Color$1.BLACK, this.colorKeys[0].color, time / this.colorKeys[0].time);
                  } else if (time > this.colorKeys[lastIndex].time) {
                    Color$1.lerp(this._color, this.colorKeys[lastIndex].color, Color$1.BLACK, (time - this.colorKeys[lastIndex].time) / (1 - this.colorKeys[lastIndex].time));
                  }
                } else if (this.colorKeys.length === 1) {
                  this._color.set(this.colorKeys[0].color);

                  return this._color;
                } else {
                  this._color.set(Color$1.WHITE);

                  return this._color;
                }
              }

              getAlpha(time) {
                const basicAlpha = 0;

                if (this.alphaKeys.length > 1) {
                  time = repeat$2(time, 1);

                  for (let i = 1; i < this.alphaKeys.length; ++i) {
                    const preTime = this.alphaKeys[i - 1].time;
                    const curTime = this.alphaKeys[i].time;

                    if (time >= preTime && time < curTime) {
                      if (this.mode === Mode$2.Fixed) {
                        return this.alphaKeys[i].alpha;
                      }

                      const factor = (time - preTime) / (curTime - preTime);
                      return lerp(this.alphaKeys[i - 1].alpha, this.alphaKeys[i].alpha, factor);
                    }
                  }

                  const lastIndex = this.alphaKeys.length - 1;

                  if (time < this.alphaKeys[0].time) {
                    return lerp(basicAlpha, this.alphaKeys[0].alpha, time / this.alphaKeys[0].time);
                  } else if (time > this.alphaKeys[lastIndex].time) {
                    return lerp(this.alphaKeys[lastIndex].alpha, basicAlpha, (time - this.alphaKeys[lastIndex].time) / (1 - this.alphaKeys[lastIndex].time));
                  }
                } else if (this.alphaKeys.length === 1) {
                  return this.alphaKeys[0].alpha;
                } else {
                  return 255;
                }
              }

            }, _class9.Mode = Mode$2, _temp3), (_descriptor5$l = _applyDecoratedDescriptor(_class8.prototype, "colorKeys", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Array();
              }
            }), _descriptor6$f = _applyDecoratedDescriptor(_class8.prototype, "alphaKeys", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Array();
              }
            }), _descriptor7$d = _applyDecoratedDescriptor(_class8.prototype, "mode", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Mode$2.Blend;
              }
            })), _class8)) || _class7));

            var _dec$O, _dec2$I, _dec3$G, _dec4$D, _dec5$B, _dec6$w, _class$O, _class2$E, _descriptor$D, _descriptor2$A, _descriptor3$t, _descriptor4$r, _descriptor5$m, _descriptor6$g, _descriptor7$e, _class3$j, _temp$H;
            const SerializableTable$1 = EDITOR ;
            const Mode$3 = Enum({
              Color: 0,
              Gradient: 1,
              TwoColors: 2,
              TwoGradients: 3,
              RandomColor: 4
            });
            let GradientRange = exports('GradientRange', (_dec$O = ccclass('cc.GradientRange'), _dec2$I = type$1(Mode$3), _dec3$G = type$1(Gradient), _dec4$D = type$1(Gradient), _dec5$B = type$1(Gradient), _dec6$w = type$1(Mode$3), _dec$O(_class$O = (_class2$E = (_temp$H = _class3$j = class GradientRange {
              constructor() {
                _initializerDefineProperty(this, "color", _descriptor$D, this);

                _initializerDefineProperty(this, "colorMin", _descriptor2$A, this);

                _initializerDefineProperty(this, "colorMax", _descriptor3$t, this);

                _initializerDefineProperty(this, "gradient", _descriptor4$r, this);

                _initializerDefineProperty(this, "gradientMin", _descriptor5$m, this);

                _initializerDefineProperty(this, "gradientMax", _descriptor6$g, this);

                _initializerDefineProperty(this, "_mode", _descriptor7$e, this);

                this._color = Color$1.WHITE.clone();
              }

              get mode() {
                return this._mode;
              }

              set mode(m) {

                this._mode = m;
              }

              evaluate(time, rndRatio) {
                switch (this._mode) {
                  case Mode$3.Color:
                    return this.color;

                  case Mode$3.TwoColors:
                    Color$1.lerp(this._color, this.colorMin, this.colorMax, rndRatio);
                    return this._color;

                  case Mode$3.RandomColor:
                    return this.gradient.randomColor();

                  case Mode$3.Gradient:
                    return this.gradient.evaluate(time);

                  case Mode$3.TwoGradients:
                    Color$1.lerp(this._color, this.gradientMin.evaluate(time), this.gradientMax.evaluate(time), rndRatio);
                    return this._color;

                  default:
                    return this.color;
                }
              }

              _onBeforeSerialize(props) {
                return SerializableTable$1[this._mode];
              }

            }, _class3$j.Mode = Mode$3, _temp$H), (_applyDecoratedDescriptor(_class2$E.prototype, "mode", [_dec2$I], Object.getOwnPropertyDescriptor(_class2$E.prototype, "mode"), _class2$E.prototype), _descriptor$D = _applyDecoratedDescriptor(_class2$E.prototype, "color", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Color$1.WHITE.clone();
              }
            }), _descriptor2$A = _applyDecoratedDescriptor(_class2$E.prototype, "colorMin", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Color$1.WHITE.clone();
              }
            }), _descriptor3$t = _applyDecoratedDescriptor(_class2$E.prototype, "colorMax", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Color$1.WHITE.clone();
              }
            }), _descriptor4$r = _applyDecoratedDescriptor(_class2$E.prototype, "gradient", [_dec3$G], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Gradient();
              }
            }), _descriptor5$m = _applyDecoratedDescriptor(_class2$E.prototype, "gradientMin", [_dec4$D], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Gradient();
              }
            }), _descriptor6$g = _applyDecoratedDescriptor(_class2$E.prototype, "gradientMax", [_dec5$B], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Gradient();
              }
            }), _descriptor7$e = _applyDecoratedDescriptor(_class2$E.prototype, "_mode", [_dec6$w], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Mode$3.Color;
              }
            })), _class2$E)) || _class$O));

            function evaluateGradient(gr, time, index) {
              switch (gr.mode) {
                case Mode$3.Color:
                  return gr.color;

                case Mode$3.TwoColors:
                  return index === 0 ? gr.colorMin : gr.colorMax;

                case Mode$3.RandomColor:
                  return gr.gradient.randomColor();

                case Mode$3.Gradient:
                  return gr.gradient.evaluate(time);

                case Mode$3.TwoGradients:
                  return index === 0 ? gr.gradientMin.evaluate(time) : gr.gradientMax.evaluate(time);

                default:
                  return gr.color;
              }
            }

            function evaluateHeight$1(gr) {
              switch (gr.mode) {
                case Mode$3.TwoColors:
                  return 2;

                case Mode$3.TwoGradients:
                  return 2;

                default:
                  return 1;
              }
            }

            function packGradientRange(samples, gr) {
              const height = evaluateHeight$1(gr);
              const data = new Uint8Array(samples * height * 4);
              const interval = 1.0 / (samples - 1);
              let offset = 0;

              for (let h = 0; h < height; h++) {
                for (let j = 0; j < samples; j++) {
                  const color = evaluateGradient(gr, interval * j, h);
                  data[offset] = color.r;
                  data[offset + 1] = color.g;
                  data[offset + 2] = color.b;
                  data[offset + 3] = color.a;
                  offset += 4;
                }
              }

              const texture = new Texture2D();
              texture.create(samples, height, PixelFormat.RGBA8888);
              texture.setFilters(Filter$1.LINEAR, Filter$1.LINEAR);
              texture.setWrapMode(WrapMode.CLAMP_TO_EDGE, WrapMode.CLAMP_TO_EDGE);
              texture.uploadData(data);
              return texture;
            }

            var _dec$P, _dec2$J, _dec3$H, _dec4$E, _dec5$C, _dec6$x, _dec7$w, _dec8$s, _dec9$p, _dec10$n, _dec11$k, _dec12$j, _dec13$g, _dec14$c, _dec15$c, _dec16$b, _dec17$9, _dec18$9, _dec19$9, _dec20$8, _dec21$8, _dec22$8, _dec23$8, _dec24$7, _dec25$7, _dec26$7, _dec27$7, _dec28$6, _class$P, _class2$F, _descriptor$E, _descriptor2$B, _descriptor3$u, _descriptor4$s, _descriptor5$n, _descriptor6$h, _descriptor7$f, _temp$I;
            const _matInsInfo = {
              parent: null,
              owner: null,
              subModelIdx: 0
            };
            const CC_USE_WORLD_SPACE = 'CC_USE_WORLD_SPACE';
            const define = {
              CC_USE_WORLD_SPACE: false
            };
            let Line = function (v) { return exports({ Line: v, LineComponent: v }), v; }((_dec$P = ccclass('cc.Line'), _dec2$J = help(), _dec3$H = menu$1(), _dec4$E = type$1(Texture2D), _dec5$C = type$1(Texture2D), _dec6$x = displayOrder(), _dec7$w = tooltip(), _dec8$s = displayOrder(), _dec9$p = tooltip(), _dec10$n = type$1([Vec3]), _dec11$k = type$1([Vec3]), _dec12$j = displayOrder(), _dec13$g = tooltip(), _dec14$c = type$1(CurveRange), _dec15$c = type$1(CurveRange), _dec16$b = range(), _dec17$9 = displayOrder(), _dec18$9 = tooltip(), _dec19$9 = type$1(Vec2), _dec20$8 = displayOrder(), _dec21$8 = tooltip(), _dec22$8 = type$1(Vec2), _dec23$8 = displayOrder(), _dec24$7 = tooltip(), _dec25$7 = type$1(GradientRange), _dec26$7 = type$1(GradientRange), _dec27$7 = displayOrder(), _dec28$6 = tooltip(), _dec$P(_class$P = _dec2$J(_class$P = _dec3$H(_class$P = executeInEditMode(_class$P = (_class2$F = (_temp$I = class Line extends Component {
              get texture() {
                return this._texture;
              }

              set texture(val) {
                this._texture = val;

                if (this._materialInstance) {
                  this._materialInstance.setProperty('mainTexture', val);
                }
              }

              get worldSpace() {
                return this._worldSpace;
              }

              set worldSpace(val) {
                this._worldSpace = val;

                if (this._materialInstance) {
                  define[CC_USE_WORLD_SPACE] = this.worldSpace;

                  this._materialInstance.recompileShaders(define);

                  if (this._model) {
                    this._model.setSubModelMaterial(0, this._materialInstance);
                  }
                }
              }

              get positions() {
                return this._positions;
              }

              set positions(val) {
                this._positions = val;

                if (this._model) {
                  this._model.addLineVertexData(this._positions, this._width, this._color);
                }
              }

              get width() {
                return this._width;
              }

              set width(val) {
                this._width = val;

                if (this._model) {
                  this._model.addLineVertexData(this._positions, this._width, this._color);
                }
              }

              get tile() {
                return this._tile;
              }

              set tile(val) {
                this._tile.set(val);

                if (this._materialInstance) {
                  this._tile_offset.x = this._tile.x;
                  this._tile_offset.y = this._tile.y;

                  this._materialInstance.setProperty('mainTiling_Offset', this._tile_offset);
                }
              }

              get offset() {
                return this._offset;
              }

              set offset(val) {
                this._offset.set(val);

                if (this._materialInstance) {
                  this._tile_offset.z = this._offset.x;
                  this._tile_offset.w = this._offset.y;

                  this._materialInstance.setProperty('mainTiling_Offset', this._tile_offset);
                }
              }

              get color() {
                return this._color;
              }

              set color(val) {
                this._color = val;

                if (this._model) {
                  this._model.addLineVertexData(this._positions, this._width, this._color);
                }
              }

              constructor() {
                super();

                _initializerDefineProperty(this, "_texture", _descriptor$E, this);

                this._material = null;
                this._materialInstance = null;

                _initializerDefineProperty(this, "_worldSpace", _descriptor2$B, this);

                _initializerDefineProperty(this, "_positions", _descriptor3$u, this);

                _initializerDefineProperty(this, "_width", _descriptor4$s, this);

                _initializerDefineProperty(this, "_tile", _descriptor5$n, this);

                _initializerDefineProperty(this, "_offset", _descriptor6$h, this);

                _initializerDefineProperty(this, "_color", _descriptor7$f, this);

                this._model = null;
                this._tile_offset = new Vec4();
              }

              onLoad() {
                const model = this._model = legacyCC.director.root.createModel(LineModel);
                model.node = model.transform = this.node;

                if (this._material === null) {
                  this._material = new Material();

                  this._material.copy(builtinResMgr.get('default-trail-material'));

                  define[CC_USE_WORLD_SPACE] = this.worldSpace;
                  _matInsInfo.parent = this._material;
                  _matInsInfo.subModelIdx = 0;
                  this._materialInstance = new MaterialInstance(_matInsInfo);
                  _matInsInfo.parent = null;
                  _matInsInfo.subModelIdx = 0;

                  this._materialInstance.recompileShaders(define);
                }

                model.updateMaterial(this._materialInstance);
                model.setCapacity(100);
              }

              onEnable() {
                if (!this._model) {
                  return;
                }

                this._attachToScene();

                this.texture = this._texture;
                this.tile = this._tile;
                this.offset = this._offset;

                this._model.addLineVertexData(this._positions, this._width, this._color);
              }

              onDisable() {
                if (this._model) {
                  this._detachFromScene();
                }
              }

              _attachToScene() {
                if (this._model && this.node && this.node.scene) {
                  if (this._model.scene) {
                    this._detachFromScene();
                  }

                  this._getRenderScene().addModel(this._model);
                }
              }

              _detachFromScene() {
                if (this._model && this._model.scene) {
                  this._model.scene.removeModel(this._model);
                }
              }

            }, _temp$I), (_descriptor$E = _applyDecoratedDescriptor(_class2$F.prototype, "_texture", [_dec4$E], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _applyDecoratedDescriptor(_class2$F.prototype, "texture", [_dec5$C, _dec6$x, _dec7$w], Object.getOwnPropertyDescriptor(_class2$F.prototype, "texture"), _class2$F.prototype), _descriptor2$B = _applyDecoratedDescriptor(_class2$F.prototype, "_worldSpace", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _applyDecoratedDescriptor(_class2$F.prototype, "worldSpace", [_dec8$s, _dec9$p], Object.getOwnPropertyDescriptor(_class2$F.prototype, "worldSpace"), _class2$F.prototype), _descriptor3$u = _applyDecoratedDescriptor(_class2$F.prototype, "_positions", [_dec10$n], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _applyDecoratedDescriptor(_class2$F.prototype, "positions", [_dec11$k, _dec12$j, _dec13$g], Object.getOwnPropertyDescriptor(_class2$F.prototype, "positions"), _class2$F.prototype), _descriptor4$s = _applyDecoratedDescriptor(_class2$F.prototype, "_width", [_dec14$c], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new CurveRange();
              }
            }), _applyDecoratedDescriptor(_class2$F.prototype, "width", [_dec15$c, _dec16$b, _dec17$9, _dec18$9], Object.getOwnPropertyDescriptor(_class2$F.prototype, "width"), _class2$F.prototype), _descriptor5$n = _applyDecoratedDescriptor(_class2$F.prototype, "_tile", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec2(1, 1);
              }
            }), _applyDecoratedDescriptor(_class2$F.prototype, "tile", [_dec19$9, _dec20$8, _dec21$8], Object.getOwnPropertyDescriptor(_class2$F.prototype, "tile"), _class2$F.prototype), _descriptor6$h = _applyDecoratedDescriptor(_class2$F.prototype, "_offset", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec2(0, 0);
              }
            }), _applyDecoratedDescriptor(_class2$F.prototype, "offset", [_dec22$8, _dec23$8, _dec24$7], Object.getOwnPropertyDescriptor(_class2$F.prototype, "offset"), _class2$F.prototype), _descriptor7$f = _applyDecoratedDescriptor(_class2$F.prototype, "_color", [_dec25$7], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new GradientRange();
              }
            }), _applyDecoratedDescriptor(_class2$F.prototype, "color", [_dec26$7, _dec27$7, _dec28$6], Object.getOwnPropertyDescriptor(_class2$F.prototype, "color"), _class2$F.prototype)), _class2$F)) || _class$P) || _class$P) || _class$P) || _class$P));

            class Particle {
              constructor(particleSystem) {
                this.particleSystem = void 0;
                this.position = void 0;
                this.velocity = void 0;
                this.animatedVelocity = void 0;
                this.ultimateVelocity = void 0;
                this.angularVelocity = void 0;
                this.axisOfRotation = void 0;
                this.rotation = void 0;
                this.startEuler = void 0;
                this.startRotation = void 0;
                this.startRotated = void 0;
                this.deltaQuat = void 0;
                this.deltaMat = void 0;
                this.localMat = void 0;
                this.startSize = void 0;
                this.size = void 0;
                this.startColor = void 0;
                this.color = void 0;
                this.randomSeed = void 0;
                this.remainingLifetime = void 0;
                this.loopCount = void 0;
                this.lastLoop = void 0;
                this.trailDelay = void 0;
                this.startLifetime = void 0;
                this.emitAccumulator0 = void 0;
                this.emitAccumulator1 = void 0;
                this.frameIndex = void 0;
                this.startRow = void 0;
                this.particleSystem = particleSystem;
                this.position = new Vec3(0, 0, 0);
                this.velocity = new Vec3(0, 0, 0);
                this.animatedVelocity = new Vec3(0, 0, 0);
                this.ultimateVelocity = new Vec3(0, 0, 0);
                this.angularVelocity = new Vec3(0, 0, 0);
                this.axisOfRotation = new Vec3(0, 0, 0);
                this.rotation = new Vec3(0, 0, 0);
                this.startEuler = new Vec3(0, 0, 0);
                this.startRotation = new Quat();
                this.startRotated = false;
                this.deltaQuat = new Quat();
                this.deltaMat = new Mat4();
                this.localMat = new Mat4();
                this.startSize = new Vec3(0, 0, 0);
                this.size = new Vec3(0, 0, 0);
                this.startColor = Color$1.WHITE.clone();
                this.color = Color$1.WHITE.clone();
                this.randomSeed = 0;
                this.remainingLifetime = 0.0;
                this.loopCount = 0;
                this.lastLoop = 0;
                this.trailDelay = 0;
                this.startLifetime = 0.0;
                this.emitAccumulator0 = 0.0;
                this.emitAccumulator1 = 0.0;
                this.frameIndex = 0.0;
                this.startRow = 0;
              }

              reset() {
                this.rotation.set(0, 0, 0);
                this.startEuler.set(0, 0, 0);
                this.startRotation.set(0, 0, 0, 1);
                this.startRotated = false;
                this.deltaQuat.set(0, 0, 0, 1);
                this.deltaMat.identity();
                this.localMat.identity();
              }

            }
            Particle.INDENTIFY_NEG_QUAT = 10;
            Particle.R2D = 180.0 / Math.PI;
            const PARTICLE_MODULE_NAME = {
              COLOR: 'colorModule',
              FORCE: 'forceModule',
              LIMIT: 'limitModule',
              ROTATION: 'rotationModule',
              SIZE: 'sizeModule',
              VELOCITY: 'velocityModule',
              TEXTURE: 'textureModule'
            };
            const PARTICLE_MODULE_ORDER = ['sizeModule', 'colorModule', 'forceModule', 'velocityModule', 'limitModule', 'rotationModule', 'textureModule'];
            const PARTICLE_MODULE_PROPERTY = ['_colorOverLifetimeModule', '_shapeModule', '_sizeOvertimeModule', '_velocityOvertimeModule', '_forceOvertimeModule', '_limitVelocityOvertimeModule', '_rotationOvertimeModule', '_textureAnimationModule', '_trailModule'];
            class ParticleModuleBase {
              constructor() {
                this.target = null;
                this.needUpdate = false;
                this.needAnimate = true;
                this.name = void 0;
              }

              bindTarget(target) {
                this.target = target;
              }

              update(space, trans) {}

            }

            const Space = Enum({
              World: 0,
              Local: 1,
              Custom: 2
            });
            const CullingMode = Enum({
              Pause: 0,
              PauseAndCatchup: 1,
              AlwaysSimulate: 2
            });
            const AlignmentSpace = Enum({
              World: 0,
              Local: 1,
              View: 2
            });
            const RenderMode$1 = Enum({
              Billboard: 0,
              StrecthedBillboard: 1,
              HorizontalBillboard: 2,
              VerticalBillboard: 3,
              Mesh: 4
            });
            const ShapeType = Enum({
              Box: 0,
              Circle: 1,
              Cone: 2,
              Sphere: 3,
              Hemisphere: 4
            });
            const EmitLocation = Enum({
              Base: 0,
              Edge: 1,
              Shell: 2,
              Volume: 3
            });
            const ArcMode = Enum({
              Random: 0,
              Loop: 1,
              PingPong: 2
            });
            const TrailMode = Enum({
              Particles: 0
            });
            const TextureMode = Enum({
              Stretch: 0
            });
            const ModuleRandSeed = {
              LIMIT: 23541,
              SIZE: 39825,
              TEXTURE: 90794,
              COLOR: 91041,
              FORCE: 212165,
              ROTATION: 125292,
              VELOCITY_X: 197866,
              VELOCITY_Y: 156497,
              VELOCITY_Z: 984136
            };

            var _dec$Q, _dec2$K, _dec3$I, _dec4$F, _class$Q, _class2$G, _descriptor$F, _descriptor2$C, _temp$J;
            const COLOR_OVERTIME_RAND_OFFSET = ModuleRandSeed.COLOR;
            let ColorOvertimeModule = (_dec$Q = ccclass('cc.ColorOvertimeModule'), _dec2$K = displayOrder(), _dec3$I = type$1(GradientRange), _dec4$F = displayOrder(), _dec$Q(_class$Q = (_class2$G = (_temp$J = class ColorOvertimeModule extends ParticleModuleBase {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "_enable", _descriptor$F, this);

                _initializerDefineProperty(this, "color", _descriptor2$C, this);

                this.name = PARTICLE_MODULE_NAME.COLOR;
              }

              get enable() {
                return this._enable;
              }

              set enable(val) {
                if (this._enable === val) return;
                this._enable = val;
                if (!this.target) return;
                this.target.enableModule(this.name, val, this);
              }

              animate(particle) {
                particle.color.set(particle.startColor);
                particle.color.multiply(this.color.evaluate(1.0 - particle.remainingLifetime / particle.startLifetime, pseudoRandom(particle.randomSeed + COLOR_OVERTIME_RAND_OFFSET)));
              }

            }, _temp$J), (_descriptor$F = _applyDecoratedDescriptor(_class2$G.prototype, "_enable", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _applyDecoratedDescriptor(_class2$G.prototype, "enable", [_dec2$K], Object.getOwnPropertyDescriptor(_class2$G.prototype, "enable"), _class2$G.prototype), _descriptor2$C = _applyDecoratedDescriptor(_class2$G.prototype, "color", [_dec3$I, serializable, _dec4$F], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new GradientRange();
              }
            })), _class2$G)) || _class$Q);

            const particleEmitZAxis = new Vec3(0, 0, -1);
            function calculateTransform(systemSpace, moduleSpace, worldTransform, outQuat) {
              if (moduleSpace !== systemSpace) {
                if (systemSpace === Space.World) {
                  Mat4.getRotation(outQuat, worldTransform);
                } else {
                  Mat4.invert(worldTransform, worldTransform);
                  Mat4.getRotation(outQuat, worldTransform);
                }

                return true;
              } else {
                Quat.set(outQuat, 0, 0, 0, 1);
                return false;
              }
            }
            function fixedAngleUnitVector2(out, theta) {
              Vec2.set(out, Math.cos(theta), Math.sin(theta));
            }
            function randomUnitVector(out) {
              const z = randomRange(-1, 1);
              const a = randomRange(0, 2 * Math.PI);
              const r = Math.sqrt(1 - z * z);
              const x = r * Math.cos(a);
              const y = r * Math.sin(a);
              Vec3.set(out, x, y, z);
            }
            function randomPointBetweenSphere(out, minRadius, maxRadius) {
              randomUnitVector(out);
              Vec3.multiplyScalar(out, out, minRadius + (maxRadius - minRadius) * random());
            }
            function randomPointBetweenCircleAtFixedAngle(out, minRadius, maxRadius, theta) {
              fixedAngleUnitVector2(out, theta);
              out.z = 0;
              Vec3.multiplyScalar(out, out, minRadius + (maxRadius - minRadius) * random());
            }
            function randomPointInCube(out, extents) {
              Vec3.set(out, randomRange(-extents.x, extents.x), randomRange(-extents.y, extents.y), randomRange(-extents.z, extents.z));
            }
            function randomSortArray(arr) {
              for (let i = 0; i < arr.length; i++) {
                const transpose = i + randomRangeInt(0, arr.length - i);
                const val = arr[transpose];
                arr[transpose] = arr[i];
                arr[i] = val;
              }
            }
            function randomSign() {
              let sgn = randomRange(-1, 1);

              if (sgn === 0) {
                sgn++;
              }

              return sign$1(sgn);
            }

            var _dec$R, _dec2$L, _dec3$J, _dec4$G, _dec5$D, _dec6$y, _dec7$x, _dec8$t, _dec9$q, _dec10$o, _dec11$l, _dec12$k, _dec13$h, _dec14$d, _dec15$d, _dec16$c, _dec17$a, _class$R, _class2$H, _descriptor$G, _descriptor2$D, _descriptor3$v, _descriptor4$t, _descriptor5$o, _temp$K;
            const FORCE_OVERTIME_RAND_OFFSET = ModuleRandSeed.FORCE;

            const _temp_v3 = new Vec3();

            let ForceOvertimeModule = (_dec$R = ccclass('cc.ForceOvertimeModule'), _dec2$L = displayOrder(), _dec3$J = type$1(CurveRange), _dec4$G = range(), _dec5$D = displayOrder(), _dec6$y = tooltip(), _dec7$x = type$1(CurveRange), _dec8$t = range(), _dec9$q = displayOrder(), _dec10$o = tooltip(), _dec11$l = type$1(CurveRange), _dec12$k = range(), _dec13$h = displayOrder(), _dec14$d = tooltip(), _dec15$d = type$1(Space), _dec16$c = displayOrder(), _dec17$a = tooltip(), _dec$R(_class$R = (_class2$H = (_temp$K = class ForceOvertimeModule extends ParticleModuleBase {
              get enable() {
                return this._enable;
              }

              set enable(val) {
                if (this._enable === val) return;
                this._enable = val;
                if (!this.target) return;
                this.target.enableModule(this.name, val, this);
              }

              constructor() {
                super();

                _initializerDefineProperty(this, "_enable", _descriptor$G, this);

                _initializerDefineProperty(this, "x", _descriptor2$D, this);

                _initializerDefineProperty(this, "y", _descriptor3$v, this);

                _initializerDefineProperty(this, "z", _descriptor4$t, this);

                _initializerDefineProperty(this, "space", _descriptor5$o, this);

                this.randomized = false;
                this.rotation = void 0;
                this.needTransform = void 0;
                this.name = PARTICLE_MODULE_NAME.FORCE;
                this.rotation = new Quat();
                this.needTransform = false;
                this.needUpdate = true;
              }

              update(space, worldTransform) {
                this.needTransform = calculateTransform(space, this.space, worldTransform, this.rotation);
              }

              animate(p, dt) {
                const normalizedTime = 1 - p.remainingLifetime / p.startLifetime;
                const force = Vec3.set(_temp_v3, this.x.evaluate(normalizedTime, pseudoRandom(p.randomSeed + FORCE_OVERTIME_RAND_OFFSET)), this.y.evaluate(normalizedTime, pseudoRandom(p.randomSeed + FORCE_OVERTIME_RAND_OFFSET)), this.z.evaluate(normalizedTime, pseudoRandom(p.randomSeed + FORCE_OVERTIME_RAND_OFFSET)));

                if (this.needTransform) {
                  Vec3.transformQuat(force, force, this.rotation);
                }

                Vec3.scaleAndAdd(p.velocity, p.velocity, force, dt);
                Vec3.copy(p.ultimateVelocity, p.velocity);
              }

            }, _temp$K), (_descriptor$G = _applyDecoratedDescriptor(_class2$H.prototype, "_enable", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _applyDecoratedDescriptor(_class2$H.prototype, "enable", [_dec2$L], Object.getOwnPropertyDescriptor(_class2$H.prototype, "enable"), _class2$H.prototype), _descriptor2$D = _applyDecoratedDescriptor(_class2$H.prototype, "x", [_dec3$J, serializable, _dec4$G, _dec5$D, _dec6$y], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new CurveRange();
              }
            }), _descriptor3$v = _applyDecoratedDescriptor(_class2$H.prototype, "y", [_dec7$x, serializable, _dec8$t, _dec9$q, _dec10$o], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new CurveRange();
              }
            }), _descriptor4$t = _applyDecoratedDescriptor(_class2$H.prototype, "z", [_dec11$l, serializable, _dec12$k, _dec13$h, _dec14$d], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new CurveRange();
              }
            }), _descriptor5$o = _applyDecoratedDescriptor(_class2$H.prototype, "space", [_dec15$d, serializable, _dec16$c, _dec17$a], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Space.Local;
              }
            })), _class2$H)) || _class$R);

            var _dec$S, _dec2$M, _dec3$K, _dec4$H, _dec5$E, _dec6$z, _dec7$y, _dec8$u, _dec9$r, _dec10$p, _dec11$m, _dec12$l, _dec13$i, _dec14$e, _dec15$e, _dec16$d, _dec17$b, _dec18$a, _dec19$a, _dec20$9, _dec21$9, _dec22$9, _dec23$9, _dec24$8, _dec25$8, _class$S, _class2$I, _descriptor$H, _descriptor2$E, _descriptor3$w, _descriptor4$u, _descriptor5$p, _descriptor6$i, _descriptor7$g, _descriptor8$d, _temp$L;
            const LIMIT_VELOCITY_RAND_OFFSET = ModuleRandSeed.LIMIT;

            const _temp_v3$1 = new Vec3();

            const _temp_v3_1 = new Vec3();

            let LimitVelocityOvertimeModule = (_dec$S = ccclass('cc.LimitVelocityOvertimeModule'), _dec2$M = displayOrder(), _dec3$K = type$1(CurveRange), _dec4$H = range(), _dec5$E = displayOrder(), _dec6$z = tooltip(), _dec7$y = type$1(CurveRange), _dec8$u = range(), _dec9$r = displayOrder(), _dec10$p = tooltip(), _dec11$m = type$1(CurveRange), _dec12$l = range(), _dec13$i = displayOrder(), _dec14$e = tooltip(), _dec15$e = type$1(CurveRange), _dec16$d = range(), _dec17$b = displayOrder(), _dec18$a = tooltip(), _dec19$a = displayOrder(), _dec20$9 = tooltip(), _dec21$9 = displayOrder(), _dec22$9 = tooltip(), _dec23$9 = type$1(Space), _dec24$8 = displayOrder(), _dec25$8 = tooltip(), _dec$S(_class$S = (_class2$I = (_temp$L = class LimitVelocityOvertimeModule extends ParticleModuleBase {
              get enable() {
                return this._enable;
              }

              set enable(val) {
                if (this._enable === val) return;
                this._enable = val;
                if (!this.target) return;
                this.target.enableModule(this.name, val, this);
              }

              constructor() {
                super();

                _initializerDefineProperty(this, "_enable", _descriptor$H, this);

                _initializerDefineProperty(this, "limitX", _descriptor2$E, this);

                _initializerDefineProperty(this, "limitY", _descriptor3$w, this);

                _initializerDefineProperty(this, "limitZ", _descriptor4$u, this);

                _initializerDefineProperty(this, "limit", _descriptor5$p, this);

                _initializerDefineProperty(this, "dampen", _descriptor6$i, this);

                _initializerDefineProperty(this, "separateAxes", _descriptor7$g, this);

                _initializerDefineProperty(this, "space", _descriptor8$d, this);

                this.drag = null;
                this.multiplyDragByParticleSize = false;
                this.multiplyDragByParticleVelocity = false;
                this.name = PARTICLE_MODULE_NAME.LIMIT;
                this.rotation = void 0;
                this.needTransform = void 0;
                this.rotation = new Quat();
                this.needTransform = false;
                this.needUpdate = true;
              }

              update(space, worldTransform) {
                this.needTransform = calculateTransform(space, this.space, worldTransform, this.rotation);
              }

              animate(p, dt) {
                const normalizedTime = 1 - p.remainingLifetime / p.startLifetime;
                const dampedVel = _temp_v3$1;

                if (this.separateAxes) {
                  Vec3.set(_temp_v3_1, this.limitX.evaluate(normalizedTime, pseudoRandom(p.randomSeed + LIMIT_VELOCITY_RAND_OFFSET)), this.limitY.evaluate(normalizedTime, pseudoRandom(p.randomSeed + LIMIT_VELOCITY_RAND_OFFSET)), this.limitZ.evaluate(normalizedTime, pseudoRandom(p.randomSeed + LIMIT_VELOCITY_RAND_OFFSET)));

                  if (this.needTransform) {
                    Vec3.transformQuat(_temp_v3_1, _temp_v3_1, this.rotation);
                  }

                  Vec3.set(dampedVel, dampenBeyondLimit(p.ultimateVelocity.x, _temp_v3_1.x, this.dampen), dampenBeyondLimit(p.ultimateVelocity.y, _temp_v3_1.y, this.dampen), dampenBeyondLimit(p.ultimateVelocity.z, _temp_v3_1.z, this.dampen));
                } else {
                  Vec3.normalize(dampedVel, p.ultimateVelocity);
                  Vec3.multiplyScalar(dampedVel, dampedVel, dampenBeyondLimit(p.ultimateVelocity.length(), this.limit.evaluate(normalizedTime, pseudoRandom(p.randomSeed + LIMIT_VELOCITY_RAND_OFFSET)), this.dampen));
                }

                Vec3.copy(p.ultimateVelocity, dampedVel);
              }

            }, _temp$L), (_descriptor$H = _applyDecoratedDescriptor(_class2$I.prototype, "_enable", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _applyDecoratedDescriptor(_class2$I.prototype, "enable", [_dec2$M], Object.getOwnPropertyDescriptor(_class2$I.prototype, "enable"), _class2$I.prototype), _descriptor2$E = _applyDecoratedDescriptor(_class2$I.prototype, "limitX", [_dec3$K, serializable, _dec4$H, _dec5$E, _dec6$z], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new CurveRange();
              }
            }), _descriptor3$w = _applyDecoratedDescriptor(_class2$I.prototype, "limitY", [_dec7$y, serializable, _dec8$u, _dec9$r, _dec10$p], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new CurveRange();
              }
            }), _descriptor4$u = _applyDecoratedDescriptor(_class2$I.prototype, "limitZ", [_dec11$m, serializable, _dec12$l, _dec13$i, _dec14$e], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new CurveRange();
              }
            }), _descriptor5$p = _applyDecoratedDescriptor(_class2$I.prototype, "limit", [_dec15$e, serializable, _dec16$d, _dec17$b, _dec18$a], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new CurveRange();
              }
            }), _descriptor6$i = _applyDecoratedDescriptor(_class2$I.prototype, "dampen", [serializable, _dec19$a, _dec20$9], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 3;
              }
            }), _descriptor7$g = _applyDecoratedDescriptor(_class2$I.prototype, "separateAxes", [serializable, _dec21$9, _dec22$9], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor8$d = _applyDecoratedDescriptor(_class2$I.prototype, "space", [_dec23$9, serializable, _dec24$8, _dec25$8], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Space.Local;
              }
            })), _class2$I)) || _class$S);

            function dampenBeyondLimit(vel, limit, dampen) {
              const sgn = Math.sign(vel);
              let abs = Math.abs(vel);

              if (abs > limit) {
                abs = lerp(abs, limit, dampen);
              }

              return abs * sgn;
            }

            var _dec$T, _dec2$N, _dec3$L, _dec4$I, _dec5$F, _dec6$A, _dec7$z, _dec8$v, _dec9$s, _dec10$q, _dec11$n, _dec12$m, _dec13$j, _dec14$f, _dec15$f, _dec16$e, _class$T, _class2$J, _descriptor$I, _descriptor2$F, _descriptor3$x, _descriptor4$v, _descriptor5$q, _temp$M;
            const ROTATION_OVERTIME_RAND_OFFSET = ModuleRandSeed.ROTATION;
            let RotationOvertimeModule = (_dec$T = ccclass('cc.RotationOvertimeModule'), _dec2$N = displayOrder(), _dec3$L = displayOrder(), _dec4$I = tooltip(), _dec5$F = type$1(CurveRange), _dec6$A = range(), _dec7$z = displayOrder(), _dec8$v = tooltip(), _dec9$s = type$1(CurveRange), _dec10$q = range(), _dec11$n = displayOrder(), _dec12$m = tooltip(), _dec13$j = type$1(CurveRange), _dec14$f = range(), _dec15$f = displayOrder(), _dec16$e = tooltip(), _dec$T(_class$T = (_class2$J = (_temp$M = class RotationOvertimeModule extends ParticleModuleBase {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "_enable", _descriptor$I, this);

                _initializerDefineProperty(this, "_separateAxes", _descriptor2$F, this);

                _initializerDefineProperty(this, "x", _descriptor3$x, this);

                _initializerDefineProperty(this, "y", _descriptor4$v, this);

                _initializerDefineProperty(this, "z", _descriptor5$q, this);

                this.name = PARTICLE_MODULE_NAME.ROTATION;
                this._startMat = new Mat4();
                this._matRot = new Mat4();
                this._quatRot = new Quat();
                this._otherEuler = new Vec3();
              }

              get enable() {
                return this._enable;
              }

              set enable(val) {
                if (this._enable === val) return;
                this._enable = val;
                if (!this.target) return;
                this.target.enableModule(this.name, val, this);
              }

              get separateAxes() {
                return this._separateAxes;
              }

              set separateAxes(val) {
                this._separateAxes = val;
              }

              _processRotation(p, r2d) {
                const renderMode = p.particleSystem.processor.getInfo().renderMode;

                if (renderMode !== RenderMode$1.Mesh) {
                  if (renderMode === RenderMode$1.StrecthedBillboard) {
                    this._quatRot.set(0, 0, 0, 1);
                  }
                }

                Quat.normalize(this._quatRot, this._quatRot);

                if (this._quatRot.w < 0.0) {
                  this._quatRot.x += Particle.INDENTIFY_NEG_QUAT;
                }
              }

              animate(p, dt) {
                const normalizedTime = 1 - p.remainingLifetime / p.startLifetime;
                const rotationRand = pseudoRandom(p.randomSeed + ROTATION_OVERTIME_RAND_OFFSET);
                const renderMode = p.particleSystem.processor.getInfo().renderMode;

                if (!this._separateAxes || renderMode === RenderMode$1.VerticalBillboard || renderMode === RenderMode$1.HorizontalBillboard) {
                  Quat.fromEuler(p.deltaQuat, 0, 0, this.z.evaluate(normalizedTime, rotationRand) * dt * Particle.R2D);
                } else {
                  Quat.fromEuler(p.deltaQuat, this.x.evaluate(normalizedTime, rotationRand) * dt * Particle.R2D, this.y.evaluate(normalizedTime, rotationRand) * dt * Particle.R2D, this.z.evaluate(normalizedTime, rotationRand) * dt * Particle.R2D);
                }

                p.deltaMat = Mat4.fromQuat(p.deltaMat, p.deltaQuat);
                p.localMat = p.localMat.multiply(p.deltaMat);

                if (!p.startRotated) {
                  if (renderMode !== RenderMode$1.Mesh) {
                    if (renderMode === RenderMode$1.StrecthedBillboard) {
                      p.startEuler.set(0, 0, 0);
                    } else if (renderMode !== RenderMode$1.Billboard) {
                      p.startEuler.set(0, 0, p.startEuler.z);
                    }
                  }

                  Quat.fromEuler(p.startRotation, p.startEuler.x * Particle.R2D, p.startEuler.y * Particle.R2D, p.startEuler.z * Particle.R2D);
                  p.startRotated = true;
                }

                this._startMat = Mat4.fromQuat(this._startMat, p.startRotation);
                this._matRot = this._startMat.multiply(p.localMat);
                Mat4.getRotation(this._quatRot, this._matRot);

                this._processRotation(p, Particle.R2D);

                p.rotation.set(this._quatRot.x, this._quatRot.y, this._quatRot.z);
              }

            }, _temp$M), (_descriptor$I = _applyDecoratedDescriptor(_class2$J.prototype, "_enable", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _applyDecoratedDescriptor(_class2$J.prototype, "enable", [_dec2$N], Object.getOwnPropertyDescriptor(_class2$J.prototype, "enable"), _class2$J.prototype), _descriptor2$F = _applyDecoratedDescriptor(_class2$J.prototype, "_separateAxes", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _applyDecoratedDescriptor(_class2$J.prototype, "separateAxes", [_dec3$L, _dec4$I], Object.getOwnPropertyDescriptor(_class2$J.prototype, "separateAxes"), _class2$J.prototype), _descriptor3$x = _applyDecoratedDescriptor(_class2$J.prototype, "x", [_dec5$F, serializable, _dec6$A, radian, _dec7$z, _dec8$v], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new CurveRange();
              }
            }), _descriptor4$v = _applyDecoratedDescriptor(_class2$J.prototype, "y", [_dec9$s, serializable, _dec10$q, radian, _dec11$n, _dec12$m], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new CurveRange();
              }
            }), _descriptor5$q = _applyDecoratedDescriptor(_class2$J.prototype, "z", [_dec13$j, serializable, _dec14$f, radian, _dec15$f, _dec16$e], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new CurveRange();
              }
            })), _class2$J)) || _class$T);

            var _dec$U, _dec2$O, _dec3$M, _dec4$J, _dec5$G, _dec6$B, _dec7$A, _dec8$w, _dec9$t, _dec10$r, _dec11$o, _dec12$n, _dec13$k, _dec14$g, _dec15$g, _dec16$f, _dec17$c, _dec18$b, _dec19$b, _dec20$a, _class$U, _class2$K, _descriptor$J, _descriptor2$G, _descriptor3$y, _descriptor4$w, _descriptor5$r, _descriptor6$j, _temp$N;
            const SIZE_OVERTIME_RAND_OFFSET = ModuleRandSeed.SIZE;
            let SizeOvertimeModule = (_dec$U = ccclass('cc.SizeOvertimeModule'), _dec2$O = displayOrder(), _dec3$M = displayOrder(), _dec4$J = tooltip(), _dec5$G = type$1(CurveRange), _dec6$B = range(), _dec7$A = displayOrder(), _dec8$w = tooltip(), _dec9$t = type$1(CurveRange), _dec10$r = range(), _dec11$o = displayOrder(), _dec12$n = tooltip(), _dec13$k = type$1(CurveRange), _dec14$g = range(), _dec15$g = displayOrder(), _dec16$f = tooltip(), _dec17$c = type$1(CurveRange), _dec18$b = range(), _dec19$b = displayOrder(), _dec20$a = tooltip(), _dec$U(_class$U = (_class2$K = (_temp$N = class SizeOvertimeModule extends ParticleModuleBase {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "_enable", _descriptor$J, this);

                _initializerDefineProperty(this, "separateAxes", _descriptor2$G, this);

                _initializerDefineProperty(this, "size", _descriptor3$y, this);

                _initializerDefineProperty(this, "x", _descriptor4$w, this);

                _initializerDefineProperty(this, "y", _descriptor5$r, this);

                _initializerDefineProperty(this, "z", _descriptor6$j, this);

                this.name = PARTICLE_MODULE_NAME.SIZE;
              }

              get enable() {
                return this._enable;
              }

              set enable(val) {
                if (this._enable === val) return;
                this._enable = val;
                if (!this.target) return;
                this.target.enableModule(this.name, val, this);
              }

              animate(particle, dt) {
                if (!this.separateAxes) {
                  Vec3.multiplyScalar(particle.size, particle.startSize, this.size.evaluate(1 - particle.remainingLifetime / particle.startLifetime, pseudoRandom(particle.randomSeed + SIZE_OVERTIME_RAND_OFFSET)));
                } else {
                  const currLifetime = 1 - particle.remainingLifetime / particle.startLifetime;
                  const sizeRand = pseudoRandom(particle.randomSeed + SIZE_OVERTIME_RAND_OFFSET);
                  particle.size.x = particle.startSize.x * this.x.evaluate(currLifetime, sizeRand);
                  particle.size.y = particle.startSize.y * this.y.evaluate(currLifetime, sizeRand);
                  particle.size.z = particle.startSize.z * this.z.evaluate(currLifetime, sizeRand);
                }
              }

            }, _temp$N), (_descriptor$J = _applyDecoratedDescriptor(_class2$K.prototype, "_enable", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _applyDecoratedDescriptor(_class2$K.prototype, "enable", [_dec2$O], Object.getOwnPropertyDescriptor(_class2$K.prototype, "enable"), _class2$K.prototype), _descriptor2$G = _applyDecoratedDescriptor(_class2$K.prototype, "separateAxes", [serializable, _dec3$M, _dec4$J], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor3$y = _applyDecoratedDescriptor(_class2$K.prototype, "size", [_dec5$G, serializable, _dec6$B, _dec7$A, _dec8$w], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new CurveRange();
              }
            }), _descriptor4$w = _applyDecoratedDescriptor(_class2$K.prototype, "x", [_dec9$t, serializable, _dec10$r, _dec11$o, _dec12$n], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new CurveRange();
              }
            }), _descriptor5$r = _applyDecoratedDescriptor(_class2$K.prototype, "y", [_dec13$k, serializable, _dec14$g, _dec15$g, _dec16$f], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new CurveRange();
              }
            }), _descriptor6$j = _applyDecoratedDescriptor(_class2$K.prototype, "z", [_dec17$c, serializable, _dec18$b, _dec19$b, _dec20$a], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new CurveRange();
              }
            })), _class2$K)) || _class$U);

            var _dec$V, _dec2$P, _dec3$N, _dec4$K, _dec5$H, _dec6$C, _dec7$B, _dec8$x, _dec9$u, _dec10$s, _dec11$p, _dec12$o, _dec13$l, _dec14$h, _dec15$h, _dec16$g, _dec17$d, _dec18$c, _dec19$c, _dec20$b, _dec21$a, _dec22$a, _dec23$a, _dec24$9, _dec25$9, _dec26$8, _dec27$8, _dec28$7, _dec29$6, _class$V, _class2$L, _descriptor$K, _descriptor2$H, _descriptor3$z, _descriptor4$x, _descriptor5$s, _descriptor6$k, _descriptor7$h, _descriptor8$e, _descriptor9$b, _descriptor10$a, _descriptor11$9, _descriptor12$7, _descriptor13$5, _temp$O;
            const TEXTURE_ANIMATION_RAND_OFFSET = ModuleRandSeed.TEXTURE;
            const Mode$4 = Enum({
              Grid: 0
            });
            const Animation = Enum({
              WholeSheet: 0,
              SingleRow: 1
            });
            let TextureAnimationModule = (_dec$V = ccclass('cc.TextureAnimationModule'), _dec2$P = formerlySerializedAs('numTilesX'), _dec3$N = formerlySerializedAs('numTilesY'), _dec4$K = displayOrder(), _dec5$H = type$1(Mode$4), _dec6$C = type$1(Mode$4), _dec7$B = displayOrder(), _dec8$x = tooltip(), _dec9$u = displayOrder(), _dec10$s = tooltip(), _dec11$p = displayOrder(), _dec12$o = tooltip(), _dec13$l = type$1(Animation), _dec14$h = displayOrder(), _dec15$h = tooltip(), _dec16$g = type$1(CurveRange), _dec17$d = range(), _dec18$c = displayOrder(), _dec19$c = tooltip(), _dec20$b = type$1(CurveRange), _dec21$a = range(), _dec22$a = displayOrder(), _dec23$a = tooltip(), _dec24$9 = displayOrder(), _dec25$9 = tooltip(), _dec26$8 = displayOrder(), _dec27$8 = tooltip(), _dec28$7 = displayOrder(), _dec29$6 = tooltip(), _dec$V(_class$V = (_class2$L = (_temp$O = class TextureAnimationModule extends ParticleModuleBase {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "_enable", _descriptor$K, this);

                _initializerDefineProperty(this, "_numTilesX", _descriptor2$H, this);

                _initializerDefineProperty(this, "_numTilesY", _descriptor3$z, this);

                _initializerDefineProperty(this, "_mode", _descriptor4$x, this);

                _initializerDefineProperty(this, "animation", _descriptor5$s, this);

                _initializerDefineProperty(this, "frameOverTime", _descriptor6$k, this);

                _initializerDefineProperty(this, "startFrame", _descriptor7$h, this);

                _initializerDefineProperty(this, "cycleCount", _descriptor8$e, this);

                _initializerDefineProperty(this, "_flipU", _descriptor9$b, this);

                _initializerDefineProperty(this, "_flipV", _descriptor10$a, this);

                _initializerDefineProperty(this, "_uvChannelMask", _descriptor11$9, this);

                _initializerDefineProperty(this, "randomRow", _descriptor12$7, this);

                _initializerDefineProperty(this, "rowIndex", _descriptor13$5, this);

                this.name = PARTICLE_MODULE_NAME.TEXTURE;
              }

              get enable() {
                return this._enable;
              }

              set enable(val) {
                if (this._enable === val) return;
                this._enable = val;
                if (!this.target) return;
                this.target.updateMaterialParams();
                this.target.enableModule(this.name, val, this);
              }

              get mode() {
                return this._mode;
              }

              set mode(val) {
                if (val !== Mode$4.Grid) {
                  console.error('particle texture animation\'s sprites is not supported!');
                }
              }

              get numTilesX() {
                return this._numTilesX;
              }

              set numTilesX(val) {
                if (this._numTilesX !== val) {
                  this._numTilesX = val;
                  this.target.updateMaterialParams();
                }
              }

              get numTilesY() {
                return this._numTilesY;
              }

              set numTilesY(val) {
                if (this._numTilesY !== val) {
                  this._numTilesY = val;
                  this.target.updateMaterialParams();
                }
              }

              get flipU() {
                return this._flipU;
              }

              set flipU(val) {
                console.error('particle texture animation\'s flipU is not supported!');
              }

              get flipV() {
                return this._flipV;
              }

              set flipV(val) {
                console.error('particle texture animation\'s flipV is not supported!');
              }

              get uvChannelMask() {
                return this._uvChannelMask;
              }

              set uvChannelMask(val) {
                console.error('particle texture animation\'s uvChannelMask is not supported!');
              }

              init(p) {
                p.startRow = Math.floor(Math.random() * this.numTilesY);
              }

              animate(p, dt) {
                const normalizedTime = 1 - p.remainingLifetime / p.startLifetime;
                const startFrame = this.startFrame.evaluate(normalizedTime, pseudoRandom(p.randomSeed + TEXTURE_ANIMATION_RAND_OFFSET)) / (this.numTilesX * this.numTilesY);

                if (this.animation === Animation.WholeSheet) {
                  p.frameIndex = repeat$2(this.cycleCount * (this.frameOverTime.evaluate(normalizedTime, pseudoRandom(p.randomSeed + TEXTURE_ANIMATION_RAND_OFFSET)) + startFrame), 1);
                } else if (this.animation === Animation.SingleRow) {
                  const rowLength = 1 / this.numTilesY;

                  if (this.randomRow) {
                    const f = repeat$2(this.cycleCount * (this.frameOverTime.evaluate(normalizedTime, pseudoRandom(p.randomSeed + TEXTURE_ANIMATION_RAND_OFFSET)) + startFrame), 1);
                    const from = p.startRow * rowLength;
                    const to = from + rowLength;
                    p.frameIndex = lerp(from, to, f);
                  } else {
                    const from = this.rowIndex * rowLength;
                    const to = from + rowLength;
                    p.frameIndex = lerp(from, to, repeat$2(this.cycleCount * (this.frameOverTime.evaluate(normalizedTime, pseudoRandom(p.randomSeed + TEXTURE_ANIMATION_RAND_OFFSET)) + startFrame), 1));
                  }
                }
              }

            }, _temp$O), (_descriptor$K = _applyDecoratedDescriptor(_class2$L.prototype, "_enable", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor2$H = _applyDecoratedDescriptor(_class2$L.prototype, "_numTilesX", [_dec2$P], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor3$z = _applyDecoratedDescriptor(_class2$L.prototype, "_numTilesY", [_dec3$N], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _applyDecoratedDescriptor(_class2$L.prototype, "enable", [_dec4$K], Object.getOwnPropertyDescriptor(_class2$L.prototype, "enable"), _class2$L.prototype), _descriptor4$x = _applyDecoratedDescriptor(_class2$L.prototype, "_mode", [_dec5$H], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Mode$4.Grid;
              }
            }), _applyDecoratedDescriptor(_class2$L.prototype, "mode", [_dec6$C, _dec7$B, _dec8$x], Object.getOwnPropertyDescriptor(_class2$L.prototype, "mode"), _class2$L.prototype), _applyDecoratedDescriptor(_class2$L.prototype, "numTilesX", [_dec9$u, _dec10$s], Object.getOwnPropertyDescriptor(_class2$L.prototype, "numTilesX"), _class2$L.prototype), _applyDecoratedDescriptor(_class2$L.prototype, "numTilesY", [_dec11$p, _dec12$o], Object.getOwnPropertyDescriptor(_class2$L.prototype, "numTilesY"), _class2$L.prototype), _descriptor5$s = _applyDecoratedDescriptor(_class2$L.prototype, "animation", [_dec13$l, serializable, _dec14$h, _dec15$h], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Animation.WholeSheet;
              }
            }), _descriptor6$k = _applyDecoratedDescriptor(_class2$L.prototype, "frameOverTime", [_dec16$g, serializable, _dec17$d, _dec18$c, _dec19$c], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new CurveRange();
              }
            }), _descriptor7$h = _applyDecoratedDescriptor(_class2$L.prototype, "startFrame", [_dec20$b, serializable, _dec21$a, _dec22$a, _dec23$a], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new CurveRange();
              }
            }), _descriptor8$e = _applyDecoratedDescriptor(_class2$L.prototype, "cycleCount", [serializable, _dec24$9, _dec25$9], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor9$b = _applyDecoratedDescriptor(_class2$L.prototype, "_flipU", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor10$a = _applyDecoratedDescriptor(_class2$L.prototype, "_flipV", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor11$9 = _applyDecoratedDescriptor(_class2$L.prototype, "_uvChannelMask", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return -1;
              }
            }), _descriptor12$7 = _applyDecoratedDescriptor(_class2$L.prototype, "randomRow", [serializable, _dec26$8, _dec27$8], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor13$5 = _applyDecoratedDescriptor(_class2$L.prototype, "rowIndex", [serializable, _dec28$7, _dec29$6], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            })), _class2$L)) || _class$V);

            var _dec$W, _dec2$Q, _dec3$O, _dec4$L, _dec5$I, _dec6$D, _dec7$C, _dec8$y, _dec9$v, _dec10$t, _dec11$q, _dec12$p, _dec13$m, _dec14$i, _dec15$i, _dec16$h, _dec17$e, _dec18$d, _dec19$d, _dec20$c, _dec21$b, _class$W, _class2$M, _descriptor$L, _descriptor2$I, _descriptor3$A, _descriptor4$y, _descriptor5$t, _descriptor6$l, _temp$P;
            const VELOCITY_X_OVERTIME_RAND_OFFSET = ModuleRandSeed.VELOCITY_X;
            const VELOCITY_Y_OVERTIME_RAND_OFFSET = ModuleRandSeed.VELOCITY_Y;
            const VELOCITY_Z_OVERTIME_RAND_OFFSET = ModuleRandSeed.VELOCITY_Z;

            const _temp_v3$2 = new Vec3();

            let VelocityOvertimeModule = (_dec$W = ccclass('cc.VelocityOvertimeModule'), _dec2$Q = displayOrder(), _dec3$O = type$1(CurveRange), _dec4$L = range(), _dec5$I = displayOrder(), _dec6$D = tooltip(), _dec7$C = type$1(CurveRange), _dec8$y = range(), _dec9$v = displayOrder(), _dec10$t = tooltip(), _dec11$q = type$1(CurveRange), _dec12$p = range(), _dec13$m = displayOrder(), _dec14$i = tooltip(), _dec15$i = type$1(CurveRange), _dec16$h = range(), _dec17$e = displayOrder(), _dec18$d = tooltip(), _dec19$d = type$1(Space), _dec20$c = displayOrder(), _dec21$b = tooltip(), _dec$W(_class$W = (_class2$M = (_temp$P = class VelocityOvertimeModule extends ParticleModuleBase {
              get enable() {
                return this._enable;
              }

              set enable(val) {
                if (this._enable === val) return;
                this._enable = val;
                if (!this.target) return;
                this.target.enableModule(this.name, val, this);
              }

              constructor() {
                super();

                _initializerDefineProperty(this, "_enable", _descriptor$L, this);

                _initializerDefineProperty(this, "x", _descriptor2$I, this);

                _initializerDefineProperty(this, "y", _descriptor3$A, this);

                _initializerDefineProperty(this, "z", _descriptor4$y, this);

                _initializerDefineProperty(this, "speedModifier", _descriptor5$t, this);

                _initializerDefineProperty(this, "space", _descriptor6$l, this);

                this.rotation = void 0;
                this.needTransform = void 0;
                this.name = PARTICLE_MODULE_NAME.VELOCITY;
                this.rotation = new Quat();
                this.speedModifier.constant = 1;
                this.needTransform = false;
                this.needUpdate = true;
              }

              update(space, worldTransform) {
                this.needTransform = calculateTransform(space, this.space, worldTransform, this.rotation);
              }

              animate(p, dt) {
                const normalizedTime = 1 - p.remainingLifetime / p.startLifetime;
                const vel = Vec3.set(_temp_v3$2, this.x.evaluate(normalizedTime, pseudoRandom(p.randomSeed ^ VELOCITY_X_OVERTIME_RAND_OFFSET)), this.y.evaluate(normalizedTime, pseudoRandom(p.randomSeed ^ VELOCITY_Y_OVERTIME_RAND_OFFSET)), this.z.evaluate(normalizedTime, pseudoRandom(p.randomSeed ^ VELOCITY_Z_OVERTIME_RAND_OFFSET)));

                if (this.needTransform) {
                  Vec3.transformQuat(vel, vel, this.rotation);
                }

                Vec3.add(p.animatedVelocity, p.animatedVelocity, vel);
                Vec3.add(p.ultimateVelocity, p.velocity, p.animatedVelocity);
                Vec3.multiplyScalar(p.ultimateVelocity, p.ultimateVelocity, this.speedModifier.evaluate(1 - p.remainingLifetime / p.startLifetime, pseudoRandom(p.randomSeed + VELOCITY_X_OVERTIME_RAND_OFFSET)));
              }

            }, _temp$P), (_descriptor$L = _applyDecoratedDescriptor(_class2$M.prototype, "_enable", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _applyDecoratedDescriptor(_class2$M.prototype, "enable", [_dec2$Q], Object.getOwnPropertyDescriptor(_class2$M.prototype, "enable"), _class2$M.prototype), _descriptor2$I = _applyDecoratedDescriptor(_class2$M.prototype, "x", [_dec3$O, serializable, _dec4$L, _dec5$I, _dec6$D], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new CurveRange();
              }
            }), _descriptor3$A = _applyDecoratedDescriptor(_class2$M.prototype, "y", [_dec7$C, serializable, _dec8$y, _dec9$v, _dec10$t], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new CurveRange();
              }
            }), _descriptor4$y = _applyDecoratedDescriptor(_class2$M.prototype, "z", [_dec11$q, serializable, _dec12$p, _dec13$m, _dec14$i], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new CurveRange();
              }
            }), _descriptor5$t = _applyDecoratedDescriptor(_class2$M.prototype, "speedModifier", [_dec15$i, serializable, _dec16$h, _dec17$e, _dec18$d], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new CurveRange();
              }
            }), _descriptor6$l = _applyDecoratedDescriptor(_class2$M.prototype, "space", [_dec19$d, serializable, _dec20$c, _dec21$b], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Space.Local;
              }
            })), _class2$M)) || _class$W);

            var _dec$X, _dec2$R, _dec3$P, _class$X, _class2$N, _descriptor$M, _descriptor2$J, _descriptor3$B, _descriptor4$z, _temp$Q;
            let Burst = exports('Burst', (_dec$X = ccclass('cc.Burst'), _dec2$R = type$1(CurveRange), _dec3$P = range(), _dec$X(_class$X = (_class2$N = (_temp$Q = class Burst {
              get time() {
                return this._time;
              }

              set time(val) {
                this._time = val;
                this._curTime = val;
              }

              get repeatCount() {
                return this._repeatCount;
              }

              set repeatCount(val) {
                this._repeatCount = val;
                this._remainingCount = val;
              }

              constructor() {
                _initializerDefineProperty(this, "_time", _descriptor$M, this);

                _initializerDefineProperty(this, "_repeatCount", _descriptor2$J, this);

                _initializerDefineProperty(this, "repeatInterval", _descriptor3$B, this);

                _initializerDefineProperty(this, "count", _descriptor4$z, this);

                this._remainingCount = void 0;
                this._curTime = void 0;
                this._remainingCount = 0;
                this._curTime = 0.0;
              }

              update(psys, dt) {
                if (this._remainingCount === 0) {
                  this._remainingCount = this._repeatCount;
                  this._curTime = this._time;
                }

                if (this._remainingCount > 0) {
                  let preFrameTime = repeat$2(psys._time - psys.startDelay.evaluate(0, 1), psys.duration) - dt;
                  preFrameTime = preFrameTime > 0.0 ? preFrameTime : 0.0;
                  const curFrameTime = repeat$2(psys.time - psys.startDelay.evaluate(0, 1), psys.duration);

                  if (this._curTime >= preFrameTime && this._curTime < curFrameTime) {
                    psys.emit(this.count.evaluate(this._curTime / psys.duration, 1), dt - (curFrameTime - this._curTime));
                    this._curTime += this.repeatInterval;
                    --this._remainingCount;
                  }
                }
              }

              reset() {
                this._remainingCount = 0;
                this._curTime = 0.0;
              }

              getMaxCount(psys) {
                return this.count.getMax() * Math.min(Math.ceil(psys.duration / this.repeatInterval), this.repeatCount);
              }

            }, _temp$Q), (_descriptor$M = _applyDecoratedDescriptor(_class2$N.prototype, "_time", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _applyDecoratedDescriptor(_class2$N.prototype, "time", [editable], Object.getOwnPropertyDescriptor(_class2$N.prototype, "time"), _class2$N.prototype), _descriptor2$J = _applyDecoratedDescriptor(_class2$N.prototype, "_repeatCount", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            }), _applyDecoratedDescriptor(_class2$N.prototype, "repeatCount", [editable], Object.getOwnPropertyDescriptor(_class2$N.prototype, "repeatCount"), _class2$N.prototype), _descriptor3$B = _applyDecoratedDescriptor(_class2$N.prototype, "repeatInterval", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            }), _descriptor4$z = _applyDecoratedDescriptor(_class2$N.prototype, "count", [_dec2$R, serializable, _dec3$P], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new CurveRange();
              }
            })), _class2$N)) || _class$X));

            var _dec$Y, _dec2$S, _dec3$Q, _dec4$M, _dec5$J, _dec6$E, _dec7$D, _dec8$z, _dec9$w, _dec10$u, _dec11$r, _dec12$q, _dec13$n, _dec14$j, _dec15$j, _dec16$i, _dec17$f, _dec18$e, _dec19$e, _dec20$d, _dec21$c, _dec22$b, _dec23$b, _dec24$a, _dec25$a, _dec26$9, _dec27$9, _dec28$8, _dec29$7, _dec30$6, _dec31$5, _dec32$5, _dec33$4, _dec34$3, _dec35$2, _dec36$2, _dec37$2, _dec38$2, _dec39$2, _dec40$2, _dec41$2, _dec42$2, _dec43$2, _dec44$1, _dec45$1, _dec46, _dec47, _class$Y, _class2$O, _descriptor$N, _descriptor2$K, _descriptor3$C, _descriptor4$A, _descriptor5$u, _descriptor6$m, _descriptor7$i, _descriptor8$f, _descriptor9$c, _descriptor10$b, _descriptor11$a, _descriptor12$8, _descriptor13$6, _descriptor14$4, _descriptor15$3, _descriptor16$3, _descriptor17$2, _descriptor18$1, _descriptor19, _temp$R;

            const _intermediVec = new Vec3(0, 0, 0);

            const _intermediArr = [];

            const _unitBoxExtent = new Vec3(0.5, 0.5, 0.5);

            let ShapeModule = (_dec$Y = ccclass('cc.ShapeModule'), _dec2$S = displayOrder(), _dec3$Q = tooltip(), _dec4$M = displayOrder(), _dec5$J = tooltip(), _dec6$E = displayOrder(), _dec7$D = tooltip(), _dec8$z = displayOrder(), _dec9$w = tooltip(), _dec10$u = displayOrder(), _dec11$r = tooltip(), _dec12$q = displayOrder(), _dec13$n = type$1(ShapeType), _dec14$j = formerlySerializedAs('shapeType'), _dec15$j = displayOrder(), _dec16$i = type$1(ShapeType), _dec17$f = tooltip(), _dec18$e = type$1(EmitLocation), _dec19$e = displayOrder(), _dec20$d = tooltip(), _dec21$c = displayOrder(), _dec22$b = tooltip(), _dec23$b = displayOrder(), _dec24$a = tooltip(), _dec25$a = displayOrder(), _dec26$9 = tooltip(), _dec27$9 = displayOrder(), _dec28$8 = tooltip(), _dec29$7 = displayOrder(), _dec30$6 = tooltip(), _dec31$5 = displayOrder(), _dec32$5 = tooltip(), _dec33$4 = type$1(ArcMode), _dec34$3 = displayOrder(), _dec35$2 = tooltip(), _dec36$2 = visible(), _dec37$2 = displayOrder(), _dec38$2 = tooltip(), _dec39$2 = type$1(CurveRange), _dec40$2 = visible(), _dec41$2 = range(), _dec42$2 = displayOrder(), _dec43$2 = tooltip(), _dec44$1 = displayOrder(), _dec45$1 = tooltip(), _dec46 = displayOrder(), _dec47 = tooltip(), _dec$Y(_class$Y = (_class2$O = (_temp$R = class ShapeModule {
              get position() {
                return this._position;
              }

              set position(val) {
                this._position = val;
                this.constructMat();
              }

              get rotation() {
                return this._rotation;
              }

              set rotation(val) {
                this._rotation = val;
                this.constructMat();
              }

              get scale() {
                return this._scale;
              }

              set scale(val) {
                this._scale = val;
                this.constructMat();
              }

              get arc() {
                return toDegree(this._arc);
              }

              set arc(val) {
                this._arc = toRadian(val);
              }

              get angle() {
                return Math.round(toDegree(this._angle) * 100) / 100;
              }

              set angle(val) {
                this._angle = toRadian(val);
              }

              get enable() {
                return this._enable;
              }

              set enable(val) {
                this._enable = val;
              }

              get shapeType() {
                return this._shapeType;
              }

              set shapeType(val) {
                this._shapeType = val;

                switch (this._shapeType) {
                  case ShapeType.Box:
                    if (this.emitFrom === EmitLocation.Base) {
                      this.emitFrom = EmitLocation.Volume;
                    }

                    break;

                  case ShapeType.Cone:
                    if (this.emitFrom === EmitLocation.Edge) {
                      this.emitFrom = EmitLocation.Base;
                    }

                    break;

                  case ShapeType.Sphere:
                  case ShapeType.Hemisphere:
                    if (this.emitFrom === EmitLocation.Base || this.emitFrom === EmitLocation.Edge) {
                      this.emitFrom = EmitLocation.Volume;
                    }

                    break;
                }
              }

              constructor() {
                _initializerDefineProperty(this, "_enable", _descriptor$N, this);

                _initializerDefineProperty(this, "_shapeType", _descriptor2$K, this);

                _initializerDefineProperty(this, "emitFrom", _descriptor3$C, this);

                _initializerDefineProperty(this, "alignToDirection", _descriptor4$A, this);

                _initializerDefineProperty(this, "randomDirectionAmount", _descriptor5$u, this);

                _initializerDefineProperty(this, "sphericalDirectionAmount", _descriptor6$m, this);

                _initializerDefineProperty(this, "randomPositionAmount", _descriptor7$i, this);

                _initializerDefineProperty(this, "radius", _descriptor8$f, this);

                _initializerDefineProperty(this, "radiusThickness", _descriptor9$c, this);

                _initializerDefineProperty(this, "arcMode", _descriptor10$b, this);

                _initializerDefineProperty(this, "arcSpread", _descriptor11$a, this);

                _initializerDefineProperty(this, "arcSpeed", _descriptor12$8, this);

                _initializerDefineProperty(this, "length", _descriptor13$6, this);

                _initializerDefineProperty(this, "boxThickness", _descriptor14$4, this);

                _initializerDefineProperty(this, "_position", _descriptor15$3, this);

                _initializerDefineProperty(this, "_rotation", _descriptor16$3, this);

                _initializerDefineProperty(this, "_scale", _descriptor17$2, this);

                _initializerDefineProperty(this, "_arc", _descriptor18$1, this);

                _initializerDefineProperty(this, "_angle", _descriptor19, this);

                this.mat = void 0;
                this.quat = void 0;
                this.particleSystem = void 0;
                this.lastTime = void 0;
                this.totalAngle = void 0;
                this.mat = new Mat4();
                this.quat = new Quat();
                this.particleSystem = null;
                this.lastTime = 0;
                this.totalAngle = 0;
              }

              onInit(ps) {
                this.particleSystem = ps;
                this.constructMat();
                this.lastTime = this.particleSystem._time;
              }

              emit(p) {
                switch (this.shapeType) {
                  case ShapeType.Box:
                    boxEmit(this.emitFrom, this.boxThickness, p.position, p.velocity);
                    break;

                  case ShapeType.Circle:
                    circleEmit(this.radius, this.radiusThickness, this.generateArcAngle(), p.position, p.velocity);
                    break;

                  case ShapeType.Cone:
                    coneEmit(this.emitFrom, this.radius, this.radiusThickness, this.generateArcAngle(), this._angle, this.length, p.position, p.velocity);
                    break;

                  case ShapeType.Sphere:
                    sphereEmit(this.emitFrom, this.radius, this.radiusThickness, p.position, p.velocity);
                    break;

                  case ShapeType.Hemisphere:
                    hemisphereEmit(this.emitFrom, this.radius, this.radiusThickness, p.position, p.velocity);
                    break;

                  default:
                    console.warn(`${this.shapeType} shapeType is not supported by ShapeModule.`);
                }

                if (this.randomPositionAmount > 0) {
                  p.position.x += randomRange(-this.randomPositionAmount, this.randomPositionAmount);
                  p.position.y += randomRange(-this.randomPositionAmount, this.randomPositionAmount);
                  p.position.z += randomRange(-this.randomPositionAmount, this.randomPositionAmount);
                }

                Vec3.transformQuat(p.velocity, p.velocity, this.quat);
                Vec3.transformMat4(p.position, p.position, this.mat);

                if (this.sphericalDirectionAmount > 0) {
                  const sphericalVel = Vec3.normalize(_intermediVec, p.position);
                  Vec3.lerp(p.velocity, p.velocity, sphericalVel, this.sphericalDirectionAmount);
                }

                this.lastTime = this.particleSystem._time;
              }

              constructMat() {
                Quat.fromEuler(this.quat, this._rotation.x, this._rotation.y, this._rotation.z);
                Mat4.fromRTS(this.mat, this.quat, this._position, this._scale);
              }

              generateArcAngle() {
                if (this.arcMode === ArcMode.Random) {
                  return randomRange(0, this._arc);
                }

                let angle = this.totalAngle + 2 * Math.PI * this.arcSpeed.evaluate(this.particleSystem._time, 1) * (this.particleSystem._time - this.lastTime);
                this.totalAngle = angle;

                if (this.arcSpread !== 0) {
                  angle = Math.floor(angle / (this._arc * this.arcSpread)) * this._arc * this.arcSpread;
                }

                switch (this.arcMode) {
                  case ArcMode.Loop:
                    return repeat$2(angle, this._arc);

                  case ArcMode.PingPong:
                    return pingPong(angle, this._arc);

                  default:
                    return repeat$2(angle, this._arc);
                }
              }

            }, _temp$R), (_applyDecoratedDescriptor(_class2$O.prototype, "position", [_dec2$S, _dec3$Q], Object.getOwnPropertyDescriptor(_class2$O.prototype, "position"), _class2$O.prototype), _applyDecoratedDescriptor(_class2$O.prototype, "rotation", [_dec4$M, _dec5$J], Object.getOwnPropertyDescriptor(_class2$O.prototype, "rotation"), _class2$O.prototype), _applyDecoratedDescriptor(_class2$O.prototype, "scale", [_dec6$E, _dec7$D], Object.getOwnPropertyDescriptor(_class2$O.prototype, "scale"), _class2$O.prototype), _applyDecoratedDescriptor(_class2$O.prototype, "arc", [_dec8$z, _dec9$w], Object.getOwnPropertyDescriptor(_class2$O.prototype, "arc"), _class2$O.prototype), _applyDecoratedDescriptor(_class2$O.prototype, "angle", [_dec10$u, _dec11$r], Object.getOwnPropertyDescriptor(_class2$O.prototype, "angle"), _class2$O.prototype), _descriptor$N = _applyDecoratedDescriptor(_class2$O.prototype, "_enable", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _applyDecoratedDescriptor(_class2$O.prototype, "enable", [_dec12$q], Object.getOwnPropertyDescriptor(_class2$O.prototype, "enable"), _class2$O.prototype), _descriptor2$K = _applyDecoratedDescriptor(_class2$O.prototype, "_shapeType", [_dec13$n, _dec14$j, _dec15$j], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return ShapeType.Cone;
              }
            }), _applyDecoratedDescriptor(_class2$O.prototype, "shapeType", [_dec16$i, _dec17$f], Object.getOwnPropertyDescriptor(_class2$O.prototype, "shapeType"), _class2$O.prototype), _descriptor3$C = _applyDecoratedDescriptor(_class2$O.prototype, "emitFrom", [_dec18$e, serializable, _dec19$e, _dec20$d], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return EmitLocation.Volume;
              }
            }), _descriptor4$A = _applyDecoratedDescriptor(_class2$O.prototype, "alignToDirection", [serializable, _dec21$c, _dec22$b], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor5$u = _applyDecoratedDescriptor(_class2$O.prototype, "randomDirectionAmount", [serializable, _dec23$b, _dec24$a], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor6$m = _applyDecoratedDescriptor(_class2$O.prototype, "sphericalDirectionAmount", [serializable, _dec25$a, _dec26$9], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor7$i = _applyDecoratedDescriptor(_class2$O.prototype, "randomPositionAmount", [serializable, _dec27$9, _dec28$8], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor8$f = _applyDecoratedDescriptor(_class2$O.prototype, "radius", [serializable, _dec29$7, _dec30$6], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            }), _descriptor9$c = _applyDecoratedDescriptor(_class2$O.prototype, "radiusThickness", [serializable, _dec31$5, _dec32$5], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            }), _descriptor10$b = _applyDecoratedDescriptor(_class2$O.prototype, "arcMode", [_dec33$4, serializable, _dec34$3, _dec35$2], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return ArcMode.Random;
              }
            }), _descriptor11$a = _applyDecoratedDescriptor(_class2$O.prototype, "arcSpread", [_dec36$2, serializable, _dec37$2, _dec38$2], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor12$8 = _applyDecoratedDescriptor(_class2$O.prototype, "arcSpeed", [_dec39$2, _dec40$2, _dec41$2, serializable, _dec42$2, _dec43$2], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new CurveRange();
              }
            }), _descriptor13$6 = _applyDecoratedDescriptor(_class2$O.prototype, "length", [serializable, _dec44$1, _dec45$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 5;
              }
            }), _descriptor14$4 = _applyDecoratedDescriptor(_class2$O.prototype, "boxThickness", [serializable, _dec46, _dec47], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec3(0, 0, 0);
              }
            }), _descriptor15$3 = _applyDecoratedDescriptor(_class2$O.prototype, "_position", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec3(0, 0, 0);
              }
            }), _descriptor16$3 = _applyDecoratedDescriptor(_class2$O.prototype, "_rotation", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec3(0, 0, 0);
              }
            }), _descriptor17$2 = _applyDecoratedDescriptor(_class2$O.prototype, "_scale", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec3(1, 1, 1);
              }
            }), _descriptor18$1 = _applyDecoratedDescriptor(_class2$O.prototype, "_arc", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return toRadian(360);
              }
            }), _descriptor19 = _applyDecoratedDescriptor(_class2$O.prototype, "_angle", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return toRadian(25);
              }
            })), _class2$O)) || _class$Y);

            function sphereEmit(emitFrom, radius, radiusThickness, pos, dir) {
              switch (emitFrom) {
                case EmitLocation.Volume:
                  randomPointBetweenSphere(pos, radius * (1 - radiusThickness), radius);
                  Vec3.normalize(dir, pos);
                  break;

                case EmitLocation.Shell:
                  randomUnitVector(pos);
                  Vec3.multiplyScalar(pos, pos, radius);
                  Vec3.normalize(dir, pos);
                  break;

                default:
                  console.warn(`${emitFrom} is not supported for sphere emitter.`);
              }
            }

            function hemisphereEmit(emitFrom, radius, radiusThickness, pos, dir) {
              switch (emitFrom) {
                case EmitLocation.Volume:
                  randomPointBetweenSphere(pos, radius * (1 - radiusThickness), radius);

                  if (pos.z > 0) {
                    pos.z *= -1;
                  }

                  Vec3.normalize(dir, pos);
                  break;

                case EmitLocation.Shell:
                  randomUnitVector(pos);
                  Vec3.multiplyScalar(pos, pos, radius);

                  if (pos.z > 0) {
                    pos.z *= -1;
                  }

                  Vec3.normalize(dir, pos);
                  break;

                default:
                  console.warn(`${emitFrom} is not supported for hemisphere emitter.`);
              }
            }

            function coneEmit(emitFrom, radius, radiusThickness, theta, angle, length, pos, dir) {
              switch (emitFrom) {
                case EmitLocation.Base:
                  randomPointBetweenCircleAtFixedAngle(pos, radius * (1 - radiusThickness), radius, theta);
                  Vec2.multiplyScalar(dir, pos, Math.sin(angle));
                  dir.z = -Math.cos(angle) * radius;
                  Vec3.normalize(dir, dir);
                  pos.z = 0;
                  break;

                case EmitLocation.Shell:
                  fixedAngleUnitVector2(pos, theta);
                  Vec2.multiplyScalar(dir, pos, Math.sin(angle));
                  dir.z = -Math.cos(angle);
                  Vec3.normalize(dir, dir);
                  Vec2.multiplyScalar(pos, pos, radius);
                  pos.z = 0;
                  break;

                case EmitLocation.Volume:
                  randomPointBetweenCircleAtFixedAngle(pos, radius * (1 - radiusThickness), radius, theta);
                  Vec2.multiplyScalar(dir, pos, Math.sin(angle));
                  dir.z = -Math.cos(angle) * radius;
                  Vec3.normalize(dir, dir);
                  pos.z = 0;
                  Vec3.add(pos, pos, Vec3.multiplyScalar(_intermediVec, dir, length * random() / -dir.z));
                  break;

                default:
                  console.warn(`${emitFrom} is not supported for cone emitter.`);
              }
            }

            function boxEmit(emitFrom, boxThickness, pos, dir) {
              switch (emitFrom) {
                case EmitLocation.Volume:
                  randomPointInCube(pos, _unitBoxExtent);
                  break;

                case EmitLocation.Shell:
                  _intermediArr.splice(0, _intermediArr.length);

                  _intermediArr.push(randomRange(-0.5, 0.5));

                  _intermediArr.push(randomRange(-0.5, 0.5));

                  _intermediArr.push(randomSign() * 0.5);

                  randomSortArray(_intermediArr);
                  applyBoxThickness(_intermediArr, boxThickness);
                  Vec3.set(pos, _intermediArr[0], _intermediArr[1], _intermediArr[2]);
                  break;

                case EmitLocation.Edge:
                  _intermediArr.splice(0, _intermediArr.length);

                  _intermediArr.push(randomRange(-0.5, 0.5));

                  _intermediArr.push(randomSign() * 0.5);

                  _intermediArr.push(randomSign() * 0.5);

                  randomSortArray(_intermediArr);
                  applyBoxThickness(_intermediArr, boxThickness);
                  Vec3.set(pos, _intermediArr[0], _intermediArr[1], _intermediArr[2]);
                  break;

                default:
                  console.warn(`${emitFrom} is not supported for box emitter.`);
              }

              Vec3.copy(dir, particleEmitZAxis);
            }

            function circleEmit(radius, radiusThickness, theta, pos, dir) {
              randomPointBetweenCircleAtFixedAngle(pos, radius * (1 - radiusThickness), radius, theta);
              Vec3.normalize(dir, pos);
            }

            function applyBoxThickness(pos, thickness) {
              if (thickness.x > 0) {
                pos[0] += 0.5 * randomRange(-thickness.x, thickness.x);
                pos[0] = clamp$1(pos[0], -0.5, 0.5);
              }

              if (thickness.y > 0) {
                pos[1] += 0.5 * randomRange(-thickness.y, thickness.y);
                pos[1] = clamp$1(pos[1], -0.5, 0.5);
              }

              if (thickness.z > 0) {
                pos[2] += 0.5 * randomRange(-thickness.z, thickness.z);
                pos[2] = clamp$1(pos[2], -0.5, 0.5);
              }
            }

            const _uvs$1 = [0, 0, 1, 0, 0, 1, 1, 1];
            class ParticleBatchModel extends Model {
              constructor() {
                super();
                this._capacity = void 0;
                this._vertAttrs = void 0;
                this._vertSize = void 0;
                this._vBuffer = void 0;
                this._vertAttrsFloatCount = void 0;
                this._vdataF32 = void 0;
                this._vdataUint32 = void 0;
                this._iaInfo = void 0;
                this._iaInfoBuffer = void 0;
                this._subMeshData = void 0;
                this._mesh = void 0;
                this._vertCount = 0;
                this._indexCount = 0;
                this._startTimeOffset = 0;
                this._lifeTimeOffset = 0;
                this._material = null;
                this.type = ModelType.PARTICLE_BATCH;
                this._capacity = 0;
                this._vertAttrs = null;
                this._vertSize = 0;
                this._vBuffer = null;
                this._vertAttrsFloatCount = 0;
                this._vdataF32 = null;
                this._vdataUint32 = null;
                this._iaInfo = new IndirectBuffer([new DrawInfo()]);
                this._iaInfoBuffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.INDIRECT, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, DRAW_INFO_SIZE, DRAW_INFO_SIZE));
                this._subMeshData = null;
                this._mesh = null;
              }

              setCapacity(capacity) {
                const capChanged = this._capacity !== capacity;
                this._capacity = capacity;

                if (this._subMeshData && capChanged) {
                  this.rebuild();
                }
              }

              setVertexAttributes(mesh, attrs) {
                if (this._mesh === mesh && this._vertAttrs === attrs) {
                  return;
                }

                this._mesh = mesh;
                this._vertAttrs = attrs;
                this._vertSize = 0;

                for (const a of this._vertAttrs) {
                  a.offset = this._vertSize;
                  this._vertSize += FormatInfos[a.format].size;
                }

                this._vertAttrsFloatCount = this._vertSize / 4;
                this.rebuild();
              }

              createSubMeshData() {
                this.destroySubMeshData();
                this._vertCount = 4;
                this._indexCount = 6;

                if (this._mesh) {
                  this._vertCount = this._mesh.struct.vertexBundles[this._mesh.struct.primitives[0].vertexBundelIndices[0]].view.count;
                  this._indexCount = this._mesh.struct.primitives[0].indexView.count;
                }

                const vertexBuffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, this._vertSize * this._capacity * this._vertCount, this._vertSize));

                const vBuffer = new ArrayBuffer(this._vertSize * this._capacity * this._vertCount);

                if (this._mesh && this._capacity > 0) {
                  let vOffset = this._vertAttrs[this._vertAttrs.findIndex(val => val.name === AttributeName.ATTR_TEX_COORD)].offset;

                  this._mesh.copyAttribute(0, AttributeName.ATTR_TEX_COORD, vBuffer, this._vertSize, vOffset);

                  let vIdx = this._vertAttrs.findIndex(val => val.name === AttributeName.ATTR_TEX_COORD3);

                  vOffset = this._vertAttrs[vIdx++].offset;

                  this._mesh.copyAttribute(0, AttributeName.ATTR_POSITION, vBuffer, this._vertSize, vOffset);

                  vOffset = this._vertAttrs[vIdx++].offset;

                  this._mesh.copyAttribute(0, AttributeName.ATTR_NORMAL, vBuffer, this._vertSize, vOffset);

                  vOffset = this._vertAttrs[vIdx++].offset;

                  if (!this._mesh.copyAttribute(0, AttributeName.ATTR_COLOR, vBuffer, this._vertSize, vOffset)) {
                    const vb = new Uint32Array(vBuffer);

                    for (let iVertex = 0; iVertex < this._vertCount; ++iVertex) {
                      vb[iVertex * this._vertAttrsFloatCount + vOffset / 4] = Color$1.WHITE._val;
                    }
                  }

                  const vbFloatArray = new Float32Array(vBuffer);

                  for (let i = 1; i < this._capacity; i++) {
                    vbFloatArray.copyWithin(i * this._vertSize * this._vertCount / 4, 0, this._vertSize * this._vertCount / 4);
                  }
                }

                vertexBuffer.update(vBuffer);
                const indices = new Uint16Array(this._capacity * this._indexCount);

                if (this._mesh) {
                  this._mesh.copyIndices(0, indices);

                  for (let i = 1; i < this._capacity; i++) {
                    for (let j = 0; j < this._indexCount; j++) {
                      indices[i * this._indexCount + j] = indices[j] + i * this._vertCount;
                    }
                  }
                } else {
                  let dst = 0;

                  for (let i = 0; i < this._capacity; ++i) {
                    const baseIdx = 4 * i;
                    indices[dst++] = baseIdx;
                    indices[dst++] = baseIdx + 1;
                    indices[dst++] = baseIdx + 2;
                    indices[dst++] = baseIdx + 3;
                    indices[dst++] = baseIdx + 2;
                    indices[dst++] = baseIdx + 1;
                  }
                }

                const indexBuffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, this._capacity * this._indexCount * Uint16Array.BYTES_PER_ELEMENT, Uint16Array.BYTES_PER_ELEMENT));

                indexBuffer.update(indices);
                this._iaInfo.drawInfos[0].vertexCount = this._capacity * this._vertCount;
                this._iaInfo.drawInfos[0].indexCount = this._capacity * this._indexCount;

                if (!this._iaInfoBuffer) {
                  this._iaInfoBuffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.INDIRECT, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, DRAW_INFO_SIZE, DRAW_INFO_SIZE));
                }

                this._iaInfoBuffer.update(this._iaInfo);

                this._subMeshData = new RenderingSubMesh([vertexBuffer], this._vertAttrs, PrimitiveMode.TRIANGLE_LIST, indexBuffer, this._iaInfoBuffer);
                this.initSubModel(0, this._subMeshData, this._material);
                return vBuffer;
              }

              updateMaterial(mat) {
                this._material = mat;
                this.setSubModelMaterial(0, mat);
              }

              addParticleVertexData(index, pvdata) {
                if (!this._mesh) {
                  let offset = index * this._vertAttrsFloatCount;
                  this._vdataF32[offset++] = pvdata[0].x;
                  this._vdataF32[offset++] = pvdata[0].y;
                  this._vdataF32[offset++] = pvdata[0].z;
                  this._vdataF32[offset++] = pvdata[1].x;
                  this._vdataF32[offset++] = pvdata[1].y;
                  this._vdataF32[offset++] = pvdata[1].z;
                  this._vdataF32[offset++] = pvdata[2].x;
                  this._vdataF32[offset++] = pvdata[2].y;
                  this._vdataF32[offset++] = pvdata[2].z;
                  this._vdataF32[offset++] = pvdata[3].x;
                  this._vdataF32[offset++] = pvdata[3].y;
                  this._vdataF32[offset++] = pvdata[3].z;
                  this._vdataUint32[offset++] = pvdata[4];

                  if (pvdata[5]) {
                    this._vdataF32[offset++] = pvdata[5].x;
                    this._vdataF32[offset++] = pvdata[5].y;
                    this._vdataF32[offset++] = pvdata[5].z;
                  }
                } else {
                  for (let i = 0; i < this._vertCount; i++) {
                    let offset = (index * this._vertCount + i) * this._vertAttrsFloatCount;
                    this._vdataF32[offset++] = pvdata[0].x;
                    this._vdataF32[offset++] = pvdata[0].y;
                    this._vdataF32[offset++] = pvdata[0].z;
                    offset += 2;
                    this._vdataF32[offset++] = pvdata[1].z;
                    this._vdataF32[offset++] = pvdata[2].x;
                    this._vdataF32[offset++] = pvdata[2].y;
                    this._vdataF32[offset++] = pvdata[2].z;
                    this._vdataF32[offset++] = pvdata[3].x;
                    this._vdataF32[offset++] = pvdata[3].y;
                    this._vdataF32[offset++] = pvdata[3].z;
                    this._vdataUint32[offset++] = pvdata[4];
                  }
                }
              }

              addGPUParticleVertexData(p, num, time) {
                let offset = num * this._vertAttrsFloatCount * this._vertCount;

                for (let i = 0; i < this._vertCount; i++) {
                  let idx = offset;
                  this._vdataF32[idx++] = p.position.x;
                  this._vdataF32[idx++] = p.position.y;
                  this._vdataF32[idx++] = p.position.z;
                  this._vdataF32[idx++] = time;
                  this._vdataF32[idx++] = p.startSize.x;
                  this._vdataF32[idx++] = p.startSize.y;
                  this._vdataF32[idx++] = p.startSize.z;
                  this._vdataF32[idx++] = _uvs$1[2 * i];
                  this._vdataF32[idx++] = p.rotation.x;
                  this._vdataF32[idx++] = p.rotation.y;
                  this._vdataF32[idx++] = p.rotation.z;
                  this._vdataF32[idx++] = _uvs$1[2 * i + 1];
                  this._vdataF32[idx++] = p.startColor.r / 255.0;
                  this._vdataF32[idx++] = p.startColor.g / 255.0;
                  this._vdataF32[idx++] = p.startColor.b / 255.0;
                  this._vdataF32[idx++] = p.startColor.a / 255.0;
                  this._vdataF32[idx++] = p.velocity.x;
                  this._vdataF32[idx++] = p.velocity.y;
                  this._vdataF32[idx++] = p.velocity.z;
                  this._vdataF32[idx++] = p.startLifetime;
                  this._vdataF32[idx++] = p.randomSeed;
                  offset += this._vertAttrsFloatCount;
                }
              }

              updateGPUParticles(num, time, dt) {
                const pSize = this._vertAttrsFloatCount * this._vertCount;
                let pBaseIndex = 0;
                let startTime = 0;
                let lifeTime = 0;
                let lastBaseIndex = 0;
                let interval = 0;

                for (let i = 0; i < num; ++i) {
                  pBaseIndex = i * pSize;
                  startTime = this._vdataF32[pBaseIndex + this._startTimeOffset];
                  lifeTime = this._vdataF32[pBaseIndex + this._lifeTimeOffset];
                  interval = time - startTime;

                  if (lifeTime - interval < dt) {
                    lastBaseIndex = --num * pSize;

                    this._vdataF32.copyWithin(pBaseIndex, lastBaseIndex, lastBaseIndex + pSize);

                    i--;
                  }
                }

                return num;
              }

              constructAttributeIndex() {
                if (!this._vertAttrs) {
                  return;
                }

                let vIdx = this._vertAttrs.findIndex(val => val.name === 'a_position_starttime');

                let vOffset = this._vertAttrs[vIdx].offset;
                this._startTimeOffset = vOffset / 4 + 3;
                vIdx = this._vertAttrs.findIndex(val => val.name === 'a_dir_life');
                vOffset = this._vertAttrs[vIdx].offset;
                this._lifeTimeOffset = vOffset / 4 + 3;
              }

              updateIA(count) {
                if (count <= 0) {
                  return;
                }

                const ia = this._subModels[0].inputAssembler;
                ia.vertexBuffers[0].update(this._vdataF32);
                this._iaInfo.drawInfos[0].firstIndex = 0;
                this._iaInfo.drawInfos[0].indexCount = this._indexCount * count;

                this._iaInfoBuffer.update(this._iaInfo);
              }

              clear() {
                this._subModels[0].inputAssembler.indexCount = 0;
              }

              destroy() {
                super.destroy();
                this._vBuffer = null;
                this._vdataF32 = null;
                this.destroySubMeshData();

                if (this._iaInfoBuffer) {
                  this._iaInfoBuffer.destroy();

                  this._iaInfoBuffer = null;
                }
              }

              rebuild() {
                this._vBuffer = this.createSubMeshData();
                this._vdataF32 = new Float32Array(this._vBuffer);
                this._vdataUint32 = new Uint32Array(this._vBuffer);
              }

              destroySubMeshData() {
                if (this._subMeshData) {
                  this._subMeshData.destroy();

                  this._subMeshData = null;
                  this._iaInfoBuffer = null;
                }
              }

            }

            class ParticleSystemRendererBase {
              constructor(info) {
                this._particleSystem = null;
                this._model = null;
                this._renderInfo = null;
                this._vertAttrs = [];
                this._renderInfo = info;
              }

              getInfo() {
                return this._renderInfo;
              }

              onInit(ps) {
                this._particleSystem = ps;
              }

              onEnable() {
                if (!this._particleSystem) {
                  return;
                }

                this.attachToScene();
                const model = this._model;

                if (model) {
                  model.node = model.transform = this._particleSystem.node;
                  model.enabled = this._particleSystem.enabledInHierarchy;
                }
              }

              onDisable() {
                this.detachFromScene();
              }

              onDestroy() {
                if (this._model) {
                  legacyCC.director.root.destroyModel(this._model);
                  this._model = null;
                }
              }

              attachToScene() {
                if (this._model) {
                  if (this._model.scene) {
                    this.detachFromScene();
                  }

                  this._particleSystem._getRenderScene().addModel(this._model);
                }
              }

              detachFromScene() {
                if (this._model && this._model.scene) {
                  this._model.scene.removeModel(this._model);
                }
              }

              setVertexAttributes() {
                if (this._model) {
                  this._model.setVertexAttributes(this._renderInfo.renderMode === RenderMode$1.Mesh ? this._renderInfo.mesh : null, this._vertAttrs);
                }
              }

              clear() {
                if (this._model) this._model.enabled = false;
              }

              getModel() {
                return this._model;
              }

              _initModel() {
                if (!this._model) {
                  this._model = legacyCC.director.root.createModel(ParticleBatchModel);

                  this._model.setCapacity(this._particleSystem.capacity);

                  this._model.visFlags = this._particleSystem.visibility;
                }
              }

              updateTrailMaterial() {}

              getDefaultTrailMaterial() {
                return null;
              }

            }

            const _tempAttribUV = new Vec3();

            const _tempWorldTrans = new Mat4();

            const _node_rot = new Quat();

            const _node_euler = new Vec3();

            const _anim_module = ['_colorOverLifetimeModule', '_sizeOvertimeModule', '_velocityOvertimeModule', '_forceOvertimeModule', '_limitVelocityOvertimeModule', '_rotationOvertimeModule', '_textureAnimationModule'];
            const _uvs$2 = [0, 0, 1, 0, 0, 1, 1, 1];
            const CC_USE_WORLD_SPACE$1 = 'CC_USE_WORLD_SPACE';
            const CC_RENDER_MODE = 'CC_RENDER_MODE';
            const ROTATION_OVER_TIME_MODULE_ENABLE = 'ROTATION_OVER_TIME_MODULE_ENABLE';
            const RENDER_MODE_BILLBOARD = 0;
            const RENDER_MODE_STRETCHED_BILLBOARD = 1;
            const RENDER_MODE_HORIZONTAL_BILLBOARD = 2;
            const RENDER_MODE_VERTICAL_BILLBOARD = 3;
            const RENDER_MODE_MESH = 4;
            const _vertex_attrs$1 = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD1, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD2, Format.RGB32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA8, true)];
            const _vertex_attrs_stretch = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD1, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD2, Format.RGB32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA8, true), new Attribute(AttributeName.ATTR_COLOR1, Format.RGB32F)];
            const _vertex_attrs_mesh = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD1, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD2, Format.RGB32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA8, true), new Attribute(AttributeName.ATTR_TEX_COORD3, Format.RGB32F), new Attribute(AttributeName.ATTR_NORMAL, Format.RGB32F), new Attribute(AttributeName.ATTR_COLOR1, Format.RGBA8, true)];
            const _matInsInfo$1 = {
              parent: null,
              owner: null,
              subModelIdx: 0
            };
            class ParticleSystemRendererCPU extends ParticleSystemRendererBase {
              constructor(info) {
                super(info);
                this._defines = void 0;
                this._trailDefines = void 0;
                this._frameTile_velLenScale = void 0;
                this._tmp_velLenScale = void 0;
                this._defaultMat = null;
                this._node_scale = void 0;
                this._attrs = void 0;
                this._particles = null;
                this._defaultTrailMat = null;
                this._updateList = new Map();
                this._animateList = new Map();
                this._runAnimateList = new Array();
                this._fillDataFunc = null;
                this._uScaleHandle = 0;
                this._uLenHandle = 0;
                this._uNodeRotHandle = 0;
                this._alignSpace = AlignmentSpace.View;
                this._inited = false;
                this._localMat = new Mat4();
                this._gravity = new Vec4();
                this._model = null;
                this._frameTile_velLenScale = new Vec4(1, 1, 0, 0);
                this._tmp_velLenScale = this._frameTile_velLenScale.clone();
                this._node_scale = new Vec4();
                this._attrs = new Array(5);
                this._defines = {
                  CC_USE_WORLD_SPACE: true,
                  CC_USE_BILLBOARD: true,
                  CC_USE_STRETCHED_BILLBOARD: false,
                  CC_USE_HORIZONTAL_BILLBOARD: false,
                  CC_USE_VERTICAL_BILLBOARD: false
                };
                this._trailDefines = {
                  CC_USE_WORLD_SPACE: true
                };
              }

              onInit(ps) {
                super.onInit(ps);
                this._particles = new RecyclePool(() => new Particle(this), 16);

                this._setVertexAttrib();

                this._setFillFunc();

                this._initModuleList();

                this._initModel();

                this.updateMaterialParams();
                this.updateTrailMaterial();
                this.setVertexAttributes();
                this._inited = true;
              }

              clear() {
                super.clear();

                this._particles.reset();

                if (this._particleSystem._trailModule) {
                  this._particleSystem._trailModule.clear();
                }

                this.updateRenderData();
                this._model.enabled = false;
              }

              updateRenderMode() {
                this._setVertexAttrib();

                this._setFillFunc();

                this.updateMaterialParams();
                this.setVertexAttributes();
              }

              getFreeParticle() {
                if (this._particles.length >= this._particleSystem.capacity) {
                  return null;
                }

                return this._particles.add();
              }

              getDefaultTrailMaterial() {
                return this._defaultTrailMat;
              }

              setNewParticle(p) {}

              _initModuleList() {
                _anim_module.forEach(val => {
                  const pm = this._particleSystem[val];

                  if (pm && pm.enable) {
                    if (pm.needUpdate) {
                      this._updateList[pm.name] = pm;
                    }

                    if (pm.needAnimate) {
                      this._animateList[pm.name] = pm;
                    }
                  }
                });

                this._runAnimateList.length = 0;

                for (let i = 0, len = PARTICLE_MODULE_ORDER.length; i < len; i++) {
                  const p = this._animateList[PARTICLE_MODULE_ORDER[i]];

                  if (p) {
                    this._runAnimateList.push(p);
                  }
                }
              }

              enableModule(name, val, pm) {
                if (val) {
                  if (pm.needUpdate) {
                    this._updateList[pm.name] = pm;
                  }

                  if (pm.needAnimate) {
                    this._animateList[pm.name] = pm;
                  }
                } else {
                  delete this._animateList[name];
                  delete this._updateList[name];
                }

                this._runAnimateList.length = 0;

                for (let i = 0, len = PARTICLE_MODULE_ORDER.length; i < len; i++) {
                  const p = this._animateList[PARTICLE_MODULE_ORDER[i]];

                  if (p) {
                    this._runAnimateList.push(p);
                  }
                }

                this.updateMaterialParams();
              }

              updateAlignSpace(space) {
                this._alignSpace = space;
              }

              updateRotation() {
                const ps = this._particleSystem;

                if (!ps) {
                  return;
                }

                const mat = ps.getMaterialInstance(0) || this._defaultMat;

                const pass = mat.passes[0];
                this.doUpdateRotation(pass);
              }

              doUpdateRotation(pass) {
                if (this._alignSpace === AlignmentSpace.Local) {
                  this._particleSystem.node.getRotation(_node_rot);
                } else if (this._alignSpace === AlignmentSpace.World) {
                  this._particleSystem.node.getWorldRotation(_node_rot);
                } else if (this._alignSpace === AlignmentSpace.View) {
                  var _this$_particleSystem;

                  _node_rot.set(0.0, 0.0, 0.0, 1.0);

                  const cameraLst = (_this$_particleSystem = this._particleSystem.node.scene.renderScene) === null || _this$_particleSystem === void 0 ? void 0 : _this$_particleSystem.cameras;

                  if (cameraLst !== undefined) {
                    for (let i = 0; i < (cameraLst === null || cameraLst === void 0 ? void 0 : cameraLst.length); ++i) {
                      const camera = cameraLst[i];
                      const checkCamera =  (camera.visibility & this._particleSystem.node.layer) === this._particleSystem.node.layer ;

                      if (checkCamera) {
                        Quat.fromViewUp(_node_rot, camera.forward);
                        break;
                      }
                    }
                  }
                } else {
                  _node_rot.set(0.0, 0.0, 0.0, 1.0);
                }

                pass.setUniform(this._uNodeRotHandle, _node_rot);
              }

              updateScale() {
                const ps = this._particleSystem;

                if (!ps) {
                  return;
                }

                const mat = ps.getMaterialInstance(0) || this._defaultMat;

                const pass = mat.passes[0];
                this.doUpdateScale(pass);
              }

              doUpdateScale(pass) {
                switch (this._particleSystem.scaleSpace) {
                  case Space.Local:
                    this._particleSystem.node.getScale(this._node_scale);

                    break;

                  case Space.World:
                    this._particleSystem.node.getWorldScale(this._node_scale);

                    break;
                }

                pass.setUniform(this._uScaleHandle, this._node_scale);
              }

              updateParticles(dt) {
                const ps = this._particleSystem;

                if (!ps) {
                  return this._particles.length;
                }

                ps.node.getWorldMatrix(_tempWorldTrans);

                const mat = ps.getMaterialInstance(0) || this._defaultMat;

                const pass = mat.passes[0];
                this.doUpdateScale(pass);
                this.doUpdateRotation(pass);

                this._updateList.forEach((value, key) => {
                  value.update(ps._simulationSpace, _tempWorldTrans);
                });

                const trailModule = ps._trailModule;
                const trailEnable = trailModule && trailModule.enable;

                if (trailEnable) {
                  trailModule.update();
                }

                if (ps.simulationSpace === Space.Local) {
                  const r = ps.node.getRotation();
                  Mat4.fromQuat(this._localMat, r);

                  this._localMat.transpose();
                }

                for (let i = 0; i < this._particles.length; ++i) {
                  const p = this._particles.data[i];
                  p.remainingLifetime -= dt;
                  Vec3.set(p.animatedVelocity, 0, 0, 0);

                  if (p.remainingLifetime < 0.0) {
                    if (trailEnable) {
                      trailModule.removeParticle(p);
                    }

                    this._particles.removeAt(i);

                    --i;
                    continue;
                  }

                  if (ps.simulationSpace === Space.Local) {
                    const gravityFactor = -ps.gravityModifier.evaluate(1 - p.remainingLifetime / p.startLifetime, pseudoRandom(p.randomSeed)) * 9.8 * dt;
                    this._gravity.x = 0.0;
                    this._gravity.y = gravityFactor;
                    this._gravity.z = 0.0;
                    this._gravity.w = 1.0;
                    this._gravity = this._gravity.transformMat4(this._localMat);
                    p.velocity.x += this._gravity.x;
                    p.velocity.y += this._gravity.y;
                    p.velocity.z += this._gravity.z;
                  } else {
                    p.velocity.y -= ps.gravityModifier.evaluate(1 - p.remainingLifetime / p.startLifetime, pseudoRandom(p.randomSeed)) * 9.8 * dt;
                  }

                  Vec3.copy(p.ultimateVelocity, p.velocity);

                  this._runAnimateList.forEach(value => {
                    value.animate(p, dt);
                  });

                  Vec3.scaleAndAdd(p.position, p.position, p.ultimateVelocity, dt);

                  if (trailEnable) {
                    trailModule.animate(p, dt);
                  }
                }

                this._model.enabled = this._particles.length > 0;
                return this._particles.length;
              }

              updateRenderData() {
                let idx = 0;

                for (let i = 0; i < this._particles.length; ++i) {
                  const p = this._particles.data[i];
                  let fi = 0;
                  const textureModule = this._particleSystem._textureAnimationModule;

                  if (textureModule && textureModule.enable) {
                    fi = p.frameIndex;
                  }

                  idx = i * 4;

                  this._fillDataFunc(p, idx, fi);
                }
              }

              beforeRender() {
                this._model.updateIA(this._particles.length);
              }

              getParticleCount() {
                return this._particles.length;
              }

              onMaterialModified(index, material) {
                if (!this._inited) {
                  return;
                }

                if (index === 0) {
                  this.updateMaterialParams();
                } else {
                  this.updateTrailMaterial();
                }
              }

              onRebuildPSO(index, material) {
                if (this._model && index === 0) {
                  this._model.setSubModelMaterial(0, material);
                }

                const trailModule = this._particleSystem._trailModule;

                if (trailModule && trailModule._trailModel && index === 1) {
                  trailModule._trailModel.setSubModelMaterial(0, material);
                }
              }

              _setFillFunc() {
                if (this._renderInfo.renderMode === RenderMode$1.Mesh) {
                  this._fillDataFunc = this._fillMeshData;
                } else if (this._renderInfo.renderMode === RenderMode$1.StrecthedBillboard) {
                  this._fillDataFunc = this._fillStrecthedData;
                } else {
                  this._fillDataFunc = this._fillNormalData;
                }
              }

              _fillMeshData(p, idx, fi) {
                const i = idx / 4;
                this._attrs[0] = p.position;
                _tempAttribUV.z = fi;
                this._attrs[1] = _tempAttribUV;
                this._attrs[2] = p.size;
                this._attrs[3] = p.rotation;
                this._attrs[4] = p.color._val;

                this._model.addParticleVertexData(i, this._attrs);
              }

              _fillStrecthedData(p, idx, fi) {
                for (let j = 0; j < 4; ++j) {
                  this._attrs[0] = p.position;
                  _tempAttribUV.x = _uvs$2[2 * j];
                  _tempAttribUV.y = _uvs$2[2 * j + 1];
                  _tempAttribUV.z = fi;
                  this._attrs[1] = _tempAttribUV;
                  this._attrs[2] = p.size;
                  this._attrs[3] = p.rotation;
                  this._attrs[4] = p.color._val;
                  this._attrs[5] = p.ultimateVelocity;
                  this._attrs[6] = null;

                  this._model.addParticleVertexData(idx++, this._attrs);
                }
              }

              _fillNormalData(p, idx, fi) {
                for (let j = 0; j < 4; ++j) {
                  this._attrs[0] = p.position;
                  _tempAttribUV.x = _uvs$2[2 * j];
                  _tempAttribUV.y = _uvs$2[2 * j + 1];
                  _tempAttribUV.z = fi;
                  this._attrs[1] = _tempAttribUV;
                  this._attrs[2] = p.size;
                  this._attrs[3] = p.rotation;
                  this._attrs[4] = p.color._val;
                  this._attrs[5] = null;

                  this._model.addParticleVertexData(idx++, this._attrs);
                }
              }

              _setVertexAttrib() {
                switch (this._renderInfo.renderMode) {
                  case RenderMode$1.StrecthedBillboard:
                    this._vertAttrs = _vertex_attrs_stretch.slice();
                    break;

                  case RenderMode$1.Mesh:
                    this._vertAttrs = _vertex_attrs_mesh.slice();
                    break;

                  default:
                    this._vertAttrs = _vertex_attrs$1.slice();
                }
              }

              updateMaterialParams() {
                if (!this._particleSystem) {
                  return;
                }

                const ps = this._particleSystem;
                const shareMaterial = ps.sharedMaterial;

                if (shareMaterial != null) {
                  const effectName = shareMaterial._effectAsset._name;
                  this._renderInfo.mainTexture = shareMaterial.getProperty('mainTexture', 0);

                  if (effectName.indexOf('particle') === -1 || effectName.indexOf('particle-gpu') !== -1) {
                    ps.setMaterial(null, 0);
                  }
                }

                if (ps.sharedMaterial == null && this._defaultMat == null) {
                  _matInsInfo$1.parent = builtinResMgr.get('default-particle-material');
                  _matInsInfo$1.owner = this._particleSystem;
                  _matInsInfo$1.subModelIdx = 0;
                  this._defaultMat = new MaterialInstance(_matInsInfo$1);
                  _matInsInfo$1.parent = null;
                  _matInsInfo$1.owner = null;
                  _matInsInfo$1.subModelIdx = 0;

                  if (this._renderInfo.mainTexture !== null) {
                    this._defaultMat.setProperty('mainTexture', this._renderInfo.mainTexture);
                  }
                }

                const mat = ps.getMaterialInstance(0) || this._defaultMat;

                if (ps._simulationSpace === Space.World) {
                  this._defines[CC_USE_WORLD_SPACE$1] = true;
                } else {
                  this._defines[CC_USE_WORLD_SPACE$1] = false;
                }

                const pass = mat.passes[0];
                this._uScaleHandle = pass.getHandle('scale');
                this._uLenHandle = pass.getHandle('frameTile_velLenScale');
                this._uNodeRotHandle = pass.getHandle('nodeRotation');
                const renderMode = this._renderInfo.renderMode;
                const vlenScale = this._frameTile_velLenScale;

                if (renderMode === RenderMode$1.Billboard) {
                  this._defines[CC_RENDER_MODE] = RENDER_MODE_BILLBOARD;
                } else if (renderMode === RenderMode$1.StrecthedBillboard) {
                  this._defines[CC_RENDER_MODE] = RENDER_MODE_STRETCHED_BILLBOARD;
                  vlenScale.z = this._renderInfo.velocityScale;
                  vlenScale.w = this._renderInfo.lengthScale;
                } else if (renderMode === RenderMode$1.HorizontalBillboard) {
                  this._defines[CC_RENDER_MODE] = RENDER_MODE_HORIZONTAL_BILLBOARD;
                } else if (renderMode === RenderMode$1.VerticalBillboard) {
                  this._defines[CC_RENDER_MODE] = RENDER_MODE_VERTICAL_BILLBOARD;
                } else if (renderMode === RenderMode$1.Mesh) {
                  this._defines[CC_RENDER_MODE] = RENDER_MODE_MESH;
                } else {
                  console.warn(`particle system renderMode ${renderMode} not support.`);
                }

                const textureModule = ps._textureAnimationModule;

                if (textureModule && textureModule.enable) {
                  Vec4.copy(this._tmp_velLenScale, vlenScale);
                  Vec2.set(this._tmp_velLenScale, textureModule.numTilesX, textureModule.numTilesY);
                  pass.setUniform(this._uLenHandle, this._tmp_velLenScale);
                } else {
                  pass.setUniform(this._uLenHandle, vlenScale);
                }

                let enable = false;
                const roationModule = this._particleSystem._rotationOvertimeModule;
                enable = roationModule && roationModule.enable;
                this._defines[ROTATION_OVER_TIME_MODULE_ENABLE] = enable;
                mat.recompileShaders(this._defines);

                if (this._model) {
                  this._model.updateMaterial(mat);
                }
              }

              updateTrailMaterial() {
                if (!this._particleSystem) {
                  return;
                }

                const ps = this._particleSystem;
                const trailModule = ps._trailModule;

                if (trailModule && trailModule.enable) {
                  if (ps.simulationSpace === Space.World || trailModule.space === Space.World) {
                    this._trailDefines[CC_USE_WORLD_SPACE$1] = true;
                  } else {
                    this._trailDefines[CC_USE_WORLD_SPACE$1] = false;
                  }

                  let mat = ps.getMaterialInstance(1);

                  if (mat === null && this._defaultTrailMat === null) {
                    _matInsInfo$1.parent = builtinResMgr.get('default-trail-material');
                    _matInsInfo$1.owner = this._particleSystem;
                    _matInsInfo$1.subModelIdx = 1;
                    this._defaultTrailMat = new MaterialInstance(_matInsInfo$1);
                    _matInsInfo$1.parent = null;
                    _matInsInfo$1.owner = null;
                    _matInsInfo$1.subModelIdx = 0;
                  }

                  mat = mat || this._defaultTrailMat;
                  mat.recompileShaders(this._trailDefines);
                  trailModule.updateMaterial();
                }
              }

            }

            const _tempWorldTrans$1 = new Mat4();

            const _tempVec4 = new Vec4();

            const _world_rot = new Quat();

            const _node_rot$1 = new Quat();

            const _node_euler$1 = new Vec3();

            const _sample_num = 32;

            const _sample_interval = 1.0 / _sample_num;

            const CC_USE_WORLD_SPACE$2 = 'CC_USE_WORLD_SPACE';
            const CC_RENDER_MODE$1 = 'CC_RENDER_MODE';
            const RENDER_MODE_BILLBOARD$1 = 0;
            const RENDER_MODE_STRETCHED_BILLBOARD$1 = 1;
            const RENDER_MODE_HORIZONTAL_BILLBOARD$1 = 2;
            const RENDER_MODE_VERTICAL_BILLBOARD$1 = 3;
            const RENDER_MODE_MESH$1 = 4;
            const COLOR_OVER_TIME_MODULE_ENABLE = 'COLOR_OVER_TIME_MODULE_ENABLE';
            const ROTATION_OVER_TIME_MODULE_ENABLE$1 = 'ROTATION_OVER_TIME_MODULE_ENABLE';
            const SIZE_OVER_TIME_MODULE_ENABLE = 'SIZE_OVER_TIME_MODULE_ENABLE';
            const VELOCITY_OVER_TIME_MODULE_ENABLE = 'VELOCITY_OVER_TIME_MODULE_ENABLE';
            const FORCE_OVER_TIME_MODULE_ENABLE = 'FORCE_OVER_TIME_MODULE_ENABLE';
            const TEXTURE_ANIMATION_MODULE_ENABLE = 'TEXTURE_ANIMATION_MODULE_ENABLE';
            const USE_VK_SHADER = 'USE_VK_SHADER';
            const _vert_attr_name = {
              POSITION_STARTTIME: 'a_position_starttime',
              VERT_SIZE_UV: 'a_size_uv',
              VERT_ROTATION_UV: 'a_rotation_uv',
              COLOR: 'a_color',
              DIR_LIFE: 'a_dir_life',
              RANDOM_SEED: 'a_rndSeed'
            };
            const _gpu_vert_attr = [new Attribute(_vert_attr_name.POSITION_STARTTIME, Format.RGBA32F), new Attribute(_vert_attr_name.VERT_SIZE_UV, Format.RGBA32F), new Attribute(_vert_attr_name.VERT_ROTATION_UV, Format.RGBA32F), new Attribute(_vert_attr_name.COLOR, Format.RGBA32F), new Attribute(_vert_attr_name.DIR_LIFE, Format.RGBA32F), new Attribute(_vert_attr_name.RANDOM_SEED, Format.R32F)];
            const _gpu_vert_attr_mesh = [new Attribute(_vert_attr_name.POSITION_STARTTIME, Format.RGBA32F), new Attribute(_vert_attr_name.VERT_SIZE_UV, Format.RGBA32F), new Attribute(_vert_attr_name.VERT_ROTATION_UV, Format.RGBA32F), new Attribute(_vert_attr_name.COLOR, Format.RGBA32F), new Attribute(_vert_attr_name.DIR_LIFE, Format.RGBA32F), new Attribute(_vert_attr_name.RANDOM_SEED, Format.R32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD3, Format.RGB32F), new Attribute(AttributeName.ATTR_NORMAL, Format.RGB32F), new Attribute(AttributeName.ATTR_COLOR1, Format.RGBA8, true)];
            const _matInsInfo$2 = {
              parent: null,
              owner: null,
              subModelIdx: 0
            };
            class ParticleSystemRendererGPU extends ParticleSystemRendererBase {
              constructor(info) {
                super(info);
                this._defines = void 0;
                this._frameTile_velLenScale = void 0;
                this._unifrom_velLenScale = void 0;
                this._tmp_velLenScale = void 0;
                this._node_scale = void 0;
                this._vertAttrs = [];
                this._defaultMat = null;
                this._particleNum = 0;
                this._tempParticle = null;
                this._colorTexture = null;
                this._forceTexture = null;
                this._velocityTexture = null;
                this._rotationTexture = null;
                this._sizeTexture = null;
                this._animTexture = null;
                this._uTimeHandle = 0;
                this._uRotHandle = 0;
                this._uNodeRotHandle = 0;
                this._alignSpace = AlignmentSpace.View;
                this._inited = false;
                this._frameTile_velLenScale = new Vec4(1, 1, 0, 0);
                this._unifrom_velLenScale = this._frameTile_velLenScale.clone();
                this._tmp_velLenScale = this._frameTile_velLenScale.clone();
                this._node_scale = new Vec4();
                this._defines = {
                  CC_USE_WORLD_SPACE: true,
                  CC_USE_BILLBOARD: true,
                  CC_USE_STRETCHED_BILLBOARD: false,
                  CC_USE_HORIZONTAL_BILLBOARD: false,
                  CC_USE_VERTICAL_BILLBOARD: false,
                  COLOR_OVER_TIME_MODULE_ENABLE: false
                };
                this._tempParticle = new Particle(null);
                this._particleNum = 0;
              }

              onInit(ps) {
                super.onInit(ps);

                this._setVertexAttrib();

                this._initModel();

                this.updateMaterialParams();
                this.setVertexAttributes();
                this._inited = true;
              }

              updateRenderMode() {
                this._setVertexAttrib();

                this.updateMaterialParams();
                this.setVertexAttributes();
              }

              setVertexAttributes() {
                super.setVertexAttributes();

                this._model.constructAttributeIndex();
              }

              clear() {
                super.clear();
                this._particleNum = 0;
                this.updateRenderData();
              }

              onDestroy() {
                super.onDestroy();
                if (this._forceTexture) this._forceTexture.destroy();
                if (this._velocityTexture) this._velocityTexture.destroy();
                if (this._colorTexture) this._colorTexture.destroy();
                if (this._sizeTexture) this._sizeTexture.destroy();
                if (this._rotationTexture) this._rotationTexture.destroy();
                if (this._animTexture) this._animTexture.destroy();
              }

              enableModule(name, val, pm) {
                const mat = this._particleSystem.getMaterialInstance(0) || this._defaultMat;

                if (!mat) {
                  return;
                }

                this.initShaderUniform(mat);
                mat.recompileShaders(this._defines);

                if (this._model) {
                  this._model.setSubModelMaterial(0, mat);
                }
              }

              getFreeParticle() {
                if (this._particleNum >= this._particleSystem._capacity) {
                  return null;
                }

                return this._tempParticle;
              }

              setNewParticle(p) {
                this._model.addGPUParticleVertexData(p, this._particleNum, this._particleSystem._time);

                this._particleNum++;
              }

              updateRotation() {
                const mat = this._particleSystem.getMaterialInstance(0) || this._defaultMat;

                if (!mat) {
                  return;
                }

                const pass = mat.passes[0];
                this.doUpdateRotation(pass);
              }

              doUpdateRotation(pass) {
                if (this._alignSpace === AlignmentSpace.Local) {
                  this._particleSystem.node.getRotation(_node_rot$1);
                } else if (this._alignSpace === AlignmentSpace.World) {
                  this._particleSystem.node.getWorldRotation(_node_rot$1);
                } else if (this._alignSpace === AlignmentSpace.View) {
                  var _this$_particleSystem;

                  _node_rot$1.set(0.0, 0.0, 0.0, 1.0);

                  const cameraLst = (_this$_particleSystem = this._particleSystem.node.scene.renderScene) === null || _this$_particleSystem === void 0 ? void 0 : _this$_particleSystem.cameras;

                  if (cameraLst !== undefined) {
                    for (let i = 0; i < (cameraLst === null || cameraLst === void 0 ? void 0 : cameraLst.length); ++i) {
                      const camera = cameraLst[i];
                      const checkCamera =  (camera.visibility & this._particleSystem.node.layer) === this._particleSystem.node.layer ;

                      if (checkCamera) {
                        Quat.fromViewUp(_node_rot$1, camera.forward);
                        break;
                      }
                    }
                  }
                } else {
                  _node_rot$1.set(0.0, 0.0, 0.0, 1.0);
                }

                pass.setUniform(this._uNodeRotHandle, _node_rot$1);
              }

              updateScale() {
                const mat = this._particleSystem.getMaterialInstance(0) || this._defaultMat;

                if (!mat) {
                  return;
                }

                const pass = mat.passes[0];
                this.doUpdateScale(pass);
              }

              doUpdateScale(pass) {
                switch (this._particleSystem.scaleSpace) {
                  case Space.Local:
                    this._particleSystem.node.getScale(this._node_scale);

                    break;

                  case Space.World:
                    this._particleSystem.node.getWorldScale(this._node_scale);

                    break;
                }

                pass.setUniform(pass.getHandle('scale'), this._node_scale);
              }

              updateParticles(dt) {

                this._particleNum = this._model.updateGPUParticles(this._particleNum, this._particleSystem._time, dt);
                this.updateShaderUniform(dt);
                this._model.enabled = this._particleNum > 0;
                return this._particleNum;
              }

              updateRenderData() {}

              beforeRender() {
                this._model.updateIA(this._particleNum);
              }

              updateAlignSpace(space) {
                this._alignSpace = space;
              }

              updateShaderUniform(dt) {
                const mat = this._particleSystem.getMaterialInstance(0) || this._defaultMat;

                if (!mat) {
                  return;
                }

                const pass = mat.passes[0];
                _tempVec4.x = this._particleSystem._time;
                _tempVec4.y = dt;
                pass.setUniform(this._uTimeHandle, _tempVec4);

                this._particleSystem.node.getWorldRotation(_world_rot);

                pass.setUniform(this._uRotHandle, _world_rot);
                this.doUpdateRotation(pass);
              }

              initShaderUniform(mat) {
                const pass = mat.passes[0];
                this._uTimeHandle = pass.getHandle('u_timeDelta');
                this._uRotHandle = pass.getHandle('u_worldRot');
                this._uNodeRotHandle = pass.getHandle('nodeRotation');
                this.doUpdateScale(pass);
                pass.setUniform(pass.getHandle('frameTile_velLenScale'), this._unifrom_velLenScale);
                _tempVec4.x = _sample_num;
                _tempVec4.y = _sample_interval;
                pass.setUniform(pass.getHandle('u_sampleInfo'), _tempVec4);
                let enable = false;
                const forceModule = this._particleSystem._forceOvertimeModule;
                enable = forceModule && forceModule.enable;
                this._defines[FORCE_OVER_TIME_MODULE_ENABLE] = enable;

                if (enable) {
                  if (this._forceTexture) this._forceTexture.destroy();
                  this._forceTexture = packCurveRangeXYZ(_sample_num, forceModule.x, forceModule.y, forceModule.z);
                  const handle = pass.getHandle('force_over_time_tex0');
                  const binding = Pass.getBindingFromHandle(handle);
                  pass.bindSampler(binding, this._forceTexture.getGFXSampler());
                  pass.bindTexture(binding, this._forceTexture.getGFXTexture());
                  const spaceHandle = pass.getHandle('u_force_space');
                  pass.setUniform(spaceHandle, forceModule.space);
                  const modeHandle = pass.getHandle('u_force_mode');
                  pass.setUniform(modeHandle, this._forceTexture.height);
                }

                const velocityModule = this._particleSystem._velocityOvertimeModule;
                enable = velocityModule && velocityModule.enable;
                this._defines[VELOCITY_OVER_TIME_MODULE_ENABLE] = enable;

                if (enable) {
                  if (this._velocityTexture) this._velocityTexture.destroy();
                  this._velocityTexture = packCurveRangeXYZW(_sample_num, velocityModule.x, velocityModule.y, velocityModule.z, velocityModule.speedModifier);
                  const handle = pass.getHandle('velocity_over_time_tex0');
                  const binding = Pass.getBindingFromHandle(handle);
                  pass.bindSampler(binding, this._velocityTexture.getGFXSampler());
                  pass.bindTexture(binding, this._velocityTexture.getGFXTexture());
                  const spaceHandle = pass.getHandle('u_velocity_space');
                  pass.setUniform(spaceHandle, velocityModule.space);
                  const modeHandle = pass.getHandle('u_velocity_mode');
                  pass.setUniform(modeHandle, this._velocityTexture.height);
                }

                const colorModule = this._particleSystem._colorOverLifetimeModule;
                enable = colorModule && colorModule.enable;
                this._defines[COLOR_OVER_TIME_MODULE_ENABLE] = enable;

                if (enable) {
                  if (this._colorTexture) this._colorTexture.destroy();
                  this._colorTexture = packGradientRange(_sample_num, colorModule.color);
                  const handle = pass.getHandle('color_over_time_tex0');
                  const binding = Pass.getBindingFromHandle(handle);
                  pass.bindSampler(binding, this._colorTexture.getGFXSampler());
                  pass.bindTexture(binding, this._colorTexture.getGFXTexture());
                  const modeHandle = pass.getHandle('u_color_mode');
                  pass.setUniform(modeHandle, this._colorTexture.height);
                }

                const roationModule = this._particleSystem._rotationOvertimeModule;
                enable = roationModule && roationModule.enable;
                this._defines[ROTATION_OVER_TIME_MODULE_ENABLE$1] = enable;

                if (enable) {
                  if (this._rotationTexture) this._rotationTexture.destroy();

                  if (roationModule.separateAxes) {
                    this._rotationTexture = packCurveRangeXYZ(_sample_num, roationModule.x, roationModule.y, roationModule.z);
                  } else {
                    this._rotationTexture = packCurveRangeZ(_sample_num, roationModule.z);
                  }

                  const handle = pass.getHandle('rotation_over_time_tex0');
                  const binding = Pass.getBindingFromHandle(handle);
                  pass.bindSampler(binding, this._rotationTexture.getGFXSampler());
                  pass.bindTexture(binding, this._rotationTexture.getGFXTexture());
                  const modeHandle = pass.getHandle('u_rotation_mode');
                  pass.setUniform(modeHandle, this._rotationTexture.height);
                }

                const sizeModule = this._particleSystem._sizeOvertimeModule;
                enable = sizeModule && sizeModule.enable;
                this._defines[SIZE_OVER_TIME_MODULE_ENABLE] = enable;

                if (enable) {
                  if (this._sizeTexture) this._sizeTexture.destroy();

                  if (sizeModule.separateAxes) {
                    this._sizeTexture = packCurveRangeXYZ(_sample_num, sizeModule.x, sizeModule.y, sizeModule.z, true);
                  } else {
                    this._sizeTexture = packCurveRangeN(_sample_num, sizeModule.size, true);
                  }

                  const handle = pass.getHandle('size_over_time_tex0');
                  const binding = Pass.getBindingFromHandle(handle);
                  pass.bindSampler(binding, this._sizeTexture.getGFXSampler());
                  pass.bindTexture(binding, this._sizeTexture.getGFXTexture());
                  const modeHandle = pass.getHandle('u_size_mode');
                  pass.setUniform(modeHandle, this._sizeTexture.height);
                }

                const textureModule = this._particleSystem._textureAnimationModule;
                enable = textureModule && textureModule.enable;
                this._defines[TEXTURE_ANIMATION_MODULE_ENABLE] = enable;

                if (enable) {
                  if (this._animTexture) this._animTexture.destroy();
                  this._animTexture = packCurveRangeXY(_sample_num, textureModule.startFrame, textureModule.frameOverTime);
                  const handle = pass.getHandle('texture_animation_tex0');
                  const binding = Pass.getBindingFromHandle(handle);
                  pass.bindSampler(binding, this._animTexture.getGFXSampler());
                  pass.bindTexture(binding, this._animTexture.getGFXTexture());
                  const infoHandle = pass.getHandle('u_anim_info');
                  _tempVec4.x = this._animTexture.height;
                  _tempVec4.y = textureModule.numTilesX * textureModule.numTilesY;
                  _tempVec4.z = textureModule.cycleCount;
                  pass.setUniform(infoHandle, _tempVec4);
                }

                this._defines[USE_VK_SHADER] = legacyCC.game._gfxDevice.gfxAPI === API.VULKAN;
              }

              getParticleCount() {
                return this._particleNum;
              }

              onMaterialModified(index, material) {
                if (!this._inited) {
                  return;
                }

                this.updateMaterialParams();
              }

              onRebuildPSO(index, material) {
                if (this._model && index === 0) {
                  this._model.setSubModelMaterial(0, material);
                }
              }

              _setVertexAttrib() {
                switch (this._renderInfo.renderMode) {
                  case RenderMode$1.StrecthedBillboard:
                    this._vertAttrs = _gpu_vert_attr.slice();
                    break;

                  case RenderMode$1.Mesh:
                    this._vertAttrs = _gpu_vert_attr_mesh.slice();
                    break;

                  default:
                    this._vertAttrs = _gpu_vert_attr.slice();
                }
              }

              updateMaterialParams() {
                if (!this._particleSystem) {
                  return;
                }

                const ps = this._particleSystem;
                const shareMaterial = ps.sharedMaterial;

                if (shareMaterial !== null) {
                  const effectName = shareMaterial._effectAsset._name;
                  this._renderInfo.mainTexture = shareMaterial.getProperty('mainTexture', 0);

                  if (effectName.indexOf('particle-gpu') === -1) {
                    this._renderInfo.mainTexture = shareMaterial.getProperty('mainTexture', 0);

                    this._particleSystem.setMaterial(null, 0);
                  }
                }

                if (ps.sharedMaterial == null && this._defaultMat == null) {
                  _matInsInfo$2.parent = builtinResMgr.get('default-particle-gpu-material');
                  _matInsInfo$2.owner = ps;
                  _matInsInfo$2.subModelIdx = 0;
                  this._defaultMat = new MaterialInstance(_matInsInfo$2);
                  _matInsInfo$2.parent = null;
                  _matInsInfo$2.owner = null;
                  _matInsInfo$2.subModelIdx = 0;

                  if (this._renderInfo.mainTexture !== null) {
                    this._defaultMat.setProperty('mainTexture', this._renderInfo.mainTexture);
                  }
                }

                const mat = ps.getMaterialInstance(0) || this._defaultMat;

                ps.node.getWorldMatrix(_tempWorldTrans$1);

                if (ps._simulationSpace === Space.World) {
                  this._defines[CC_USE_WORLD_SPACE$2] = true;
                } else {
                  this._defines[CC_USE_WORLD_SPACE$2] = false;
                }

                const renderMode = this._renderInfo.renderMode;

                if (renderMode === RenderMode$1.Billboard) {
                  this._defines[CC_RENDER_MODE$1] = RENDER_MODE_BILLBOARD$1;
                } else if (renderMode === RenderMode$1.StrecthedBillboard) {
                  this._defines[CC_RENDER_MODE$1] = RENDER_MODE_STRETCHED_BILLBOARD$1;
                  this._frameTile_velLenScale.z = this._renderInfo.velocityScale;
                  this._frameTile_velLenScale.w = this._renderInfo.lengthScale;
                } else if (renderMode === RenderMode$1.HorizontalBillboard) {
                  this._defines[CC_RENDER_MODE$1] = RENDER_MODE_HORIZONTAL_BILLBOARD$1;
                } else if (renderMode === RenderMode$1.VerticalBillboard) {
                  this._defines[CC_RENDER_MODE$1] = RENDER_MODE_VERTICAL_BILLBOARD$1;
                } else if (renderMode === RenderMode$1.Mesh) {
                  this._defines[CC_RENDER_MODE$1] = RENDER_MODE_MESH$1;
                } else {
                  console.warn(`particle system renderMode ${renderMode} not support.`);
                }

                const textureModule = ps._textureAnimationModule;

                if (textureModule && textureModule.enable) {
                  Vec2.set(this._frameTile_velLenScale, textureModule.numTilesX, textureModule.numTilesY);
                  Vec4.copy(this._unifrom_velLenScale, this._frameTile_velLenScale);
                } else {
                  this._tmp_velLenScale.z = this._frameTile_velLenScale.z;
                  this._tmp_velLenScale.w = this._frameTile_velLenScale.w;
                  Vec4.copy(this._unifrom_velLenScale, this._tmp_velLenScale);
                }

                this.initShaderUniform(mat);
                mat.recompileShaders(this._defines);

                if (this._model) {
                  this._model.updateMaterial(mat);
                }
              }

            }

            var _dec$Z, _dec2$T, _dec3$R, _dec4$N, _dec5$K, _dec6$F, _dec7$E, _dec8$A, _dec9$x, _dec10$v, _dec11$s, _dec12$r, _dec13$o, _dec14$k, _dec15$k, _dec16$j, _dec17$g, _dec18$f, _dec19$f, _dec20$e, _dec21$d, _dec22$c, _dec23$c, _class$Z, _class2$P, _descriptor$O, _descriptor2$L, _descriptor3$D, _descriptor4$B, _descriptor5$v, _descriptor6$n, _descriptor7$j, _class3$k, _temp$S;

            function isSupportGPUParticle() {
              const device = director.root.device;

              if (device.capabilities.maxVertexTextureUnits >= 8 && device.hasFeature(Feature.TEXTURE_FLOAT)) {
                return true;
              }

              legacyCC.warn('Maybe the device has restrictions on vertex textures or does not support float textures.');
              return false;
            }

            let ParticleSystemRenderer = (_dec$Z = ccclass('cc.ParticleSystemRenderer'), _dec2$T = type$1(RenderMode$1), _dec3$R = displayOrder(), _dec4$N = tooltip(), _dec5$K = displayOrder(), _dec6$F = tooltip(), _dec7$E = displayOrder(), _dec8$A = tooltip(), _dec9$x = type$1(RenderMode$1), _dec10$v = type$1(Mesh), _dec11$s = displayOrder(), _dec12$r = tooltip(), _dec13$o = type$1(Material), _dec14$k = displayOrder(), _dec15$k = tooltip(), _dec16$j = type$1(Material), _dec17$g = displayOrder(), _dec18$f = tooltip(), _dec19$f = displayOrder(), _dec20$e = tooltip(), _dec21$d = type$1(AlignmentSpace), _dec22$c = displayOrder(), _dec23$c = tooltip(), _dec$Z(_class$Z = (_class2$P = (_temp$S = _class3$k = class ParticleSystemRenderer {
              constructor() {
                _initializerDefineProperty(this, "_renderMode", _descriptor$O, this);

                _initializerDefineProperty(this, "_velocityScale", _descriptor2$L, this);

                _initializerDefineProperty(this, "_lengthScale", _descriptor3$D, this);

                _initializerDefineProperty(this, "_mesh", _descriptor4$B, this);

                _initializerDefineProperty(this, "_mainTexture", _descriptor5$v, this);

                _initializerDefineProperty(this, "_useGPU", _descriptor6$n, this);

                _initializerDefineProperty(this, "_alignSpace", _descriptor7$j, this);

                this._particleSystem = null;
              }

              get renderMode() {
                return this._renderMode;
              }

              set renderMode(val) {
                if (this._renderMode === val) {
                  return;
                }

                this._renderMode = val;

                if (this._particleSystem) {
                  this._particleSystem.processor.updateRenderMode();
                }
              }

              get velocityScale() {
                return this._velocityScale;
              }

              set velocityScale(val) {
                this._velocityScale = val;

                if (this._particleSystem) {
                  this._particleSystem.processor.updateMaterialParams();
                }
              }

              get lengthScale() {
                return this._lengthScale;
              }

              set lengthScale(val) {
                this._lengthScale = val;

                if (this._particleSystem) {
                  this._particleSystem.processor.updateMaterialParams();
                }
              }

              get mesh() {
                return this._mesh;
              }

              set mesh(val) {
                this._mesh = val;

                if (this._particleSystem) {
                  this._particleSystem.processor.setVertexAttributes();
                }
              }

              get particleMaterial() {
                if (!this._particleSystem) {
                  return null;
                }

                return this._particleSystem.getMaterial(0);
              }

              set particleMaterial(val) {
                if (this._particleSystem) {
                  this._particleSystem.setMaterial(val, 0);
                }
              }

              get trailMaterial() {
                if (!this._particleSystem) {
                  return null;
                }

                return this._particleSystem.getMaterial(1);
              }

              set trailMaterial(val) {
                if (this._particleSystem) {
                  this._particleSystem.setMaterial(val, 1);
                }
              }

              get mainTexture() {
                return this._mainTexture;
              }

              set mainTexture(val) {
                this._mainTexture = val;
              }

              get useGPU() {
                return this._useGPU;
              }

              set useGPU(val) {
                if (this._useGPU === val) {
                  return;
                }

                if (!isSupportGPUParticle()) {
                  this._useGPU = false;
                } else {
                  this._useGPU = val;
                }

                this._switchProcessor();
              }

              get alignSpace() {
                return this._alignSpace;
              }

              set alignSpace(val) {
                this._alignSpace = val;

                this._particleSystem.processor.updateAlignSpace(this._alignSpace);
              }

              create(ps) {
                if (this._particleSystem === null) {
                  this._particleSystem = ps;
                } else if (this._particleSystem !== ps) {
                  errorID(6033);
                }
              }

              onInit(ps) {
                this.create(ps);

                if (!this._particleSystem.processor) {
                  const useGPU = this._useGPU && isSupportGPUParticle();
                  this._particleSystem.processor = useGPU ? new ParticleSystemRendererGPU(this) : new ParticleSystemRendererCPU(this);

                  this._particleSystem.processor.updateAlignSpace(this.alignSpace);

                  this._particleSystem.processor.onInit(ps);
                } else {
                  errorID(6034);
                }
              }

              _switchProcessor() {
                if (!this._particleSystem) {
                  return;
                }

                if (this._particleSystem.processor) {
                  this._particleSystem.processor.detachFromScene();

                  this._particleSystem.processor.clear();

                  this._particleSystem.processor = null;
                }

                this._particleSystem.processor = this._useGPU ? new ParticleSystemRendererGPU(this) : new ParticleSystemRendererCPU(this);

                this._particleSystem.processor.onInit(this._particleSystem);

                this._particleSystem.processor.onEnable();

                this._particleSystem.bindModule();
              }

            }, _class3$k.AlignmentSpace = AlignmentSpace, _temp$S), (_applyDecoratedDescriptor(_class2$P.prototype, "renderMode", [_dec2$T, _dec3$R, _dec4$N], Object.getOwnPropertyDescriptor(_class2$P.prototype, "renderMode"), _class2$P.prototype), _applyDecoratedDescriptor(_class2$P.prototype, "velocityScale", [_dec5$K, _dec6$F], Object.getOwnPropertyDescriptor(_class2$P.prototype, "velocityScale"), _class2$P.prototype), _applyDecoratedDescriptor(_class2$P.prototype, "lengthScale", [_dec7$E, _dec8$A], Object.getOwnPropertyDescriptor(_class2$P.prototype, "lengthScale"), _class2$P.prototype), _descriptor$O = _applyDecoratedDescriptor(_class2$P.prototype, "_renderMode", [_dec9$x, serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return RenderMode$1.Billboard;
              }
            }), _descriptor2$L = _applyDecoratedDescriptor(_class2$P.prototype, "_velocityScale", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            }), _descriptor3$D = _applyDecoratedDescriptor(_class2$P.prototype, "_lengthScale", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            }), _descriptor4$B = _applyDecoratedDescriptor(_class2$P.prototype, "_mesh", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _applyDecoratedDescriptor(_class2$P.prototype, "mesh", [_dec10$v, _dec11$s, _dec12$r], Object.getOwnPropertyDescriptor(_class2$P.prototype, "mesh"), _class2$P.prototype), _applyDecoratedDescriptor(_class2$P.prototype, "particleMaterial", [_dec13$o, _dec14$k, _dec15$k], Object.getOwnPropertyDescriptor(_class2$P.prototype, "particleMaterial"), _class2$P.prototype), _applyDecoratedDescriptor(_class2$P.prototype, "trailMaterial", [_dec16$j, _dec17$g, _dec18$f], Object.getOwnPropertyDescriptor(_class2$P.prototype, "trailMaterial"), _class2$P.prototype), _descriptor5$v = _applyDecoratedDescriptor(_class2$P.prototype, "_mainTexture", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor6$n = _applyDecoratedDescriptor(_class2$P.prototype, "_useGPU", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _applyDecoratedDescriptor(_class2$P.prototype, "useGPU", [_dec19$f, _dec20$e], Object.getOwnPropertyDescriptor(_class2$P.prototype, "useGPU"), _class2$P.prototype), _applyDecoratedDescriptor(_class2$P.prototype, "alignSpace", [_dec21$d, _dec22$c, _dec23$c], Object.getOwnPropertyDescriptor(_class2$P.prototype, "alignSpace"), _class2$P.prototype), _descriptor7$j = _applyDecoratedDescriptor(_class2$P.prototype, "_alignSpace", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return AlignmentSpace.View;
              }
            })), _class2$P)) || _class$Z);

            var _dec$_, _dec2$U, _dec3$S, _dec4$O, _dec5$L, _dec6$G, _dec7$F, _dec8$B, _dec9$y, _dec10$w, _dec11$t, _dec12$s, _dec13$p, _dec14$l, _dec15$l, _dec16$k, _dec17$h, _dec18$g, _dec19$g, _dec20$f, _dec21$e, _dec22$d, _dec23$d, _dec24$b, _dec25$b, _dec26$a, _dec27$a, _dec28$9, _dec29$8, _dec30$7, _dec31$6, _dec32$6, _class$_, _class2$Q, _descriptor$P, _descriptor2$M, _descriptor3$E, _descriptor4$C, _descriptor5$w, _descriptor6$o, _descriptor7$k, _descriptor8$g, _descriptor9$d, _descriptor10$c, _descriptor11$b, _descriptor12$9, _descriptor13$7, _temp$T;
            const PRE_TRIANGLE_INDEX = 1;
            const NEXT_TRIANGLE_INDEX = 1 << 2;
            const DIRECTION_THRESHOLD = Math.cos(toRadian(100));
            const _temp_trailEle = {
              position: new Vec3(),
              velocity: new Vec3()
            };

            const _temp_quat = new Quat();

            const _temp_xform = new Mat4();

            const _temp_vec3 = new Vec3();

            const _temp_vec3_1 = new Vec3();

            const _temp_color = new Color$1();

            class TrailSegment {
              constructor(maxTrailElementNum) {
                this.start = void 0;
                this.end = void 0;
                this.trailElements = void 0;
                this.start = -1;
                this.end = -1;
                this.trailElements = [];

                while (maxTrailElementNum--) {
                  this.trailElements.push({
                    position: new Vec3(),
                    lifetime: 0,
                    width: 0,
                    velocity: new Vec3(),
                    direction: 0,
                    color: new Color$1()
                  });
                }
              }

              getElement(idx) {
                if (this.start === -1) {
                  return null;
                }

                if (idx < 0) {
                  idx = (idx + this.trailElements.length) % this.trailElements.length;
                }

                if (idx >= this.trailElements.length) {
                  idx %= this.trailElements.length;
                }

                return this.trailElements[idx];
              }

              addElement() {
                if (this.trailElements.length === 0) {
                  return null;
                }

                if (this.start === -1) {
                  this.start = 0;
                  this.end = 1;
                  return this.trailElements[0];
                }

                if (this.start === this.end) {
                  this.trailElements.splice(this.end, 0, {
                    position: new Vec3(),
                    lifetime: 0,
                    width: 0,
                    velocity: new Vec3(),
                    direction: 0,
                    color: new Color$1()
                  });
                  this.start++;
                  this.start %= this.trailElements.length;
                }

                const newEleLoc = this.end++;
                this.end %= this.trailElements.length;
                return this.trailElements[newEleLoc];
              }

              iterateElement(target, f, p, dt) {
                const end = this.start >= this.end ? this.end + this.trailElements.length : this.end;

                for (let i = this.start; i < end; i++) {
                  if (f(target, this.trailElements[i % this.trailElements.length], p, dt)) {
                    this.start++;
                    this.start %= this.trailElements.length;
                  }
                }

                if (this.start === end) {
                  this.start = -1;
                  this.end = -1;
                }
              }

              count() {
                if (this.start < this.end) {
                  return this.end - this.start;
                } else {
                  return this.trailElements.length + this.end - this.start;
                }
              }

              clear() {
                this.start = -1;
                this.end = -1;
              }

            }

            let TrailModule = (_dec$_ = ccclass('cc.TrailModule'), _dec2$U = displayOrder(), _dec3$S = type$1(TrailMode), _dec4$O = displayOrder(), _dec5$L = tooltip(), _dec6$G = type$1(CurveRange), _dec7$F = range(), _dec8$B = displayOrder(), _dec9$y = tooltip(), _dec10$w = displayOrder(), _dec11$t = tooltip(), _dec12$s = type$1(Space), _dec13$p = displayOrder(), _dec14$l = tooltip(), _dec15$l = type$1(TextureMode), _dec16$k = displayOrder(), _dec17$h = tooltip(), _dec18$g = displayOrder(), _dec19$g = tooltip(), _dec20$f = type$1(CurveRange), _dec21$e = range(), _dec22$d = displayOrder(), _dec23$d = tooltip(), _dec24$b = displayOrder(), _dec25$b = tooltip(), _dec26$a = type$1(GradientRange), _dec27$a = displayOrder(), _dec28$9 = tooltip(), _dec29$8 = type$1(GradientRange), _dec30$7 = displayOrder(), _dec31$6 = tooltip(), _dec32$6 = type$1(Space), _dec$_(_class$_ = (_class2$Q = (_temp$T = class TrailModule {
              get enable() {
                return this._enable;
              }

              set enable(val) {
                if (val === this._enable && this._trailModel) {
                  return;
                }

                if (val && !this._enable) {
                  this._enable = val;
                  if (this._particleSystem.processor) this._particleSystem.processor.updateTrailMaterial();
                }

                if (val && !this._trailModel) {
                  this._createModel();

                  this.rebuild();
                }

                this._enable = val;

                if (this._trailModel) {
                  this._trailModel.enabled = val;
                }

                if (val) this.onEnable();else this.onDisable();
              }

              get minParticleDistance() {
                return this._minParticleDistance;
              }

              set minParticleDistance(val) {
                this._minParticleDistance = val;
                this._minSquaredDistance = val * val;
              }

              get space() {
                return this._space;
              }

              set space(val) {
                this._space = val;
                const ps = this._particleSystem;

                if (ps && ps.processor) {
                  ps.processor.updateTrailMaterial();
                }
              }

              constructor() {
                _initializerDefineProperty(this, "_enable", _descriptor$P, this);

                _initializerDefineProperty(this, "mode", _descriptor2$M, this);

                _initializerDefineProperty(this, "lifeTime", _descriptor3$E, this);

                _initializerDefineProperty(this, "_minParticleDistance", _descriptor4$C, this);

                _initializerDefineProperty(this, "existWithParticles", _descriptor5$w, this);

                _initializerDefineProperty(this, "textureMode", _descriptor6$o, this);

                _initializerDefineProperty(this, "widthFromParticle", _descriptor7$k, this);

                _initializerDefineProperty(this, "widthRatio", _descriptor8$g, this);

                _initializerDefineProperty(this, "colorFromParticle", _descriptor9$d, this);

                _initializerDefineProperty(this, "colorOverTrail", _descriptor10$c, this);

                _initializerDefineProperty(this, "colorOvertime", _descriptor11$b, this);

                _initializerDefineProperty(this, "_space", _descriptor12$9, this);

                _initializerDefineProperty(this, "_particleSystem", _descriptor13$7, this);

                this._minSquaredDistance = 0;
                this._vertSize = void 0;
                this._trailNum = 0;
                this._trailLifetime = 0;
                this.vbOffset = 0;
                this.ibOffset = 0;
                this._trailSegments = null;
                this._particleTrail = void 0;
                this._trailModel = null;
                this._iaInfo = void 0;
                this._iaInfoBuffer = null;
                this._subMeshData = null;
                this._vertAttrs = void 0;
                this._vbF32 = null;
                this._vbUint32 = null;
                this._iBuffer = null;
                this._needTransform = false;
                this._material = null;
                this._iaInfo = new IndirectBuffer([new DrawInfo()]);
                this._vertAttrs = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RGBA32F), new Attribute(AttributeName.ATTR_TEX_COORD1, Format.RGB32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA8, true)];
                this._vertSize = 0;

                for (const a of this._vertAttrs) {
                  this._vertSize += FormatInfos[a.format].size;
                }

                this._particleTrail = new Map();
              }

              onInit(ps) {
                this._particleSystem = ps;
                this.minParticleDistance = this._minParticleDistance;
                let burstCount = 0;
                const psTime = ps.startLifetime.getMax();
                const psRate = ps.rateOverTime.getMax();
                const duration = ps.duration;

                for (let i = 0, len = ps.bursts.length; i < len; i++) {
                  const b = ps.bursts[i];
                  burstCount += b.getMaxCount(ps) * Math.ceil(psTime / duration);
                }

                this._trailNum = Math.ceil(psTime * this.lifeTime.getMax() * 60 * (psRate * duration + burstCount));
                this._trailSegments = new Pool(() => new TrailSegment(10), Math.ceil(psRate * duration), obj => obj.trailElements.length = 0);

                if (this._enable) {
                  this.enable = this._enable;
                }
              }

              onEnable() {
                this._attachToScene();
              }

              onDisable() {
                this._particleTrail.clear();

                this._detachFromScene();
              }

              _attachToScene() {
                if (this._trailModel) {
                  if (this._trailModel.scene) {
                    this._detachFromScene();
                  }

                  this._particleSystem._getRenderScene().addModel(this._trailModel);
                }
              }

              _detachFromScene() {
                if (this._trailModel && this._trailModel.scene) {
                  this._trailModel.scene.removeModel(this._trailModel);
                }
              }

              destroy() {
                this.destroySubMeshData();

                if (this._trailModel) {
                  director.root.destroyModel(this._trailModel);
                  this._trailModel = null;
                }

                if (this._trailSegments) {
                  this._trailSegments.destroy();

                  this._trailSegments = null;
                }
              }

              play() {
                if (this._trailModel && this._enable) {
                  this._trailModel.enabled = true;
                }
              }

              clear() {
                if (this.enable) {
                  const trailIter = this._particleTrail.values();

                  let trail = trailIter.next();

                  while (!trail.done) {
                    trail.value.clear();
                    trail = trailIter.next();
                  }

                  this._particleTrail.clear();

                  this.updateRenderData();
                  if (this._trailModel) this._trailModel.enabled = false;
                }
              }

              updateMaterial() {
                if (this._particleSystem) {
                  this._material = this._particleSystem.getMaterialInstance(1) || this._particleSystem.processor._defaultTrailMat;

                  if (this._trailModel) {
                    this._trailModel.setSubModelMaterial(0, this._material);
                  }
                }
              }

              update() {
                this._trailLifetime = this.lifeTime.evaluate(this._particleSystem._time, 1);

                if (this.space === Space.World && this._particleSystem._simulationSpace === Space.Local) {
                  this._needTransform = true;

                  this._particleSystem.node.getWorldMatrix(_temp_xform);

                  this._particleSystem.node.getWorldRotation(_temp_quat);
                } else {
                  this._needTransform = false;
                }
              }

              animate(p, scaledDt) {
                if (!this._trailSegments) {
                  return;
                }

                if (p.loopCount > p.lastLoop) {
                  if (p.trailDelay > 1) {
                    p.lastLoop = p.loopCount;
                    p.trailDelay = 0;
                  } else {
                    p.trailDelay++;
                  }

                  return;
                }

                let trail = this._particleTrail.get(p);

                if (!trail) {
                  trail = this._trailSegments.alloc();

                  this._particleTrail.set(p, trail);

                  return;
                }

                let lastSeg = trail.getElement(trail.end - 1);

                if (this._needTransform) {
                  Vec3.transformMat4(_temp_vec3, p.position, _temp_xform);
                } else {
                  Vec3.copy(_temp_vec3, p.position);
                }

                if (lastSeg) {
                  trail.iterateElement(this, this._updateTrailElement, p, scaledDt);

                  if (Vec3.squaredDistance(lastSeg.position, _temp_vec3) < this._minSquaredDistance) {
                    return;
                  }
                }

                lastSeg = trail.addElement();

                if (!lastSeg) {
                  return;
                }

                Vec3.copy(lastSeg.position, _temp_vec3);
                lastSeg.lifetime = 0;

                if (this.widthFromParticle) {
                  lastSeg.width = p.size.x * this.widthRatio.evaluate(0, 1);
                } else {
                  lastSeg.width = this.widthRatio.evaluate(0, 1);
                }

                const trailNum = trail.count();

                if (trailNum === 2) {
                  const lastSecondTrail = trail.getElement(trail.end - 2);
                  Vec3.subtract(lastSecondTrail.velocity, lastSeg.position, lastSecondTrail.position);
                } else if (trailNum > 2) {
                  const lastSecondTrail = trail.getElement(trail.end - 2);
                  const lastThirdTrail = trail.getElement(trail.end - 3);
                  Vec3.subtract(_temp_vec3, lastThirdTrail.position, lastSecondTrail.position);
                  Vec3.subtract(_temp_vec3_1, lastSeg.position, lastSecondTrail.position);
                  Vec3.subtract(lastSecondTrail.velocity, _temp_vec3_1, _temp_vec3);

                  if (Vec3.equals(Vec3.ZERO, lastSecondTrail.velocity)) {
                    Vec3.copy(lastSecondTrail.velocity, _temp_vec3);
                  }

                  Vec3.normalize(lastSecondTrail.velocity, lastSecondTrail.velocity);

                  this._checkDirectionReverse(lastSecondTrail, lastThirdTrail);
                }

                if (this.colorFromParticle) {
                  lastSeg.color.set(p.color);
                } else {
                  lastSeg.color.set(this.colorOvertime.evaluate(0, 1));
                }
              }

              removeParticle(p) {
                const trail = this._particleTrail.get(p);

                if (trail && this._trailSegments) {
                  trail.clear();

                  this._trailSegments.free(trail);

                  this._particleTrail.delete(p);
                }
              }

              updateRenderData() {
                this.vbOffset = 0;
                this.ibOffset = 0;

                for (const p of this._particleTrail.keys()) {
                  const trailSeg = this._particleTrail.get(p);

                  if (trailSeg.start === -1) {
                    continue;
                  }

                  const indexOffset = this.vbOffset * 4 / this._vertSize;
                  const end = trailSeg.start >= trailSeg.end ? trailSeg.end + trailSeg.trailElements.length : trailSeg.end;
                  const trailNum = end - trailSeg.start;
                  const textCoordSeg = 1 / trailNum;
                  const startSegEle = trailSeg.trailElements[trailSeg.start];

                  this._fillVertexBuffer(startSegEle, this.colorOverTrail.evaluate(1, 1), indexOffset, 1, 0, NEXT_TRIANGLE_INDEX);

                  for (let i = trailSeg.start + 1; i < end; i++) {
                    const segEle = trailSeg.trailElements[i % trailSeg.trailElements.length];
                    const j = i - trailSeg.start;

                    this._fillVertexBuffer(segEle, this.colorOverTrail.evaluate(1 - j / trailNum, 1), indexOffset, 1 - j * textCoordSeg, j, PRE_TRIANGLE_INDEX | NEXT_TRIANGLE_INDEX);
                  }

                  if (this._needTransform) {
                    Vec3.transformMat4(_temp_trailEle.position, p.position, _temp_xform);
                  } else {
                    Vec3.copy(_temp_trailEle.position, p.position);
                  }

                  const trailModel = this._trailModel;

                  if (trailModel) {
                    trailModel.node.invalidateChildren(TransformBit.POSITION);
                  }

                  if (trailNum === 1 || trailNum === 2) {
                    const lastSecondTrail = trailSeg.getElement(trailSeg.end - 1);
                    Vec3.subtract(lastSecondTrail.velocity, _temp_trailEle.position, lastSecondTrail.position);
                    this._vbF32[this.vbOffset - this._vertSize / 4 - 4] = lastSecondTrail.velocity.x;
                    this._vbF32[this.vbOffset - this._vertSize / 4 - 3] = lastSecondTrail.velocity.y;
                    this._vbF32[this.vbOffset - this._vertSize / 4 - 2] = lastSecondTrail.velocity.z;
                    this._vbF32[this.vbOffset - 4] = lastSecondTrail.velocity.x;
                    this._vbF32[this.vbOffset - 3] = lastSecondTrail.velocity.y;
                    this._vbF32[this.vbOffset - 2] = lastSecondTrail.velocity.z;
                    Vec3.subtract(_temp_trailEle.velocity, _temp_trailEle.position, lastSecondTrail.position);

                    this._checkDirectionReverse(_temp_trailEle, lastSecondTrail);
                  } else if (trailNum > 2) {
                    const lastSecondTrail = trailSeg.getElement(trailSeg.end - 1);
                    const lastThirdTrail = trailSeg.getElement(trailSeg.end - 2);
                    Vec3.subtract(_temp_vec3, lastThirdTrail.position, lastSecondTrail.position);
                    Vec3.subtract(_temp_vec3_1, _temp_trailEle.position, lastSecondTrail.position);
                    Vec3.normalize(_temp_vec3, _temp_vec3);
                    Vec3.normalize(_temp_vec3_1, _temp_vec3_1);
                    Vec3.subtract(lastSecondTrail.velocity, _temp_vec3_1, _temp_vec3);
                    Vec3.normalize(lastSecondTrail.velocity, lastSecondTrail.velocity);

                    this._checkDirectionReverse(lastSecondTrail, lastThirdTrail);

                    this.vbOffset -= this._vertSize / 4 * 2;
                    this.ibOffset -= 6;

                    this._fillVertexBuffer(lastSecondTrail, this.colorOverTrail.evaluate(textCoordSeg, 1), indexOffset, textCoordSeg, trailNum - 1, PRE_TRIANGLE_INDEX | NEXT_TRIANGLE_INDEX);

                    Vec3.subtract(_temp_trailEle.velocity, _temp_trailEle.position, lastSecondTrail.position);
                    Vec3.normalize(_temp_trailEle.velocity, _temp_trailEle.velocity);

                    this._checkDirectionReverse(_temp_trailEle, lastSecondTrail);
                  }

                  if (this.widthFromParticle) {
                    _temp_trailEle.width = p.size.x * this.widthRatio.evaluate(0, 1);
                  } else {
                    _temp_trailEle.width = this.widthRatio.evaluate(0, 1);
                  }

                  _temp_trailEle.color = p.color;

                  if (Vec3.equals(_temp_trailEle.velocity, Vec3.ZERO)) {
                    this.ibOffset -= 3;
                  } else {
                    this._fillVertexBuffer(_temp_trailEle, this.colorOverTrail.evaluate(0, 1), indexOffset, 0, trailNum, PRE_TRIANGLE_INDEX);
                  }
                }

                this._trailModel.enabled = this.ibOffset > 0;
              }

              updateIA(count) {
                const subModels = this._trailModel && this._trailModel.subModels;

                if (subModels && subModels.length > 0) {
                  const subModel = subModels[0];
                  subModel.inputAssembler.vertexBuffers[0].update(this._vbF32);
                  subModel.inputAssembler.indexBuffer.update(this._iBuffer);
                  this._iaInfo.drawInfos[0].firstIndex = 0;
                  this._iaInfo.drawInfos[0].indexCount = count;

                  this._iaInfoBuffer.update(this._iaInfo);
                }
              }

              beforeRender() {
                this.updateIA(this.ibOffset);
              }

              _createModel() {
                if (this._trailModel) {
                  return;
                }

                this._trailModel = legacyCC.director.root.createModel(Model);
              }

              rebuild() {
                const device = director.root.device;
                const vertexBuffer = device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, this._vertSize * (this._trailNum + 1) * 2, this._vertSize));
                const vBuffer = new ArrayBuffer(this._vertSize * (this._trailNum + 1) * 2);
                this._vbF32 = new Float32Array(vBuffer);
                this._vbUint32 = new Uint32Array(vBuffer);
                vertexBuffer.update(vBuffer);
                const indexBuffer = device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, Math.max(1, this._trailNum) * 6 * Uint16Array.BYTES_PER_ELEMENT, Uint16Array.BYTES_PER_ELEMENT));
                this._iBuffer = new Uint16Array(Math.max(1, this._trailNum) * 6);
                indexBuffer.update(this._iBuffer);
                this._iaInfoBuffer = device.createBuffer(new BufferInfo(BufferUsageBit.INDIRECT, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, DRAW_INFO_SIZE, DRAW_INFO_SIZE));
                this._iaInfo.drawInfos[0].vertexCount = (this._trailNum + 1) * 2;
                this._iaInfo.drawInfos[0].indexCount = this._trailNum * 6;

                this._iaInfoBuffer.update(this._iaInfo);

                this._subMeshData = new RenderingSubMesh([vertexBuffer], this._vertAttrs, PrimitiveMode.TRIANGLE_LIST, indexBuffer, this._iaInfoBuffer);
                const trailModel = this._trailModel;

                if (trailModel) {
                  trailModel.node = trailModel.transform = this._particleSystem.node;
                  trailModel.visFlags = this._particleSystem.visibility;
                  trailModel.initSubModel(0, this._subMeshData, this._material);
                  trailModel.enabled = true;
                }
              }

              _updateTrailElement(module, trailEle, p, dt) {
                trailEle.lifetime += dt;

                if (module.colorFromParticle) {
                  trailEle.color.set(p.color);
                  trailEle.color.multiply(module.colorOvertime.evaluate(1.0 - p.remainingLifetime / p.startLifetime, 1));
                } else {
                  trailEle.color.set(module.colorOvertime.evaluate(1.0 - p.remainingLifetime / p.startLifetime, 1));
                }

                if (module.widthFromParticle) {
                  trailEle.width = p.size.x * module.widthRatio.evaluate(trailEle.lifetime / module._trailLifetime, 1);
                } else {
                  trailEle.width = module.widthRatio.evaluate(trailEle.lifetime / module._trailLifetime, 1);
                }

                return trailEle.lifetime > module._trailLifetime;
              }

              _fillVertexBuffer(trailSeg, colorModifer, indexOffset, xTexCoord, trailEleIdx, indexSet) {
                this._vbF32[this.vbOffset++] = trailSeg.position.x;
                this._vbF32[this.vbOffset++] = trailSeg.position.y;
                this._vbF32[this.vbOffset++] = trailSeg.position.z;
                this._vbF32[this.vbOffset++] = trailSeg.direction;
                this._vbF32[this.vbOffset++] = trailSeg.width;
                this._vbF32[this.vbOffset++] = xTexCoord;
                this._vbF32[this.vbOffset++] = 0;
                this._vbF32[this.vbOffset++] = trailSeg.velocity.x;
                this._vbF32[this.vbOffset++] = trailSeg.velocity.y;
                this._vbF32[this.vbOffset++] = trailSeg.velocity.z;

                _temp_color.set(trailSeg.color);

                _temp_color.multiply(colorModifer);

                this._vbUint32[this.vbOffset++] = _temp_color._val;
                this._vbF32[this.vbOffset++] = trailSeg.position.x;
                this._vbF32[this.vbOffset++] = trailSeg.position.y;
                this._vbF32[this.vbOffset++] = trailSeg.position.z;
                this._vbF32[this.vbOffset++] = 1 - trailSeg.direction;
                this._vbF32[this.vbOffset++] = trailSeg.width;
                this._vbF32[this.vbOffset++] = xTexCoord;
                this._vbF32[this.vbOffset++] = 1;
                this._vbF32[this.vbOffset++] = trailSeg.velocity.x;
                this._vbF32[this.vbOffset++] = trailSeg.velocity.y;
                this._vbF32[this.vbOffset++] = trailSeg.velocity.z;
                this._vbUint32[this.vbOffset++] = _temp_color._val;

                if (indexSet & PRE_TRIANGLE_INDEX) {
                  this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx;
                  this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx - 1;
                  this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx + 1;
                }

                if (indexSet & NEXT_TRIANGLE_INDEX) {
                  this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx;
                  this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx + 1;
                  this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx + 2;
                }
              }

              _checkDirectionReverse(currElement, prevElement) {
                if (Vec3.dot(currElement.velocity, prevElement.velocity) < DIRECTION_THRESHOLD) {
                  currElement.direction = 1 - prevElement.direction;
                } else {
                  currElement.direction = prevElement.direction;
                }
              }

              destroySubMeshData() {
                if (this._subMeshData) {
                  this._subMeshData.destroy();

                  this._subMeshData = null;
                }
              }

            }, _temp$T), (_applyDecoratedDescriptor(_class2$Q.prototype, "enable", [_dec2$U], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "enable"), _class2$Q.prototype), _descriptor$P = _applyDecoratedDescriptor(_class2$Q.prototype, "_enable", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor2$M = _applyDecoratedDescriptor(_class2$Q.prototype, "mode", [_dec3$S, serializable, _dec4$O, _dec5$L], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return TrailMode.Particles;
              }
            }), _descriptor3$E = _applyDecoratedDescriptor(_class2$Q.prototype, "lifeTime", [_dec6$G, serializable, _dec7$F, _dec8$B, _dec9$y], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new CurveRange();
              }
            }), _descriptor4$C = _applyDecoratedDescriptor(_class2$Q.prototype, "_minParticleDistance", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.1;
              }
            }), _applyDecoratedDescriptor(_class2$Q.prototype, "minParticleDistance", [_dec10$w, _dec11$t], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "minParticleDistance"), _class2$Q.prototype), _applyDecoratedDescriptor(_class2$Q.prototype, "space", [_dec12$s, _dec13$p, _dec14$l], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "space"), _class2$Q.prototype), _descriptor5$w = _applyDecoratedDescriptor(_class2$Q.prototype, "existWithParticles", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _descriptor6$o = _applyDecoratedDescriptor(_class2$Q.prototype, "textureMode", [_dec15$l, serializable, _dec16$k, _dec17$h], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return TextureMode.Stretch;
              }
            }), _descriptor7$k = _applyDecoratedDescriptor(_class2$Q.prototype, "widthFromParticle", [serializable, _dec18$g, _dec19$g], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _descriptor8$g = _applyDecoratedDescriptor(_class2$Q.prototype, "widthRatio", [_dec20$f, serializable, _dec21$e, _dec22$d, _dec23$d], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new CurveRange();
              }
            }), _descriptor9$d = _applyDecoratedDescriptor(_class2$Q.prototype, "colorFromParticle", [serializable, _dec24$b, _dec25$b], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor10$c = _applyDecoratedDescriptor(_class2$Q.prototype, "colorOverTrail", [_dec26$a, serializable, _dec27$a, _dec28$9], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new GradientRange();
              }
            }), _descriptor11$b = _applyDecoratedDescriptor(_class2$Q.prototype, "colorOvertime", [_dec29$8, serializable, _dec30$7, _dec31$6], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new GradientRange();
              }
            }), _descriptor12$9 = _applyDecoratedDescriptor(_class2$Q.prototype, "_space", [_dec32$6], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Space.World;
              }
            }), _descriptor13$7 = _applyDecoratedDescriptor(_class2$Q.prototype, "_particleSystem", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            })), _class2$Q)) || _class$_);

            const _node_mat = new Mat4();

            const _node_rol = new Quat();

            const _node_scale = new Vec3();

            const _anim_module$1 = ['_colorOverLifetimeModule', '_sizeOvertimeModule', '_velocityOvertimeModule', '_forceOvertimeModule', '_limitVelocityOvertimeModule', '_rotationOvertimeModule', '_textureAnimationModule'];
            class ParticleCuller {
              constructor(ps) {
                this._particleSystem = void 0;
                this._processor = void 0;
                this._node = void 0;
                this._particlesAll = void 0;
                this._updateList = new Map();
                this._animateList = new Map();
                this._runAnimateList = new Array();
                this._localMat = new Mat4();
                this._gravity = new Vec4();
                this.minPos = new Vec3();
                this.maxPos = new Vec3();
                this._nodePos = new Vec3();
                this._nodeSize = new Vec3();
                this._particleSystem = ps;
                this._processor = this._particleSystem.processor;
                this._node = ps.node;
                this._particlesAll = [];

                this._initModuleList();
              }

              _updateBoundingNode() {
                this._nodeSize.set(this.maxPos.x - this.minPos.x, this.maxPos.y - this.minPos.y, this.maxPos.z - this.minPos.z);

                this._nodePos.set(this.minPos.x + this._nodeSize.x * 0.5, this.minPos.y + this._nodeSize.y * 0.5, this.minPos.z + this._nodeSize.z * 0.5);
              }

              setBoundingBoxSize(halfExt) {
                this.maxPos.x = this._nodePos.x + halfExt.x;
                this.maxPos.y = this._nodePos.y + halfExt.y;
                this.maxPos.z = this._nodePos.z + halfExt.z;
                this.minPos.x = this._nodePos.x - halfExt.x;
                this.minPos.y = this._nodePos.y - halfExt.y;
                this.minPos.z = this._nodePos.z - halfExt.z;

                this._updateBoundingNode();
              }

              setBoundingBoxCenter(px, py, pz) {
                this.maxPos.x = px + this._nodeSize.x * 0.5;
                this.maxPos.y = py + this._nodeSize.y * 0.5;
                this.maxPos.z = pz + this._nodeSize.z * 0.5;
                this.minPos.x = px - this._nodeSize.x * 0.5;
                this.minPos.y = py - this._nodeSize.y * 0.5;
                this.minPos.z = pz - this._nodeSize.z * 0.5;

                this._updateBoundingNode();
              }

              _initModuleList() {
                _anim_module$1.forEach(val => {
                  const pm = this._particleSystem[val];

                  if (pm && pm.enable) {
                    if (pm.needUpdate) {
                      this._updateList[pm.name] = pm;
                    }

                    if (pm.needAnimate) {
                      this._animateList[pm.name] = pm;
                    }
                  }
                });

                this._runAnimateList.length = 0;

                for (let i = 0, len = PARTICLE_MODULE_ORDER.length; i < len; i++) {
                  const p = this._animateList[PARTICLE_MODULE_ORDER[i]];

                  if (p) {
                    this._runAnimateList.push(p);
                  }
                }
              }

              _emit(count, dt, particleLst) {
                const ps = this._particleSystem;
                const node = this._node;
                const loopDelta = ps.time % ps.duration / ps.duration;
                node.invalidateChildren(TransformBit.POSITION);

                if (ps.simulationSpace === Space.World) {
                  node.getWorldMatrix(_node_mat);
                  node.getWorldRotation(_node_rol);
                }

                for (let i = 0; i < count; ++i) {
                  const particle = new Particle(ps);
                  particle.particleSystem = ps;
                  particle.reset();
                  const rand = pseudoRandom(randomRangeInt(0, INT_MAX));

                  if (ps._shapeModule && ps._shapeModule.enable) {
                    ps._shapeModule.emit(particle);
                  } else {
                    Vec3.set(particle.position, 0, 0, 0);
                    Vec3.copy(particle.velocity, particleEmitZAxis);
                  }

                  if (ps._textureAnimationModule && ps._textureAnimationModule.enable) {
                    ps._textureAnimationModule.init(particle);
                  }

                  const curveStartSpeed = ps.startSpeed.evaluate(loopDelta, rand);
                  Vec3.multiplyScalar(particle.velocity, particle.velocity, curveStartSpeed);

                  if (ps.simulationSpace === Space.World) {
                    Vec3.transformMat4(particle.position, particle.position, _node_mat);
                    Vec3.transformQuat(particle.velocity, particle.velocity, _node_rol);
                  }

                  Vec3.copy(particle.ultimateVelocity, particle.velocity);
                  Vec3.set(particle.rotation, 0, 0, 0);

                  if (ps.startSize3D) {
                    Vec3.set(particle.startSize, ps.startSizeX.evaluate(loopDelta, rand), ps.startSizeY.evaluate(loopDelta, rand), ps.startSizeZ.evaluate(loopDelta, rand));
                  } else {
                    Vec3.set(particle.startSize, ps.startSizeX.evaluate(loopDelta, rand), 1, 1);
                    particle.startSize.y = particle.startSize.x;
                  }

                  Vec3.copy(particle.size, particle.startSize);
                  particle.startLifetime = ps.startLifetime.evaluate(loopDelta, rand) + dt;
                  particle.remainingLifetime = particle.startLifetime;
                  particleLst.push(particle);
                }
              }

              _updateParticles(dt, particleLst) {
                const ps = this._particleSystem;
                ps.node.getWorldMatrix(_node_mat);

                switch (ps.scaleSpace) {
                  case Space.Local:
                    ps.node.getScale(_node_scale);
                    break;

                  case Space.World:
                    ps.node.getWorldScale(_node_scale);
                    break;
                }

                this._updateList.forEach((value, key) => {
                  value.update(ps.simulationSpace, _node_mat);
                });

                if (ps.simulationSpace === Space.Local) {
                  const r = ps.node.getRotation();
                  Mat4.fromQuat(this._localMat, r);

                  this._localMat.transpose();
                }

                for (let i = 0; i < particleLst.length; ++i) {
                  const p = particleLst[i];
                  p.remainingLifetime -= dt;
                  Vec3.set(p.animatedVelocity, 0, 0, 0);

                  if (ps.simulationSpace === Space.Local) {
                    const gravityFactor = -ps.gravityModifier.evaluate(1 - p.remainingLifetime / p.startLifetime, pseudoRandom(p.randomSeed)) * 9.8 * dt;
                    this._gravity.x = 0.0;
                    this._gravity.y = gravityFactor;
                    this._gravity.z = 0.0;
                    this._gravity.w = 1.0;
                    this._gravity = this._gravity.transformMat4(this._localMat);
                    p.velocity.x += this._gravity.x;
                    p.velocity.y += this._gravity.y;
                    p.velocity.z += this._gravity.z;
                  } else {
                    p.velocity.y -= ps.gravityModifier.evaluate(1 - p.remainingLifetime / p.startLifetime, pseudoRandom(p.randomSeed)) * 9.8 * dt;
                  }

                  Vec3.copy(p.ultimateVelocity, p.velocity);

                  this._runAnimateList.forEach(value => {
                    value.animate(p, dt);
                  });

                  Vec3.scaleAndAdd(p.position, p.position, p.ultimateVelocity, dt);
                }
              }

              _calculateBounding(isInit) {
                const size = new Vec3();
                const position = new Vec3();
                const subPos = new Vec3();
                const addPos = new Vec3();
                const meshSize = new Vec3(1.0, 1.0, 1.0);

                if (this._processor.getInfo().renderMode === RenderMode$1.Mesh) {
                  const mesh = this._processor.getInfo().mesh;

                  if (mesh && mesh.struct.minPosition && mesh.struct.maxPosition) {
                    const meshAABB = new AABB();
                    AABB.fromPoints(meshAABB, mesh.struct.minPosition, mesh.struct.maxPosition);
                    const meshMax = Math.max(meshAABB.halfExtents.x, meshAABB.halfExtents.y, meshAABB.halfExtents.z);
                    meshSize.set(meshMax, meshMax, meshMax);
                  }
                }

                for (let i = 0; i < this._particlesAll.length; ++i) {
                  const p = this._particlesAll[i];
                  Vec3.multiply(size, _node_scale, p.size);
                  Vec3.multiply(size, size, meshSize);
                  position.set(p.position);

                  if (this._particleSystem.simulationSpace !== Space.World) {
                    Vec3.transformMat4(position, position, this._particleSystem.node._mat);
                  }

                  if (isInit && i === 0) {
                    Vec3.subtract(this.minPos, position, size);
                    Vec3.add(this.maxPos, position, size);
                  } else {
                    Vec3.subtract(subPos, position, size);
                    Vec3.add(addPos, position, size);
                    Vec3.min(this.minPos, this.minPos, subPos);
                    Vec3.max(this.maxPos, this.maxPos, addPos);
                  }
                }
              }

              calculatePositions() {
                this._emit(this._particleSystem.capacity, 0, this._particlesAll);

                const rand = pseudoRandom(randomRangeInt(0, INT_MAX));

                this._updateParticles(0, this._particlesAll);

                this._calculateBounding(true);

                this._updateParticles(this._particleSystem.startLifetime.evaluate(0, rand), this._particlesAll);

                this._calculateBounding(false);

                this._updateBoundingNode();
              }

              clear() {
                this._particlesAll.length = 0;
              }

              destroy() {}

            }

            var _dec$$, _dec2$V, _dec3$T, _dec4$P, _dec5$M, _dec6$H, _dec7$G, _dec8$C, _dec9$z, _dec10$x, _dec11$u, _dec12$t, _dec13$q, _dec14$m, _dec15$m, _dec16$l, _dec17$i, _dec18$h, _dec19$h, _dec20$g, _dec21$f, _dec22$e, _dec23$e, _dec24$c, _dec25$c, _dec26$b, _dec27$b, _dec28$a, _dec29$9, _dec30$8, _dec31$7, _dec32$7, _dec33$5, _dec34$4, _dec35$3, _dec36$3, _dec37$3, _dec38$3, _dec39$3, _dec40$3, _dec41$3, _dec42$3, _dec43$3, _dec44$2, _dec45$2, _dec46$1, _dec47$1, _dec48, _dec49, _dec50, _dec51, _dec52, _dec53, _dec54, _dec55, _dec56, _dec57, _dec58, _dec59, _dec60, _dec61, _dec62, _dec63, _dec64, _dec65, _dec66, _dec67, _dec68, _dec69, _dec70, _dec71, _dec72, _dec73, _dec74, _dec75, _dec76, _dec77, _dec78, _dec79, _dec80, _dec81, _dec82, _dec83, _dec84, _dec85, _dec86, _dec87, _dec88, _dec89, _dec90, _dec91, _dec92, _dec93, _dec94, _dec95, _dec96, _dec97, _dec98, _dec99, _dec100, _dec101, _dec102, _dec103, _dec104, _dec105, _dec106, _dec107, _dec108, _dec109, _dec110, _dec111, _dec112, _dec113, _dec114, _dec115, _dec116, _dec117, _dec118, _dec119, _dec120, _dec121, _dec122, _dec123, _dec124, _dec125, _dec126, _dec127, _dec128, _dec129, _dec130, _dec131, _dec132, _dec133, _dec134, _dec135, _dec136, _dec137, _dec138, _dec139, _dec140, _dec141, _dec142, _class$$, _class2$R, _descriptor$Q, _descriptor2$N, _descriptor3$F, _descriptor4$D, _descriptor5$x, _descriptor6$p, _descriptor7$l, _descriptor8$h, _descriptor9$e, _descriptor10$d, _descriptor11$c, _descriptor12$a, _descriptor13$8, _descriptor14$5, _descriptor15$4, _descriptor16$4, _descriptor17$3, _descriptor18$2, _descriptor19$1, _descriptor20, _descriptor21, _descriptor22, _descriptor23, _descriptor24, _descriptor25, _descriptor26, _descriptor27, _descriptor28, _descriptor29, _descriptor30, _descriptor31, _descriptor32, _descriptor33, _descriptor34, _descriptor35, _descriptor36, _descriptor37, _descriptor38, _descriptor39, _descriptor40, _class3$l, _temp$U;

            const _world_mat = new Mat4();

            const _world_rol = new Quat();

            const superMaterials = Object.getOwnPropertyDescriptor(RenderableComponent.prototype, 'sharedMaterials');
            let ParticleSystem = function (v) { return exports({ ParticleSystem: v, ParticleSystemComponent: v }), v; }((_dec$$ = ccclass('cc.ParticleSystem'), _dec2$V = help(), _dec3$T = menu$1(), _dec4$P = executionOrder(99), _dec5$M = displayOrder(), _dec6$H = tooltip(), _dec7$G = type$1(GradientRange), _dec8$C = displayOrder(), _dec9$z = tooltip(), _dec10$x = type$1(Space), _dec11$u = displayOrder(), _dec12$t = tooltip(), _dec13$q = displayOrder(), _dec14$m = tooltip(), _dec15$m = formerlySerializedAs('startSize'), _dec16$l = range(), _dec17$i = type$1(CurveRange), _dec18$h = displayOrder(), _dec19$h = tooltip(), _dec20$g = type$1(CurveRange), _dec21$f = range(), _dec22$e = displayOrder(), _dec23$e = tooltip(), _dec24$c = type$1(CurveRange), _dec25$c = range(), _dec26$b = displayOrder(), _dec27$b = tooltip(), _dec28$a = type$1(CurveRange), _dec29$9 = range(), _dec30$8 = displayOrder(), _dec31$7 = tooltip(), _dec32$7 = displayOrder(), _dec33$5 = tooltip(), _dec34$4 = type$1(CurveRange), _dec35$3 = range(), _dec36$3 = displayOrder(), _dec37$3 = tooltip(), _dec38$3 = type$1(CurveRange), _dec39$3 = range(), _dec40$3 = displayOrder(), _dec41$3 = tooltip(), _dec42$3 = type$1(CurveRange), _dec43$3 = formerlySerializedAs('startRotation'), _dec44$2 = range(), _dec45$2 = displayOrder(), _dec46$1 = tooltip(), _dec47$1 = type$1(CurveRange), _dec48 = range(), _dec49 = displayOrder(), _dec50 = tooltip(), _dec51 = type$1(CurveRange), _dec52 = range(), _dec53 = displayOrder(), _dec54 = tooltip(), _dec55 = displayOrder(), _dec56 = tooltip(), _dec57 = displayOrder(), _dec58 = tooltip(), _dec59 = displayOrder(), _dec60 = tooltip(), _dec61 = type$1(Space), _dec62 = displayOrder(), _dec63 = tooltip(), _dec64 = displayOrder(), _dec65 = tooltip(), _dec66 = displayOrder(), _dec67 = tooltip(), _dec68 = type$1(CurveRange), _dec69 = range(), _dec70 = displayOrder(), _dec71 = tooltip(), _dec72 = type$1(CurveRange), _dec73 = range(), _dec74 = displayOrder(), _dec75 = tooltip(), _dec76 = type$1(CurveRange), _dec77 = range(), _dec78 = displayOrder(), _dec79 = tooltip(), _dec80 = type$1([Burst]), _dec81 = displayOrder(), _dec82 = tooltip(), _dec83 = type$1(Boolean), _dec84 = displayOrder(), _dec85 = tooltip(), _dec86 = type$1(CullingMode), _dec87 = displayOrder(), _dec88 = tooltip(), _dec89 = type$1(Number), _dec90 = displayOrder(), _dec91 = tooltip(), _dec92 = type$1(Number), _dec93 = displayOrder(), _dec94 = tooltip(), _dec95 = type$1(Number), _dec96 = displayOrder(), _dec97 = tooltip(), _dec98 = displayOrder(), _dec99 = tooltip(), _dec100 = formerlySerializedAs('enableCulling'), _dec101 = visible(), _dec102 = type$1(Material), _dec103 = displayName(), _dec104 = type$1(ColorOvertimeModule), _dec105 = type$1(ColorOvertimeModule), _dec106 = displayOrder(), _dec107 = tooltip(), _dec108 = type$1(ShapeModule), _dec109 = type$1(ShapeModule), _dec110 = displayOrder(), _dec111 = tooltip(), _dec112 = type$1(SizeOvertimeModule), _dec113 = type$1(SizeOvertimeModule), _dec114 = displayOrder(), _dec115 = tooltip(), _dec116 = type$1(VelocityOvertimeModule), _dec117 = type$1(VelocityOvertimeModule), _dec118 = displayOrder(), _dec119 = tooltip(), _dec120 = type$1(ForceOvertimeModule), _dec121 = type$1(ForceOvertimeModule), _dec122 = displayOrder(), _dec123 = tooltip(), _dec124 = type$1(LimitVelocityOvertimeModule), _dec125 = type$1(LimitVelocityOvertimeModule), _dec126 = displayOrder(), _dec127 = tooltip(), _dec128 = type$1(RotationOvertimeModule), _dec129 = type$1(RotationOvertimeModule), _dec130 = displayOrder(), _dec131 = tooltip(), _dec132 = type$1(TextureAnimationModule), _dec133 = type$1(TextureAnimationModule), _dec134 = displayOrder(), _dec135 = tooltip(), _dec136 = type$1(TrailModule), _dec137 = type$1(TrailModule), _dec138 = displayOrder(), _dec139 = tooltip(), _dec140 = type$1(ParticleSystemRenderer), _dec141 = displayOrder(), _dec142 = tooltip(), _dec$$(_class$$ = _dec2$V(_class$$ = _dec3$T(_class$$ = _dec4$P(_class$$ = executeInEditMode(_class$$ = (_class2$R = (_temp$U = _class3$l = class ParticleSystem extends RenderableComponent {
              get capacity() {
                return this._capacity;
              }

              set capacity(val) {
                this._capacity = Math.floor(val);

                if (this.processor && this.processor._model) {
                  this.processor._model.setCapacity(this._capacity);
                }
              }

              get prewarm() {
                return this._prewarm;
              }

              set prewarm(val) {
                if (val === true && this.loop === false) ;

                this._prewarm = val;
              }

              get simulationSpace() {
                return this._simulationSpace;
              }

              set simulationSpace(val) {
                if (val !== this._simulationSpace) {
                  this._simulationSpace = val;

                  if (this.processor) {
                    this.processor.updateMaterialParams();
                    this.processor.updateTrailMaterial();
                  }
                }
              }

              set renderCulling(value) {
                this._renderCulling = value;

                if (value) {
                  if (!this._boundingBox) {
                    this._boundingBox = new AABB();

                    this._calculateBounding(false);
                  }
                }
              }

              get renderCulling() {
                return this._renderCulling;
              }

              get cullingMode() {
                return this._cullingMode;
              }

              set cullingMode(value) {
                this._cullingMode = value;
              }

              get aabbHalfX() {
                const res = this.getBoundingX();

                if (res) {
                  return res;
                } else {
                  return 0;
                }
              }

              set aabbHalfX(value) {
                this.setBoundingX(value);
              }

              get aabbHalfY() {
                const res = this.getBoundingY();

                if (res) {
                  return res;
                } else {
                  return 0;
                }
              }

              set aabbHalfY(value) {
                this.setBoundingY(value);
              }

              get aabbHalfZ() {
                const res = this.getBoundingZ();

                if (res) {
                  return res;
                } else {
                  return 0;
                }
              }

              set aabbHalfZ(value) {
                this.setBoundingZ(value);
              }

              get dataCulling() {
                return this._dataCulling;
              }

              set dataCulling(value) {
                this._dataCulling = value;
              }

              get sharedMaterials() {
                return superMaterials.get.call(this);
              }

              set sharedMaterials(val) {
                superMaterials.set.call(this, val);
              }

              get colorOverLifetimeModule() {

                return this._colorOverLifetimeModule;
              }

              set colorOverLifetimeModule(val) {
                if (!val) return;
                this._colorOverLifetimeModule = val;
              }

              get shapeModule() {

                return this._shapeModule;
              }

              set shapeModule(val) {
                if (!val) return;
                this._shapeModule = val;
              }

              get sizeOvertimeModule() {

                return this._sizeOvertimeModule;
              }

              set sizeOvertimeModule(val) {
                if (!val) return;
                this._sizeOvertimeModule = val;
              }

              get velocityOvertimeModule() {

                return this._velocityOvertimeModule;
              }

              set velocityOvertimeModule(val) {
                if (!val) return;
                this._velocityOvertimeModule = val;
              }

              get forceOvertimeModule() {

                return this._forceOvertimeModule;
              }

              set forceOvertimeModule(val) {
                if (!val) return;
                this._forceOvertimeModule = val;
              }

              get limitVelocityOvertimeModule() {

                return this._limitVelocityOvertimeModule;
              }

              set limitVelocityOvertimeModule(val) {
                if (!val) return;
                this._limitVelocityOvertimeModule = val;
              }

              get rotationOvertimeModule() {

                return this._rotationOvertimeModule;
              }

              set rotationOvertimeModule(val) {
                if (!val) return;
                this._rotationOvertimeModule = val;
              }

              get textureAnimationModule() {

                return this._textureAnimationModule;
              }

              set textureAnimationModule(val) {
                if (!val) return;
                this._textureAnimationModule = val;
              }

              get trailModule() {

                return this._trailModule;
              }

              set trailModule(val) {
                if (!val) return;
                this._trailModule = val;
              }

              constructor() {
                super();

                _initializerDefineProperty(this, "startColor", _descriptor$Q, this);

                _initializerDefineProperty(this, "scaleSpace", _descriptor2$N, this);

                _initializerDefineProperty(this, "startSize3D", _descriptor3$F, this);

                _initializerDefineProperty(this, "startSizeX", _descriptor4$D, this);

                _initializerDefineProperty(this, "startSizeY", _descriptor5$x, this);

                _initializerDefineProperty(this, "startSizeZ", _descriptor6$p, this);

                _initializerDefineProperty(this, "startSpeed", _descriptor7$l, this);

                _initializerDefineProperty(this, "startRotation3D", _descriptor8$h, this);

                _initializerDefineProperty(this, "startRotationX", _descriptor9$e, this);

                _initializerDefineProperty(this, "startRotationY", _descriptor10$d, this);

                _initializerDefineProperty(this, "startRotationZ", _descriptor11$c, this);

                _initializerDefineProperty(this, "startDelay", _descriptor12$a, this);

                _initializerDefineProperty(this, "startLifetime", _descriptor13$8, this);

                _initializerDefineProperty(this, "duration", _descriptor14$5, this);

                _initializerDefineProperty(this, "loop", _descriptor15$4, this);

                _initializerDefineProperty(this, "simulationSpeed", _descriptor16$4, this);

                _initializerDefineProperty(this, "playOnAwake", _descriptor17$3, this);

                _initializerDefineProperty(this, "gravityModifier", _descriptor18$2, this);

                _initializerDefineProperty(this, "rateOverTime", _descriptor19$1, this);

                _initializerDefineProperty(this, "rateOverDistance", _descriptor20, this);

                _initializerDefineProperty(this, "bursts", _descriptor21, this);

                _initializerDefineProperty(this, "_renderCulling", _descriptor22, this);

                _initializerDefineProperty(this, "_cullingMode", _descriptor23, this);

                _initializerDefineProperty(this, "_aabbHalfX", _descriptor24, this);

                _initializerDefineProperty(this, "_aabbHalfY", _descriptor25, this);

                _initializerDefineProperty(this, "_aabbHalfZ", _descriptor26, this);

                _initializerDefineProperty(this, "_dataCulling", _descriptor27, this);

                _initializerDefineProperty(this, "_colorOverLifetimeModule", _descriptor28, this);

                _initializerDefineProperty(this, "_shapeModule", _descriptor29, this);

                _initializerDefineProperty(this, "_sizeOvertimeModule", _descriptor30, this);

                _initializerDefineProperty(this, "_velocityOvertimeModule", _descriptor31, this);

                _initializerDefineProperty(this, "_forceOvertimeModule", _descriptor32, this);

                _initializerDefineProperty(this, "_limitVelocityOvertimeModule", _descriptor33, this);

                _initializerDefineProperty(this, "_rotationOvertimeModule", _descriptor34, this);

                _initializerDefineProperty(this, "_textureAnimationModule", _descriptor35, this);

                _initializerDefineProperty(this, "_trailModule", _descriptor36, this);

                _initializerDefineProperty(this, "renderer", _descriptor37, this);

                this._isPlaying = void 0;
                this._isPaused = void 0;
                this._isStopped = void 0;
                this._isEmitting = void 0;
                this._needRefresh = void 0;
                this._time = void 0;
                this._emitRateTimeCounter = void 0;
                this._emitRateDistanceCounter = void 0;
                this._oldWPos = void 0;
                this._curWPos = void 0;
                this._boundingBox = void 0;
                this._culler = void 0;
                this._oldPos = void 0;
                this._curPos = void 0;
                this._isCulled = void 0;
                this._customData1 = void 0;
                this._customData2 = void 0;
                this._subEmitters = void 0;

                _initializerDefineProperty(this, "_prewarm", _descriptor38, this);

                _initializerDefineProperty(this, "_capacity", _descriptor39, this);

                _initializerDefineProperty(this, "_simulationSpace", _descriptor40, this);

                this.processor = null;
                this.rateOverTime.constant = 10;
                this.startLifetime.constant = 5;
                this.startSizeX.constant = 1;
                this.startSpeed.constant = 5;
                this._isPlaying = false;
                this._isPaused = false;
                this._isStopped = true;
                this._isEmitting = false;
                this._needRefresh = true;
                this._time = 0.0;
                this._emitRateTimeCounter = 0.0;
                this._emitRateDistanceCounter = 0.0;
                this._oldWPos = new Vec3();
                this._curWPos = new Vec3();
                this._boundingBox = null;
                this._culler = null;
                this._oldPos = null;
                this._curPos = null;
                this._isCulled = false;
                this._customData1 = new Vec2();
                this._customData2 = new Vec2();
                this._subEmitters = [];
              }

              onFocusInEditor() {
                this.renderer.create(this);
              }

              onLoad() {
                this.renderer.onInit(this);
                if (this._shapeModule) this._shapeModule.onInit(this);
                if (this._trailModule) this._trailModule.onInit(this);
                this.bindModule();

                this._resetPosition();
              }

              _onMaterialModified(index, material) {
                if (this.processor !== null) {
                  this.processor.onMaterialModified(index, material);
                }
              }

              _onRebuildPSO(index, material) {
                this.processor.onRebuildPSO(index, material);
              }

              _collectModels() {
                this._models.length = 0;

                this._models.push(this.processor._model);

                if (this._trailModule && this._trailModule.enable && this._trailModule._trailModel) {
                  this._models.push(this._trailModule._trailModel);
                }

                return this._models;
              }

              _attachToScene() {
                this.processor.attachToScene();

                if (this._trailModule && this._trailModule.enable) {
                  this._trailModule._attachToScene();
                }
              }

              _detachFromScene() {
                this.processor.detachFromScene();

                if (this._trailModule && this._trailModule.enable) {
                  this._trailModule._detachFromScene();
                }

                if (this._boundingBox) {
                  this._boundingBox = null;
                }

                if (this._culler) {
                  this._culler.clear();

                  this._culler.destroy();

                  this._culler = null;
                }
              }

              bindModule() {
                if (this._colorOverLifetimeModule) this._colorOverLifetimeModule.bindTarget(this.processor);
                if (this._sizeOvertimeModule) this._sizeOvertimeModule.bindTarget(this.processor);
                if (this._rotationOvertimeModule) this._rotationOvertimeModule.bindTarget(this.processor);
                if (this._forceOvertimeModule) this._forceOvertimeModule.bindTarget(this.processor);
                if (this._limitVelocityOvertimeModule) this._limitVelocityOvertimeModule.bindTarget(this.processor);
                if (this._velocityOvertimeModule) this._velocityOvertimeModule.bindTarget(this.processor);
                if (this._textureAnimationModule) this._textureAnimationModule.bindTarget(this.processor);
              }

              play() {
                if (this._isPaused) {
                  this._isPaused = false;
                }

                if (this._isStopped) {
                  this._isStopped = false;
                }

                this._isPlaying = true;
                this._isEmitting = true;

                this._resetPosition();

                if (this._prewarm) {
                  this._prewarmSystem();
                }

                if (this._trailModule) {
                  this._trailModule.play();
                }
              }

              pause() {
                if (this._isStopped) {
                  console.warn('pause(): particle system is already stopped.');
                  return;
                }

                if (this._isPlaying) {
                  this._isPlaying = false;
                }

                this._isPaused = true;
              }

              stop() {
                if (this._isPlaying || this._isPaused) {
                  this.clear();
                }

                if (this._isPlaying) {
                  this._isPlaying = false;
                }

                if (this._isPaused) {
                  this._isPaused = false;
                }

                this._time = 0.0;
                this._emitRateTimeCounter = 0.0;
                this._emitRateDistanceCounter = 0.0;
                this._isStopped = true;
                this._needRefresh = true;

                for (const burst of this.bursts) {
                  burst.reset();
                }
              }

              clear() {
                if (this.enabledInHierarchy) {
                  this.processor.clear();
                  if (this._trailModule) this._trailModule.clear();
                }

                this._calculateBounding(true);
              }

              getParticleCount() {
                return this.processor.getParticleCount();
              }

              setCustomData1(x, y) {
                Vec2.set(this._customData1, x, y);
              }

              setCustomData2(x, y) {
                Vec2.set(this._customData2, x, y);
              }

              onDestroy() {
                legacyCC.director.off(legacyCC.Director.EVENT_BEFORE_COMMIT, this.beforeRender, this);
                this.processor.onDestroy();
                if (this._trailModule) this._trailModule.destroy();

                if (this._culler) {
                  this._culler.clear();

                  this._culler.destroy();

                  this._culler = null;
                }
              }

              onEnable() {
                legacyCC.director.on(legacyCC.Director.EVENT_BEFORE_COMMIT, this.beforeRender, this);

                if (this.playOnAwake) {
                  this.play();
                }

                this.processor.onEnable();
                if (this._trailModule) this._trailModule.onEnable();
              }

              onDisable() {
                legacyCC.director.off(legacyCC.Director.EVENT_BEFORE_COMMIT, this.beforeRender, this);
                this.processor.onDisable();
                if (this._trailModule) this._trailModule.onDisable();

                if (this._boundingBox) {
                  this._boundingBox = null;
                }

                if (this._culler) {
                  this._culler.clear();

                  this._culler.destroy();

                  this._culler = null;
                }
              }

              _calculateBounding(forceRefresh) {
                if (this._boundingBox) {
                  if (!this._culler) {
                    this._culler = new ParticleCuller(this);
                  }

                  this._culler.calculatePositions();

                  AABB.fromPoints(this._boundingBox, this._culler.minPos, this._culler.maxPos);

                  if (forceRefresh) {
                    this.aabbHalfX = this._boundingBox.halfExtents.x;
                    this.aabbHalfY = this._boundingBox.halfExtents.y;
                    this.aabbHalfZ = this._boundingBox.halfExtents.z;
                  } else {
                    if (this.aabbHalfX) {
                      this.setBoundingX(this.aabbHalfX);
                    } else {
                      this.aabbHalfX = this._boundingBox.halfExtents.x;
                    }

                    if (this.aabbHalfY) {
                      this.setBoundingY(this.aabbHalfY);
                    } else {
                      this.aabbHalfY = this._boundingBox.halfExtents.y;
                    }

                    if (this.aabbHalfZ) {
                      this.setBoundingZ(this.aabbHalfZ);
                    } else {
                      this.aabbHalfZ = this._boundingBox.halfExtents.z;
                    }
                  }

                  this._culler.clear();
                }
              }

              update(dt) {
                const scaledDeltaTime = dt * this.simulationSpeed;

                if (this.renderCulling) {
                  var _this$node$scene$rend;

                  if (!this._boundingBox) {
                    this._boundingBox = new AABB();

                    this._calculateBounding(false);
                  }

                  if (!this._curPos) {
                    this._curPos = new Vec3();
                  }

                  this.node.getWorldPosition(this._curPos);

                  if (!this._oldPos) {
                    this._oldPos = new Vec3();

                    this._oldPos.set(this._curPos);
                  }

                  if (!this._curPos.equals(this._oldPos) && this._boundingBox && this._culler) {
                    const dx = this._curPos.x - this._oldPos.x;
                    const dy = this._curPos.y - this._oldPos.y;
                    const dz = this._curPos.z - this._oldPos.z;
                    const center = this._boundingBox.center;
                    center.x += dx;
                    center.y += dy;
                    center.z += dz;

                    this._culler.setBoundingBoxCenter(center.x, center.y, center.z);

                    this._oldPos.set(this._curPos);
                  }

                  const cameraLst = (_this$node$scene$rend = this.node.scene.renderScene) === null || _this$node$scene$rend === void 0 ? void 0 : _this$node$scene$rend.cameras;
                  let culled = true;

                  if (cameraLst !== undefined && this._boundingBox) {
                    for (let i = 0; i < cameraLst.length; ++i) {
                      const camera = cameraLst[i];
                      const visibility = camera.visibility;

                      if ((visibility & this.node.layer) === this.node.layer) {
                        if (intersect.aabbFrustum(this._boundingBox, camera.frustum)) {
                          culled = false;
                          break;
                        }
                      }
                    }
                  }

                  if (culled) {
                    if (this._cullingMode !== CullingMode.AlwaysSimulate) {
                      this.pause();
                    }

                    if (!this._isCulled) {
                      this.processor.detachFromScene();
                      this._isCulled = true;
                    }

                    if (this._trailModule && this._trailModule.enable) {
                      this._trailModule._detachFromScene();
                    }

                    if (this._cullingMode === CullingMode.PauseAndCatchup) {
                      this._time += scaledDeltaTime;
                    }

                    if (this._cullingMode !== CullingMode.AlwaysSimulate) {
                      return;
                    }
                  } else {
                    if (this._isCulled) {
                      this._attachToScene();

                      this._isCulled = false;
                    }

                    if (!this._isPlaying) {
                      this.play();
                    }
                  }
                } else {
                  if (this._boundingBox) {
                    this._boundingBox = null;
                  }

                  if (this._culler) {
                    this._culler.clear();

                    this._culler.destroy();

                    this._culler = null;
                  }
                }

                if (this._isPlaying) {
                  this._time += scaledDeltaTime;

                  this._emit(scaledDeltaTime);

                  if (this.processor.updateParticles(scaledDeltaTime) === 0 && !this._isEmitting) {
                    this.stop();
                  }
                } else {
                  this.processor.updateRotation();
                  this.processor.updateScale();
                }

                this.processor.updateRenderData();

                if (this._trailModule && this._trailModule.enable) {
                  this._trailModule.updateRenderData();
                }
              }

              beforeRender() {
                if (!this._isPlaying) return;
                this.processor.beforeRender();

                if (this._trailModule && this._trailModule.enable) {
                  this._trailModule.beforeRender();
                }
              }

              _onVisibilityChange(val) {
                if (this.processor._model) {
                  this.processor._model.visFlags = val;
                }
              }

              emit(count, dt) {
                const loopDelta = this._time % this.duration / this.duration;

                if (this._needRefresh) {
                  this.node.invalidateChildren(TransformBit.POSITION);
                  this._needRefresh = false;
                }

                if (this._simulationSpace === Space.World) {
                  this.node.getWorldMatrix(_world_mat);
                  this.node.getWorldRotation(_world_rol);
                }

                for (let i = 0; i < count; ++i) {
                  const particle = this.processor.getFreeParticle();

                  if (particle === null) {
                    return;
                  }

                  particle.particleSystem = this;
                  particle.reset();
                  const rand = pseudoRandom(randomRangeInt(0, INT_MAX));

                  if (this._shapeModule && this._shapeModule.enable) {
                    this._shapeModule.emit(particle);
                  } else {
                    Vec3.set(particle.position, 0, 0, 0);
                    Vec3.copy(particle.velocity, particleEmitZAxis);
                  }

                  if (this._textureAnimationModule && this._textureAnimationModule.enable) {
                    this._textureAnimationModule.init(particle);
                  }

                  const curveStartSpeed = this.startSpeed.evaluate(loopDelta, rand);
                  Vec3.multiplyScalar(particle.velocity, particle.velocity, curveStartSpeed);

                  if (this._simulationSpace === Space.World) {
                    Vec3.transformMat4(particle.position, particle.position, _world_mat);
                    Vec3.transformQuat(particle.velocity, particle.velocity, _world_rol);
                  }

                  Vec3.copy(particle.ultimateVelocity, particle.velocity);

                  if (this.startRotation3D) {
                    particle.startEuler.set(this.startRotationX.evaluate(loopDelta, rand), this.startRotationY.evaluate(loopDelta, rand), this.startRotationZ.evaluate(loopDelta, rand));
                  } else {
                    particle.startEuler.set(0, 0, this.startRotationZ.evaluate(loopDelta, rand));
                  }

                  Vec3.set(particle.rotation, particle.startEuler.x, particle.startEuler.y, particle.startEuler.z);

                  if (this.startSize3D) {
                    Vec3.set(particle.startSize, this.startSizeX.evaluate(loopDelta, rand), this.startSizeY.evaluate(loopDelta, rand), this.startSizeZ.evaluate(loopDelta, rand));
                  } else {
                    Vec3.set(particle.startSize, this.startSizeX.evaluate(loopDelta, rand), 1, 1);
                    particle.startSize.y = particle.startSize.x;
                  }

                  Vec3.copy(particle.size, particle.startSize);
                  particle.startColor.set(this.startColor.evaluate(loopDelta, rand));
                  particle.color.set(particle.startColor);
                  particle.startLifetime = this.startLifetime.evaluate(loopDelta, rand) + dt;
                  particle.remainingLifetime = particle.startLifetime;
                  particle.randomSeed = randomRangeInt(0, 233280);
                  particle.loopCount++;
                  this.processor.setNewParticle(particle);
                }
              }

              _prewarmSystem() {
                this.startDelay.mode = Mode$1.Constant;
                this.startDelay.constant = 0;
                const dt = 1.0;
                const cnt = this.duration / dt;

                for (let i = 0; i < cnt; ++i) {
                  this._time += dt;

                  this._emit(dt);

                  this.processor.updateParticles(dt);
                }
              }

              _emit(dt) {
                const startDelay = this.startDelay.evaluate(0, 1);

                if (this._time > startDelay) {
                  if (this._time > this.duration + startDelay) {
                    if (!this.loop) {
                      this._isEmitting = false;
                      return;
                    }
                  }

                  this._emitRateTimeCounter += this.rateOverTime.evaluate(this._time / this.duration, 1) * dt;

                  if (this._emitRateTimeCounter > 1 && this._isEmitting) {
                    const emitNum = Math.floor(this._emitRateTimeCounter);
                    this._emitRateTimeCounter -= emitNum;
                    this.emit(emitNum, dt);
                  }

                  this.node.getWorldPosition(this._curWPos);
                  const distance = Vec3.distance(this._curWPos, this._oldWPos);
                  Vec3.copy(this._oldWPos, this._curWPos);
                  this._emitRateDistanceCounter += distance * this.rateOverDistance.evaluate(this._time / this.duration, 1);

                  if (this._emitRateDistanceCounter > 1 && this._isEmitting) {
                    const emitNum = Math.floor(this._emitRateDistanceCounter);
                    this._emitRateDistanceCounter -= emitNum;
                    this.emit(emitNum, dt);
                  }

                  for (const burst of this.bursts) {
                    burst.update(this, dt);
                  }
                }
              }

              _resetPosition() {
                this.node.getWorldPosition(this._oldWPos);
                Vec3.copy(this._curWPos, this._oldWPos);
              }

              addSubEmitter(subEmitter) {
                this._subEmitters.push(subEmitter);
              }

              removeSubEmitter(idx) {
                this._subEmitters.splice(this._subEmitters.indexOf(idx), 1);
              }

              addBurst(burst) {
                this.bursts.push(burst);
              }

              removeBurst(idx) {
                this.bursts.splice(this.bursts.indexOf(idx), 1);
              }

              getBoundingX() {
                return this._aabbHalfX;
              }

              getBoundingY() {
                return this._aabbHalfY;
              }

              getBoundingZ() {
                return this._aabbHalfZ;
              }

              setBoundingX(value) {
                if (this._boundingBox && this._culler) {
                  this._boundingBox.halfExtents.x = value;

                  this._culler.setBoundingBoxSize(this._boundingBox.halfExtents);

                  this._aabbHalfX = value;
                }
              }

              setBoundingY(value) {
                if (this._boundingBox && this._culler) {
                  this._boundingBox.halfExtents.y = value;

                  this._culler.setBoundingBoxSize(this._boundingBox.halfExtents);

                  this._aabbHalfY = value;
                }
              }

              setBoundingZ(value) {
                if (this._boundingBox && this._culler) {
                  this._boundingBox.halfExtents.z = value;

                  this._culler.setBoundingBoxSize(this._boundingBox.halfExtents);

                  this._aabbHalfZ = value;
                }
              }

              get isPlaying() {
                return this._isPlaying;
              }

              get isPaused() {
                return this._isPaused;
              }

              get isStopped() {
                return this._isStopped;
              }

              get isEmitting() {
                return this._isEmitting;
              }

              get time() {
                return this._time;
              }

              _onBeforeSerialize(props) {
                return this.dataCulling ? props.filter(p => !PARTICLE_MODULE_PROPERTY.includes(p) || this[p] && this[p].enable) : props;
              }

            }, _class3$l.CullingMode = CullingMode, _temp$U), (_applyDecoratedDescriptor(_class2$R.prototype, "capacity", [_dec5$M, _dec6$H], Object.getOwnPropertyDescriptor(_class2$R.prototype, "capacity"), _class2$R.prototype), _descriptor$Q = _applyDecoratedDescriptor(_class2$R.prototype, "startColor", [_dec7$G, serializable, _dec8$C, _dec9$z], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new GradientRange();
              }
            }), _descriptor2$N = _applyDecoratedDescriptor(_class2$R.prototype, "scaleSpace", [_dec10$x, serializable, _dec11$u, _dec12$t], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Space.Local;
              }
            }), _descriptor3$F = _applyDecoratedDescriptor(_class2$R.prototype, "startSize3D", [serializable, _dec13$q, _dec14$m], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor4$D = _applyDecoratedDescriptor(_class2$R.prototype, "startSizeX", [_dec15$m, _dec16$l, _dec17$i, _dec18$h, _dec19$h], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new CurveRange();
              }
            }), _descriptor5$x = _applyDecoratedDescriptor(_class2$R.prototype, "startSizeY", [_dec20$g, serializable, _dec21$f, _dec22$e, _dec23$e], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new CurveRange();
              }
            }), _descriptor6$p = _applyDecoratedDescriptor(_class2$R.prototype, "startSizeZ", [_dec24$c, serializable, _dec25$c, _dec26$b, _dec27$b], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new CurveRange();
              }
            }), _descriptor7$l = _applyDecoratedDescriptor(_class2$R.prototype, "startSpeed", [_dec28$a, serializable, _dec29$9, _dec30$8, _dec31$7], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new CurveRange();
              }
            }), _descriptor8$h = _applyDecoratedDescriptor(_class2$R.prototype, "startRotation3D", [serializable, _dec32$7, _dec33$5], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor9$e = _applyDecoratedDescriptor(_class2$R.prototype, "startRotationX", [_dec34$4, serializable, _dec35$3, radian, _dec36$3, _dec37$3], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new CurveRange();
              }
            }), _descriptor10$d = _applyDecoratedDescriptor(_class2$R.prototype, "startRotationY", [_dec38$3, serializable, _dec39$3, radian, _dec40$3, _dec41$3], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new CurveRange();
              }
            }), _descriptor11$c = _applyDecoratedDescriptor(_class2$R.prototype, "startRotationZ", [_dec42$3, _dec43$3, _dec44$2, radian, _dec45$2, _dec46$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new CurveRange();
              }
            }), _descriptor12$a = _applyDecoratedDescriptor(_class2$R.prototype, "startDelay", [_dec47$1, serializable, _dec48, _dec49, _dec50], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new CurveRange();
              }
            }), _descriptor13$8 = _applyDecoratedDescriptor(_class2$R.prototype, "startLifetime", [_dec51, serializable, _dec52, _dec53, _dec54], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new CurveRange();
              }
            }), _descriptor14$5 = _applyDecoratedDescriptor(_class2$R.prototype, "duration", [serializable, _dec55, _dec56], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 5.0;
              }
            }), _descriptor15$4 = _applyDecoratedDescriptor(_class2$R.prototype, "loop", [serializable, _dec57, _dec58], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _applyDecoratedDescriptor(_class2$R.prototype, "prewarm", [_dec59, _dec60], Object.getOwnPropertyDescriptor(_class2$R.prototype, "prewarm"), _class2$R.prototype), _applyDecoratedDescriptor(_class2$R.prototype, "simulationSpace", [_dec61, serializable, _dec62, _dec63], Object.getOwnPropertyDescriptor(_class2$R.prototype, "simulationSpace"), _class2$R.prototype), _descriptor16$4 = _applyDecoratedDescriptor(_class2$R.prototype, "simulationSpeed", [serializable, _dec64, _dec65], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1.0;
              }
            }), _descriptor17$3 = _applyDecoratedDescriptor(_class2$R.prototype, "playOnAwake", [serializable, _dec66, _dec67], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _descriptor18$2 = _applyDecoratedDescriptor(_class2$R.prototype, "gravityModifier", [_dec68, serializable, _dec69, _dec70, _dec71], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new CurveRange();
              }
            }), _descriptor19$1 = _applyDecoratedDescriptor(_class2$R.prototype, "rateOverTime", [_dec72, serializable, _dec73, _dec74, _dec75], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new CurveRange();
              }
            }), _descriptor20 = _applyDecoratedDescriptor(_class2$R.prototype, "rateOverDistance", [_dec76, serializable, _dec77, _dec78, _dec79], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new CurveRange();
              }
            }), _descriptor21 = _applyDecoratedDescriptor(_class2$R.prototype, "bursts", [_dec80, serializable, _dec81, _dec82], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _applyDecoratedDescriptor(_class2$R.prototype, "renderCulling", [_dec83, _dec84, _dec85], Object.getOwnPropertyDescriptor(_class2$R.prototype, "renderCulling"), _class2$R.prototype), _descriptor22 = _applyDecoratedDescriptor(_class2$R.prototype, "_renderCulling", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _applyDecoratedDescriptor(_class2$R.prototype, "cullingMode", [_dec86, _dec87, _dec88], Object.getOwnPropertyDescriptor(_class2$R.prototype, "cullingMode"), _class2$R.prototype), _descriptor23 = _applyDecoratedDescriptor(_class2$R.prototype, "_cullingMode", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return CullingMode.Pause;
              }
            }), _applyDecoratedDescriptor(_class2$R.prototype, "aabbHalfX", [_dec89, _dec90, _dec91], Object.getOwnPropertyDescriptor(_class2$R.prototype, "aabbHalfX"), _class2$R.prototype), _descriptor24 = _applyDecoratedDescriptor(_class2$R.prototype, "_aabbHalfX", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _applyDecoratedDescriptor(_class2$R.prototype, "aabbHalfY", [_dec92, _dec93, _dec94], Object.getOwnPropertyDescriptor(_class2$R.prototype, "aabbHalfY"), _class2$R.prototype), _descriptor25 = _applyDecoratedDescriptor(_class2$R.prototype, "_aabbHalfY", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _applyDecoratedDescriptor(_class2$R.prototype, "aabbHalfZ", [_dec95, _dec96, _dec97], Object.getOwnPropertyDescriptor(_class2$R.prototype, "aabbHalfZ"), _class2$R.prototype), _descriptor26 = _applyDecoratedDescriptor(_class2$R.prototype, "_aabbHalfZ", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _applyDecoratedDescriptor(_class2$R.prototype, "dataCulling", [_dec98, _dec99], Object.getOwnPropertyDescriptor(_class2$R.prototype, "dataCulling"), _class2$R.prototype), _descriptor27 = _applyDecoratedDescriptor(_class2$R.prototype, "_dataCulling", [serializable, _dec100], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _applyDecoratedDescriptor(_class2$R.prototype, "sharedMaterials", [override, _dec101, _dec102, serializable, _dec103], Object.getOwnPropertyDescriptor(_class2$R.prototype, "sharedMaterials"), _class2$R.prototype), _descriptor28 = _applyDecoratedDescriptor(_class2$R.prototype, "_colorOverLifetimeModule", [_dec104], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _applyDecoratedDescriptor(_class2$R.prototype, "colorOverLifetimeModule", [_dec105, _dec106, _dec107], Object.getOwnPropertyDescriptor(_class2$R.prototype, "colorOverLifetimeModule"), _class2$R.prototype), _descriptor29 = _applyDecoratedDescriptor(_class2$R.prototype, "_shapeModule", [_dec108], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _applyDecoratedDescriptor(_class2$R.prototype, "shapeModule", [_dec109, _dec110, _dec111], Object.getOwnPropertyDescriptor(_class2$R.prototype, "shapeModule"), _class2$R.prototype), _descriptor30 = _applyDecoratedDescriptor(_class2$R.prototype, "_sizeOvertimeModule", [_dec112], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _applyDecoratedDescriptor(_class2$R.prototype, "sizeOvertimeModule", [_dec113, _dec114, _dec115], Object.getOwnPropertyDescriptor(_class2$R.prototype, "sizeOvertimeModule"), _class2$R.prototype), _descriptor31 = _applyDecoratedDescriptor(_class2$R.prototype, "_velocityOvertimeModule", [_dec116], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _applyDecoratedDescriptor(_class2$R.prototype, "velocityOvertimeModule", [_dec117, _dec118, _dec119], Object.getOwnPropertyDescriptor(_class2$R.prototype, "velocityOvertimeModule"), _class2$R.prototype), _descriptor32 = _applyDecoratedDescriptor(_class2$R.prototype, "_forceOvertimeModule", [_dec120], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _applyDecoratedDescriptor(_class2$R.prototype, "forceOvertimeModule", [_dec121, _dec122, _dec123], Object.getOwnPropertyDescriptor(_class2$R.prototype, "forceOvertimeModule"), _class2$R.prototype), _descriptor33 = _applyDecoratedDescriptor(_class2$R.prototype, "_limitVelocityOvertimeModule", [_dec124], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _applyDecoratedDescriptor(_class2$R.prototype, "limitVelocityOvertimeModule", [_dec125, _dec126, _dec127], Object.getOwnPropertyDescriptor(_class2$R.prototype, "limitVelocityOvertimeModule"), _class2$R.prototype), _descriptor34 = _applyDecoratedDescriptor(_class2$R.prototype, "_rotationOvertimeModule", [_dec128], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _applyDecoratedDescriptor(_class2$R.prototype, "rotationOvertimeModule", [_dec129, _dec130, _dec131], Object.getOwnPropertyDescriptor(_class2$R.prototype, "rotationOvertimeModule"), _class2$R.prototype), _descriptor35 = _applyDecoratedDescriptor(_class2$R.prototype, "_textureAnimationModule", [_dec132], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _applyDecoratedDescriptor(_class2$R.prototype, "textureAnimationModule", [_dec133, _dec134, _dec135], Object.getOwnPropertyDescriptor(_class2$R.prototype, "textureAnimationModule"), _class2$R.prototype), _descriptor36 = _applyDecoratedDescriptor(_class2$R.prototype, "_trailModule", [_dec136], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _applyDecoratedDescriptor(_class2$R.prototype, "trailModule", [_dec137, _dec138, _dec139], Object.getOwnPropertyDescriptor(_class2$R.prototype, "trailModule"), _class2$R.prototype), _descriptor37 = _applyDecoratedDescriptor(_class2$R.prototype, "renderer", [_dec140, serializable, _dec141, _dec142], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new ParticleSystemRenderer();
              }
            }), _descriptor38 = _applyDecoratedDescriptor(_class2$R.prototype, "_prewarm", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor39 = _applyDecoratedDescriptor(_class2$R.prototype, "_capacity", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 100;
              }
            }), _descriptor40 = _applyDecoratedDescriptor(_class2$R.prototype, "_simulationSpace", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Space.Local;
              }
            })), _class2$R)) || _class$$) || _class$$) || _class$$) || _class$$) || _class$$));

            class ParticleUtils {
              static instantiate(prefab) {
                if (!this.registeredSceneEvent) {
                  director.on(Director.EVENT_BEFORE_SCENE_LAUNCH, this.onSceneUnload, this);
                  this.registeredSceneEvent = true;
                }

                if (!this.particleSystemPool.has(prefab._uuid)) {
                  this.particleSystemPool.set(prefab._uuid, new Pool(() => instantiate(prefab) || new Node(), 1, prefab => prefab.destroy()));
                }

                return this.particleSystemPool.get(prefab._uuid).alloc();
              }

              static destroy(prefab) {
                if (this.particleSystemPool.has(prefab._prefab.asset._uuid)) {
                  this.stop(prefab);
                  this.particleSystemPool.get(prefab._prefab.asset._uuid).free(prefab);
                }
              }

              static play(rootNode) {
                for (const ps of rootNode.getComponentsInChildren(ParticleSystem)) {
                  ps.play();
                }
              }

              static stop(rootNode) {
                for (const ps of rootNode.getComponentsInChildren(ParticleSystem)) {
                  ps.stop();
                }
              }

              static onSceneUnload() {
                this.particleSystemPool.forEach(value => value.destroy());
                this.particleSystemPool.clear();
              }

            } exports('ParticleUtils', ParticleUtils);
            ParticleUtils.particleSystemPool = new Map();
            ParticleUtils.registeredSceneEvent = false;

            removeProperty(Burst.prototype, 'Burst.prototype', [{
              name: 'minCount'
            }, {
              name: 'maxCount'
            }]);
            replaceProperty(ParticleSystem.prototype, 'ParticleSystem.prototype', [{
              name: 'enableCulling',
              newName: 'dataCulling'
            }]);
            legacyCC.ParticleSystemComponent = ParticleSystem;
            js.setClassAlias(ParticleSystem, 'cc.ParticleSystemComponent');
            legacyCC.BillboardComponent = Billboard;
            js.setClassAlias(Billboard, 'cc.BillboardComponent');
            legacyCC.LineComponent = Line;
            js.setClassAlias(Line, 'cc.LineComponent');

            legacyCC.ParticleUtils = ParticleUtils;

            function wireframe(indices) {
              const offsets = [[0, 1], [1, 2], [2, 0]];
              const lines = [];
              const lineIDs = {};

              for (let i = 0; i < indices.length; i += 3) {
                for (let k = 0; k < 3; ++k) {
                  const i1 = indices[i + offsets[k][0]];
                  const i2 = indices[i + offsets[k][1]];
                  const id = i1 > i2 ? i2 << 16 | i1 : i1 << 16 | i2;

                  if (lineIDs[id] === undefined) {
                    lineIDs[id] = 0;
                    lines.push(i1, i2);
                  }
                }
              }

              return lines;
            }
            function invWinding(indices) {
              const newIB = [];

              for (let i = 0; i < indices.length; i += 3) {
                newIB.push(indices[i], indices[i + 2], indices[i + 1]);
              }

              return newIB;
            }
            function toWavefrontOBJ(primitive, scale = 1) {
              if (!primitive.indices || !primitive.uvs || !primitive.normals || primitive.primitiveMode !== undefined && primitive.primitiveMode !== PrimitiveMode.TRIANGLE_LIST) {
                return '';
              }

              const v = primitive.positions;
              const t = primitive.uvs;
              const n = primitive.normals;
              const IB = primitive.indices;

              const V = i => `${IB[i] + 1}/${IB[i] + 1}/${IB[i] + 1}`;

              let content = '';

              for (let i = 0; i < v.length; i += 3) {
                content += `v ${v[i] * scale} ${v[i + 1] * scale} ${v[i + 2] * scale}\n`;
              }

              for (let i = 0; i < t.length; i += 2) {
                content += `vt ${t[i]} ${t[i + 1]}\n`;
              }

              for (let i = 0; i < n.length; i += 3) {
                content += `vn ${n[i]} ${n[i + 1]} ${n[i + 2]}\n`;
              }

              for (let i = 0; i < IB.length; i += 3) {
                content += `f ${V(i)} ${V(i + 1)} ${V(i + 2)}\n`;
              }

              return content;
            }
            function normals(positions, nms, length = 1) {
              const verts = new Array(2 * positions.length);

              for (let i = 0; i < positions.length / 3; ++i) {
                const i3 = 3 * i;
                const i6 = 6 * i;
                verts[i6 + 0] = positions[i3 + 0];
                verts[i6 + 1] = positions[i3 + 1];
                verts[i6 + 2] = positions[i3 + 2];
                verts[i6 + 3] = positions[i3 + 0] + nms[i3 + 0] * length;
                verts[i6 + 4] = positions[i3 + 1] + nms[i3 + 1] * length;
                verts[i6 + 5] = positions[i3 + 2] + nms[i3 + 2] * length;
              }

              return verts;
            }

            function cone(radius = 0.5, height = 1, opts = {}) {
              return cylinder(0, radius, height, opts);
            }

            function quad(options) {
              const normalizedOptions = applyDefaultGeometryOptions(options);
              const result = {
                positions: [-0.5, -0.5, 0, -0.5, 0.5, 0, 0.5, 0.5, 0, 0.5, -0.5, 0],
                indices: [0, 3, 1, 3, 2, 1],
                minPos: {
                  x: -0.5,
                  y: -0.5,
                  z: 0
                },
                maxPos: {
                  x: 0.5,
                  y: 0.5,
                  z: 0
                },
                boundingRadius: Math.sqrt(0.5 * 0.5 + 0.5 * 0.5)
              };

              if (normalizedOptions.includeNormal !== false) {
                result.normals = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1];
              }

              if (normalizedOptions.includeUV !== false) {
                result.uvs = [0, 0, 0, 1, 1, 1, 1, 0];
              }

              return result;
            }

            function sphere(radius = 0.5, opts = {}) {
              const segments = opts.segments !== undefined ? opts.segments : 32;
              const positions = [];
              const normals = [];
              const uvs = [];
              const indices = [];
              const minPos = new Vec3(-radius, -radius, -radius);
              const maxPos = new Vec3(radius, radius, radius);
              const boundingRadius = radius;

              for (let lat = 0; lat <= segments; ++lat) {
                const theta = lat * Math.PI / segments;
                const sinTheta = Math.sin(theta);
                const cosTheta = -Math.cos(theta);

                for (let lon = 0; lon <= segments; ++lon) {
                  const phi = lon * 2 * Math.PI / segments - Math.PI / 2.0;
                  const sinPhi = Math.sin(phi);
                  const cosPhi = Math.cos(phi);
                  const x = sinPhi * sinTheta;
                  const y = cosTheta;
                  const z = cosPhi * sinTheta;
                  const u = lon / segments;
                  const v = lat / segments;
                  positions.push(x * radius, y * radius, z * radius);
                  normals.push(x, y, z);
                  uvs.push(u, v);

                  if (lat < segments && lon < segments) {
                    const seg1 = segments + 1;
                    const a = seg1 * lat + lon;
                    const b = seg1 * (lat + 1) + lon;
                    const c = seg1 * (lat + 1) + lon + 1;
                    const d = seg1 * lat + lon + 1;
                    indices.push(a, d, b);
                    indices.push(d, c, b);
                  }
                }
              }

              return {
                positions,
                indices,
                normals,
                uvs,
                minPos,
                maxPos,
                boundingRadius
              };
            }

            function torus(radius = 0.4, tube = 0.1, opts = {}) {
              const radialSegments = opts.radialSegments || 32;
              const tubularSegments = opts.tubularSegments || 32;
              const arc = opts.arc || 2.0 * Math.PI;
              const positions = [];
              const normals = [];
              const uvs = [];
              const indices = [];
              const minPos = new Vec3(-radius - tube, -tube, -radius - tube);
              const maxPos = new Vec3(radius + tube, tube, radius + tube);
              const boundingRadius = radius + tube;

              for (let j = 0; j <= radialSegments; j++) {
                for (let i = 0; i <= tubularSegments; i++) {
                  const u = i / tubularSegments;
                  const v = j / radialSegments;
                  const u1 = u * arc;
                  const v1 = v * Math.PI * 2;
                  const x = (radius + tube * Math.cos(v1)) * Math.sin(u1);
                  const y = tube * Math.sin(v1);
                  const z = (radius + tube * Math.cos(v1)) * Math.cos(u1);
                  const nx = Math.sin(u1) * Math.cos(v1);
                  const ny = Math.sin(v1);
                  const nz = Math.cos(u1) * Math.cos(v1);
                  positions.push(x, y, z);
                  normals.push(nx, ny, nz);
                  uvs.push(u, v);

                  if (i < tubularSegments && j < radialSegments) {
                    const seg1 = tubularSegments + 1;
                    const a = seg1 * j + i;
                    const b = seg1 * (j + 1) + i;
                    const c = seg1 * (j + 1) + i + 1;
                    const d = seg1 * j + i + 1;
                    indices.push(a, d, b);
                    indices.push(d, c, b);
                  }
                }
              }

              return {
                positions,
                normals,
                uvs,
                indices,
                minPos,
                maxPos,
                boundingRadius
              };
            }

            function applyDefaultCircleOptions(options) {
              options = applyDefaultGeometryOptions(options);
              options.segments = 64;
              return options;
            }

            function circle(options) {
              const normalizedOptions = applyDefaultCircleOptions(options);
              const segments = normalizedOptions.segments;
              const positions = new Array(3 * (segments + 1));
              positions[0] = 0;
              positions[1] = 0;
              positions[2] = 0;
              const indices = new Array(1 + segments * 2);
              indices[0] = 0;
              const step = Math.PI * 2 / segments;

              for (let iSegment = 0; iSegment < segments; ++iSegment) {
                const angle = step * iSegment;
                const x = Math.cos(angle);
                const y = Math.sin(angle);
                const p = (iSegment + 1) * 3;
                positions[p + 0] = x;
                positions[p + 1] = y;
                positions[p + 2] = 0;
                const i = iSegment * 2;
                indices[1 + i] = iSegment + 1;
                indices[1 + (i + 1)] = iSegment + 2;
              }

              if (segments > 0) {
                indices[indices.length - 1] = 1;
              }

              const result = {
                positions,
                indices,
                minPos: {
                  x: 1,
                  y: 1,
                  z: 0
                },
                maxPos: {
                  x: -1,
                  y: -1,
                  z: 0
                },
                boundingRadius: 1,
                primitiveMode: PrimitiveMode.TRIANGLE_FAN
              };
              return result;
            }

            function translate(geometry, offset) {
              const x = offset.x || 0;
              const y = offset.y || 0;
              const z = offset.z || 0;
              const nVertex = Math.floor(geometry.positions.length / 3);

              for (let iVertex = 0; iVertex < nVertex; ++iVertex) {
                const iX = iVertex * 3;
                const iY = iVertex * 3 + 1;
                const iZ = iVertex * 3 + 2;
                geometry.positions[iX] += x;
                geometry.positions[iY] += y;
                geometry.positions[iZ] += z;
              }

              if (geometry.minPos) {
                geometry.minPos.x += x;
                geometry.minPos.y += y;
                geometry.minPos.z += z;
              }

              if (geometry.maxPos) {
                geometry.maxPos.x += x;
                geometry.maxPos.y += y;
                geometry.maxPos.z += z;
              }

              return geometry;
            }
            function scale(geometry, value) {
              const x = value.x || 0;
              const y = value.y || 0;
              const z = value.z || 0;
              const nVertex = Math.floor(geometry.positions.length / 3);

              for (let iVertex = 0; iVertex < nVertex; ++iVertex) {
                const iX = iVertex * 3;
                const iY = iVertex * 3 + 1;
                const iZ = iVertex * 3 + 2;
                geometry.positions[iX] *= x;
                geometry.positions[iY] *= y;
                geometry.positions[iZ] *= z;
              }

              if (geometry.minPos) {
                geometry.minPos.x *= x;
                geometry.minPos.y *= y;
                geometry.minPos.z *= z;
              }

              if (geometry.maxPos) {
                geometry.maxPos.x *= x;
                geometry.maxPos.y *= y;
                geometry.maxPos.z *= z;
              }

              geometry.boundingRadius = Math.max(Math.max(x, y), z);
              return geometry;
            }
            function wireframed(geometry) {
              const {
                indices
              } = geometry;

              if (!indices) {
                return geometry;
              }

              if (geometry.primitiveMode && geometry.primitiveMode !== PrimitiveMode.TRIANGLE_LIST) {
                return geometry;
              }

              const offsets = [[0, 1], [1, 2], [2, 0]];
              const lines = [];
              const lineIDs = {};

              for (let i = 0; i < indices.length; i += 3) {
                for (let k = 0; k < 3; ++k) {
                  const i1 = indices[i + offsets[k][0]];
                  const i2 = indices[i + offsets[k][1]];
                  const id = i1 > i2 ? i2 << 16 | i1 : i1 << 16 | i2;

                  if (lineIDs[id] === undefined) {
                    lineIDs[id] = 0;
                    lines.push(i1, i2);
                  }
                }
              }

              geometry.indices = lines;
              geometry.primitiveMode = PrimitiveMode.LINE_LIST;
              return geometry;
            }

            var primitives = /*#__PURE__*/Object.freeze({
                __proto__: null,
                box: box,
                cone: cone,
                cylinder: cylinder,
                plane: plane,
                quad: quad,
                sphere: sphere,
                torus: torus,
                capsule: capsule,
                circle: circle,
                translate: translate,
                scale: scale,
                wireframed: wireframed,
                wireframe: wireframe,
                invWinding: invWinding,
                toWavefrontOBJ: toWavefrontOBJ,
                normals: normals,
                applyDefaultGeometryOptions: applyDefaultGeometryOptions
            });
            exports('primitives', primitives);

            const TriggerEventObject = {
              type: 'onTriggerEnter',
              selfCollider: null,
              otherCollider: null,
              impl: null
            };
            const CollisionEventObject = {
              type: 'onCollisionEnter',
              selfCollider: null,
              otherCollider: null,
              contacts: [],
              impl: null
            };
            class BulletCache {
              constructor() {
                this.BT_TRANSFORM_0 = bt.Transform_new();
                this.BT_TRANSFORM_1 = bt.Transform_new();
                this.BT_V3_0 = bt.Vec3_new(0, 0, 0);
                this.BT_V3_1 = bt.Vec3_new(0, 0, 0);
                this.BT_V3_2 = bt.Vec3_new(0, 0, 0);
                this.BT_QUAT_0 = bt.Quat_new(0, 0, 0, 1);
              }

              static get instance() {
                if (BulletCache._instance == null) BulletCache._instance = new BulletCache();
                return BulletCache._instance;
              }

              static setWrapper(impl, type, wrap) {
                if (!this.ROOT[type]) this.ROOT[type] = {};
                this.ROOT[type][impl] = wrap;
              }

              static delWrapper(impl, type) {
                delete this.ROOT[type][impl];
              }

              static getWrapper(ptr, type) {
                return this.ROOT[type][ptr];
              }

              static isNotEmptyShape(ptr) {
                return ptr !== bt.EmptyShape_static();
              }

            }
            BulletCache._instance = void 0;
            BulletCache.ROOT = {};
            const CC_V3_0 = new Vec3();
            const CC_V3_1 = new Vec3();
            const CC_QUAT_0 = new Quat();
            bt.CACHE = BulletCache;

            function cocos2BulletVec3(out, v) {
              bt.Vec3_set(out, v.x, v.y, v.z);
              return out;
            }
            function bullet2CocosVec3(out, v) {
              out.x = bt.Vec3_x(v);
              out.y = bt.Vec3_y(v);
              out.z = bt.Vec3_z(v);
              return out;
            }
            function cocos2BulletQuat(out, q) {
              bt.Quat_set(out, q.x, q.y, q.z, q.w);
              return out;
            }
            function bullet2CocosQuat(out, q) {
              out.x = bt.Quat_x(q);
              out.y = bt.Quat_y(q);
              out.z = bt.Quat_z(q);
              out.w = bt.Quat_w(q);
              return out;
            }
            function cocos2BulletTriMesh(out, mesh) {
              const len = mesh.renderingSubMeshes.length;

              for (let i = 0; i < len; i++) {
                const subMesh = mesh.renderingSubMeshes[i];
                const geoInfo = subMesh.geometricInfo;

                if (geoInfo) {
                  const primitiveMode = subMesh.primitiveMode;
                  const vb = geoInfo.positions;
                  const ib = geoInfo.indices;
                  const v0 = BulletCache.instance.BT_V3_0;
                  const v1 = BulletCache.instance.BT_V3_1;
                  const v2 = BulletCache.instance.BT_V3_2;

                  if (primitiveMode === PrimitiveMode.TRIANGLE_LIST) {
                    const cnt = ib.length;

                    for (let j = 0; j < cnt; j += 3) {
                      const i0 = ib[j] * 3;
                      const i1 = ib[j + 1] * 3;
                      const i2 = ib[j + 2] * 3;
                      bt.Vec3_set(v0, vb[i0], vb[i0 + 1], vb[i0 + 2]);
                      bt.Vec3_set(v1, vb[i1], vb[i1 + 1], vb[i1 + 2]);
                      bt.Vec3_set(v2, vb[i2], vb[i2 + 1], vb[i2 + 2]);
                      bt.TriangleMesh_addTriangle(out, v0, v1, v2);
                    }
                  } else if (primitiveMode === PrimitiveMode.TRIANGLE_STRIP) {
                    const cnt = ib.length - 2;
                    let rev = 0;

                    for (let j = 0; j < cnt; j += 1) {
                      const i0 = ib[j - rev] * 3;
                      const i1 = ib[j + rev + 1] * 3;
                      const i2 = ib[j + 2] * 3;
                      rev = ~rev;
                      bt.Vec3_set(v0, vb[i0], vb[i0 + 1], vb[i0 + 2]);
                      bt.Vec3_set(v1, vb[i1], vb[i1 + 1], vb[i1 + 2]);
                      bt.Vec3_set(v2, vb[i2], vb[i2 + 1], vb[i2 + 2]);
                      bt.TriangleMesh_addTriangle(out, v0, v1, v2);
                    }
                  } else if (primitiveMode === PrimitiveMode.TRIANGLE_FAN) {
                    const cnt = ib.length - 1;
                    const i0 = ib[0] * 3;
                    bt.Vec3_set(v0, vb[i0], vb[i0 + 1], vb[i0 + 2]);

                    for (let j = 1; j < cnt; j += 1) {
                      const i1 = ib[j] * 3;
                      const i2 = ib[j + 1] * 3;
                      bt.Vec3_set(v1, vb[i1], vb[i1 + 1], vb[i1 + 2]);
                      bt.Vec3_set(v2, vb[i2], vb[i2 + 1], vb[i2 + 2]);
                      bt.TriangleMesh_addTriangle(out, v0, v1, v2);
                    }
                  }
                }
              }

              return out;
            }

            let EBtSharedBodyDirty;

            (function (EBtSharedBodyDirty) {
              EBtSharedBodyDirty[EBtSharedBodyDirty["BODY_RE_ADD"] = 1] = "BODY_RE_ADD";
              EBtSharedBodyDirty[EBtSharedBodyDirty["GHOST_RE_ADD"] = 2] = "GHOST_RE_ADD";
            })(EBtSharedBodyDirty || (EBtSharedBodyDirty = {}));

            let btCollisionFlags;

            (function (btCollisionFlags) {
              btCollisionFlags[btCollisionFlags["CF_STATIC_OBJECT"] = 1] = "CF_STATIC_OBJECT";
              btCollisionFlags[btCollisionFlags["CF_KINEMATIC_OBJECT"] = 2] = "CF_KINEMATIC_OBJECT";
              btCollisionFlags[btCollisionFlags["CF_NO_CONTACT_RESPONSE"] = 4] = "CF_NO_CONTACT_RESPONSE";
              btCollisionFlags[btCollisionFlags["CF_CUSTOM_MATERIAL_CALLBACK"] = 8] = "CF_CUSTOM_MATERIAL_CALLBACK";
              btCollisionFlags[btCollisionFlags["CF_CHARACTER_OBJECT"] = 16] = "CF_CHARACTER_OBJECT";
              btCollisionFlags[btCollisionFlags["CF_DISABLE_VISUALIZE_OBJECT"] = 32] = "CF_DISABLE_VISUALIZE_OBJECT";
              btCollisionFlags[btCollisionFlags["CF_DISABLE_SPU_COLLISION_PROCESSING"] = 64] = "CF_DISABLE_SPU_COLLISION_PROCESSING";
            })(btCollisionFlags || (btCollisionFlags = {}));

            let btCollisionObjectTypes;

            (function (btCollisionObjectTypes) {
              btCollisionObjectTypes[btCollisionObjectTypes["CO_COLLISION_OBJECT"] = 1] = "CO_COLLISION_OBJECT";
              btCollisionObjectTypes[btCollisionObjectTypes["CO_RIGID_BODY"] = 2] = "CO_RIGID_BODY";
              btCollisionObjectTypes[btCollisionObjectTypes["CO_GHOST_OBJECT"] = 4] = "CO_GHOST_OBJECT";
              btCollisionObjectTypes[btCollisionObjectTypes["CO_SOFT_BODY"] = 8] = "CO_SOFT_BODY";
              btCollisionObjectTypes[btCollisionObjectTypes["CO_HF_FLUID"] = 16] = "CO_HF_FLUID";
              btCollisionObjectTypes[btCollisionObjectTypes["CO_USER_TYPE"] = 32] = "CO_USER_TYPE";
              btCollisionObjectTypes[btCollisionObjectTypes["CO_FEATHERSTONE_LINK"] = 64] = "CO_FEATHERSTONE_LINK";
            })(btCollisionObjectTypes || (btCollisionObjectTypes = {}));

            let btCollisionObjectStates;

            (function (btCollisionObjectStates) {
              btCollisionObjectStates[btCollisionObjectStates["ACTIVE_TAG"] = 1] = "ACTIVE_TAG";
              btCollisionObjectStates[btCollisionObjectStates["ISLAND_SLEEPING"] = 2] = "ISLAND_SLEEPING";
              btCollisionObjectStates[btCollisionObjectStates["WANTS_DEACTIVATION"] = 3] = "WANTS_DEACTIVATION";
              btCollisionObjectStates[btCollisionObjectStates["DISABLE_DEACTIVATION"] = 4] = "DISABLE_DEACTIVATION";
              btCollisionObjectStates[btCollisionObjectStates["DISABLE_SIMULATION"] = 5] = "DISABLE_SIMULATION";
            })(btCollisionObjectStates || (btCollisionObjectStates = {}));

            let btRigidBodyFlags;

            (function (btRigidBodyFlags) {
              btRigidBodyFlags[btRigidBodyFlags["BT_DISABLE_WORLD_GRAVITY"] = 1] = "BT_DISABLE_WORLD_GRAVITY";
              btRigidBodyFlags[btRigidBodyFlags["BT_ENABLE_GYROPSCOPIC_FORCE"] = 2] = "BT_ENABLE_GYROPSCOPIC_FORCE";
            })(btRigidBodyFlags || (btRigidBodyFlags = {}));

            const v3_0 = CC_V3_0;
            const v3_1$4 = CC_V3_1;
            class BulletRigidBody {
              get isAwake() {
                const state = bt.CollisionObject_getActivationState(this.impl);
                return state === btCollisionObjectStates.ACTIVE_TAG || state === btCollisionObjectStates.DISABLE_DEACTIVATION;
              }

              get isSleepy() {
                const state = bt.CollisionObject_getActivationState(this.impl);
                return state === btCollisionObjectStates.WANTS_DEACTIVATION;
              }

              get isSleeping() {
                const state = bt.CollisionObject_getActivationState(this.impl);
                return state === btCollisionObjectStates.ISLAND_SLEEPING;
              }

              setMass(value) {
                if (!this._rigidBody.isDynamic) return;
                bt.RigidBody_setMass(this.impl, value);

                this._wakeUpIfSleep();

                this._sharedBody.dirty |= EBtSharedBodyDirty.BODY_RE_ADD;
              }

              setType(v) {
                this._sharedBody.setType(v);
              }

              setLinearDamping(value) {
                bt.RigidBody_setDamping(this.impl, this._rigidBody.linearDamping, this._rigidBody.angularDamping);
              }

              setAngularDamping(value) {
                bt.RigidBody_setDamping(this.impl, this._rigidBody.linearDamping, this._rigidBody.angularDamping);
              }

              useGravity(value) {
                if (!this._rigidBody.isDynamic) return;
                let m_rigidBodyFlag = bt.RigidBody_getFlags(this.impl);

                if (value) {
                  m_rigidBodyFlag &= ~btRigidBodyFlags.BT_DISABLE_WORLD_GRAVITY;
                } else {
                  bt.RigidBody_setGravity(this.impl, cocos2BulletVec3(BulletCache.instance.BT_V3_0, Vec3.ZERO));
                  m_rigidBodyFlag |= btRigidBodyFlags.BT_DISABLE_WORLD_GRAVITY;
                }

                bt.RigidBody_setFlags(this.impl, m_rigidBodyFlag);

                this._wakeUpIfSleep();

                this._sharedBody.dirty |= EBtSharedBodyDirty.BODY_RE_ADD;
              }

              useCCD(value) {
                bt.CollisionObject_setCcdMotionThreshold(this.impl, value ? 0.01 : 0);
                bt.CollisionObject_setCcdSweptSphereRadius(this.impl, value ? 0.1 : 0);
                this._isUsingCCD = value;
              }

              isUsingCCD() {
                return this._isUsingCCD;
              }

              setLinearFactor(v) {
                bt.RigidBody_setLinearFactor(this.impl, cocos2BulletVec3(BulletCache.instance.BT_V3_0, v));

                this._wakeUpIfSleep();
              }

              setAngularFactor(v) {
                bt.RigidBody_setAngularFactor(this.impl, cocos2BulletVec3(BulletCache.instance.BT_V3_0, v));

                this._wakeUpIfSleep();
              }

              setAllowSleep(v) {
                if (!this._rigidBody.isDynamic) return;

                if (v) {
                  bt.CollisionObject_forceActivationState(this.impl, btCollisionObjectStates.ACTIVE_TAG);
                } else {
                  bt.CollisionObject_forceActivationState(this.impl, btCollisionObjectStates.DISABLE_DEACTIVATION);
                }

                this._wakeUpIfSleep();
              }

              get impl() {
                return this._sharedBody.body;
              }

              get rigidBody() {
                return this._rigidBody;
              }

              get sharedBody() {
                return this._sharedBody;
              }

              get isEnabled() {
                return this._isEnabled;
              }

              constructor() {
                this.id = void 0;
                this._isEnabled = false;
                this._isUsingCCD = false;
                this._sharedBody = void 0;
                this._rigidBody = void 0;
                this.id = BulletRigidBody.idCounter++;
              }

              clearState() {
                bt.RigidBody_clearState(this.impl);
              }

              clearVelocity() {
                this.setLinearVelocity(Vec3.ZERO);
                this.setAngularVelocity(Vec3.ZERO);
              }

              clearForces() {
                bt.RigidBody_clearForces(this.impl);
              }

              initialize(com) {
                this._rigidBody = com;
                this._sharedBody = PhysicsSystem.instance.physicsWorld.getSharedBody(this._rigidBody.node, this);
                this._sharedBody.reference = true;
              }

              onEnable() {
                this._isEnabled = true;
                this.setMass(this._rigidBody.mass);
                this.setAllowSleep(this._rigidBody.allowSleep);
                this.setLinearDamping(this._rigidBody.linearDamping);
                this.setAngularDamping(this._rigidBody.angularDamping);
                this.setLinearFactor(this._rigidBody.linearFactor);
                this.setAngularFactor(this._rigidBody.angularFactor);
                this.useGravity(this._rigidBody.useGravity);
                this._sharedBody.bodyEnabled = true;
              }

              onDisable() {
                this._isEnabled = false;
                this._sharedBody.bodyEnabled = false;
              }

              onDestroy() {
                this._sharedBody.reference = false;
                this._rigidBody = null;
                this._sharedBody = null;
              }

              wakeUp(force = true) {
                bt.CollisionObject_activate(this.impl, force);
              }

              sleep() {
                return bt.RigidBody_wantsSleeping(this.impl);
              }

              setSleepThreshold(v) {
                this._wakeUpIfSleep();

                bt.RigidBody_setSleepingThresholds(this.impl, v, v);
              }

              getSleepThreshold() {
                return bt.RigidBody_getLinearSleepingThreshold(this.impl);
              }

              getLinearVelocity(out) {
                return bullet2CocosVec3(out, bt.RigidBody_getLinearVelocity(this.impl));
              }

              setLinearVelocity(value) {
                this._wakeUpIfSleep();

                cocos2BulletVec3(bt.RigidBody_getLinearVelocity(this.impl), value);
              }

              getAngularVelocity(out) {
                return bullet2CocosVec3(out, bt.RigidBody_getAngularVelocity(this.impl));
              }

              setAngularVelocity(value) {
                this._wakeUpIfSleep();

                cocos2BulletVec3(bt.RigidBody_getAngularVelocity(this.impl), value);
              }

              applyLocalForce(force, rel_pos) {
                this._sharedBody.syncSceneToPhysics();

                this._wakeUpIfSleep();

                const quat = this._sharedBody.node.worldRotation;
                const v = Vec3.transformQuat(v3_0, force, quat);
                const rp = rel_pos ? Vec3.transformQuat(v3_1$4, rel_pos, quat) : Vec3.ZERO;
                bt.RigidBody_applyForce(this.impl, cocos2BulletVec3(BulletCache.instance.BT_V3_0, v), cocos2BulletVec3(BulletCache.instance.BT_V3_1, rp));
              }

              applyLocalTorque(torque) {
                this._sharedBody.syncSceneToPhysics();

                this._wakeUpIfSleep();

                Vec3.transformQuat(v3_0, torque, this._sharedBody.node.worldRotation);
                bt.RigidBody_applyTorque(this.impl, cocos2BulletVec3(BulletCache.instance.BT_V3_0, v3_0));
              }

              applyLocalImpulse(impulse, rel_pos) {
                this._sharedBody.syncSceneToPhysics();

                this._wakeUpIfSleep();

                const quat = this._sharedBody.node.worldRotation;
                const v = Vec3.transformQuat(v3_0, impulse, quat);
                const rp = rel_pos ? Vec3.transformQuat(v3_1$4, rel_pos, quat) : Vec3.ZERO;
                bt.RigidBody_applyImpulse(this.impl, cocos2BulletVec3(BulletCache.instance.BT_V3_0, v), cocos2BulletVec3(BulletCache.instance.BT_V3_1, rp));
              }

              applyForce(force, rel_pos) {
                this._sharedBody.syncSceneToPhysics();

                this._wakeUpIfSleep();

                const rp = rel_pos || Vec3.ZERO;
                bt.RigidBody_applyForce(this.impl, cocos2BulletVec3(BulletCache.instance.BT_V3_0, force), cocos2BulletVec3(BulletCache.instance.BT_V3_1, rp));
              }

              applyTorque(torque) {
                this._sharedBody.syncSceneToPhysics();

                this._wakeUpIfSleep();

                bt.RigidBody_applyTorque(this.impl, cocos2BulletVec3(BulletCache.instance.BT_V3_0, torque));
              }

              applyImpulse(impulse, rel_pos) {
                this._sharedBody.syncSceneToPhysics();

                this._wakeUpIfSleep();

                const rp = rel_pos || Vec3.ZERO;
                bt.RigidBody_applyImpulse(this.impl, cocos2BulletVec3(BulletCache.instance.BT_V3_0, impulse), cocos2BulletVec3(BulletCache.instance.BT_V3_1, rp));
              }

              getGroup() {
                return this._sharedBody.collisionFilterGroup;
              }

              setGroup(v) {
                this._sharedBody.collisionFilterGroup = v;
              }

              addGroup(v) {
                this._sharedBody.collisionFilterGroup |= v;
              }

              removeGroup(v) {
                this._sharedBody.collisionFilterGroup &= ~v;
              }

              getMask() {
                return this._sharedBody.collisionFilterMask;
              }

              setMask(v) {
                this._sharedBody.collisionFilterMask = v;
              }

              addMask(v) {
                this._sharedBody.collisionFilterMask |= v;
              }

              removeMask(v) {
                this._sharedBody.collisionFilterMask &= ~v;
              }

              _wakeUpIfSleep() {
                if (!this.isAwake) {
                  bt.CollisionObject_activate(this.impl, true);
                }
              }

            }
            BulletRigidBody.idCounter = 0;

            const v3_0$1 = CC_V3_0;
            const quat_0 = CC_QUAT_0;
            let IDCounter = 0;
            class BulletSharedBody {
              static getSharedBody(node, wrappedWorld, wrappedBody) {
                const key = node.uuid;
                let newSB;

                if (BulletSharedBody.sharedBodesMap.has(key)) {
                  newSB = BulletSharedBody.sharedBodesMap.get(key);
                } else {
                  newSB = new BulletSharedBody(node, wrappedWorld);
                  const g = PhysicsGroup$1.DEFAULT;
                  const m = PhysicsSystem.instance.collisionMatrix[g];
                  newSB._collisionFilterGroup = g;
                  newSB._collisionFilterMask = m;
                  BulletSharedBody.sharedBodesMap.set(node.uuid, newSB);
                }

                if (wrappedBody) {
                  newSB._wrappedBody = wrappedBody;
                  const g = wrappedBody.rigidBody.group;
                  const m = PhysicsSystem.instance.collisionMatrix[g];
                  newSB._collisionFilterGroup = g;
                  newSB._collisionFilterMask = m;
                }

                return newSB;
              }

              get wrappedBody() {
                return this._wrappedBody;
              }

              get bodyCompoundShape() {
                return this.bodyStruct.compound;
              }

              get ghostCompoundShape() {
                return this.ghostStruct.compound;
              }

              get body() {
                return this.bodyStruct.body;
              }

              get ghost() {
                return this.ghostStruct.ghost;
              }

              get collisionFilterGroup() {
                return this._collisionFilterGroup;
              }

              set collisionFilterGroup(v) {
                if (v !== this._collisionFilterGroup) {
                  this._collisionFilterGroup = v;
                  this.dirty |= EBtSharedBodyDirty.BODY_RE_ADD;
                  this.dirty |= EBtSharedBodyDirty.GHOST_RE_ADD;
                }
              }

              get collisionFilterMask() {
                return this._collisionFilterMask;
              }

              set collisionFilterMask(v) {
                if (v !== this._collisionFilterMask) {
                  this._collisionFilterMask = v;
                  this.dirty |= EBtSharedBodyDirty.BODY_RE_ADD;
                  this.dirty |= EBtSharedBodyDirty.GHOST_RE_ADD;
                }
              }

              get bodyStruct() {
                this._instantiateBodyStruct();

                return this._bodyStruct;
              }

              get ghostStruct() {
                this._instantiateGhostStruct();

                return this._ghostStruct;
              }

              set bodyEnabled(v) {
                if (v) {
                  if (this.bodyIndex < 0) {
                    if (this.bodyStruct.wrappedShapes.length === 0) {
                      if (!this.wrappedBody) return;
                      if (!this.wrappedBody.rigidBody.isDynamic) return;
                    }

                    this.bodyIndex = this.wrappedWorld.bodies.length;
                    this.wrappedWorld.addSharedBody(this);
                    this.syncInitialBody();
                  }
                } else if (this.bodyIndex >= 0) {
                  const isRemoveBody = this.bodyStruct.wrappedShapes.length === 0 && this.wrappedBody == null || this.bodyStruct.wrappedShapes.length === 0 && this.wrappedBody != null && !this.wrappedBody.isEnabled || this.bodyStruct.wrappedShapes.length === 0 && this.wrappedBody != null && !this.wrappedBody.rigidBody.enabledInHierarchy;

                  if (isRemoveBody) {
                    bt.RigidBody_clearState(this.body);
                    this.bodyIndex = -1;
                    this.wrappedWorld.removeSharedBody(this);
                  }
                }
              }

              set ghostEnabled(v) {
                if (v) {
                  if (this.ghostIndex < 0 && this.ghostStruct.wrappedShapes.length > 0) {
                    this.ghostIndex = 1;
                    this.wrappedWorld.addGhostObject(this);
                    this.syncInitialGhost();
                  }
                } else if (this.ghostIndex >= 0) {
                  const isRemoveGhost = this.ghostStruct.wrappedShapes.length === 0 && this.ghost;

                  if (isRemoveGhost) {
                    this.ghostIndex = -1;
                    this.wrappedWorld.removeGhostObject(this);
                  }
                }
              }

              set reference(v) {
                v ? this.ref++ : this.ref--;

                if (this.ref === 0) {
                  this.destroy();
                }
              }

              constructor(node, wrappedWorld) {
                this.id = void 0;
                this.node = void 0;
                this.wrappedWorld = void 0;
                this.wrappedJoints0 = [];
                this.wrappedJoints1 = [];
                this.dirty = 0;
                this._collisionFilterGroup = PhysicsSystem.PhysicsGroup.DEFAULT;
                this._collisionFilterMask = -1;
                this.ref = 0;
                this.bodyIndex = -1;
                this.ghostIndex = -1;
                this._bodyStruct = void 0;
                this._ghostStruct = void 0;
                this._wrappedBody = null;
                this.id = BulletSharedBody.idCounter++;
                this.wrappedWorld = wrappedWorld;
                this.node = node;
              }

              _instantiateBodyStruct() {
                if (this._bodyStruct) return;
                let mass = 0;

                if (this._wrappedBody && this._wrappedBody.rigidBody.enabled && this._wrappedBody.rigidBody.isDynamic) {
                  mass = this._wrappedBody.rigidBody.mass;
                }

                const trans = BulletCache.instance.BT_TRANSFORM_0;
                const quat = BulletCache.instance.BT_QUAT_0;
                cocos2BulletVec3(bt.Transform_getOrigin(trans), this.node.worldPosition);
                cocos2BulletQuat(quat, this.node.worldRotation);
                bt.Transform_setRotation(trans, quat);
                const motionState = bt.ccMotionState_new(this.id, trans);
                const body = bt.RigidBody_new(mass, motionState);
                const sleepTd = PhysicsSystem.instance.sleepThreshold;
                bt.RigidBody_setSleepingThresholds(body, sleepTd, sleepTd);
                this._bodyStruct = {
                  id: IDCounter++,
                  body,
                  motionState,
                  compound: bt.ccCompoundShape_new(),
                  wrappedShapes: [],
                  useCompound: false
                };
                BulletCache.setWrapper(this.id, bt.BODY_CACHE_NAME, this);
                if (this._ghostStruct) bt.CollisionObject_setIgnoreCollisionCheck(this.ghost, this.body, true);
                if (this._wrappedBody) this.setBodyType(this._wrappedBody.rigidBody.type);
              }

              _instantiateGhostStruct() {
                if (this._ghostStruct) return;
                const ghost = bt.CollisionObject_new();
                const ghostShape = bt.ccCompoundShape_new();
                bt.CollisionObject_setCollisionShape(ghost, ghostShape);
                bt.CollisionObject_setCollisionFlags(ghost, btCollisionFlags.CF_STATIC_OBJECT | btCollisionFlags.CF_NO_CONTACT_RESPONSE);
                this._ghostStruct = {
                  id: IDCounter++,
                  ghost,
                  compound: ghostShape,
                  wrappedShapes: []
                };
                if (this._bodyStruct) bt.CollisionObject_setIgnoreCollisionCheck(this.body, this.ghost, true);
                if (this._wrappedBody) this.setGhostType(this._wrappedBody.rigidBody.type);
              }

              setType(v) {
                this.setBodyType(v);
                this.setGhostType(v);
              }

              setBodyType(v) {
                if (this._bodyStruct && this._wrappedBody) {
                  const body = this._bodyStruct.body;
                  const wrap = this._wrappedBody;
                  const com = wrap.rigidBody;
                  let m_bcf = bt.CollisionObject_getCollisionFlags(body);
                  const localInertia = BulletCache.instance.BT_V3_0;

                  switch (v) {
                    case ERigidBodyType.DYNAMIC:
                      m_bcf &= ~btCollisionFlags.CF_KINEMATIC_OBJECT;
                      m_bcf &= ~btCollisionFlags.CF_STATIC_OBJECT;
                      bt.CollisionObject_setCollisionFlags(body, m_bcf);
                      wrap.setMass(com.mass);
                      wrap.useGravity(com.useGravity);
                      wrap.setAllowSleep(com.allowSleep);
                      break;

                    case ERigidBodyType.KINEMATIC:
                      bt.Vec3_set(localInertia, 0, 0, 0);
                      bt.RigidBody_setMassProps(body, 0, localInertia);
                      m_bcf |= btCollisionFlags.CF_KINEMATIC_OBJECT;
                      m_bcf &= ~btCollisionFlags.CF_STATIC_OBJECT;
                      bt.CollisionObject_setCollisionFlags(body, m_bcf);
                      bt.CollisionObject_forceActivationState(body, btCollisionObjectStates.DISABLE_DEACTIVATION);
                      break;

                    case ERigidBodyType.STATIC:
                    default:
                      bt.Vec3_set(localInertia, 0, 0, 0);
                      bt.RigidBody_setMassProps(body, 0, localInertia);
                      m_bcf |= btCollisionFlags.CF_STATIC_OBJECT;
                      m_bcf &= ~btCollisionFlags.CF_KINEMATIC_OBJECT;
                      bt.CollisionObject_setCollisionFlags(body, m_bcf);
                      bt.CollisionObject_forceActivationState(body, btCollisionObjectStates.ISLAND_SLEEPING);
                      break;
                  }

                  this.dirty |= EBtSharedBodyDirty.BODY_RE_ADD;
                }
              }

              setGhostType(v) {
                if (this._ghostStruct) {
                  const ghost = this._ghostStruct.ghost;
                  let m_gcf = bt.CollisionObject_getCollisionFlags(ghost);

                  switch (v) {
                    case ERigidBodyType.DYNAMIC:
                    case ERigidBodyType.KINEMATIC:
                      m_gcf &= ~btCollisionFlags.CF_STATIC_OBJECT;
                      m_gcf |= btCollisionFlags.CF_KINEMATIC_OBJECT;
                      bt.CollisionObject_setCollisionFlags(ghost, m_gcf);
                      bt.CollisionObject_forceActivationState(ghost, btCollisionObjectStates.DISABLE_DEACTIVATION);
                      break;

                    case ERigidBodyType.STATIC:
                    default:
                      m_gcf &= ~btCollisionFlags.CF_KINEMATIC_OBJECT;
                      m_gcf |= btCollisionFlags.CF_STATIC_OBJECT;
                      bt.CollisionObject_setCollisionFlags(ghost, m_gcf);
                      bt.CollisionObject_forceActivationState(ghost, btCollisionObjectStates.ISLAND_SLEEPING);
                      break;
                  }

                  this.dirty |= EBtSharedBodyDirty.GHOST_RE_ADD;
                }
              }

              addShape(v, isTrigger) {
                function switchShape(that, shape) {
                  bt.CollisionObject_setCollisionShape(that.body, shape);
                  that.dirty |= EBtSharedBodyDirty.BODY_RE_ADD;

                  if (that._wrappedBody && that._wrappedBody.isEnabled) {
                    that._wrappedBody.setMass(that._wrappedBody.rigidBody.mass);
                  }
                }

                if (isTrigger) {
                  const index = this.ghostStruct.wrappedShapes.indexOf(v);

                  if (index < 0) {
                    this.ghostStruct.wrappedShapes.push(v);
                    v.setCompound(this.ghostCompoundShape);
                    this.ghostEnabled = true;
                  }
                } else {
                  const index = this.bodyStruct.wrappedShapes.indexOf(v);

                  if (index < 0) {
                    this.bodyStruct.wrappedShapes.push(v);

                    if (this.bodyStruct.useCompound) {
                      v.setCompound(this.bodyCompoundShape);
                    } else {
                      const l = this.bodyStruct.wrappedShapes.length;

                      if (l === 1 && !v.needCompound()) {
                        switchShape(this, v.impl);
                      } else {
                        this.bodyStruct.useCompound = true;

                        for (let i = 0; i < l; i++) {
                          const childShape = this.bodyStruct.wrappedShapes[i];
                          childShape.setCompound(this.bodyCompoundShape);
                        }

                        switchShape(this, this.bodyStruct.compound);
                      }
                    }

                    this.bodyEnabled = true;
                  }
                }
              }

              removeShape(v, isTrigger) {
                if (isTrigger) {
                  const index = this.ghostStruct.wrappedShapes.indexOf(v);

                  if (index >= 0) {
                    fastRemoveAt(this.ghostStruct.wrappedShapes, index);
                    v.setCompound(0);
                    this.ghostEnabled = false;
                  }
                } else {
                  const index = this.bodyStruct.wrappedShapes.indexOf(v);

                  if (index >= 0) {
                    if (this.bodyStruct.useCompound) {
                      v.setCompound(0);
                    } else {
                      bt.CollisionObject_setCollisionShape(this.body, bt.EmptyShape_static());
                    }

                    bt.CollisionObject_activate(this.body, true);
                    this.dirty |= EBtSharedBodyDirty.BODY_RE_ADD;
                    fastRemoveAt(this.bodyStruct.wrappedShapes, index);
                    this.bodyEnabled = false;
                  }
                }
              }

              addJoint(v, type) {
                if (type) {
                  const i = this.wrappedJoints1.indexOf(v);
                  if (i < 0) this.wrappedJoints1.push(v);
                } else {
                  const i = this.wrappedJoints0.indexOf(v);
                  if (i < 0) this.wrappedJoints0.push(v);
                }
              }

              removeJoint(v, type) {
                if (type) {
                  const i = this.wrappedJoints1.indexOf(v);
                  if (i >= 0) fastRemoveAt(this.wrappedJoints1, i);
                } else {
                  const i = this.wrappedJoints0.indexOf(v);
                  if (i >= 0) fastRemoveAt(this.wrappedJoints0, i);
                }
              }

              updateDirty() {
                if (this.dirty) {
                  if (this.bodyIndex >= 0 && this.dirty & EBtSharedBodyDirty.BODY_RE_ADD) this.updateBodyByReAdd();
                  if (this.ghostIndex >= 0 && this.dirty & EBtSharedBodyDirty.GHOST_RE_ADD) this.updateGhostByReAdd();
                  this.dirty = 0;
                }
              }

              syncSceneToPhysics() {
                if (this.node.hasChangedFlags) {
                  const bt_quat = BulletCache.instance.BT_QUAT_0;
                  const bt_transform = bt.CollisionObject_getWorldTransform(this.body);
                  cocos2BulletQuat(bt_quat, this.node.worldRotation);
                  cocos2BulletVec3(bt.Transform_getOrigin(bt_transform), this.node.worldPosition);
                  bt.Transform_setRotation(bt_transform, bt_quat);

                  if (this.node.hasChangedFlags & TransformBit.SCALE) {
                    this.syncBodyScale();
                  }

                  if (bt.CollisionObject_isKinematicObject(this.body)) {
                    const ms = bt.RigidBody_getMotionState(this.body);
                    if (ms) bt.MotionState_setWorldTransform(ms, bt_transform);
                  } else if (this.isBodySleeping()) bt.CollisionObject_activate(this.body);
                }
              }

              syncPhysicsToScene() {
                if (bt.CollisionObject_isStaticOrKinematicObject(this.body)) return;
                this.syncPhysicsToGraphics();
              }

              syncPhysicsToGraphics() {
                if (this.isBodySleeping()) return;
                const bt_quat = BulletCache.instance.BT_QUAT_0;
                const bt_transform = BulletCache.instance.BT_TRANSFORM_0;
                bt.MotionState_getWorldTransform(bt.RigidBody_getMotionState(this.body), bt_transform);
                bt.Transform_getRotation(bt_transform, bt_quat);
                this.node.worldRotation = bullet2CocosQuat(quat_0, bt_quat);
                this.node.worldPosition = bullet2CocosVec3(v3_0$1, bt.Transform_getOrigin(bt_transform));

                if (this._ghostStruct) {
                  const bt_transform1 = bt.CollisionObject_getWorldTransform(this.ghost);
                  cocos2BulletVec3(bt.Transform_getOrigin(bt_transform1), this.node.worldPosition);
                  cocos2BulletQuat(bt_quat, this.node.worldRotation);
                  bt.Transform_setRotation(bt_transform1, bt_quat);
                }
              }

              syncSceneToGhost() {
                if (this.node.hasChangedFlags) {
                  const bt_quat = BulletCache.instance.BT_QUAT_0;
                  const bt_transform = bt.CollisionObject_getWorldTransform(this.ghost);
                  cocos2BulletVec3(bt.Transform_getOrigin(bt_transform), this.node.worldPosition);
                  cocos2BulletQuat(bt_quat, this.node.worldRotation);
                  bt.Transform_setRotation(bt_transform, bt_quat);
                  if (this.node.hasChangedFlags & TransformBit.SCALE) this.syncGhostScale();
                  bt.CollisionObject_activate(this.ghost);
                }
              }

              syncInitialBody() {
                const bt_quat = BulletCache.instance.BT_QUAT_0;
                const bt_transform = bt.CollisionObject_getWorldTransform(this.body);
                cocos2BulletVec3(bt.Transform_getOrigin(bt_transform), this.node.worldPosition);
                cocos2BulletQuat(bt_quat, this.node.worldRotation);
                bt.Transform_setRotation(bt_transform, bt_quat);
                this.syncBodyScale();
                bt.CollisionObject_activate(this.body);
              }

              syncInitialGhost() {
                const bt_quat = BulletCache.instance.BT_QUAT_0;
                const bt_transform = bt.CollisionObject_getWorldTransform(this.ghost);
                cocos2BulletVec3(bt.Transform_getOrigin(bt_transform), this.node.worldPosition);
                cocos2BulletQuat(bt_quat, this.node.worldRotation);
                bt.Transform_setRotation(bt_transform, bt_quat);
                this.syncGhostScale();
                bt.CollisionObject_activate(this.body);
              }

              syncBodyScale() {
                for (let i = 0; i < this.bodyStruct.wrappedShapes.length; i++) {
                  this.bodyStruct.wrappedShapes[i].updateScale();
                }

                for (let i = 0; i < this.wrappedJoints0.length; i++) {
                  this.wrappedJoints0[i].updateScale0();
                }

                for (let i = 0; i < this.wrappedJoints1.length; i++) {
                  this.wrappedJoints1[i].updateScale1();
                }
              }

              syncGhostScale() {
                for (let i = 0; i < this.ghostStruct.wrappedShapes.length; i++) {
                  this.ghostStruct.wrappedShapes[i].updateScale();
                }
              }

              updateBodyByReAdd() {
                if (this.bodyIndex >= 0) {
                  this.wrappedWorld.removeSharedBody(this);
                  this.bodyIndex = this.wrappedWorld.bodies.length;
                  this.wrappedWorld.addSharedBody(this);
                }
              }

              updateGhostByReAdd() {
                if (this.ghostIndex >= 0) {
                  this.wrappedWorld.removeGhostObject(this);
                  this.ghostIndex = this.wrappedWorld.ghosts.length;
                  this.wrappedWorld.addGhostObject(this);
                }
              }

              destroy() {
                BulletSharedBody.sharedBodesMap.delete(this.node.uuid);
                this.node = null;
                this.wrappedWorld = null;

                if (this._bodyStruct) {
                  const bodyStruct = this._bodyStruct;
                  BulletCache.delWrapper(bodyStruct.body, bt.BODY_CACHE_NAME);
                  bt.MotionState_del(bodyStruct.motionState);
                  bt.CollisionShape_del(bodyStruct.compound);
                  bt.CollisionObject_del(bodyStruct.body);
                  this._bodyStruct = null;
                }

                if (this._ghostStruct) {
                  const ghostStruct = this._ghostStruct;
                  bt.CollisionShape_del(ghostStruct.compound);
                  bt.CollisionObject_del(ghostStruct.ghost);
                  this._ghostStruct = null;
                }
              }

              isBodySleeping() {
                return bt.CollisionObject_getActivationState(this.body) === btCollisionObjectStates.ISLAND_SLEEPING;
              }

            }
            BulletSharedBody.idCounter = 0;
            BulletSharedBody.sharedBodesMap = new Map();

            const v3_0$2 = CC_V3_0;
            const ccMaterialBooks = {};
            class BulletShape {
              constructor() {
                this.id = BulletShape.idCounter++;
                this._isEnabled = false;
                this._isTrigger = false;
                this._isInitialized = false;
                this._impl = 0;
                this._compound = 0;
                this.quat = bt.Quat_new(0, 0, 0, 1);
                this.transform = bt.Transform_new();
                this._collider = void 0;
                this._sharedBody = void 0;
              }

              updateEventListener() {
                this._sharedBody.wrappedWorld.updateNeedEmitEvents(this.collider.needCollisionEvent || this.collider.needTriggerEvent);
              }

              setMaterial(v) {
                if (!this._isTrigger && this._isEnabled && v) {
                  if (this._compound) {
                    if (!ccMaterialBooks[v._uuid]) ccMaterialBooks[v._uuid] = bt.ccMaterial_new();
                    const mat = ccMaterialBooks[v._uuid];
                    bt.ccMaterial_set(mat, v.restitution, v.friction, v.rollingFriction, v.spinningFriction);
                    bt.CollisionShape_setMaterial(this._impl, mat);
                  } else {
                    bt.CollisionObject_setMaterial(this._sharedBody.body, v.restitution, v.friction, v.rollingFriction, v.spinningFriction);
                  }
                }
              }

              setCenter(v) {
                Vec3.copy(v3_0$2, v);
                v3_0$2.multiply(this._collider.node.worldScale);
                cocos2BulletVec3(bt.Transform_getOrigin(this.transform), v3_0$2);
                this.updateCompoundTransform();
              }

              setAsTrigger(v) {
                if (this._isTrigger === v) return;

                if (this._isEnabled) {
                  this._sharedBody.removeShape(this, !v);

                  this._sharedBody.addShape(this, v);
                }

                this._isTrigger = v;
              }

              get attachedRigidBody() {
                if (this._sharedBody.wrappedBody) return this._sharedBody.wrappedBody.rigidBody;
                return null;
              }

              get impl() {
                return this._impl;
              }

              get collider() {
                return this._collider;
              }

              get sharedBody() {
                return this._sharedBody;
              }

              getAABB(v) {
                const bt_transform = BulletCache.instance.BT_TRANSFORM_0;
                bt.Transform_setIdentity(bt_transform);
                bt.Transform_setRotation(bt_transform, cocos2BulletQuat(BulletCache.instance.BT_QUAT_0, this._collider.node.worldRotation));
                const MIN = BulletCache.instance.BT_V3_0;
                const MAX = BulletCache.instance.BT_V3_1;
                bt.CollisionShape_getAabb(this._impl, bt_transform, MIN, MAX);
                v.halfExtents.x = (bt.Vec3_x(MAX) - bt.Vec3_x(MIN)) / 2;
                v.halfExtents.y = (bt.Vec3_y(MAX) - bt.Vec3_y(MIN)) / 2;
                v.halfExtents.z = (bt.Vec3_z(MAX) - bt.Vec3_z(MIN)) / 2;
                Vec3.add(v.center, this._collider.node.worldPosition, this._collider.center);
              }

              getBoundingSphere(v) {
                v.radius = bt.CollisionShape_getLocalBoundingSphere(this._impl);
                Vec3.add(v.center, this._collider.node.worldPosition, this._collider.center);
              }

              initialize(com) {
                this._collider = com;
                this._isInitialized = true;
                this._sharedBody = PhysicsSystem.instance.physicsWorld.getSharedBody(this._collider.node);
                this._sharedBody.reference = true;
                this.onComponentSet();
                this.setWrapper();
              }

              setWrapper() {
                if (BulletCache.isNotEmptyShape(this._impl)) {
                  bt.CollisionShape_setUserPointer(this._impl, this._impl);
                  BulletCache.setWrapper(this._impl, BulletShape.TYPE, this);
                }
              }

              onLoad() {
                this.setCenter(this._collider.center);
                this.setAsTrigger(this._collider.isTrigger);
              }

              onEnable() {
                this._isEnabled = true;

                this._sharedBody.addShape(this, this._isTrigger);

                this.setMaterial(this.collider.sharedMaterial);
              }

              onDisable() {
                this._isEnabled = false;

                this._sharedBody.removeShape(this, this._isTrigger);
              }

              onDestroy() {
                this._sharedBody.reference = false;
                this._collider = null;
                bt.Quat_del(this.quat);
                bt.Transform_del(this.transform);
                if (this._compound) bt.CollisionShape_del(this._compound);

                if (BulletCache.isNotEmptyShape(this._impl)) {
                  bt.CollisionShape_del(this._impl);
                  BulletCache.delWrapper(this._impl, BulletShape.TYPE);
                }
              }

              updateByReAdd() {
                if (this._isEnabled) {
                  this._sharedBody.removeShape(this, this._isTrigger);

                  this._sharedBody.addShape(this, this._isTrigger);
                }
              }

              getGroup() {
                return this._sharedBody.collisionFilterGroup;
              }

              setGroup(v) {
                this._sharedBody.collisionFilterGroup = v;
              }

              addGroup(v) {
                this._sharedBody.collisionFilterGroup |= v;
              }

              removeGroup(v) {
                this._sharedBody.collisionFilterGroup &= ~v;
              }

              getMask() {
                return this._sharedBody.collisionFilterMask;
              }

              setMask(v) {
                this._sharedBody.collisionFilterMask = v;
              }

              addMask(v) {
                this._sharedBody.collisionFilterMask |= v;
              }

              removeMask(v) {
                this._sharedBody.collisionFilterMask &= ~v;
              }

              setCompound(compound) {
                if (this._compound) bt.CompoundShape_removeChildShape(this._compound, this._impl);
                if (compound) bt.CompoundShape_addChildShape(compound, this.transform, this._impl);
                this._compound = compound;
              }

              updateScale() {
                this.setCenter(this._collider.center);
              }

              updateCompoundTransform() {
                if (this._compound) {
                  bt.CompoundShape_updateChildTransform(this._compound, this._impl, this.transform, true);
                } else if (this._isEnabled && !this._isTrigger) {
                  if (this._sharedBody && !this._sharedBody.bodyStruct.useCompound) {
                    this._sharedBody.dirty |= EBtSharedBodyDirty.BODY_RE_ADD;
                  }
                }
              }

              needCompound() {
                if (this._collider.type === EColliderType.TERRAIN) {
                  return true;
                }

                if (this._collider.center.equals(Vec3.ZERO)) {
                  return false;
                }

                return true;
              }

            }
            BulletShape.TYPE = 'shape';
            BulletShape.idCounter = 0;

            class ArrayCollisionMatrix {
              constructor() {
                this.matrix = [];
              }

              get(i, j) {
                if (j > i) {
                  const temp = j;
                  j = i;
                  i = temp;
                }

                return this.matrix[(i * (i + 1) >> 1) + j - 1];
              }

              set(i, j, value) {
                if (j > i) {
                  const temp = j;
                  j = i;
                  i = temp;
                }

                this.matrix[(i * (i + 1) >> 1) + j - 1] = value ? 1 : 0;
              }

              reset() {
                this.matrix.length = 0;
              }

              setNumObjects(n) {
                this.matrix.length = n * (n - 1) >> 1;
              }

            }

            class TupleDictionary {
              constructor() {
                this.data = void 0;
                this.data = {
                  keys: []
                };
              }

              get(i, j) {
                if (i > j) {
                  const temp = j;
                  j = i;
                  i = temp;
                }

                return this.data[`${i}-${j}`];
              }

              set(i, j, value) {
                if (i > j) {
                  const temp = j;
                  j = i;
                  i = temp;
                }

                const key = `${i}-${j}`;

                if (value == null) {
                  const idx = this.data.keys.indexOf(key);

                  if (idx !== -1) {
                    this.data.keys.splice(idx, 1);
                    delete this.data[key];
                    return value;
                  }
                }

                if (!this.get(i, j)) {
                  this.data.keys.push(key);
                }

                this.data[key] = value;
                return this.data[key];
              }

              reset() {
                this.data = {
                  keys: []
                };
              }

              getLength() {
                return this.data.keys.length;
              }

              getKeyByIndex(index) {
                return this.data.keys[index];
              }

              getDataByKey(Key) {
                return this.data[Key];
              }

            }

            class BulletContactData {
              get isBodyA() {
                const sb = this.event.selfCollider.shape.sharedBody.body;
                return sb === bt.PersistentManifold_getBody0(this.impl);
              }

              constructor(event) {
                this.impl = 0;
                this.event = event;
              }

              getLocalPointOnA(out) {
                if (this.impl) bullet2CocosVec3(out, bt.ManifoldPoint_get_m_localPointA(this.impl));
              }

              getLocalPointOnB(out) {
                if (this.impl) bullet2CocosVec3(out, bt.ManifoldPoint_get_m_localPointB(this.impl));
              }

              getWorldPointOnA(out) {
                if (this.impl) bullet2CocosVec3(out, bt.ManifoldPoint_get_m_positionWorldOnA(this.impl));
              }

              getWorldPointOnB(out) {
                if (this.impl) bullet2CocosVec3(out, bt.ManifoldPoint_get_m_positionWorldOnB(this.impl));
              }

              getLocalNormalOnA(out) {
                if (this.impl) {
                  const bt_rot = BulletCache.instance.BT_QUAT_0;
                  const body = bt.PersistentManifold_getBody0(this.impl);
                  const trans = bt.CollisionObject_getWorldTransform(body);
                  bt.Transform_getRotation(trans, bt_rot);
                  const inv_rot = CC_QUAT_0;
                  bullet2CocosQuat(inv_rot, bt_rot);
                  Quat.conjugate(inv_rot, inv_rot);
                  bullet2CocosVec3(out, bt.ManifoldPoint_get_m_normalWorldOnB(this.impl));
                  if (!this.isBodyA) Vec3.negate(out, out);
                  Vec3.transformQuat(out, out, inv_rot);
                }
              }

              getLocalNormalOnB(out) {
                if (this.impl) {
                  const bt_rot = BulletCache.instance.BT_QUAT_0;
                  const body = bt.PersistentManifold_getBody1(this.impl);
                  const trans = bt.CollisionObject_getWorldTransform(body);
                  bt.Transform_getRotation(trans, bt_rot);
                  const inv_rot = CC_QUAT_0;
                  bullet2CocosQuat(inv_rot, bt_rot);
                  Quat.conjugate(inv_rot, inv_rot);
                  bullet2CocosVec3(out, bt.ManifoldPoint_get_m_normalWorldOnB(this.impl));
                  Vec3.transformQuat(out, out, inv_rot);
                }
              }

              getWorldNormalOnA(out) {
                if (this.impl) {
                  bullet2CocosVec3(out, bt.ManifoldPoint_get_m_normalWorldOnB(this.impl));
                  if (!this.isBodyA) Vec3.negate(out, out);
                }
              }

              getWorldNormalOnB(out) {
                if (this.impl) bullet2CocosVec3(out, bt.ManifoldPoint_get_m_normalWorldOnB(this.impl));
              }

            }

            const contactsPool = [];
            const v3_0$3 = CC_V3_0;
            const v3_1$5 = CC_V3_1;
            class BulletWorld {
              setDefaultMaterial(v) {}

              setAllowSleep(v) {
                bt.ccDiscreteDynamicsWorld_setAllowSleep(this._world, v);
              }

              setGravity(gravity) {
                bt.DynamicsWorld_setGravity(this._world, cocos2BulletVec3(BulletCache.instance.BT_V3_0, gravity));
              }

              updateNeedEmitEvents(v) {
                if (!this.ghosts) return;

                if (v) {
                  this._needEmitEvents = true;
                } else {
                  this._needEmitEvents = false;

                  for (let i = 0; i < this.ghosts.length; i++) {
                    const ghost = this.ghosts[i];
                    const shapes = ghost.ghostStruct.wrappedShapes;

                    for (let j = 0; j < shapes.length; j++) {
                      const collider = shapes[j].collider;

                      if (collider.needCollisionEvent || collider.needTriggerEvent) {
                        this._needEmitEvents = true;
                        return;
                      }
                    }
                  }

                  for (let i = 0; i < this.bodies.length; i++) {
                    const body = this.bodies[i];
                    const shapes = body.bodyStruct.wrappedShapes;

                    for (let j = 0; j < shapes.length; j++) {
                      const collider = shapes[j].collider;

                      if (collider.needCollisionEvent || collider.needTriggerEvent) {
                        this._needEmitEvents = true;
                        return;
                      }
                    }
                  }
                }
              }

              get impl() {
                return this._world;
              }

              constructor() {
                this._world = void 0;
                this._broadphase = void 0;
                this._solver = void 0;
                this._dispatcher = void 0;
                this._needEmitEvents = false;
                this._needSyncAfterEvents = false;
                this.bodies = [];
                this.ghosts = [];
                this.constraints = [];
                this.triggerArrayMat = new ArrayCollisionMatrix();
                this.collisionArrayMat = new ArrayCollisionMatrix();
                this.contactsDic = new TupleDictionary();
                this.oldContactsDic = new TupleDictionary();
                this._broadphase = bt.DbvtBroadphase_new();
                this._dispatcher = bt.CollisionDispatcher_new();
                this._solver = bt.SequentialImpulseConstraintSolver_new();
                this._world = bt.ccDiscreteDynamicsWorld_new(this._dispatcher, this._broadphase, this._solver);
              }

              destroy() {
                if (this.constraints.length || this.bodies.length) error('You should destroy all physics component first.');
                bt.CollisionWorld_del(this._world);
                bt.DbvtBroadphase_del(this._broadphase);
                bt.CollisionDispatcher_del(this._dispatcher);
                bt.SequentialImpulseConstraintSolver_del(this._solver);
                this.bodies = null;
                this.ghosts = null;
                this.constraints = null;
                this.triggerArrayMat = null;
                this.collisionArrayMat = null;
                this.contactsDic = null;
                this.oldContactsDic = null;
                contactsPool.length = 0;
              }

              step(deltaTime, timeSinceLastCalled, maxSubStep = 0) {
                if (!this.bodies.length && !this.ghosts.length) return;
                if (timeSinceLastCalled === undefined) timeSinceLastCalled = deltaTime;
                bt.DynamicsWorld_stepSimulation(this._world, timeSinceLastCalled, maxSubStep, deltaTime);
              }

              syncSceneToPhysics() {
                for (let i = this.ghosts.length - 1; i >= 0; i--) {
                  const ghost = this.ghosts[i];
                  ghost.updateDirty();
                  ghost.syncSceneToGhost();
                }

                for (let i = this.bodies.length - 1; i >= 0; i--) {
                  const body = this.bodies[i];
                  body.updateDirty();
                  body.syncSceneToPhysics();
                }
              }

              syncAfterEvents() {
                if (!this._needSyncAfterEvents) return;
                this.syncSceneToPhysics();
              }

              raycast(worldRay, options, pool, results) {
                worldRay.computeHit(v3_0$3, options.maxDistance);
                const to = cocos2BulletVec3(BulletCache.instance.BT_V3_0, v3_0$3);
                const from = cocos2BulletVec3(BulletCache.instance.BT_V3_1, worldRay.o);
                const allHitsCB = bt.ccAllRayCallback_static();
                bt.ccAllRayCallback_reset(allHitsCB, from, to, options.mask, options.queryTrigger);
                bt.CollisionWorld_rayTest(this._world, from, to, allHitsCB);

                if (bt.RayCallback_hasHit(allHitsCB)) {
                  const posArray = bt.ccAllRayCallback_getHitPointWorld(allHitsCB);
                  const normalArray = bt.ccAllRayCallback_getHitNormalWorld(allHitsCB);
                  const ptrArray = bt.ccAllRayCallback_getCollisionShapePtrs(allHitsCB);

                  for (let i = 0, n = bt.int_array_size(ptrArray); i < n; i++) {
                    bullet2CocosVec3(v3_0$3, bt.Vec3_array_at(posArray, i));
                    bullet2CocosVec3(v3_1$5, bt.Vec3_array_at(normalArray, i));
                    const shape = BulletCache.getWrapper(bt.int_array_at(ptrArray, i), BulletShape.TYPE);
                    const r = pool.add();
                    results.push(r);

                    r._assign(v3_0$3, Vec3.distance(worldRay.o, v3_0$3), shape.collider, v3_1$5);
                  }

                  return true;
                }

                return false;
              }

              raycastClosest(worldRay, options, result) {
                worldRay.computeHit(v3_0$3, options.maxDistance);
                const to = cocos2BulletVec3(BulletCache.instance.BT_V3_0, v3_0$3);
                const from = cocos2BulletVec3(BulletCache.instance.BT_V3_1, worldRay.o);
                const closeHitCB = bt.ccClosestRayCallback_static();
                bt.ccClosestRayCallback_reset(closeHitCB, from, to, options.mask, options.queryTrigger);
                bt.CollisionWorld_rayTest(this._world, from, to, closeHitCB);

                if (bt.RayCallback_hasHit(closeHitCB)) {
                  bullet2CocosVec3(v3_0$3, bt.ccClosestRayCallback_getHitPointWorld(closeHitCB));
                  bullet2CocosVec3(v3_1$5, bt.ccClosestRayCallback_getHitNormalWorld(closeHitCB));
                  const shape = BulletCache.getWrapper(bt.ccClosestRayCallback_getCollisionShapePtr(closeHitCB), BulletShape.TYPE);

                  result._assign(v3_0$3, Vec3.distance(worldRay.o, v3_0$3), shape.collider, v3_1$5);

                  return true;
                }

                return false;
              }

              getSharedBody(node, wrappedBody) {
                return BulletSharedBody.getSharedBody(node, this, wrappedBody);
              }

              addSharedBody(sharedBody) {
                const i = this.bodies.indexOf(sharedBody);

                if (i < 0) {
                  this.bodies.push(sharedBody);
                  bt.DynamicsWorld_addRigidBody(this._world, sharedBody.body, sharedBody.collisionFilterGroup, sharedBody.collisionFilterMask);
                }
              }

              removeSharedBody(sharedBody) {
                const i = this.bodies.indexOf(sharedBody);

                if (i >= 0) {
                  fastRemoveAt(this.bodies, i);
                  bt.DynamicsWorld_removeRigidBody(this._world, sharedBody.body);
                }
              }

              addGhostObject(sharedBody) {
                const i = this.ghosts.indexOf(sharedBody);

                if (i < 0) {
                  this.ghosts.push(sharedBody);
                  bt.CollisionWorld_addCollisionObject(this._world, sharedBody.ghost, sharedBody.collisionFilterGroup, sharedBody.collisionFilterMask);
                }
              }

              removeGhostObject(sharedBody) {
                const i = this.ghosts.indexOf(sharedBody);

                if (i >= 0) {
                  fastRemoveAt(this.ghosts, i);
                  bt.CollisionWorld_removeCollisionObject(this._world, sharedBody.ghost);
                }
              }

              addConstraint(constraint) {
                const i = this.constraints.indexOf(constraint);

                if (i < 0) {
                  this.constraints.push(constraint);
                  bt.DynamicsWorld_addConstraint(this.impl, constraint.impl, !constraint.constraint.enableCollision);
                  constraint.index = i;
                }
              }

              removeConstraint(constraint) {
                const i = this.constraints.indexOf(constraint);

                if (i >= 0) {
                  this.constraints.splice(i, 1);
                  bt.DynamicsWorld_removeConstraint(this.impl, constraint.impl);
                  constraint.index = -1;
                }
              }

              emitEvents() {
                this._needSyncAfterEvents = false;
                if (!this._needEmitEvents) return;
                this.gatherConatactData();
                let dicL = this.contactsDic.getLength();

                while (dicL--) {
                  contactsPool.push.apply(contactsPool, CollisionEventObject.contacts);
                  CollisionEventObject.contacts.length = 0;
                  const key = this.contactsDic.getKeyByIndex(dicL);
                  const data = this.contactsDic.getDataByKey(key);
                  const shape0 = data.shape0;
                  const shape1 = data.shape1;
                  this.oldContactsDic.set(shape0.id, shape1.id, data);
                  const collider0 = shape0.collider;
                  const collider1 = shape1.collider;

                  if (collider0 && collider1) {
                    const isTrigger = collider0.isTrigger || collider1.isTrigger;

                    if (isTrigger) {
                      if (this.triggerArrayMat.get(shape0.id, shape1.id)) {
                        TriggerEventObject.type = 'onTriggerStay';
                      } else {
                        TriggerEventObject.type = 'onTriggerEnter';
                        this.triggerArrayMat.set(shape0.id, shape1.id, true);
                      }

                      TriggerEventObject.impl = data.impl;
                      TriggerEventObject.selfCollider = collider0;
                      TriggerEventObject.otherCollider = collider1;
                      collider0.emit(TriggerEventObject.type, TriggerEventObject);
                      TriggerEventObject.selfCollider = collider1;
                      TriggerEventObject.otherCollider = collider0;
                      collider1.emit(TriggerEventObject.type, TriggerEventObject);
                      this._needSyncAfterEvents = true;
                    } else {
                      const body0 = collider0.attachedRigidBody;
                      const body1 = collider1.attachedRigidBody;

                      if (body0 && body1) {
                        if (body0.isSleeping && body1.isSleeping) continue;
                      } else if (!body0 && body1) {
                        if (body1.isSleeping) continue;
                      } else if (!body1 && body0) {
                        if (body0.isSleeping) continue;
                      }

                      if (this.collisionArrayMat.get(shape0.id, shape1.id)) {
                        CollisionEventObject.type = 'onCollisionStay';
                      } else {
                        CollisionEventObject.type = 'onCollisionEnter';
                        this.collisionArrayMat.set(shape0.id, shape1.id, true);
                      }

                      for (let i = 0; i < data.contacts.length; i++) {
                        const cq = data.contacts[i];

                        if (contactsPool.length > 0) {
                          const c = contactsPool.pop();
                          c.impl = cq;
                          CollisionEventObject.contacts.push(c);
                        } else {
                          const c = new BulletContactData(CollisionEventObject);
                          c.impl = cq;
                          CollisionEventObject.contacts.push(c);
                        }
                      }

                      CollisionEventObject.impl = data.impl;
                      CollisionEventObject.selfCollider = collider0;
                      CollisionEventObject.otherCollider = collider1;
                      collider0.emit(CollisionEventObject.type, CollisionEventObject);
                      CollisionEventObject.selfCollider = collider1;
                      CollisionEventObject.otherCollider = collider0;
                      collider1.emit(CollisionEventObject.type, CollisionEventObject);
                      this._needSyncAfterEvents = true;
                    }

                    if (this.oldContactsDic.get(shape0.id, shape1.id) == null) {
                      this.oldContactsDic.set(shape0.id, shape1.id, data);
                    }
                  }
                }

                let oldDicL = this.oldContactsDic.getLength();

                while (oldDicL--) {
                  const key = this.oldContactsDic.getKeyByIndex(oldDicL);
                  const data = this.oldContactsDic.getDataByKey(key);
                  const shape0 = data.shape0;
                  const shape1 = data.shape1;
                  const collider0 = shape0.collider;
                  const collider1 = shape1.collider;

                  if (collider0 && collider1) {
                    const isTrigger = collider0.isTrigger || collider1.isTrigger;

                    if (this.contactsDic.getDataByKey(key) == null) {
                      if (isTrigger) {
                        if (this.triggerArrayMat.get(shape0.id, shape1.id)) {
                          TriggerEventObject.type = 'onTriggerExit';
                          TriggerEventObject.selfCollider = collider0;
                          TriggerEventObject.otherCollider = collider1;
                          collider0.emit(TriggerEventObject.type, TriggerEventObject);
                          TriggerEventObject.selfCollider = collider1;
                          TriggerEventObject.otherCollider = collider0;
                          collider1.emit(TriggerEventObject.type, TriggerEventObject);
                          this.triggerArrayMat.set(shape0.id, shape1.id, false);
                          this.oldContactsDic.set(shape0.id, shape1.id, null);
                          this._needSyncAfterEvents = true;
                        }
                      } else if (this.collisionArrayMat.get(shape0.id, shape1.id)) {
                        contactsPool.push.apply(contactsPool, CollisionEventObject.contacts);
                        CollisionEventObject.contacts.length = 0;
                        CollisionEventObject.type = 'onCollisionExit';
                        CollisionEventObject.selfCollider = collider0;
                        CollisionEventObject.otherCollider = collider1;
                        collider0.emit(CollisionEventObject.type, CollisionEventObject);
                        CollisionEventObject.selfCollider = collider1;
                        CollisionEventObject.otherCollider = collider0;
                        collider1.emit(CollisionEventObject.type, CollisionEventObject);
                        this.collisionArrayMat.set(shape0.id, shape1.id, false);
                        this.oldContactsDic.set(shape0.id, shape1.id, null);
                        this._needSyncAfterEvents = true;
                      }
                    }
                  }
                }

                this.contactsDic.reset();
              }

              gatherConatactData() {
                const numManifolds = bt.Dispatcher_getNumManifolds(this._dispatcher);

                for (let i = 0; i < numManifolds; i++) {
                  const manifold = bt.Dispatcher_getManifoldByIndexInternal(this._dispatcher, i);
                  const numContacts = bt.PersistentManifold_getNumContacts(manifold);

                  for (let j = 0; j < numContacts; j++) {
                    const manifoldPoint = bt.PersistentManifold_getContactPoint(manifold, j);
                    const s0 = bt.ManifoldPoint_getShape0(manifoldPoint);
                    const s1 = bt.ManifoldPoint_getShape1(manifoldPoint);
                    const shape0 = BulletCache.getWrapper(s0, BulletShape.TYPE);
                    const shape1 = BulletCache.getWrapper(s1, BulletShape.TYPE);

                    if (shape0.collider.needTriggerEvent || shape1.collider.needTriggerEvent || shape0.collider.needCollisionEvent || shape1.collider.needCollisionEvent) {
                      let item = this.contactsDic.get(shape0.id, shape1.id);

                      if (!item) {
                        item = this.contactsDic.set(shape0.id, shape1.id, {
                          shape0,
                          shape1,
                          contacts: [],
                          impl: manifold
                        });
                      }

                      item.contacts.push(manifoldPoint);
                    }
                  }
                }
              }

            }

            class BulletBoxShape extends BulletShape {
              updateSize() {
                const hf = BulletCache.instance.BT_V3_0;
                cocos2BulletVec3(hf, this.getMinUnscaledHalfExtents(VEC3_0));
                bt.BoxShape_setUnscaledHalfExtents(this.impl, hf);
                this.updateCompoundTransform();
              }

              get collider() {
                return this._collider;
              }

              onComponentSet() {
                const hf = BulletCache.instance.BT_V3_0;
                cocos2BulletVec3(hf, this.getMinUnscaledHalfExtents(VEC3_0));
                this._impl = bt.BoxShape_new(hf);
                this.updateScale();
              }

              updateScale() {
                super.updateScale();
                const bt_v3 = BulletCache.instance.BT_V3_0;
                bt.CollisionShape_setLocalScaling(this._impl, cocos2BulletVec3(bt_v3, this.getMinScale(VEC3_0)));
                this.updateCompoundTransform();
              }

              getMinUnscaledHalfExtents(out) {
                const size = this.collider.size;
                const ws = absolute(VEC3_0.set(this._collider.node.worldScale));
                const minVolumeSize = PhysicsSystem.instance.minVolumeSize;
                const halfSizeX = size.x / 2;
                const halfSizeY = size.y / 2;
                const halfSizeZ = size.z / 2;
                const halfX = halfSizeX * ws.x < minVolumeSize ? minVolumeSize / ws.x : halfSizeX;
                const halfY = halfSizeY * ws.y < minVolumeSize ? minVolumeSize / ws.y : halfSizeY;
                const halfZ = halfSizeZ * ws.z < minVolumeSize ? minVolumeSize / ws.z : halfSizeZ;
                out.set(halfX, halfY, halfZ);
                return out;
              }

              getMinScale(out) {
                const size = this.collider.size;
                const ws = absolute(VEC3_0.set(this._collider.node.worldScale));
                const minVolumeSize = PhysicsSystem.instance.minVolumeSize;
                const halfSizeX = size.x / 2;
                const halfSizeY = size.y / 2;
                const halfSizeZ = size.z / 2;
                const scaleX = halfSizeX * ws.x < minVolumeSize ? minVolumeSize / halfSizeX : ws.x;
                const scaleY = halfSizeY * ws.y < minVolumeSize ? minVolumeSize / halfSizeY : ws.y;
                const scaleZ = halfSizeZ * ws.z < minVolumeSize ? minVolumeSize / halfSizeZ : ws.z;
                out.set(scaleX, scaleY, scaleZ);
                return out;
              }

            }

            class BulletSphereShape extends BulletShape {
              updateRadius() {
                bt.SphereShape_setUnscaledRadius(this.impl, this.getMinUnscaledRadius());
                this.updateCompoundTransform();
              }

              get collider() {
                return this._collider;
              }

              onComponentSet() {
                this._impl = bt.SphereShape_new(this.getMinUnscaledRadius());
                this.updateScale();
              }

              updateScale() {
                super.updateScale();
                const scale = this.getMinScale();
                CC_V3_0.set(scale, scale, scale);
                const bt_v3 = BulletCache.instance.BT_V3_0;
                bt.CollisionShape_setLocalScaling(this._impl, cocos2BulletVec3(bt_v3, CC_V3_0));
                this.updateCompoundTransform();
              }

              getMinUnscaledRadius() {
                const radius = this.collider.radius;
                const ws = Math.abs(absMaxComponent(this._collider.node.worldScale));
                const minVolumeSize = PhysicsSystem.instance.minVolumeSize;
                return ws * radius < minVolumeSize ? minVolumeSize / ws : radius;
              }

              getMinScale() {
                const radius = this.collider.radius;
                const ws = Math.abs(absMaxComponent(this._collider.node.worldScale));
                const minVolumeSize = PhysicsSystem.instance.minVolumeSize;
                return ws * radius < minVolumeSize ? minVolumeSize / radius : ws;
              }

            }

            class BulletCapsuleShape extends BulletShape {
              setCylinderHeight(v) {
                this.updateProperties(this.collider.radius, this.collider.cylinderHeight, this.collider.direction, this._collider.node.worldScale);
              }

              setDirection(v) {
                this.updateProperties(this.collider.radius, this.collider.cylinderHeight, this.collider.direction, this._collider.node.worldScale);
              }

              setRadius(v) {
                this.updateProperties(this.collider.radius, this.collider.cylinderHeight, this.collider.direction, this._collider.node.worldScale);
              }

              get collider() {
                return this._collider;
              }

              onComponentSet() {
                this._impl = bt.CapsuleShape_new(0.5, 1);
                this.setRadius(this.collider.radius);
              }

              updateScale() {
                super.updateScale();
                this.setRadius(this.collider.radius);
              }

              updateProperties(radius, height, direction, scale) {
                const ws = scale;
                const upAxis = direction;
                let wr;
                let halfH;

                if (upAxis === 1) {
                  wr = radius * Math.abs(absMax(ws.x, ws.z));
                  halfH = height / 2 * Math.abs(ws.y);
                } else if (upAxis === 0) {
                  wr = radius * Math.abs(absMax(ws.y, ws.z));
                  halfH = height / 2 * Math.abs(ws.x);
                } else {
                  wr = radius * Math.abs(absMax(ws.x, ws.y));
                  halfH = height / 2 * Math.abs(ws.z);
                }

                bt.CapsuleShape_updateProp(this._impl, wr, halfH, upAxis);
                this.updateCompoundTransform();
              }

            }

            class BulletTrimeshShape extends BulletShape {
              constructor(...args) {
                super(...args);
                this.refBtTriangleMesh = 0;
              }

              get collider() {
                return this._collider;
              }

              setMesh(v) {
                if (!this._isInitialized) return;

                if (this._impl && BulletCache.isNotEmptyShape(this._impl)) {
                  warnID(9620);
                } else {
                  const mesh = v;

                  if (mesh && mesh.renderingSubMeshes.length > 0) {
                    const btTriangleMesh = this._getBtTriangleMesh(mesh);

                    if (this.collider.convex) {
                      this._impl = bt.ConvexTriangleMeshShape_new(btTriangleMesh);
                    } else {
                      this._impl = bt.BvhTriangleMeshShape_new(btTriangleMesh, true, true);
                    }

                    const bt_v3 = BulletCache.instance.BT_V3_0;
                    cocos2BulletVec3(bt_v3, this._collider.node.worldScale);
                    bt.CollisionShape_setMargin(this._impl, 0.01);
                    bt.CollisionShape_setLocalScaling(this._impl, bt_v3);
                    this.setCompound(this._compound);
                    this.updateByReAdd();
                    this.setWrapper();
                  } else {
                    this._impl = bt.EmptyShape_static();
                  }
                }
              }

              onComponentSet() {
                this.setMesh(this.collider.mesh);
              }

              onDestroy() {
                if (this.refBtTriangleMesh) {
                  bt.TriangleMesh_del(this.refBtTriangleMesh);
                }

                super.onDestroy();
              }

              updateScale() {
                super.updateScale();
                const bt_v3 = BulletCache.instance.BT_V3_0;
                cocos2BulletVec3(bt_v3, this._collider.node.worldScale);
                bt.CollisionShape_setLocalScaling(this._impl, bt_v3);
                this.updateCompoundTransform();
              }

              _getBtTriangleMesh(mesh) {
                this.refBtTriangleMesh = bt.TriangleMesh_new();
                cocos2BulletTriMesh(this.refBtTriangleMesh, mesh);
                return this.refBtTriangleMesh;
              }

            }

            class BulletCylinderShape extends BulletShape {
              setHeight(v) {
                this.updateProperties(this.collider.radius, this.collider.height, this.collider.direction, this._collider.node.worldScale);
              }

              setDirection(v) {
                this.updateProperties(this.collider.radius, this.collider.height, this.collider.direction, this._collider.node.worldScale);
              }

              setRadius(v) {
                this.updateProperties(this.collider.radius, this.collider.height, this.collider.direction, this._collider.node.worldScale);
              }

              get collider() {
                return this._collider;
              }

              onComponentSet() {
                const bt_v3 = BulletCache.instance.BT_V3_0;
                bt.Vec3_set(bt_v3, 0.5, 1, 0.5);
                this._impl = bt.CylinderShape_new(bt_v3);
                this.setRadius(this.collider.radius);
              }

              updateScale() {
                super.updateScale();
                this.setRadius(this.collider.radius);
              }

              updateProperties(radius, height, direction, scale) {
                const ws = scale;
                const upAxis = direction;
                let wr;
                let wh;

                if (upAxis === 1) {
                  wh = height * Math.abs(ws.y);
                  wr = radius * Math.abs(absMax(ws.x, ws.z));
                } else if (upAxis === 0) {
                  wh = height * Math.abs(ws.x);
                  wr = radius * Math.abs(absMax(ws.y, ws.z));
                } else {
                  wh = height * Math.abs(ws.z);
                  wr = radius * Math.abs(absMax(ws.x, ws.y));
                }

                bt.CylinderShape_updateProp(this._impl, wr, wh / 2, upAxis);
                this.updateCompoundTransform();
              }

            }

            class BulletConeShape extends BulletShape {
              setHeight(v) {
                this.updateProperties(this.collider.radius, this.collider.height, this.collider.direction, this._collider.node.worldScale);
              }

              setDirection(v) {
                this.updateProperties(this.collider.radius, this.collider.height, this.collider.direction, this._collider.node.worldScale);
              }

              setRadius(v) {
                this.updateProperties(this.collider.radius, this.collider.height, this.collider.direction, this._collider.node.worldScale);
              }

              get impl() {
                return this._impl;
              }

              get collider() {
                return this._collider;
              }

              onComponentSet() {
                this._impl = bt.ConeShape_new(0.5, 1);
                this.setRadius(this.collider.radius);
              }

              updateScale() {
                super.updateScale();
                this.setRadius(this.collider.radius);
              }

              updateProperties(radius, height, direction, scale) {
                const ws = scale;
                const upAxis = direction;
                let wr;
                let wh;

                if (upAxis === 1) {
                  wh = height * Math.abs(ws.y);
                  wr = radius * Math.abs(absMax(ws.x, ws.z));
                } else if (upAxis === 0) {
                  wh = height * Math.abs(ws.x);
                  wr = radius * Math.abs(absMax(ws.y, ws.z));
                } else {
                  wh = height * Math.abs(ws.z);
                  wr = radius * Math.abs(absMax(ws.x, ws.y));
                }

                bt.ConeShape_setRadius(this._impl, wr);
                bt.ConeShape_setHeight(this._impl, wh);
                bt.ConeShape_setConeUpIndex(this._impl, upAxis);
                const bt_v3 = BulletCache.instance.BT_V3_0;
                bt.Vec3_set(bt_v3, 1, 1, 1);
                bt.CollisionShape_setLocalScaling(this._impl, bt_v3);
                this.updateCompoundTransform();
              }

            }

            class BulletTerrainShape extends BulletShape {
              constructor(...args) {
                super(...args);
                this._bufPtr = 0;
                this._tileSize = 0;
                this._localOffset = new Vec3();
              }

              get collider() {
                return this._collider;
              }

              setTerrain(v) {
                if (!this._isInitialized) return;

                if (this._impl && BulletCache.isNotEmptyShape(this._impl)) {
                  warn('[Physics][Bullet]: change the terrain asset after initialization is not support.');
                } else {
                  const terrain = v;

                  if (terrain) {
                    this._tileSize = terrain.tileSize;
                    const sizeI = terrain.getVertexCountI();
                    const sizeJ = terrain.getVertexCountJ();
                    this._bufPtr = bt._malloc(4 * sizeI * sizeJ);
                    let offset = 0;
                    let min = Number.MAX_SAFE_INTEGER;
                    let max = Number.MIN_SAFE_INTEGER;

                    for (let j = 0; j < sizeJ; j++) {
                      for (let i = 0; i < sizeI; i++) {
                        const v = terrain.getHeight(i, j);

                        bt._write_f32(this._bufPtr + offset, v);

                        if (min > v) min = v;
                        if (v > max) max = v;
                        offset += 4;
                      }
                    }

                    max += 0.01;
                    min -= 0.01;

                    this._localOffset.set((sizeI - 1) / 2 * this._tileSize, (max + min) / 2, (sizeJ - 1) / 2 * this._tileSize);

                    this._impl = bt.TerrainShape_new(sizeI, sizeJ, this._bufPtr, 1, min, max);
                    const bt_v3 = BulletCache.instance.BT_V3_0;
                    bt.Vec3_set(bt_v3, this._tileSize, 1, this._tileSize);
                    bt.CollisionShape_setLocalScaling(this._impl, bt_v3);
                    this.setCompound(this._compound);
                    this.updateByReAdd();
                    this.setWrapper();
                  } else {
                    this._impl = bt.EmptyShape_static();
                  }
                }
              }

              onComponentSet() {
                this.setTerrain(this.collider.terrain);
              }

              onDestroy() {
                if (this._bufPtr) bt._free(this._bufPtr);
                super.onDestroy();
              }

              setCenter(v) {
                Vec3.copy(CC_V3_0, v);
                CC_V3_0.add(this._localOffset);
                cocos2BulletVec3(bt.Transform_getOrigin(this.transform), CC_V3_0);
                this.updateCompoundTransform();
              }

            }

            console.log('pptest importing cc 3');
            class BulletSimplexShape extends BulletShape {
              setShapeType(v) {}

              setVertices(v) {}

              get collider() {
                return this._collider;
              }

              onComponentSet() {
                this._impl = bt.SimplexShape_new();
                const length = this.collider.shapeType;
                const vertices = this.collider.vertices;
                const bt_v3 = BulletCache.instance.BT_V3_0;

                for (let i = 0; i < length; i++) {
                  bt.SimplexShape_addVertex(this._impl, cocos2BulletVec3(bt_v3, vertices[i]));
                }

                bt.CollisionShape_setLocalScaling(this._impl, cocos2BulletVec3(bt_v3, this._collider.node.worldScale));
              }

              onLoad() {
                super.onLoad();
                this.collider.updateVertices();
              }

              updateScale() {
                super.updateScale();
                const bt_v3 = BulletCache.instance.BT_V3_0;
                bt.CollisionShape_setLocalScaling(this._impl, cocos2BulletVec3(bt_v3, this._collider.node.worldScale));
              }

            }

            class BulletPlaneShape extends BulletShape {
              setNormal(v) {
                cocos2BulletVec3(bt.StaticPlaneShape_getPlaneNormal(this.impl), v);
                this.updateCompoundTransform();
              }

              setConstant(v) {
                bt.StaticPlaneShape_setPlaneConstant(this.impl, v);
                this.updateCompoundTransform();
              }

              updateScale() {
                super.updateScale();
                const bt_v3 = BulletCache.instance.BT_V3_0;
                cocos2BulletVec3(bt_v3, this._collider.node.worldScale);
                bt.CollisionShape_setLocalScaling(this._impl, bt_v3);
                this.updateCompoundTransform();
              }

              get collider() {
                return this._collider;
              }

              onComponentSet() {
                const normal = BulletCache.instance.BT_V3_0;
                cocos2BulletVec3(normal, this.collider.normal);
                this._impl = bt.StaticPlaneShape_new(normal, this.collider.constant);
                this.updateScale();
              }

            }

            class BulletConstraint {
              constructor() {
                this.dirty = 0;
                this.index = -1;
                this._impl = 0;
                this._com = void 0;
                this._rigidBody = void 0;
                this._collided = false;
              }

              setConnectedBody(v) {}

              setEnableCollision(v) {
                if (this._collided !== v) {
                  this._collided = v;
                  this.updateByReAdd();
                }
              }

              get impl() {
                return this._impl;
              }

              get constraint() {
                return this._com;
              }

              updateByReAdd() {
                if (this._rigidBody && this.index >= 0) {
                  const sb = this._rigidBody.body.sharedBody;
                  sb.wrappedWorld.removeConstraint(this);
                  sb.wrappedWorld.addConstraint(this);
                }
              }

              initialize(v) {
                this._com = v;
                this._rigidBody = v.attachedBody;
                this._collided = v.enableCollision;
                this.onComponentSet();
              }

              onEnable() {
                const sb = this._rigidBody.body.sharedBody;
                sb.wrappedWorld.addConstraint(this);
                sb.addJoint(this, 0);
                const connect = this.constraint.connectedBody;

                if (connect) {
                  const sb2 = connect.body.sharedBody;
                  sb2.addJoint(this, 1);
                }
              }

              onDisable() {
                const sb = this._rigidBody.body.sharedBody;
                sb.wrappedWorld.removeConstraint(this);
                sb.removeJoint(this, 0);
                const connect = this.constraint.connectedBody;

                if (connect) {
                  const sb2 = connect.body.sharedBody;
                  sb2.removeJoint(this, 1);
                }
              }

              onDestroy() {
                bt.TypedConstraint_del(this._impl);
                this._com = null;
                this._rigidBody = null;
              }

            }

            class BulletP2PConstraint extends BulletConstraint {
              setPivotA(v) {
                const cs = this.constraint;
                const pivotA = BulletCache.instance.BT_V3_0;
                Vec3.multiply(CC_V3_0, cs.node.worldScale, cs.pivotA);
                cocos2BulletVec3(pivotA, CC_V3_0);
                bt.P2PConstraint_setPivotA(this._impl, pivotA);
                if (!cs.connectedBody) this.setPivotB(cs.pivotB);
              }

              setPivotB(v) {
                const cs = this.constraint;
                const node = this._rigidBody.node;
                const pivotB = BulletCache.instance.BT_V3_0;
                const cb = cs.connectedBody;

                if (cb) {
                  Vec3.multiply(CC_V3_0, cb.node.worldScale, cs.pivotB);
                  cocos2BulletVec3(pivotB, CC_V3_0);
                } else {
                  Vec3.multiply(CC_V3_0, node.worldScale, cs.pivotA);
                  Vec3.add(CC_V3_0, CC_V3_0, node.worldPosition);
                  Vec3.add(CC_V3_0, CC_V3_0, cs.pivotB);
                  cocos2BulletVec3(pivotB, CC_V3_0);
                }

                bt.P2PConstraint_setPivotB(this._impl, pivotB);
              }

              get constraint() {
                return this._com;
              }

              onComponentSet() {
                const cb = this.constraint.connectedBody;
                const bodyA = this._rigidBody.body.impl;
                const bodyB = cb ? cb.body.impl : bt.TypedConstraint_getFixedBody();
                const pivotA = BulletCache.instance.BT_V3_0;
                const pivotB = BulletCache.instance.BT_V3_1;
                this._impl = bt.P2PConstraint_new(bodyA, bodyB, pivotA, pivotB);
                this.setPivotA(this.constraint.pivotA);
                this.setPivotB(this.constraint.pivotB);
              }

              updateScale0() {
                this.setPivotA(this.constraint.pivotA);
              }

              updateScale1() {
                this.setPivotB(this.constraint.pivotB);
              }

            }

            class BulletHingeConstraint extends BulletConstraint {
              setPivotA(v) {
                this.updateFrames();
              }

              setPivotB(v) {
                this.updateFrames();
              }

              setAxis(v) {
                this.updateFrames();
              }

              get constraint() {
                return this._com;
              }

              onComponentSet() {
                const cb = this.constraint.connectedBody;
                const bodyA = this._rigidBody.body.impl;
                const bodyB = cb ? cb.body.impl : bt.TypedConstraint_getFixedBody();
                const trans0 = BulletCache.instance.BT_TRANSFORM_0;
                const trans1 = BulletCache.instance.BT_TRANSFORM_1;
                this._impl = bt.HingeConstraint_new(bodyA, bodyB, trans0, trans1);
                this.updateFrames();
              }

              updateFrames() {
                const cs = this.constraint;
                const node = cs.node;
                const v3_0 = CC_V3_0;
                const rot_0 = CC_QUAT_0;
                const trans0 = BulletCache.instance.BT_TRANSFORM_0;
                Vec3.multiply(v3_0, node.worldScale, cs.pivotA);
                cocos2BulletVec3(bt.Transform_getOrigin(trans0), v3_0);
                const quat = BulletCache.instance.BT_QUAT_0;
                Quat.rotationTo(rot_0, Vec3.UNIT_Z, cs.axis);
                cocos2BulletQuat(quat, rot_0);
                bt.Transform_setRotation(trans0, quat);
                const trans1 = BulletCache.instance.BT_TRANSFORM_1;
                const cb = this.constraint.connectedBody;

                if (cb) {
                  Vec3.multiply(v3_0, cb.node.worldScale, cs.pivotB);
                } else {
                  Vec3.multiply(v3_0, node.worldScale, cs.pivotA);
                  Vec3.add(v3_0, v3_0, node.worldPosition);
                  Vec3.add(v3_0, v3_0, cs.pivotB);
                  Quat.multiply(rot_0, rot_0, node.worldRotation);
                }

                cocos2BulletVec3(bt.Transform_getOrigin(trans1), v3_0);
                cocos2BulletQuat(quat, rot_0);
                bt.Transform_setRotation(trans1, quat);
                bt.HingeConstraint_setFrames(this._impl, trans0, trans1);
              }

              updateScale0() {
                this.updateFrames();
              }

              updateScale1() {
                this.updateFrames();
              }

            }

            game.once(Game.EVENT_ENGINE_INITED, () => {
              selector.register('bullet', {
                PhysicsWorld: BulletWorld,
                RigidBody: BulletRigidBody,
                BoxShape: BulletBoxShape,
                SphereShape: BulletSphereShape,
                CapsuleShape: BulletCapsuleShape,
                TrimeshShape: BulletTrimeshShape,
                CylinderShape: BulletCylinderShape,
                ConeShape: BulletConeShape,
                TerrainShape: BulletTerrainShape,
                SimplexShape: BulletSimplexShape,
                PlaneShape: BulletPlaneShape,
                PointToPointConstraint: BulletP2PConstraint,
                HingeConstraint: BulletHingeConstraint
              });
            });

            let WRAPPER;
            let physicsEngineId;
            function select(id, wrapper) {
              physicsEngineId = id;
              legacyCC._global.CC_PHYSICS_2D_BUILTIN = id == 'builtin';
              legacyCC._global.CC_PHYSICS_2D_BOX2D = id == 'box2d';
              WRAPPER = wrapper;
            }

            var box2d_umd=createCommonjsModule(function(module,exports){(function(global,factory){factory(exports);})(commonjsGlobal,function(exports){function b2Assert(condition,...args){if(!condition){throw new Error(...args);}}function b2Maybe(value,def){return value!==undefined?value:def;}const b2_maxFloat=1E+37;const b2_epsilon=1E-5;const b2_epsilon_sq=b2_epsilon*b2_epsilon;const b2_pi=3.14159265359;const b2_maxManifoldPoints=2;const b2_maxPolygonVertices=8;const b2_aabbExtension=0.1;const b2_aabbMultiplier=2;const b2_linearSlop=0.008;const b2_angularSlop=2/180*b2_pi;const b2_polygonRadius=2*b2_linearSlop;const b2_maxSubSteps=8;const b2_maxTOIContacts=32;const b2_velocityThreshold=1;const b2_maxLinearCorrection=0.2;const b2_maxAngularCorrection=8/180*b2_pi;const b2_maxTranslation=2;const b2_maxTranslationSquared=b2_maxTranslation*b2_maxTranslation;const b2_maxRotation=0.5*b2_pi;const b2_maxRotationSquared=b2_maxRotation*b2_maxRotation;const b2_baumgarte=0.2;const b2_toiBaumgarte=0.75;const b2_invalidParticleIndex=-1;const b2_maxParticleIndex=0x7FFFFFFF;const b2_particleStride=0.75;const b2_minParticleWeight=1.0;const b2_maxParticlePressure=0.25;const b2_maxParticleForce=0.5;const b2_maxTriadDistance=2.0;const b2_maxTriadDistanceSquared=b2_maxTriadDistance*b2_maxTriadDistance;const b2_minParticleSystemBufferCapacity=256;const b2_barrierCollisionTime=2.5;const b2_timeToSleep=0.5;const b2_linearSleepTolerance=0.01;const b2_angularSleepTolerance=2/180*b2_pi;function b2Alloc(size){return null;}function b2Free(mem){}function b2Log(message,...args){}class b2Version{constructor(major=0,minor=0,revision=0){this.major=0;this.minor=0;this.revision=0;this.major=major;this.minor=minor;this.revision=revision;}toString(){return this.major+"."+this.minor+"."+this.revision;}}const b2_version=new b2Version(2,3,2);const b2_branch="master";const b2_commit="fbf51801d80fc389d43dc46524520e89043b6faf";function b2ParseInt(v){return parseInt(v,10);}function b2ParseUInt(v){return Math.abs(parseInt(v,10));}function b2MakeArray(length,init){const a=new Array(length);for(let i=0;i<length;++i){a[i]=init(i);}return a;}function b2MakeNullArray(length){const a=new Array(length);for(let i=0;i<length;++i){a[i]=null;}return a;}function b2MakeNumberArray(length,init=0){const a=new Array(length);for(let i=0;i<length;++i){a[i]=init;}return a;}const b2_pi_over_180=b2_pi/180;const b2_180_over_pi=180/b2_pi;const b2_two_pi=2*b2_pi;const b2Abs=Math.abs;function b2Min(a,b){return a<b?a:b;}function b2Max(a,b){return a>b?a:b;}function b2Clamp(a,lo,hi){return a<lo?lo:a>hi?hi:a;}function b2Swap(a,b){const tmp=a[0];a[0]=b[0];b[0]=tmp;}const b2IsValid=isFinite;function b2Sq(n){return n*n;}function b2InvSqrt(n){return 1/Math.sqrt(n);}const b2Sqrt=Math.sqrt;const b2Pow=Math.pow;function b2DegToRad(degrees){return degrees*b2_pi_over_180;}function b2RadToDeg(radians){return radians*b2_180_over_pi;}const b2Cos=Math.cos;const b2Sin=Math.sin;const b2Acos=Math.acos;const b2Asin=Math.asin;const b2Atan2=Math.atan2;function b2NextPowerOfTwo(x){x|=x>>1&0x7FFFFFFF;x|=x>>2&0x3FFFFFFF;x|=x>>4&0x0FFFFFFF;x|=x>>8&0x00FFFFFF;x|=x>>16&0x0000FFFF;return x+1;}function b2IsPowerOfTwo(x){return x>0&&(x&x-1)===0;}function b2Random(){return Math.random()*2-1;}function b2RandomRange(lo,hi){return (hi-lo)*Math.random()+lo;}class b2Vec2{constructor(...args){if(args[0]instanceof Float32Array){if(args[0].length!==2){throw new Error();}this.data=args[0];}else {const x=typeof args[0]==="number"?args[0]:0;const y=typeof args[1]==="number"?args[1]:0;this.data=new Float32Array([x,y]);}}get x(){return this.data[0];}set x(value){this.data[0]=value;}get y(){return this.data[1];}set y(value){this.data[1]=value;}Clone(){return new b2Vec2(this.x,this.y);}SetZero(){this.x=0;this.y=0;return this;}Set(x,y){this.x=x;this.y=y;return this;}Copy(other){this.x=other.x;this.y=other.y;return this;}SelfAdd(v){this.x+=v.x;this.y+=v.y;return this;}SelfAddXY(x,y){this.x+=x;this.y+=y;return this;}SelfSub(v){this.x-=v.x;this.y-=v.y;return this;}SelfSubXY(x,y){this.x-=x;this.y-=y;return this;}SelfMul(s){this.x*=s;this.y*=s;return this;}SelfMulAdd(s,v){this.x+=s*v.x;this.y+=s*v.y;return this;}SelfMulSub(s,v){this.x-=s*v.x;this.y-=s*v.y;return this;}Dot(v){return this.x*v.x+this.y*v.y;}Cross(v){return this.x*v.y-this.y*v.x;}Length(){const x=this.x,y=this.y;return Math.sqrt(x*x+y*y);}LengthSquared(){const x=this.x,y=this.y;return x*x+y*y;}Normalize(){const length=this.Length();if(length>=b2_epsilon){const inv_length=1/length;this.x*=inv_length;this.y*=inv_length;}return length;}SelfNormalize(){const length=this.Length();if(length>=b2_epsilon){const inv_length=1/length;this.x*=inv_length;this.y*=inv_length;}return this;}SelfRotate(radians){const c=Math.cos(radians);const s=Math.sin(radians);const x=this.x;this.x=c*x-s*this.y;this.y=s*x+c*this.y;return this;}SelfRotateCosSin(c,s){const x=this.x;this.x=c*x-s*this.y;this.y=s*x+c*this.y;return this;}IsValid(){return isFinite(this.x)&&isFinite(this.y);}SelfCrossVS(s){const x=this.x;this.x=s*this.y;this.y=-s*x;return this;}SelfCrossSV(s){const x=this.x;this.x=-s*this.y;this.y=s*x;return this;}SelfMinV(v){this.x=b2Min(this.x,v.x);this.y=b2Min(this.y,v.y);return this;}SelfMaxV(v){this.x=b2Max(this.x,v.x);this.y=b2Max(this.y,v.y);return this;}SelfAbs(){this.x=b2Abs(this.x);this.y=b2Abs(this.y);return this;}SelfNeg(){this.x=-this.x;this.y=-this.y;return this;}SelfSkew(){const x=this.x;this.x=-this.y;this.y=x;return this;}static MakeArray(length){return b2MakeArray(length,i=>new b2Vec2());}static AbsV(v,out){out.x=b2Abs(v.x);out.y=b2Abs(v.y);return out;}static MinV(a,b,out){out.x=b2Min(a.x,b.x);out.y=b2Min(a.y,b.y);return out;}static MaxV(a,b,out){out.x=b2Max(a.x,b.x);out.y=b2Max(a.y,b.y);return out;}static ClampV(v,lo,hi,out){out.x=b2Clamp(v.x,lo.x,hi.x);out.y=b2Clamp(v.y,lo.y,hi.y);return out;}static RotateV(v,radians,out){const v_x=v.x,v_y=v.y;const c=Math.cos(radians);const s=Math.sin(radians);out.x=c*v_x-s*v_y;out.y=s*v_x+c*v_y;return out;}static DotVV(a,b){return a.x*b.x+a.y*b.y;}static CrossVV(a,b){return a.x*b.y-a.y*b.x;}static CrossVS(v,s,out){const v_x=v.x;out.x=s*v.y;out.y=-s*v_x;return out;}static CrossVOne(v,out){const v_x=v.x;out.x=v.y;out.y=-v_x;return out;}static CrossSV(s,v,out){const v_x=v.x;out.x=-s*v.y;out.y=s*v_x;return out;}static CrossOneV(v,out){const v_x=v.x;out.x=-v.y;out.y=v_x;return out;}static AddVV(a,b,out){out.x=a.x+b.x;out.y=a.y+b.y;return out;}static SubVV(a,b,out){out.x=a.x-b.x;out.y=a.y-b.y;return out;}static MulSV(s,v,out){out.x=v.x*s;out.y=v.y*s;return out;}static MulVS(v,s,out){out.x=v.x*s;out.y=v.y*s;return out;}static AddVMulSV(a,s,b,out){out.x=a.x+s*b.x;out.y=a.y+s*b.y;return out;}static SubVMulSV(a,s,b,out){out.x=a.x-s*b.x;out.y=a.y-s*b.y;return out;}static AddVCrossSV(a,s,v,out){const v_x=v.x;out.x=a.x-s*v.y;out.y=a.y+s*v_x;return out;}static MidVV(a,b,out){out.x=(a.x+b.x)*0.5;out.y=(a.y+b.y)*0.5;return out;}static ExtVV(a,b,out){out.x=(b.x-a.x)*0.5;out.y=(b.y-a.y)*0.5;return out;}static IsEqualToV(a,b){return a.x===b.x&&a.y===b.y;}static DistanceVV(a,b){const c_x=a.x-b.x;const c_y=a.y-b.y;return Math.sqrt(c_x*c_x+c_y*c_y);}static DistanceSquaredVV(a,b){const c_x=a.x-b.x;const c_y=a.y-b.y;return c_x*c_x+c_y*c_y;}static NegV(v,out){out.x=-v.x;out.y=-v.y;return out;}}b2Vec2.ZERO=new b2Vec2(0,0);b2Vec2.UNITX=new b2Vec2(1,0);b2Vec2.UNITY=new b2Vec2(0,1);b2Vec2.s_t0=new b2Vec2();b2Vec2.s_t1=new b2Vec2();b2Vec2.s_t2=new b2Vec2();b2Vec2.s_t3=new b2Vec2();const b2Vec2_zero=new b2Vec2(0,0);class b2Vec3{constructor(...args){if(args[0]instanceof Float32Array){if(args[0].length!==3){throw new Error();}this.data=args[0];}else {const x=typeof args[0]==="number"?args[0]:0;const y=typeof args[1]==="number"?args[1]:0;const z=typeof args[2]==="number"?args[2]:0;this.data=new Float32Array([x,y,z]);}}get x(){return this.data[0];}set x(value){this.data[0]=value;}get y(){return this.data[1];}set y(value){this.data[1]=value;}get z(){return this.data[2];}set z(value){this.data[2]=value;}Clone(){return new b2Vec3(this.x,this.y,this.z);}SetZero(){this.x=0;this.y=0;this.z=0;return this;}SetXYZ(x,y,z){this.x=x;this.y=y;this.z=z;return this;}Copy(other){this.x=other.x;this.y=other.y;this.z=other.z;return this;}SelfNeg(){this.x=-this.x;this.y=-this.y;this.z=-this.z;return this;}SelfAdd(v){this.x+=v.x;this.y+=v.y;this.z+=v.z;return this;}SelfAddXYZ(x,y,z){this.x+=x;this.y+=y;this.z+=z;return this;}SelfSub(v){this.x-=v.x;this.y-=v.y;this.z-=v.z;return this;}SelfSubXYZ(x,y,z){this.x-=x;this.y-=y;this.z-=z;return this;}SelfMul(s){this.x*=s;this.y*=s;this.z*=s;return this;}static DotV3V3(a,b){return a.x*b.x+a.y*b.y+a.z*b.z;}static CrossV3V3(a,b,out){const a_x=a.x,a_y=a.y,a_z=a.z;const b_x=b.x,b_y=b.y,b_z=b.z;out.x=a_y*b_z-a_z*b_y;out.y=a_z*b_x-a_x*b_z;out.z=a_x*b_y-a_y*b_x;return out;}}b2Vec3.ZERO=new b2Vec3(0,0,0);b2Vec3.s_t0=new b2Vec3();class b2Mat22{constructor(){this.data=new Float32Array([1,0,0,1]);this.ex=new b2Vec2(this.data.subarray(0,2));this.ey=new b2Vec2(this.data.subarray(2,4));}Clone(){return new b2Mat22().Copy(this);}static FromVV(c1,c2){return new b2Mat22().SetVV(c1,c2);}static FromSSSS(r1c1,r1c2,r2c1,r2c2){return new b2Mat22().SetSSSS(r1c1,r1c2,r2c1,r2c2);}static FromAngle(radians){return new b2Mat22().SetAngle(radians);}SetSSSS(r1c1,r1c2,r2c1,r2c2){this.ex.Set(r1c1,r2c1);this.ey.Set(r1c2,r2c2);return this;}SetVV(c1,c2){this.ex.Copy(c1);this.ey.Copy(c2);return this;}SetAngle(radians){const c=Math.cos(radians);const s=Math.sin(radians);this.ex.Set(c,s);this.ey.Set(-s,c);return this;}Copy(other){this.ex.Copy(other.ex);this.ey.Copy(other.ey);return this;}SetIdentity(){this.ex.Set(1,0);this.ey.Set(0,1);return this;}SetZero(){this.ex.SetZero();this.ey.SetZero();return this;}GetAngle(){return Math.atan2(this.ex.y,this.ex.x);}GetInverse(out){const a=this.ex.x;const b=this.ey.x;const c=this.ex.y;const d=this.ey.y;let det=a*d-b*c;if(det!==0){det=1/det;}out.ex.x=det*d;out.ey.x=-det*b;out.ex.y=-det*c;out.ey.y=det*a;return out;}Solve(b_x,b_y,out){const a11=this.ex.x,a12=this.ey.x;const a21=this.ex.y,a22=this.ey.y;let det=a11*a22-a12*a21;if(det!==0){det=1/det;}out.x=det*(a22*b_x-a12*b_y);out.y=det*(a11*b_y-a21*b_x);return out;}SelfAbs(){this.ex.SelfAbs();this.ey.SelfAbs();return this;}SelfInv(){this.GetInverse(this);return this;}SelfAddM(M){this.ex.SelfAdd(M.ex);this.ey.SelfAdd(M.ey);return this;}SelfSubM(M){this.ex.SelfSub(M.ex);this.ey.SelfSub(M.ey);return this;}static AbsM(M,out){const M_ex=M.ex,M_ey=M.ey;out.ex.x=b2Abs(M_ex.x);out.ex.y=b2Abs(M_ex.y);out.ey.x=b2Abs(M_ey.x);out.ey.y=b2Abs(M_ey.y);return out;}static MulMV(M,v,out){const M_ex=M.ex,M_ey=M.ey;const v_x=v.x,v_y=v.y;out.x=M_ex.x*v_x+M_ey.x*v_y;out.y=M_ex.y*v_x+M_ey.y*v_y;return out;}static MulTMV(M,v,out){const M_ex=M.ex,M_ey=M.ey;const v_x=v.x,v_y=v.y;out.x=M_ex.x*v_x+M_ex.y*v_y;out.y=M_ey.x*v_x+M_ey.y*v_y;return out;}static AddMM(A,B,out){const A_ex=A.ex,A_ey=A.ey;const B_ex=B.ex,B_ey=B.ey;out.ex.x=A_ex.x+B_ex.x;out.ex.y=A_ex.y+B_ex.y;out.ey.x=A_ey.x+B_ey.x;out.ey.y=A_ey.y+B_ey.y;return out;}static MulMM(A,B,out){const A_ex_x=A.ex.x,A_ex_y=A.ex.y;const A_ey_x=A.ey.x,A_ey_y=A.ey.y;const B_ex_x=B.ex.x,B_ex_y=B.ex.y;const B_ey_x=B.ey.x,B_ey_y=B.ey.y;out.ex.x=A_ex_x*B_ex_x+A_ey_x*B_ex_y;out.ex.y=A_ex_y*B_ex_x+A_ey_y*B_ex_y;out.ey.x=A_ex_x*B_ey_x+A_ey_x*B_ey_y;out.ey.y=A_ex_y*B_ey_x+A_ey_y*B_ey_y;return out;}static MulTMM(A,B,out){const A_ex_x=A.ex.x,A_ex_y=A.ex.y;const A_ey_x=A.ey.x,A_ey_y=A.ey.y;const B_ex_x=B.ex.x,B_ex_y=B.ex.y;const B_ey_x=B.ey.x,B_ey_y=B.ey.y;out.ex.x=A_ex_x*B_ex_x+A_ex_y*B_ex_y;out.ex.y=A_ey_x*B_ex_x+A_ey_y*B_ex_y;out.ey.x=A_ex_x*B_ey_x+A_ex_y*B_ey_y;out.ey.y=A_ey_x*B_ey_x+A_ey_y*B_ey_y;return out;}}b2Mat22.IDENTITY=new b2Mat22();class b2Mat33{constructor(){this.data=new Float32Array([1,0,0,0,1,0,0,0,1]);this.ex=new b2Vec3(this.data.subarray(0,3));this.ey=new b2Vec3(this.data.subarray(3,6));this.ez=new b2Vec3(this.data.subarray(6,9));}Clone(){return new b2Mat33().Copy(this);}SetVVV(c1,c2,c3){this.ex.Copy(c1);this.ey.Copy(c2);this.ez.Copy(c3);return this;}Copy(other){this.ex.Copy(other.ex);this.ey.Copy(other.ey);this.ez.Copy(other.ez);return this;}SetIdentity(){this.ex.SetXYZ(1,0,0);this.ey.SetXYZ(0,1,0);this.ez.SetXYZ(0,0,1);return this;}SetZero(){this.ex.SetZero();this.ey.SetZero();this.ez.SetZero();return this;}SelfAddM(M){this.ex.SelfAdd(M.ex);this.ey.SelfAdd(M.ey);this.ez.SelfAdd(M.ez);return this;}Solve33(b_x,b_y,b_z,out){const a11=this.ex.x,a21=this.ex.y,a31=this.ex.z;const a12=this.ey.x,a22=this.ey.y,a32=this.ey.z;const a13=this.ez.x,a23=this.ez.y,a33=this.ez.z;let det=a11*(a22*a33-a32*a23)+a21*(a32*a13-a12*a33)+a31*(a12*a23-a22*a13);if(det!==0){det=1/det;}out.x=det*(b_x*(a22*a33-a32*a23)+b_y*(a32*a13-a12*a33)+b_z*(a12*a23-a22*a13));out.y=det*(a11*(b_y*a33-b_z*a23)+a21*(b_z*a13-b_x*a33)+a31*(b_x*a23-b_y*a13));out.z=det*(a11*(a22*b_z-a32*b_y)+a21*(a32*b_x-a12*b_z)+a31*(a12*b_y-a22*b_x));return out;}Solve22(b_x,b_y,out){const a11=this.ex.x,a12=this.ey.x;const a21=this.ex.y,a22=this.ey.y;let det=a11*a22-a12*a21;if(det!==0){det=1/det;}out.x=det*(a22*b_x-a12*b_y);out.y=det*(a11*b_y-a21*b_x);return out;}GetInverse22(M){const a=this.ex.x,b=this.ey.x,c=this.ex.y,d=this.ey.y;let det=a*d-b*c;if(det!==0){det=1/det;}M.ex.x=det*d;M.ey.x=-det*b;M.ex.z=0;M.ex.y=-det*c;M.ey.y=det*a;M.ey.z=0;M.ez.x=0;M.ez.y=0;M.ez.z=0;}GetSymInverse33(M){let det=b2Vec3.DotV3V3(this.ex,b2Vec3.CrossV3V3(this.ey,this.ez,b2Vec3.s_t0));if(det!==0){det=1/det;}const a11=this.ex.x,a12=this.ey.x,a13=this.ez.x;const a22=this.ey.y,a23=this.ez.y;const a33=this.ez.z;M.ex.x=det*(a22*a33-a23*a23);M.ex.y=det*(a13*a23-a12*a33);M.ex.z=det*(a12*a23-a13*a22);M.ey.x=M.ex.y;M.ey.y=det*(a11*a33-a13*a13);M.ey.z=det*(a13*a12-a11*a23);M.ez.x=M.ex.z;M.ez.y=M.ey.z;M.ez.z=det*(a11*a22-a12*a12);}static MulM33V3(A,v,out){const v_x=v.x,v_y=v.y,v_z=v.z;out.x=A.ex.x*v_x+A.ey.x*v_y+A.ez.x*v_z;out.y=A.ex.y*v_x+A.ey.y*v_y+A.ez.y*v_z;out.z=A.ex.z*v_x+A.ey.z*v_y+A.ez.z*v_z;return out;}static MulM33XYZ(A,x,y,z,out){out.x=A.ex.x*x+A.ey.x*y+A.ez.x*z;out.y=A.ex.y*x+A.ey.y*y+A.ez.y*z;out.z=A.ex.z*x+A.ey.z*y+A.ez.z*z;return out;}static MulM33V2(A,v,out){const v_x=v.x,v_y=v.y;out.x=A.ex.x*v_x+A.ey.x*v_y;out.y=A.ex.y*v_x+A.ey.y*v_y;return out;}static MulM33XY(A,x,y,out){out.x=A.ex.x*x+A.ey.x*y;out.y=A.ex.y*x+A.ey.y*y;return out;}}b2Mat33.IDENTITY=new b2Mat33();class b2Rot{constructor(angle=0){this.s=0;this.c=1;if(angle){this.s=Math.sin(angle);this.c=Math.cos(angle);}}Clone(){return new b2Rot().Copy(this);}Copy(other){this.s=other.s;this.c=other.c;return this;}SetAngle(angle){this.s=Math.sin(angle);this.c=Math.cos(angle);return this;}SetIdentity(){this.s=0;this.c=1;return this;}GetAngle(){return Math.atan2(this.s,this.c);}GetXAxis(out){out.x=this.c;out.y=this.s;return out;}GetYAxis(out){out.x=-this.s;out.y=this.c;return out;}static MulRR(q,r,out){const q_c=q.c,q_s=q.s;const r_c=r.c,r_s=r.s;out.s=q_s*r_c+q_c*r_s;out.c=q_c*r_c-q_s*r_s;return out;}static MulTRR(q,r,out){const q_c=q.c,q_s=q.s;const r_c=r.c,r_s=r.s;out.s=q_c*r_s-q_s*r_c;out.c=q_c*r_c+q_s*r_s;return out;}static MulRV(q,v,out){const q_c=q.c,q_s=q.s;const v_x=v.x,v_y=v.y;out.x=q_c*v_x-q_s*v_y;out.y=q_s*v_x+q_c*v_y;return out;}static MulTRV(q,v,out){const q_c=q.c,q_s=q.s;const v_x=v.x,v_y=v.y;out.x=q_c*v_x+q_s*v_y;out.y=-q_s*v_x+q_c*v_y;return out;}}b2Rot.IDENTITY=new b2Rot();class b2Transform{constructor(){this.p=new b2Vec2();this.q=new b2Rot();}Clone(){return new b2Transform().Copy(this);}Copy(other){this.p.Copy(other.p);this.q.Copy(other.q);return this;}SetIdentity(){this.p.SetZero();this.q.SetIdentity();return this;}SetPositionRotation(position,q){this.p.Copy(position);this.q.Copy(q);return this;}SetPositionAngle(pos,a){this.p.Copy(pos);this.q.SetAngle(a);return this;}SetPosition(position){this.p.Copy(position);return this;}SetPositionXY(x,y){this.p.Set(x,y);return this;}SetRotation(rotation){this.q.Copy(rotation);return this;}SetRotationAngle(radians){this.q.SetAngle(radians);return this;}GetPosition(){return this.p;}GetRotation(){return this.q;}GetRotationAngle(){return this.q.GetAngle();}GetAngle(){return this.q.GetAngle();}static MulXV(T,v,out){const T_q_c=T.q.c,T_q_s=T.q.s;const v_x=v.x,v_y=v.y;out.x=T_q_c*v_x-T_q_s*v_y+T.p.x;out.y=T_q_s*v_x+T_q_c*v_y+T.p.y;return out;}static MulTXV(T,v,out){const T_q_c=T.q.c,T_q_s=T.q.s;const p_x=v.x-T.p.x;const p_y=v.y-T.p.y;out.x=T_q_c*p_x+T_q_s*p_y;out.y=-T_q_s*p_x+T_q_c*p_y;return out;}static MulXX(A,B,out){b2Rot.MulRR(A.q,B.q,out.q);b2Vec2.AddVV(b2Rot.MulRV(A.q,B.p,out.p),A.p,out.p);return out;}static MulTXX(A,B,out){b2Rot.MulTRR(A.q,B.q,out.q);b2Rot.MulTRV(A.q,b2Vec2.SubVV(B.p,A.p,out.p),out.p);return out;}}b2Transform.IDENTITY=new b2Transform();class b2Sweep{constructor(){this.localCenter=new b2Vec2();this.c0=new b2Vec2();this.c=new b2Vec2();this.a0=0;this.a=0;this.alpha0=0;}Clone(){return new b2Sweep().Copy(this);}Copy(other){this.localCenter.Copy(other.localCenter);this.c0.Copy(other.c0);this.c.Copy(other.c);this.a0=other.a0;this.a=other.a;this.alpha0=other.alpha0;return this;}GetTransform(xf,beta){const one_minus_beta=1-beta;xf.p.x=one_minus_beta*this.c0.x+beta*this.c.x;xf.p.y=one_minus_beta*this.c0.y+beta*this.c.y;const angle=one_minus_beta*this.a0+beta*this.a;xf.q.SetAngle(angle);xf.p.SelfSub(b2Rot.MulRV(xf.q,this.localCenter,b2Vec2.s_t0));return xf;}Advance(alpha){const beta=(alpha-this.alpha0)/(1-this.alpha0);const one_minus_beta=1-beta;this.c0.x=one_minus_beta*this.c0.x+beta*this.c.x;this.c0.y=one_minus_beta*this.c0.y+beta*this.c.y;this.a0=one_minus_beta*this.a0+beta*this.a;this.alpha0=alpha;}Normalize(){const d=b2_two_pi*Math.floor(this.a0/b2_two_pi);this.a0-=d;this.a-=d;}}class b2Color{constructor(...args){if(args[0]instanceof Float32Array){if(args[0].length!==4){throw new Error();}this.data=args[0];}else {const rr=typeof args[0]==="number"?args[0]:0.5;const gg=typeof args[1]==="number"?args[1]:0.5;const bb=typeof args[2]==="number"?args[2]:0.5;const aa=typeof args[3]==="number"?args[3]:1.0;this.data=new Float32Array([rr,gg,bb,aa]);}}get r(){return this.data[0];}set r(value){this.data[0]=value;}get g(){return this.data[1];}set g(value){this.data[1]=value;}get b(){return this.data[2];}set b(value){this.data[2]=value;}get a(){return this.data[3];}set a(value){this.data[3]=value;}Clone(){return new b2Color().Copy(this);}Copy(other){this.r=other.r;this.g=other.g;this.b=other.b;this.a=other.a;return this;}IsEqual(color){return this.r===color.r&&this.g===color.g&&this.b===color.b&&this.a===color.a;}IsZero(){return this.r===0&&this.g===0&&this.b===0&&this.a===0;}Set(r,g,b,a=this.a){this.SetRGBA(r,g,b,a);}SetByteRGB(r,g,b){this.r=r/0xff;this.g=g/0xff;this.b=b/0xff;return this;}SetByteRGBA(r,g,b,a){this.r=r/0xff;this.g=g/0xff;this.b=b/0xff;this.a=a/0xff;return this;}SetRGB(rr,gg,bb){this.r=rr;this.g=gg;this.b=bb;return this;}SetRGBA(rr,gg,bb,aa){this.r=rr;this.g=gg;this.b=bb;this.a=aa;return this;}SelfAdd(color){this.r+=color.r;this.g+=color.g;this.b+=color.b;this.a+=color.a;return this;}Add(color,out){out.r=this.r+color.r;out.g=this.g+color.g;out.b=this.b+color.b;out.a=this.a+color.a;return out;}SelfSub(color){this.r-=color.r;this.g-=color.g;this.b-=color.b;this.a-=color.a;return this;}Sub(color,out){out.r=this.r-color.r;out.g=this.g-color.g;out.b=this.b-color.b;out.a=this.a-color.a;return out;}SelfMul(s){this.r*=s;this.g*=s;this.b*=s;this.a*=s;return this;}Mul(s,out){out.r=this.r*s;out.g=this.g*s;out.b=this.b*s;out.a=this.a*s;return out;}Mix(mixColor,strength){b2Color.MixColors(this,mixColor,strength);}static MixColors(colorA,colorB,strength){const dr=strength*(colorB.r-colorA.r);const dg=strength*(colorB.g-colorA.g);const db=strength*(colorB.b-colorA.b);const da=strength*(colorB.a-colorA.a);colorA.r+=dr;colorA.g+=dg;colorA.b+=db;colorA.a+=da;colorB.r-=dr;colorB.g-=dg;colorB.b-=db;colorB.a-=da;}MakeStyleString(alpha=this.a){return b2Color.MakeStyleString(this.r,this.g,this.b,alpha);}static MakeStyleString(r,g,b,a=1.0){r*=255;g*=255;b*=255;if(a<1){return `rgba(${r},${g},${b},${a})`;}else {return `rgb(${r},${g},${b})`;}}}b2Color.ZERO=new b2Color(0,0,0,0);b2Color.RED=new b2Color(1,0,0);b2Color.GREEN=new b2Color(0,1,0);b2Color.BLUE=new b2Color(0,0,1);(function(b2DrawFlags){b2DrawFlags[b2DrawFlags["e_none"]=0]="e_none";b2DrawFlags[b2DrawFlags["e_shapeBit"]=1]="e_shapeBit";b2DrawFlags[b2DrawFlags["e_jointBit"]=2]="e_jointBit";b2DrawFlags[b2DrawFlags["e_aabbBit"]=4]="e_aabbBit";b2DrawFlags[b2DrawFlags["e_pairBit"]=8]="e_pairBit";b2DrawFlags[b2DrawFlags["e_centerOfMassBit"]=16]="e_centerOfMassBit";b2DrawFlags[b2DrawFlags["e_particleBit"]=32]="e_particleBit";b2DrawFlags[b2DrawFlags["e_controllerBit"]=64]="e_controllerBit";b2DrawFlags[b2DrawFlags["e_all"]=63]="e_all";})(exports.b2DrawFlags||(exports.b2DrawFlags={}));class b2Draw{constructor(){this.m_drawFlags=0;}SetFlags(flags){this.m_drawFlags=flags;}GetFlags(){return this.m_drawFlags;}AppendFlags(flags){this.m_drawFlags|=flags;}ClearFlags(flags){this.m_drawFlags&=~flags;}}class b2Timer{constructor(){this.m_start=Date.now();}Reset(){this.m_start=Date.now();return this;}GetMilliseconds(){return Date.now()-this.m_start;}}class b2Counter{constructor(){this.m_count=0;this.m_min_count=0;this.m_max_count=0;}GetCount(){return this.m_count;}GetMinCount(){return this.m_min_count;}GetMaxCount(){return this.m_max_count;}ResetCount(){const count=this.m_count;this.m_count=0;return count;}ResetMinCount(){this.m_min_count=0;}ResetMaxCount(){this.m_max_count=0;}Increment(){this.m_count++;if(this.m_max_count<this.m_count){this.m_max_count=this.m_count;}}Decrement(){this.m_count--;if(this.m_min_count>this.m_count){this.m_min_count=this.m_count;}}}class b2GrowableStack{constructor(N){this.m_stack=[];this.m_count=0;this.m_stack=b2MakeArray(N,index=>null);this.m_count=0;}Reset(){this.m_count=0;return this;}Push(element){this.m_stack[this.m_count]=element;this.m_count++;}Pop(){this.m_count--;const element=this.m_stack[this.m_count];this.m_stack[this.m_count]=null;if(element===null){throw new Error();}return element;}GetCount(){return this.m_count;}}class b2BlockAllocator{}class b2StackAllocator{}class b2DistanceProxy{constructor(){this.m_buffer=b2Vec2.MakeArray(2);this.m_vertices=this.m_buffer;this.m_count=0;this.m_radius=0;}Copy(other){if(other.m_vertices===other.m_buffer){this.m_vertices=this.m_buffer;this.m_buffer[0].Copy(other.m_buffer[0]);this.m_buffer[1].Copy(other.m_buffer[1]);}else {this.m_vertices=other.m_vertices;}this.m_count=other.m_count;this.m_radius=other.m_radius;return this;}Reset(){this.m_vertices=this.m_buffer;this.m_count=0;this.m_radius=0;return this;}SetShape(shape,index){shape.SetupDistanceProxy(this,index);}SetVerticesRadius(vertices,count,radius){this.m_vertices=vertices;this.m_count=count;this.m_radius=radius;}GetSupport(d){let bestIndex=0;let bestValue=b2Vec2.DotVV(this.m_vertices[0],d);for(let i=1;i<this.m_count;++i){const value=b2Vec2.DotVV(this.m_vertices[i],d);if(value>bestValue){bestIndex=i;bestValue=value;}}return bestIndex;}GetSupportVertex(d){let bestIndex=0;let bestValue=b2Vec2.DotVV(this.m_vertices[0],d);for(let i=1;i<this.m_count;++i){const value=b2Vec2.DotVV(this.m_vertices[i],d);if(value>bestValue){bestIndex=i;bestValue=value;}}return this.m_vertices[bestIndex];}GetVertexCount(){return this.m_count;}GetVertex(index){return this.m_vertices[index];}}class b2SimplexCache{constructor(){this.metric=0;this.count=0;this.indexA=[0,0,0];this.indexB=[0,0,0];}Reset(){this.metric=0;this.count=0;return this;}}class b2DistanceInput{constructor(){this.proxyA=new b2DistanceProxy();this.proxyB=new b2DistanceProxy();this.transformA=new b2Transform();this.transformB=new b2Transform();this.useRadii=false;}Reset(){this.proxyA.Reset();this.proxyB.Reset();this.transformA.SetIdentity();this.transformB.SetIdentity();this.useRadii=false;return this;}}class b2DistanceOutput{constructor(){this.pointA=new b2Vec2();this.pointB=new b2Vec2();this.distance=0;this.iterations=0;}Reset(){this.pointA.SetZero();this.pointB.SetZero();this.distance=0;this.iterations=0;return this;}}class b2ShapeCastInput{constructor(){this.proxyA=new b2DistanceProxy();this.proxyB=new b2DistanceProxy();this.transformA=new b2Transform();this.transformB=new b2Transform();this.translationB=new b2Vec2();}}class b2ShapeCastOutput{constructor(){this.point=new b2Vec2();this.normal=new b2Vec2();this.lambda=0.0;this.iterations=0;}}exports.b2_gjkCalls=0;exports.b2_gjkIters=0;exports.b2_gjkMaxIters=0;function b2_gjk_reset(){exports.b2_gjkCalls=0;exports.b2_gjkIters=0;exports.b2_gjkMaxIters=0;}class b2SimplexVertex{constructor(){this.wA=new b2Vec2();this.wB=new b2Vec2();this.w=new b2Vec2();this.a=0;this.indexA=0;this.indexB=0;}Copy(other){this.wA.Copy(other.wA);this.wB.Copy(other.wB);this.w.Copy(other.w);this.a=other.a;this.indexA=other.indexA;this.indexB=other.indexB;return this;}}class b2Simplex{constructor(){this.m_v1=new b2SimplexVertex();this.m_v2=new b2SimplexVertex();this.m_v3=new b2SimplexVertex();this.m_vertices=[];this.m_count=0;this.m_vertices[0]=this.m_v1;this.m_vertices[1]=this.m_v2;this.m_vertices[2]=this.m_v3;}ReadCache(cache,proxyA,transformA,proxyB,transformB){this.m_count=cache.count;const vertices=this.m_vertices;for(let i=0;i<this.m_count;++i){const v=vertices[i];v.indexA=cache.indexA[i];v.indexB=cache.indexB[i];const wALocal=proxyA.GetVertex(v.indexA);const wBLocal=proxyB.GetVertex(v.indexB);b2Transform.MulXV(transformA,wALocal,v.wA);b2Transform.MulXV(transformB,wBLocal,v.wB);b2Vec2.SubVV(v.wB,v.wA,v.w);v.a=0;}if(this.m_count>1){const metric1=cache.metric;const metric2=this.GetMetric();if(metric2<0.5*metric1||2*metric1<metric2||metric2<b2_epsilon){this.m_count=0;}}if(this.m_count===0){const v=vertices[0];v.indexA=0;v.indexB=0;const wALocal=proxyA.GetVertex(0);const wBLocal=proxyB.GetVertex(0);b2Transform.MulXV(transformA,wALocal,v.wA);b2Transform.MulXV(transformB,wBLocal,v.wB);b2Vec2.SubVV(v.wB,v.wA,v.w);v.a=1;this.m_count=1;}}WriteCache(cache){cache.metric=this.GetMetric();cache.count=this.m_count;const vertices=this.m_vertices;for(let i=0;i<this.m_count;++i){cache.indexA[i]=vertices[i].indexA;cache.indexB[i]=vertices[i].indexB;}}GetSearchDirection(out){switch(this.m_count){case 1:return b2Vec2.NegV(this.m_v1.w,out);case 2:{const e12=b2Vec2.SubVV(this.m_v2.w,this.m_v1.w,out);const sgn=b2Vec2.CrossVV(e12,b2Vec2.NegV(this.m_v1.w,b2Vec2.s_t0));if(sgn>0){return b2Vec2.CrossOneV(e12,out);}else {return b2Vec2.CrossVOne(e12,out);}}default:return out.SetZero();}}GetClosestPoint(out){switch(this.m_count){case 0:return out.SetZero();case 1:return out.Copy(this.m_v1.w);case 2:return out.Set(this.m_v1.a*this.m_v1.w.x+this.m_v2.a*this.m_v2.w.x,this.m_v1.a*this.m_v1.w.y+this.m_v2.a*this.m_v2.w.y);case 3:return out.SetZero();default:return out.SetZero();}}GetWitnessPoints(pA,pB){switch(this.m_count){case 0:break;case 1:pA.Copy(this.m_v1.wA);pB.Copy(this.m_v1.wB);break;case 2:pA.x=this.m_v1.a*this.m_v1.wA.x+this.m_v2.a*this.m_v2.wA.x;pA.y=this.m_v1.a*this.m_v1.wA.y+this.m_v2.a*this.m_v2.wA.y;pB.x=this.m_v1.a*this.m_v1.wB.x+this.m_v2.a*this.m_v2.wB.x;pB.y=this.m_v1.a*this.m_v1.wB.y+this.m_v2.a*this.m_v2.wB.y;break;case 3:pB.x=pA.x=this.m_v1.a*this.m_v1.wA.x+this.m_v2.a*this.m_v2.wA.x+this.m_v3.a*this.m_v3.wA.x;pB.y=pA.y=this.m_v1.a*this.m_v1.wA.y+this.m_v2.a*this.m_v2.wA.y+this.m_v3.a*this.m_v3.wA.y;break;}}GetMetric(){switch(this.m_count){case 0:return 0;case 1:return 0;case 2:return b2Vec2.DistanceVV(this.m_v1.w,this.m_v2.w);case 3:return b2Vec2.CrossVV(b2Vec2.SubVV(this.m_v2.w,this.m_v1.w,b2Vec2.s_t0),b2Vec2.SubVV(this.m_v3.w,this.m_v1.w,b2Vec2.s_t1));default:return 0;}}Solve2(){const w1=this.m_v1.w;const w2=this.m_v2.w;const e12=b2Vec2.SubVV(w2,w1,b2Simplex.s_e12);const d12_2=-b2Vec2.DotVV(w1,e12);if(d12_2<=0){this.m_v1.a=1;this.m_count=1;return;}const d12_1=b2Vec2.DotVV(w2,e12);if(d12_1<=0){this.m_v2.a=1;this.m_count=1;this.m_v1.Copy(this.m_v2);return;}const inv_d12=1/(d12_1+d12_2);this.m_v1.a=d12_1*inv_d12;this.m_v2.a=d12_2*inv_d12;this.m_count=2;}Solve3(){const w1=this.m_v1.w;const w2=this.m_v2.w;const w3=this.m_v3.w;const e12=b2Vec2.SubVV(w2,w1,b2Simplex.s_e12);const w1e12=b2Vec2.DotVV(w1,e12);const w2e12=b2Vec2.DotVV(w2,e12);const d12_1=w2e12;const d12_2=-w1e12;const e13=b2Vec2.SubVV(w3,w1,b2Simplex.s_e13);const w1e13=b2Vec2.DotVV(w1,e13);const w3e13=b2Vec2.DotVV(w3,e13);const d13_1=w3e13;const d13_2=-w1e13;const e23=b2Vec2.SubVV(w3,w2,b2Simplex.s_e23);const w2e23=b2Vec2.DotVV(w2,e23);const w3e23=b2Vec2.DotVV(w3,e23);const d23_1=w3e23;const d23_2=-w2e23;const n123=b2Vec2.CrossVV(e12,e13);const d123_1=n123*b2Vec2.CrossVV(w2,w3);const d123_2=n123*b2Vec2.CrossVV(w3,w1);const d123_3=n123*b2Vec2.CrossVV(w1,w2);if(d12_2<=0&&d13_2<=0){this.m_v1.a=1;this.m_count=1;return;}if(d12_1>0&&d12_2>0&&d123_3<=0){const inv_d12=1/(d12_1+d12_2);this.m_v1.a=d12_1*inv_d12;this.m_v2.a=d12_2*inv_d12;this.m_count=2;return;}if(d13_1>0&&d13_2>0&&d123_2<=0){const inv_d13=1/(d13_1+d13_2);this.m_v1.a=d13_1*inv_d13;this.m_v3.a=d13_2*inv_d13;this.m_count=2;this.m_v2.Copy(this.m_v3);return;}if(d12_1<=0&&d23_2<=0){this.m_v2.a=1;this.m_count=1;this.m_v1.Copy(this.m_v2);return;}if(d13_1<=0&&d23_1<=0){this.m_v3.a=1;this.m_count=1;this.m_v1.Copy(this.m_v3);return;}if(d23_1>0&&d23_2>0&&d123_1<=0){const inv_d23=1/(d23_1+d23_2);this.m_v2.a=d23_1*inv_d23;this.m_v3.a=d23_2*inv_d23;this.m_count=2;this.m_v1.Copy(this.m_v3);return;}const inv_d123=1/(d123_1+d123_2+d123_3);this.m_v1.a=d123_1*inv_d123;this.m_v2.a=d123_2*inv_d123;this.m_v3.a=d123_3*inv_d123;this.m_count=3;}}b2Simplex.s_e12=new b2Vec2();b2Simplex.s_e13=new b2Vec2();b2Simplex.s_e23=new b2Vec2();const b2Distance_s_simplex=new b2Simplex();const b2Distance_s_saveA=[0,0,0];const b2Distance_s_saveB=[0,0,0];const b2Distance_s_p=new b2Vec2();const b2Distance_s_d=new b2Vec2();const b2Distance_s_normal=new b2Vec2();const b2Distance_s_supportA=new b2Vec2();const b2Distance_s_supportB=new b2Vec2();function b2Distance(output,cache,input){++exports.b2_gjkCalls;const proxyA=input.proxyA;const proxyB=input.proxyB;const transformA=input.transformA;const transformB=input.transformB;const simplex=b2Distance_s_simplex;simplex.ReadCache(cache,proxyA,transformA,proxyB,transformB);const vertices=simplex.m_vertices;const k_maxIters=20;const saveA=b2Distance_s_saveA;const saveB=b2Distance_s_saveB;let saveCount=0;let iter=0;while(iter<k_maxIters){saveCount=simplex.m_count;for(let i=0;i<saveCount;++i){saveA[i]=vertices[i].indexA;saveB[i]=vertices[i].indexB;}switch(simplex.m_count){case 1:break;case 2:simplex.Solve2();break;case 3:simplex.Solve3();break;}if(simplex.m_count===3){break;}const d=simplex.GetSearchDirection(b2Distance_s_d);if(d.LengthSquared()<b2_epsilon_sq){break;}const vertex=vertices[simplex.m_count];vertex.indexA=proxyA.GetSupport(b2Rot.MulTRV(transformA.q,b2Vec2.NegV(d,b2Vec2.s_t0),b2Distance_s_supportA));b2Transform.MulXV(transformA,proxyA.GetVertex(vertex.indexA),vertex.wA);vertex.indexB=proxyB.GetSupport(b2Rot.MulTRV(transformB.q,d,b2Distance_s_supportB));b2Transform.MulXV(transformB,proxyB.GetVertex(vertex.indexB),vertex.wB);b2Vec2.SubVV(vertex.wB,vertex.wA,vertex.w);++iter;++exports.b2_gjkIters;let duplicate=false;for(let i=0;i<saveCount;++i){if(vertex.indexA===saveA[i]&&vertex.indexB===saveB[i]){duplicate=true;break;}}if(duplicate){break;}++simplex.m_count;}exports.b2_gjkMaxIters=b2Max(exports.b2_gjkMaxIters,iter);simplex.GetWitnessPoints(output.pointA,output.pointB);output.distance=b2Vec2.DistanceVV(output.pointA,output.pointB);output.iterations=iter;simplex.WriteCache(cache);if(input.useRadii){const rA=proxyA.m_radius;const rB=proxyB.m_radius;if(output.distance>rA+rB&&output.distance>b2_epsilon){output.distance-=rA+rB;const normal=b2Vec2.SubVV(output.pointB,output.pointA,b2Distance_s_normal);normal.Normalize();output.pointA.SelfMulAdd(rA,normal);output.pointB.SelfMulSub(rB,normal);}else {const p=b2Vec2.MidVV(output.pointA,output.pointB,b2Distance_s_p);output.pointA.Copy(p);output.pointB.Copy(p);output.distance=0;}}}const b2ShapeCast_s_n=new b2Vec2();const b2ShapeCast_s_simplex=new b2Simplex();const b2ShapeCast_s_wA=new b2Vec2();const b2ShapeCast_s_wB=new b2Vec2();const b2ShapeCast_s_v=new b2Vec2();const b2ShapeCast_s_p=new b2Vec2();const b2ShapeCast_s_pointA=new b2Vec2();const b2ShapeCast_s_pointB=new b2Vec2();function b2ShapeCast(output,input){output.iterations=0;output.lambda=1.0;output.normal.SetZero();output.point.SetZero();const proxyA=input.proxyA;const proxyB=input.proxyB;const radiusA=b2Max(proxyA.m_radius,b2_polygonRadius);const radiusB=b2Max(proxyB.m_radius,b2_polygonRadius);const radius=radiusA+radiusB;const xfA=input.transformA;const xfB=input.transformB;const r=input.translationB;const n=b2ShapeCast_s_n.Set(0.0,0.0);let lambda=0.0;const simplex=b2ShapeCast_s_simplex;simplex.m_count=0;const vertices=simplex.m_vertices;let indexA=proxyA.GetSupport(b2Rot.MulTRV(xfA.q,b2Vec2.NegV(r,b2Vec2.s_t1),b2Vec2.s_t0));let wA=b2Transform.MulXV(xfA,proxyA.GetVertex(indexA),b2ShapeCast_s_wA);let indexB=proxyB.GetSupport(b2Rot.MulTRV(xfB.q,r,b2Vec2.s_t0));let wB=b2Transform.MulXV(xfB,proxyB.GetVertex(indexB),b2ShapeCast_s_wB);const v=b2Vec2.SubVV(wA,wB,b2ShapeCast_s_v);const sigma=b2Max(b2_polygonRadius,radius-b2_polygonRadius);const tolerance=0.5*b2_linearSlop;const k_maxIters=20;let iter=0;while(iter<k_maxIters&&b2Abs(v.Length()-sigma)>tolerance){output.iterations+=1;indexA=proxyA.GetSupport(b2Rot.MulTRV(xfA.q,b2Vec2.NegV(v,b2Vec2.s_t1),b2Vec2.s_t0));wA=b2Transform.MulXV(xfA,proxyA.GetVertex(indexA),b2ShapeCast_s_wA);indexB=proxyB.GetSupport(b2Rot.MulTRV(xfB.q,v,b2Vec2.s_t0));wB=b2Transform.MulXV(xfB,proxyB.GetVertex(indexB),b2ShapeCast_s_wB);const p=b2Vec2.SubVV(wA,wB,b2ShapeCast_s_p);v.Normalize();const vp=b2Vec2.DotVV(v,p);const vr=b2Vec2.DotVV(v,r);if(vp-sigma>lambda*vr){if(vr<=0.0){return false;}lambda=(vp-sigma)/vr;if(lambda>1.0){return false;}n.Copy(v).SelfNeg();simplex.m_count=0;}const vertex=vertices[simplex.m_count];vertex.indexA=indexB;vertex.wA.Copy(wB).SelfMulAdd(lambda,r);vertex.indexB=indexA;vertex.wB.Copy(wA);vertex.w.Copy(vertex.wB).SelfSub(vertex.wA);vertex.a=1.0;simplex.m_count+=1;switch(simplex.m_count){case 1:break;case 2:simplex.Solve2();break;case 3:simplex.Solve3();break;}if(simplex.m_count===3){return false;}simplex.GetClosestPoint(v);++iter;}const pointA=b2ShapeCast_s_pointA;const pointB=b2ShapeCast_s_pointB;simplex.GetWitnessPoints(pointA,pointB);if(v.LengthSquared()>0.0){n.Copy(v).SelfNeg();n.Normalize();}output.normal.Copy(n);output.lambda=lambda;output.iterations=iter;return true;}(function(b2ContactFeatureType){b2ContactFeatureType[b2ContactFeatureType["e_vertex"]=0]="e_vertex";b2ContactFeatureType[b2ContactFeatureType["e_face"]=1]="e_face";})(exports.b2ContactFeatureType||(exports.b2ContactFeatureType={}));class b2ContactFeature{constructor(){this._key=0;this._key_invalid=false;this._indexA=0;this._indexB=0;this._typeA=0;this._typeB=0;}get key(){if(this._key_invalid){this._key_invalid=false;this._key=this._indexA|this._indexB<<8|this._typeA<<16|this._typeB<<24;}return this._key;}set key(value){this._key=value;this._key_invalid=false;this._indexA=this._key&0xff;this._indexB=this._key>>8&0xff;this._typeA=this._key>>16&0xff;this._typeB=this._key>>24&0xff;}get indexA(){return this._indexA;}set indexA(value){this._indexA=value;this._key_invalid=true;}get indexB(){return this._indexB;}set indexB(value){this._indexB=value;this._key_invalid=true;}get typeA(){return this._typeA;}set typeA(value){this._typeA=value;this._key_invalid=true;}get typeB(){return this._typeB;}set typeB(value){this._typeB=value;this._key_invalid=true;}}class b2ContactID{constructor(){this.cf=new b2ContactFeature();}Copy(o){this.key=o.key;return this;}Clone(){return new b2ContactID().Copy(this);}get key(){return this.cf.key;}set key(value){this.cf.key=value;}}class b2ManifoldPoint{constructor(){this.localPoint=new b2Vec2();this.normalImpulse=0;this.tangentImpulse=0;this.id=new b2ContactID();}static MakeArray(length){return b2MakeArray(length,i=>new b2ManifoldPoint());}Reset(){this.localPoint.SetZero();this.normalImpulse=0;this.tangentImpulse=0;this.id.key=0;}Copy(o){this.localPoint.Copy(o.localPoint);this.normalImpulse=o.normalImpulse;this.tangentImpulse=o.tangentImpulse;this.id.Copy(o.id);return this;}}(function(b2ManifoldType){b2ManifoldType[b2ManifoldType["e_unknown"]=-1]="e_unknown";b2ManifoldType[b2ManifoldType["e_circles"]=0]="e_circles";b2ManifoldType[b2ManifoldType["e_faceA"]=1]="e_faceA";b2ManifoldType[b2ManifoldType["e_faceB"]=2]="e_faceB";})(exports.b2ManifoldType||(exports.b2ManifoldType={}));class b2Manifold{constructor(){this.points=b2ManifoldPoint.MakeArray(b2_maxManifoldPoints);this.localNormal=new b2Vec2();this.localPoint=new b2Vec2();this.type=exports.b2ManifoldType.e_unknown;this.pointCount=0;}Reset(){for(let i=0;i<b2_maxManifoldPoints;++i){this.points[i].Reset();}this.localNormal.SetZero();this.localPoint.SetZero();this.type=exports.b2ManifoldType.e_unknown;this.pointCount=0;}Copy(o){this.pointCount=o.pointCount;for(let i=0;i<b2_maxManifoldPoints;++i){this.points[i].Copy(o.points[i]);}this.localNormal.Copy(o.localNormal);this.localPoint.Copy(o.localPoint);this.type=o.type;return this;}Clone(){return new b2Manifold().Copy(this);}}class b2WorldManifold{constructor(){this.normal=new b2Vec2();this.points=b2Vec2.MakeArray(b2_maxManifoldPoints);this.separations=b2MakeNumberArray(b2_maxManifoldPoints);}Initialize(manifold,xfA,radiusA,xfB,radiusB){if(manifold.pointCount===0){return;}switch(manifold.type){case exports.b2ManifoldType.e_circles:{this.normal.Set(1,0);const pointA=b2Transform.MulXV(xfA,manifold.localPoint,b2WorldManifold.Initialize_s_pointA);const pointB=b2Transform.MulXV(xfB,manifold.points[0].localPoint,b2WorldManifold.Initialize_s_pointB);if(b2Vec2.DistanceSquaredVV(pointA,pointB)>b2_epsilon_sq){b2Vec2.SubVV(pointB,pointA,this.normal).SelfNormalize();}const cA=b2Vec2.AddVMulSV(pointA,radiusA,this.normal,b2WorldManifold.Initialize_s_cA);const cB=b2Vec2.SubVMulSV(pointB,radiusB,this.normal,b2WorldManifold.Initialize_s_cB);b2Vec2.MidVV(cA,cB,this.points[0]);this.separations[0]=b2Vec2.DotVV(b2Vec2.SubVV(cB,cA,b2Vec2.s_t0),this.normal);break;}case exports.b2ManifoldType.e_faceA:{b2Rot.MulRV(xfA.q,manifold.localNormal,this.normal);const planePoint=b2Transform.MulXV(xfA,manifold.localPoint,b2WorldManifold.Initialize_s_planePoint);for(let i=0;i<manifold.pointCount;++i){const clipPoint=b2Transform.MulXV(xfB,manifold.points[i].localPoint,b2WorldManifold.Initialize_s_clipPoint);const s=radiusA-b2Vec2.DotVV(b2Vec2.SubVV(clipPoint,planePoint,b2Vec2.s_t0),this.normal);const cA=b2Vec2.AddVMulSV(clipPoint,s,this.normal,b2WorldManifold.Initialize_s_cA);const cB=b2Vec2.SubVMulSV(clipPoint,radiusB,this.normal,b2WorldManifold.Initialize_s_cB);b2Vec2.MidVV(cA,cB,this.points[i]);this.separations[i]=b2Vec2.DotVV(b2Vec2.SubVV(cB,cA,b2Vec2.s_t0),this.normal);}break;}case exports.b2ManifoldType.e_faceB:{b2Rot.MulRV(xfB.q,manifold.localNormal,this.normal);const planePoint=b2Transform.MulXV(xfB,manifold.localPoint,b2WorldManifold.Initialize_s_planePoint);for(let i=0;i<manifold.pointCount;++i){const clipPoint=b2Transform.MulXV(xfA,manifold.points[i].localPoint,b2WorldManifold.Initialize_s_clipPoint);const s=radiusB-b2Vec2.DotVV(b2Vec2.SubVV(clipPoint,planePoint,b2Vec2.s_t0),this.normal);const cB=b2Vec2.AddVMulSV(clipPoint,s,this.normal,b2WorldManifold.Initialize_s_cB);const cA=b2Vec2.SubVMulSV(clipPoint,radiusA,this.normal,b2WorldManifold.Initialize_s_cA);b2Vec2.MidVV(cA,cB,this.points[i]);this.separations[i]=b2Vec2.DotVV(b2Vec2.SubVV(cA,cB,b2Vec2.s_t0),this.normal);}this.normal.SelfNeg();break;}}}}b2WorldManifold.Initialize_s_pointA=new b2Vec2();b2WorldManifold.Initialize_s_pointB=new b2Vec2();b2WorldManifold.Initialize_s_cA=new b2Vec2();b2WorldManifold.Initialize_s_cB=new b2Vec2();b2WorldManifold.Initialize_s_planePoint=new b2Vec2();b2WorldManifold.Initialize_s_clipPoint=new b2Vec2();(function(b2PointState){b2PointState[b2PointState["b2_nullState"]=0]="b2_nullState";b2PointState[b2PointState["b2_addState"]=1]="b2_addState";b2PointState[b2PointState["b2_persistState"]=2]="b2_persistState";b2PointState[b2PointState["b2_removeState"]=3]="b2_removeState";})(exports.b2PointState||(exports.b2PointState={}));function b2GetPointStates(state1,state2,manifold1,manifold2){let i;for(i=0;i<manifold1.pointCount;++i){const id=manifold1.points[i].id;const key=id.key;state1[i]=exports.b2PointState.b2_removeState;for(let j=0,jct=manifold2.pointCount;j<jct;++j){if(manifold2.points[j].id.key===key){state1[i]=exports.b2PointState.b2_persistState;break;}}}for(;i<b2_maxManifoldPoints;++i){state1[i]=exports.b2PointState.b2_nullState;}for(i=0;i<manifold2.pointCount;++i){const id=manifold2.points[i].id;const key=id.key;state2[i]=exports.b2PointState.b2_addState;for(let j=0,jct=manifold1.pointCount;j<jct;++j){if(manifold1.points[j].id.key===key){state2[i]=exports.b2PointState.b2_persistState;break;}}}for(;i<b2_maxManifoldPoints;++i){state2[i]=exports.b2PointState.b2_nullState;}}class b2ClipVertex{constructor(){this.v=new b2Vec2();this.id=new b2ContactID();}static MakeArray(length){return b2MakeArray(length,i=>new b2ClipVertex());}Copy(other){this.v.Copy(other.v);this.id.Copy(other.id);return this;}}class b2RayCastInput{constructor(){this.p1=new b2Vec2();this.p2=new b2Vec2();this.maxFraction=1;}Copy(o){this.p1.Copy(o.p1);this.p2.Copy(o.p2);this.maxFraction=o.maxFraction;return this;}}class b2RayCastOutput{constructor(){this.normal=new b2Vec2();this.fraction=0;}Copy(o){this.normal.Copy(o.normal);this.fraction=o.fraction;return this;}}class b2AABB{constructor(){this.lowerBound=new b2Vec2();this.upperBound=new b2Vec2();this.m_cache_center=new b2Vec2();this.m_cache_extent=new b2Vec2();}Copy(o){this.lowerBound.Copy(o.lowerBound);this.upperBound.Copy(o.upperBound);return this;}IsValid(){if(!this.lowerBound.IsValid()){return false;}if(!this.upperBound.IsValid()){return false;}if(this.upperBound.x<this.lowerBound.x){return false;}if(this.upperBound.y<this.lowerBound.y){return false;}return true;}GetCenter(){return b2Vec2.MidVV(this.lowerBound,this.upperBound,this.m_cache_center);}GetExtents(){return b2Vec2.ExtVV(this.lowerBound,this.upperBound,this.m_cache_extent);}GetPerimeter(){const wx=this.upperBound.x-this.lowerBound.x;const wy=this.upperBound.y-this.lowerBound.y;return 2*(wx+wy);}Combine1(aabb){this.lowerBound.x=b2Min(this.lowerBound.x,aabb.lowerBound.x);this.lowerBound.y=b2Min(this.lowerBound.y,aabb.lowerBound.y);this.upperBound.x=b2Max(this.upperBound.x,aabb.upperBound.x);this.upperBound.y=b2Max(this.upperBound.y,aabb.upperBound.y);return this;}Combine2(aabb1,aabb2){this.lowerBound.x=b2Min(aabb1.lowerBound.x,aabb2.lowerBound.x);this.lowerBound.y=b2Min(aabb1.lowerBound.y,aabb2.lowerBound.y);this.upperBound.x=b2Max(aabb1.upperBound.x,aabb2.upperBound.x);this.upperBound.y=b2Max(aabb1.upperBound.y,aabb2.upperBound.y);return this;}static Combine(aabb1,aabb2,out){out.Combine2(aabb1,aabb2);return out;}Contains(aabb){if(this.lowerBound.x<=aabb.lowerBound.x){return false;}if(this.lowerBound.y<=aabb.lowerBound.y){return false;}if(aabb.upperBound.x<=this.upperBound.x){return false;}if(aabb.upperBound.y<=this.upperBound.y){return false;}return true;}RayCast(output,input){let tmin=-b2_maxFloat;let tmax=b2_maxFloat;const p_x=input.p1.x;const p_y=input.p1.y;const d_x=input.p2.x-input.p1.x;const d_y=input.p2.y-input.p1.y;const absD_x=b2Abs(d_x);const absD_y=b2Abs(d_y);const normal=output.normal;if(absD_x<b2_epsilon){if(p_x<this.lowerBound.x||this.upperBound.x<p_x){return false;}}else {const inv_d=1/d_x;let t1=(this.lowerBound.x-p_x)*inv_d;let t2=(this.upperBound.x-p_x)*inv_d;let s=-1;if(t1>t2){const t3=t1;t1=t2;t2=t3;s=1;}if(t1>tmin){normal.x=s;normal.y=0;tmin=t1;}tmax=b2Min(tmax,t2);if(tmin>tmax){return false;}}if(absD_y<b2_epsilon){if(p_y<this.lowerBound.y||this.upperBound.y<p_y){return false;}}else {const inv_d=1/d_y;let t1=(this.lowerBound.y-p_y)*inv_d;let t2=(this.upperBound.y-p_y)*inv_d;let s=-1;if(t1>t2){const t3=t1;t1=t2;t2=t3;s=1;}if(t1>tmin){normal.x=0;normal.y=s;tmin=t1;}tmax=b2Min(tmax,t2);if(tmin>tmax){return false;}}if(tmin<0||input.maxFraction<tmin){return false;}output.fraction=tmin;return true;}TestContain(point){if(point.x<this.lowerBound.x||this.upperBound.x<point.x){return false;}if(point.y<this.lowerBound.y||this.upperBound.y<point.y){return false;}return true;}TestOverlap(other){if(this.upperBound.x<other.lowerBound.x){return false;}if(this.upperBound.y<other.lowerBound.y){return false;}if(other.upperBound.x<this.lowerBound.x){return false;}if(other.upperBound.y<this.lowerBound.y){return false;}return true;}}function b2TestOverlapAABB(a,b){if(a.upperBound.x<b.lowerBound.x){return false;}if(a.upperBound.y<b.lowerBound.y){return false;}if(b.upperBound.x<a.lowerBound.x){return false;}if(b.upperBound.y<a.lowerBound.y){return false;}return true;}function b2ClipSegmentToLine(vOut,vIn,normal,offset,vertexIndexA){let numOut=0;const vIn0=vIn[0];const vIn1=vIn[1];const distance0=b2Vec2.DotVV(normal,vIn0.v)-offset;const distance1=b2Vec2.DotVV(normal,vIn1.v)-offset;if(distance0<=0){vOut[numOut++].Copy(vIn0);}if(distance1<=0){vOut[numOut++].Copy(vIn1);}if(distance0*distance1<0){const interp=distance0/(distance0-distance1);const v=vOut[numOut].v;v.x=vIn0.v.x+interp*(vIn1.v.x-vIn0.v.x);v.y=vIn0.v.y+interp*(vIn1.v.y-vIn0.v.y);const id=vOut[numOut].id;id.cf.indexA=vertexIndexA;id.cf.indexB=vIn0.id.cf.indexB;id.cf.typeA=exports.b2ContactFeatureType.e_vertex;id.cf.typeB=exports.b2ContactFeatureType.e_face;++numOut;}return numOut;}const b2TestOverlapShape_s_input=new b2DistanceInput();const b2TestOverlapShape_s_simplexCache=new b2SimplexCache();const b2TestOverlapShape_s_output=new b2DistanceOutput();function b2TestOverlapShape(shapeA,indexA,shapeB,indexB,xfA,xfB){const input=b2TestOverlapShape_s_input.Reset();input.proxyA.SetShape(shapeA,indexA);input.proxyB.SetShape(shapeB,indexB);input.transformA.Copy(xfA);input.transformB.Copy(xfB);input.useRadii=true;const simplexCache=b2TestOverlapShape_s_simplexCache.Reset();simplexCache.count=0;const output=b2TestOverlapShape_s_output.Reset();b2Distance(output,simplexCache,input);return output.distance<10*b2_epsilon;}function verify(value){if(value===null){throw new Error();}return value;}class b2TreeNode{constructor(id=0){this.m_id=0;this.aabb=new b2AABB();this._userData=null;this.parent=null;this.child1=null;this.child2=null;this.height=0;this.m_id=id;}get userData(){if(this._userData===null){throw new Error();}return this._userData;}set userData(value){if(this._userData!==null){throw new Error();}this._userData=value;}Reset(){this._userData=null;}IsLeaf(){return this.child1===null;}}class b2DynamicTree{constructor(){this.m_root=null;this.m_freeList=null;this.m_path=0;this.m_insertionCount=0;this.m_stack=new b2GrowableStack(256);}Query(aabb,callback){const stack=this.m_stack.Reset();stack.Push(this.m_root);while(stack.GetCount()>0){const node=stack.Pop();if(node===null){continue;}if(node.aabb.TestOverlap(aabb)){if(node.IsLeaf()){const proceed=callback(node);if(!proceed){return;}}else {stack.Push(node.child1);stack.Push(node.child2);}}}}QueryPoint(point,callback){const stack=this.m_stack.Reset();stack.Push(this.m_root);while(stack.GetCount()>0){const node=stack.Pop();if(node===null){continue;}if(node.aabb.TestContain(point)){if(node.IsLeaf()){const proceed=callback(node);if(!proceed){return;}}else {stack.Push(node.child1);stack.Push(node.child2);}}}}RayCast(input,callback){const p1=input.p1;const p2=input.p2;const r=b2Vec2.SubVV(p2,p1,b2DynamicTree.s_r);r.Normalize();const v=b2Vec2.CrossOneV(r,b2DynamicTree.s_v);const abs_v=b2Vec2.AbsV(v,b2DynamicTree.s_abs_v);let maxFraction=input.maxFraction;const segmentAABB=b2DynamicTree.s_segmentAABB;let t_x=p1.x+maxFraction*(p2.x-p1.x);let t_y=p1.y+maxFraction*(p2.y-p1.y);segmentAABB.lowerBound.x=b2Min(p1.x,t_x);segmentAABB.lowerBound.y=b2Min(p1.y,t_y);segmentAABB.upperBound.x=b2Max(p1.x,t_x);segmentAABB.upperBound.y=b2Max(p1.y,t_y);const stack=this.m_stack.Reset();stack.Push(this.m_root);while(stack.GetCount()>0){const node=stack.Pop();if(node===null){continue;}if(!b2TestOverlapAABB(node.aabb,segmentAABB)){continue;}const c=node.aabb.GetCenter();const h=node.aabb.GetExtents();const separation=b2Abs(b2Vec2.DotVV(v,b2Vec2.SubVV(p1,c,b2Vec2.s_t0)))-b2Vec2.DotVV(abs_v,h);if(separation>0){continue;}if(node.IsLeaf()){const subInput=b2DynamicTree.s_subInput;subInput.p1.Copy(input.p1);subInput.p2.Copy(input.p2);subInput.maxFraction=maxFraction;const value=callback(subInput,node);if(value===0){return;}if(value>0){maxFraction=value;t_x=p1.x+maxFraction*(p2.x-p1.x);t_y=p1.y+maxFraction*(p2.y-p1.y);segmentAABB.lowerBound.x=b2Min(p1.x,t_x);segmentAABB.lowerBound.y=b2Min(p1.y,t_y);segmentAABB.upperBound.x=b2Max(p1.x,t_x);segmentAABB.upperBound.y=b2Max(p1.y,t_y);}}else {stack.Push(node.child1);stack.Push(node.child2);}}}AllocateNode(){if(this.m_freeList!==null){const node=this.m_freeList;this.m_freeList=node.parent;node.parent=null;node.child1=null;node.child2=null;node.height=0;return node;}return new b2TreeNode(b2DynamicTree.s_node_id++);}FreeNode(node){node.parent=this.m_freeList;node.child1=null;node.child2=null;node.height=-1;node.Reset();this.m_freeList=node;}CreateProxy(aabb,userData){const node=this.AllocateNode();const r_x=b2_aabbExtension;const r_y=b2_aabbExtension;node.aabb.lowerBound.x=aabb.lowerBound.x-r_x;node.aabb.lowerBound.y=aabb.lowerBound.y-r_y;node.aabb.upperBound.x=aabb.upperBound.x+r_x;node.aabb.upperBound.y=aabb.upperBound.y+r_y;node.userData=userData;node.height=0;this.InsertLeaf(node);return node;}DestroyProxy(node){this.RemoveLeaf(node);this.FreeNode(node);}MoveProxy(node,aabb,displacement){if(node.aabb.Contains(aabb)){return false;}this.RemoveLeaf(node);const r_x=b2_aabbExtension;const r_y=b2_aabbExtension;node.aabb.lowerBound.x=aabb.lowerBound.x-r_x;node.aabb.lowerBound.y=aabb.lowerBound.y-r_y;node.aabb.upperBound.x=aabb.upperBound.x+r_x;node.aabb.upperBound.y=aabb.upperBound.y+r_y;const d_x=b2_aabbMultiplier*displacement.x;const d_y=b2_aabbMultiplier*displacement.y;if(d_x<0.0){node.aabb.lowerBound.x+=d_x;}else {node.aabb.upperBound.x+=d_x;}if(d_y<0.0){node.aabb.lowerBound.y+=d_y;}else {node.aabb.upperBound.y+=d_y;}this.InsertLeaf(node);return true;}InsertLeaf(leaf){++this.m_insertionCount;if(this.m_root===null){this.m_root=leaf;this.m_root.parent=null;return;}const leafAABB=leaf.aabb;let sibling=this.m_root;while(!sibling.IsLeaf()){const child1=verify(sibling.child1);const child2=verify(sibling.child2);const area=sibling.aabb.GetPerimeter();const combinedAABB=b2DynamicTree.s_combinedAABB;combinedAABB.Combine2(sibling.aabb,leafAABB);const combinedArea=combinedAABB.GetPerimeter();const cost=2*combinedArea;const inheritanceCost=2*(combinedArea-area);let cost1;const aabb=b2DynamicTree.s_aabb;let oldArea;let newArea;if(child1.IsLeaf()){aabb.Combine2(leafAABB,child1.aabb);cost1=aabb.GetPerimeter()+inheritanceCost;}else {aabb.Combine2(leafAABB,child1.aabb);oldArea=child1.aabb.GetPerimeter();newArea=aabb.GetPerimeter();cost1=newArea-oldArea+inheritanceCost;}let cost2;if(child2.IsLeaf()){aabb.Combine2(leafAABB,child2.aabb);cost2=aabb.GetPerimeter()+inheritanceCost;}else {aabb.Combine2(leafAABB,child2.aabb);oldArea=child2.aabb.GetPerimeter();newArea=aabb.GetPerimeter();cost2=newArea-oldArea+inheritanceCost;}if(cost<cost1&&cost<cost2){break;}if(cost1<cost2){sibling=child1;}else {sibling=child2;}}const oldParent=sibling.parent;const newParent=this.AllocateNode();newParent.parent=oldParent;newParent.aabb.Combine2(leafAABB,sibling.aabb);newParent.height=sibling.height+1;if(oldParent!==null){if(oldParent.child1===sibling){oldParent.child1=newParent;}else {oldParent.child2=newParent;}newParent.child1=sibling;newParent.child2=leaf;sibling.parent=newParent;leaf.parent=newParent;}else {newParent.child1=sibling;newParent.child2=leaf;sibling.parent=newParent;leaf.parent=newParent;this.m_root=newParent;}let node=leaf.parent;while(node!==null){node=this.Balance(node);const child1=verify(node.child1);const child2=verify(node.child2);node.height=1+b2Max(child1.height,child2.height);node.aabb.Combine2(child1.aabb,child2.aabb);node=node.parent;}}RemoveLeaf(leaf){if(leaf===this.m_root){this.m_root=null;return;}const parent=verify(leaf.parent);const grandParent=parent&&parent.parent;const sibling=verify(parent.child1===leaf?parent.child2:parent.child1);if(grandParent!==null){if(grandParent.child1===parent){grandParent.child1=sibling;}else {grandParent.child2=sibling;}sibling.parent=grandParent;this.FreeNode(parent);let index=grandParent;while(index!==null){index=this.Balance(index);const child1=verify(index.child1);const child2=verify(index.child2);index.aabb.Combine2(child1.aabb,child2.aabb);index.height=1+b2Max(child1.height,child2.height);index=index.parent;}}else {this.m_root=sibling;sibling.parent=null;this.FreeNode(parent);}}Balance(A){if(A.IsLeaf()||A.height<2){return A;}const B=verify(A.child1);const C=verify(A.child2);const balance=C.height-B.height;if(balance>1){const F=verify(C.child1);const G=verify(C.child2);C.child1=A;C.parent=A.parent;A.parent=C;if(C.parent!==null){if(C.parent.child1===A){C.parent.child1=C;}else {C.parent.child2=C;}}else {this.m_root=C;}if(F.height>G.height){C.child2=F;A.child2=G;G.parent=A;A.aabb.Combine2(B.aabb,G.aabb);C.aabb.Combine2(A.aabb,F.aabb);A.height=1+b2Max(B.height,G.height);C.height=1+b2Max(A.height,F.height);}else {C.child2=G;A.child2=F;F.parent=A;A.aabb.Combine2(B.aabb,F.aabb);C.aabb.Combine2(A.aabb,G.aabb);A.height=1+b2Max(B.height,F.height);C.height=1+b2Max(A.height,G.height);}return C;}if(balance<-1){const D=verify(B.child1);const E=verify(B.child2);B.child1=A;B.parent=A.parent;A.parent=B;if(B.parent!==null){if(B.parent.child1===A){B.parent.child1=B;}else {B.parent.child2=B;}}else {this.m_root=B;}if(D.height>E.height){B.child2=D;A.child1=E;E.parent=A;A.aabb.Combine2(C.aabb,E.aabb);B.aabb.Combine2(A.aabb,D.aabb);A.height=1+b2Max(C.height,E.height);B.height=1+b2Max(A.height,D.height);}else {B.child2=E;A.child1=D;D.parent=A;A.aabb.Combine2(C.aabb,D.aabb);B.aabb.Combine2(A.aabb,E.aabb);A.height=1+b2Max(C.height,D.height);B.height=1+b2Max(A.height,E.height);}return B;}return A;}GetHeight(){if(this.m_root===null){return 0;}return this.m_root.height;}static GetAreaNode(node){if(node===null){return 0;}if(node.IsLeaf()){return 0;}let area=node.aabb.GetPerimeter();area+=b2DynamicTree.GetAreaNode(node.child1);area+=b2DynamicTree.GetAreaNode(node.child2);return area;}GetAreaRatio(){if(this.m_root===null){return 0;}const root=this.m_root;const rootArea=root.aabb.GetPerimeter();const totalArea=b2DynamicTree.GetAreaNode(this.m_root);return totalArea/rootArea;}static ComputeHeightNode(node){if(node===null){return 0;}if(node.IsLeaf()){return 0;}const height1=b2DynamicTree.ComputeHeightNode(node.child1);const height2=b2DynamicTree.ComputeHeightNode(node.child2);return 1+b2Max(height1,height2);}ComputeHeight(){const height=b2DynamicTree.ComputeHeightNode(this.m_root);return height;}ValidateStructure(node){if(node===null){return;}if(node===this.m_root);if(node.IsLeaf()){return;}const child1=verify(node.child1);const child2=verify(node.child2);this.ValidateStructure(child1);this.ValidateStructure(child2);}ValidateMetrics(node){if(node===null){return;}if(node.IsLeaf()){return;}const child1=verify(node.child1);const child2=verify(node.child2);const aabb=b2DynamicTree.s_aabb;aabb.Combine2(child1.aabb,child2.aabb);this.ValidateMetrics(child1);this.ValidateMetrics(child2);}Validate(){}static GetMaxBalanceNode(node,maxBalance){if(node===null){return maxBalance;}if(node.height<=1){return maxBalance;}const child1=verify(node.child1);const child2=verify(node.child2);const balance=b2Abs(child2.height-child1.height);return b2Max(maxBalance,balance);}GetMaxBalance(){const maxBalance=b2DynamicTree.GetMaxBalanceNode(this.m_root,0);return maxBalance;}RebuildBottomUp(){this.Validate();}static ShiftOriginNode(node,newOrigin){if(node===null){return;}if(node.height<=1){return;}const child1=node.child1;const child2=node.child2;b2DynamicTree.ShiftOriginNode(child1,newOrigin);b2DynamicTree.ShiftOriginNode(child2,newOrigin);node.aabb.lowerBound.SelfSub(newOrigin);node.aabb.upperBound.SelfSub(newOrigin);}ShiftOrigin(newOrigin){b2DynamicTree.ShiftOriginNode(this.m_root,newOrigin);}}b2DynamicTree.s_r=new b2Vec2();b2DynamicTree.s_v=new b2Vec2();b2DynamicTree.s_abs_v=new b2Vec2();b2DynamicTree.s_segmentAABB=new b2AABB();b2DynamicTree.s_subInput=new b2RayCastInput();b2DynamicTree.s_combinedAABB=new b2AABB();b2DynamicTree.s_aabb=new b2AABB();b2DynamicTree.s_node_id=0;function std_iter_swap(array,a,b){const tmp=array[a];array[a]=array[b];array[b]=tmp;}function default_compare(a,b){return a<b;}function std_sort(array,first=0,len=array.length-first,cmp=default_compare){let left=first;const stack=[];let pos=0;for(;;){for(;left+1<len;len++){const pivot=array[left+Math.floor(Math.random()*(len-left))];stack[pos++]=len;for(let right=left-1;;){while(cmp(array[++right],pivot)){}while(cmp(pivot,array[--len])){}if(right>=len){break;}std_iter_swap(array,right,len);}}if(pos===0){break;}left=len;len=stack[--pos];}return array;}class b2Pair{constructor(proxyA,proxyB){this.proxyA=proxyA;this.proxyB=proxyB;}}class b2BroadPhase{constructor(){this.m_tree=new b2DynamicTree();this.m_proxyCount=0;this.m_moveCount=0;this.m_moveBuffer=[];this.m_pairCount=0;this.m_pairBuffer=[];}CreateProxy(aabb,userData){const proxy=this.m_tree.CreateProxy(aabb,userData);++this.m_proxyCount;this.BufferMove(proxy);return proxy;}DestroyProxy(proxy){this.UnBufferMove(proxy);--this.m_proxyCount;this.m_tree.DestroyProxy(proxy);}MoveProxy(proxy,aabb,displacement){const buffer=this.m_tree.MoveProxy(proxy,aabb,displacement);if(buffer){this.BufferMove(proxy);}}TouchProxy(proxy){this.BufferMove(proxy);}GetProxyCount(){return this.m_proxyCount;}UpdatePairs(callback){this.m_pairCount=0;for(let i=0;i<this.m_moveCount;++i){const queryProxy=this.m_moveBuffer[i];if(queryProxy===null){continue;}const fatAABB=queryProxy.aabb;this.m_tree.Query(fatAABB,proxy=>{if(proxy.m_id===queryProxy.m_id){return true;}let proxyA;let proxyB;if(proxy.m_id<queryProxy.m_id){proxyA=proxy;proxyB=queryProxy;}else {proxyA=queryProxy;proxyB=proxy;}if(this.m_pairCount===this.m_pairBuffer.length){this.m_pairBuffer[this.m_pairCount]=new b2Pair(proxyA,proxyB);}else {const pair=this.m_pairBuffer[this.m_pairCount];pair.proxyA=proxyA;pair.proxyB=proxyB;}++this.m_pairCount;return true;});}this.m_moveCount=0;std_sort(this.m_pairBuffer,0,this.m_pairCount,b2PairLessThan);let i=0;while(i<this.m_pairCount){const primaryPair=this.m_pairBuffer[i];const userDataA=primaryPair.proxyA.userData;const userDataB=primaryPair.proxyB.userData;callback(userDataA,userDataB);++i;while(i<this.m_pairCount){const pair=this.m_pairBuffer[i];if(pair.proxyA.m_id!==primaryPair.proxyA.m_id||pair.proxyB.m_id!==primaryPair.proxyB.m_id){break;}++i;}}}Query(aabb,callback){this.m_tree.Query(aabb,callback);}QueryPoint(point,callback){this.m_tree.QueryPoint(point,callback);}RayCast(input,callback){this.m_tree.RayCast(input,callback);}GetTreeHeight(){return this.m_tree.GetHeight();}GetTreeBalance(){return this.m_tree.GetMaxBalance();}GetTreeQuality(){return this.m_tree.GetAreaRatio();}ShiftOrigin(newOrigin){this.m_tree.ShiftOrigin(newOrigin);}BufferMove(proxy){this.m_moveBuffer[this.m_moveCount]=proxy;++this.m_moveCount;}UnBufferMove(proxy){const i=this.m_moveBuffer.indexOf(proxy);this.m_moveBuffer[i]=null;}}function b2PairLessThan(pair1,pair2){if(pair1.proxyA.m_id<pair2.proxyA.m_id){return true;}if(pair1.proxyA.m_id===pair2.proxyA.m_id){return pair1.proxyB.m_id<pair2.proxyB.m_id;}return false;}exports.b2_toiTime=0;exports.b2_toiMaxTime=0;exports.b2_toiCalls=0;exports.b2_toiIters=0;exports.b2_toiMaxIters=0;exports.b2_toiRootIters=0;exports.b2_toiMaxRootIters=0;function b2_toi_reset(){exports.b2_toiTime=0;exports.b2_toiMaxTime=0;exports.b2_toiCalls=0;exports.b2_toiIters=0;exports.b2_toiMaxIters=0;exports.b2_toiRootIters=0;exports.b2_toiMaxRootIters=0;}const b2TimeOfImpact_s_xfA=new b2Transform();const b2TimeOfImpact_s_xfB=new b2Transform();const b2TimeOfImpact_s_pointA=new b2Vec2();const b2TimeOfImpact_s_pointB=new b2Vec2();const b2TimeOfImpact_s_normal=new b2Vec2();const b2TimeOfImpact_s_axisA=new b2Vec2();const b2TimeOfImpact_s_axisB=new b2Vec2();class b2TOIInput{constructor(){this.proxyA=new b2DistanceProxy();this.proxyB=new b2DistanceProxy();this.sweepA=new b2Sweep();this.sweepB=new b2Sweep();this.tMax=0;}}(function(b2TOIOutputState){b2TOIOutputState[b2TOIOutputState["e_unknown"]=0]="e_unknown";b2TOIOutputState[b2TOIOutputState["e_failed"]=1]="e_failed";b2TOIOutputState[b2TOIOutputState["e_overlapped"]=2]="e_overlapped";b2TOIOutputState[b2TOIOutputState["e_touching"]=3]="e_touching";b2TOIOutputState[b2TOIOutputState["e_separated"]=4]="e_separated";})(exports.b2TOIOutputState||(exports.b2TOIOutputState={}));class b2TOIOutput{constructor(){this.state=exports.b2TOIOutputState.e_unknown;this.t=0;}}(function(b2SeparationFunctionType){b2SeparationFunctionType[b2SeparationFunctionType["e_unknown"]=-1]="e_unknown";b2SeparationFunctionType[b2SeparationFunctionType["e_points"]=0]="e_points";b2SeparationFunctionType[b2SeparationFunctionType["e_faceA"]=1]="e_faceA";b2SeparationFunctionType[b2SeparationFunctionType["e_faceB"]=2]="e_faceB";})(exports.b2SeparationFunctionType||(exports.b2SeparationFunctionType={}));class b2SeparationFunction{constructor(){this.m_sweepA=new b2Sweep();this.m_sweepB=new b2Sweep();this.m_type=exports.b2SeparationFunctionType.e_unknown;this.m_localPoint=new b2Vec2();this.m_axis=new b2Vec2();}Initialize(cache,proxyA,sweepA,proxyB,sweepB,t1){this.m_proxyA=proxyA;this.m_proxyB=proxyB;const count=cache.count;this.m_sweepA.Copy(sweepA);this.m_sweepB.Copy(sweepB);const xfA=b2TimeOfImpact_s_xfA;const xfB=b2TimeOfImpact_s_xfB;this.m_sweepA.GetTransform(xfA,t1);this.m_sweepB.GetTransform(xfB,t1);if(count===1){this.m_type=exports.b2SeparationFunctionType.e_points;const localPointA=this.m_proxyA.GetVertex(cache.indexA[0]);const localPointB=this.m_proxyB.GetVertex(cache.indexB[0]);const pointA=b2Transform.MulXV(xfA,localPointA,b2TimeOfImpact_s_pointA);const pointB=b2Transform.MulXV(xfB,localPointB,b2TimeOfImpact_s_pointB);b2Vec2.SubVV(pointB,pointA,this.m_axis);const s=this.m_axis.Normalize();this.m_localPoint.SetZero();return s;}else if(cache.indexA[0]===cache.indexA[1]){this.m_type=exports.b2SeparationFunctionType.e_faceB;const localPointB1=this.m_proxyB.GetVertex(cache.indexB[0]);const localPointB2=this.m_proxyB.GetVertex(cache.indexB[1]);b2Vec2.CrossVOne(b2Vec2.SubVV(localPointB2,localPointB1,b2Vec2.s_t0),this.m_axis).SelfNormalize();const normal=b2Rot.MulRV(xfB.q,this.m_axis,b2TimeOfImpact_s_normal);b2Vec2.MidVV(localPointB1,localPointB2,this.m_localPoint);const pointB=b2Transform.MulXV(xfB,this.m_localPoint,b2TimeOfImpact_s_pointB);const localPointA=this.m_proxyA.GetVertex(cache.indexA[0]);const pointA=b2Transform.MulXV(xfA,localPointA,b2TimeOfImpact_s_pointA);let s=b2Vec2.DotVV(b2Vec2.SubVV(pointA,pointB,b2Vec2.s_t0),normal);if(s<0){this.m_axis.SelfNeg();s=-s;}return s;}else {this.m_type=exports.b2SeparationFunctionType.e_faceA;const localPointA1=this.m_proxyA.GetVertex(cache.indexA[0]);const localPointA2=this.m_proxyA.GetVertex(cache.indexA[1]);b2Vec2.CrossVOne(b2Vec2.SubVV(localPointA2,localPointA1,b2Vec2.s_t0),this.m_axis).SelfNormalize();const normal=b2Rot.MulRV(xfA.q,this.m_axis,b2TimeOfImpact_s_normal);b2Vec2.MidVV(localPointA1,localPointA2,this.m_localPoint);const pointA=b2Transform.MulXV(xfA,this.m_localPoint,b2TimeOfImpact_s_pointA);const localPointB=this.m_proxyB.GetVertex(cache.indexB[0]);const pointB=b2Transform.MulXV(xfB,localPointB,b2TimeOfImpact_s_pointB);let s=b2Vec2.DotVV(b2Vec2.SubVV(pointB,pointA,b2Vec2.s_t0),normal);if(s<0){this.m_axis.SelfNeg();s=-s;}return s;}}FindMinSeparation(indexA,indexB,t){const xfA=b2TimeOfImpact_s_xfA;const xfB=b2TimeOfImpact_s_xfB;this.m_sweepA.GetTransform(xfA,t);this.m_sweepB.GetTransform(xfB,t);switch(this.m_type){case exports.b2SeparationFunctionType.e_points:{const axisA=b2Rot.MulTRV(xfA.q,this.m_axis,b2TimeOfImpact_s_axisA);const axisB=b2Rot.MulTRV(xfB.q,b2Vec2.NegV(this.m_axis,b2Vec2.s_t0),b2TimeOfImpact_s_axisB);indexA[0]=this.m_proxyA.GetSupport(axisA);indexB[0]=this.m_proxyB.GetSupport(axisB);const localPointA=this.m_proxyA.GetVertex(indexA[0]);const localPointB=this.m_proxyB.GetVertex(indexB[0]);const pointA=b2Transform.MulXV(xfA,localPointA,b2TimeOfImpact_s_pointA);const pointB=b2Transform.MulXV(xfB,localPointB,b2TimeOfImpact_s_pointB);const separation=b2Vec2.DotVV(b2Vec2.SubVV(pointB,pointA,b2Vec2.s_t0),this.m_axis);return separation;}case exports.b2SeparationFunctionType.e_faceA:{const normal=b2Rot.MulRV(xfA.q,this.m_axis,b2TimeOfImpact_s_normal);const pointA=b2Transform.MulXV(xfA,this.m_localPoint,b2TimeOfImpact_s_pointA);const axisB=b2Rot.MulTRV(xfB.q,b2Vec2.NegV(normal,b2Vec2.s_t0),b2TimeOfImpact_s_axisB);indexA[0]=-1;indexB[0]=this.m_proxyB.GetSupport(axisB);const localPointB=this.m_proxyB.GetVertex(indexB[0]);const pointB=b2Transform.MulXV(xfB,localPointB,b2TimeOfImpact_s_pointB);const separation=b2Vec2.DotVV(b2Vec2.SubVV(pointB,pointA,b2Vec2.s_t0),normal);return separation;}case exports.b2SeparationFunctionType.e_faceB:{const normal=b2Rot.MulRV(xfB.q,this.m_axis,b2TimeOfImpact_s_normal);const pointB=b2Transform.MulXV(xfB,this.m_localPoint,b2TimeOfImpact_s_pointB);const axisA=b2Rot.MulTRV(xfA.q,b2Vec2.NegV(normal,b2Vec2.s_t0),b2TimeOfImpact_s_axisA);indexB[0]=-1;indexA[0]=this.m_proxyA.GetSupport(axisA);const localPointA=this.m_proxyA.GetVertex(indexA[0]);const pointA=b2Transform.MulXV(xfA,localPointA,b2TimeOfImpact_s_pointA);const separation=b2Vec2.DotVV(b2Vec2.SubVV(pointA,pointB,b2Vec2.s_t0),normal);return separation;}default:indexA[0]=-1;indexB[0]=-1;return 0;}}Evaluate(indexA,indexB,t){const xfA=b2TimeOfImpact_s_xfA;const xfB=b2TimeOfImpact_s_xfB;this.m_sweepA.GetTransform(xfA,t);this.m_sweepB.GetTransform(xfB,t);switch(this.m_type){case exports.b2SeparationFunctionType.e_points:{const localPointA=this.m_proxyA.GetVertex(indexA);const localPointB=this.m_proxyB.GetVertex(indexB);const pointA=b2Transform.MulXV(xfA,localPointA,b2TimeOfImpact_s_pointA);const pointB=b2Transform.MulXV(xfB,localPointB,b2TimeOfImpact_s_pointB);const separation=b2Vec2.DotVV(b2Vec2.SubVV(pointB,pointA,b2Vec2.s_t0),this.m_axis);return separation;}case exports.b2SeparationFunctionType.e_faceA:{const normal=b2Rot.MulRV(xfA.q,this.m_axis,b2TimeOfImpact_s_normal);const pointA=b2Transform.MulXV(xfA,this.m_localPoint,b2TimeOfImpact_s_pointA);const localPointB=this.m_proxyB.GetVertex(indexB);const pointB=b2Transform.MulXV(xfB,localPointB,b2TimeOfImpact_s_pointB);const separation=b2Vec2.DotVV(b2Vec2.SubVV(pointB,pointA,b2Vec2.s_t0),normal);return separation;}case exports.b2SeparationFunctionType.e_faceB:{const normal=b2Rot.MulRV(xfB.q,this.m_axis,b2TimeOfImpact_s_normal);const pointB=b2Transform.MulXV(xfB,this.m_localPoint,b2TimeOfImpact_s_pointB);const localPointA=this.m_proxyA.GetVertex(indexA);const pointA=b2Transform.MulXV(xfA,localPointA,b2TimeOfImpact_s_pointA);const separation=b2Vec2.DotVV(b2Vec2.SubVV(pointA,pointB,b2Vec2.s_t0),normal);return separation;}default:return 0;}}}const b2TimeOfImpact_s_timer=new b2Timer();const b2TimeOfImpact_s_cache=new b2SimplexCache();const b2TimeOfImpact_s_distanceInput=new b2DistanceInput();const b2TimeOfImpact_s_distanceOutput=new b2DistanceOutput();const b2TimeOfImpact_s_fcn=new b2SeparationFunction();const b2TimeOfImpact_s_indexA=[0];const b2TimeOfImpact_s_indexB=[0];const b2TimeOfImpact_s_sweepA=new b2Sweep();const b2TimeOfImpact_s_sweepB=new b2Sweep();function b2TimeOfImpact(output,input){const timer=b2TimeOfImpact_s_timer.Reset();++exports.b2_toiCalls;output.state=exports.b2TOIOutputState.e_unknown;output.t=input.tMax;const proxyA=input.proxyA;const proxyB=input.proxyB;const maxVertices=b2Max(b2_maxPolygonVertices,b2Max(proxyA.m_count,proxyB.m_count));const sweepA=b2TimeOfImpact_s_sweepA.Copy(input.sweepA);const sweepB=b2TimeOfImpact_s_sweepB.Copy(input.sweepB);sweepA.Normalize();sweepB.Normalize();const tMax=input.tMax;const totalRadius=proxyA.m_radius+proxyB.m_radius;const target=b2Max(b2_linearSlop,totalRadius-3*b2_linearSlop);const tolerance=0.25*b2_linearSlop;let t1=0;const k_maxIterations=20;let iter=0;const cache=b2TimeOfImpact_s_cache;cache.count=0;const distanceInput=b2TimeOfImpact_s_distanceInput;distanceInput.proxyA.Copy(input.proxyA);distanceInput.proxyB.Copy(input.proxyB);distanceInput.useRadii=false;for(;;){const xfA=b2TimeOfImpact_s_xfA;const xfB=b2TimeOfImpact_s_xfB;sweepA.GetTransform(xfA,t1);sweepB.GetTransform(xfB,t1);distanceInput.transformA.Copy(xfA);distanceInput.transformB.Copy(xfB);const distanceOutput=b2TimeOfImpact_s_distanceOutput;b2Distance(distanceOutput,cache,distanceInput);if(distanceOutput.distance<=0){output.state=exports.b2TOIOutputState.e_overlapped;output.t=0;break;}if(distanceOutput.distance<target+tolerance){output.state=exports.b2TOIOutputState.e_touching;output.t=t1;break;}const fcn=b2TimeOfImpact_s_fcn;fcn.Initialize(cache,proxyA,sweepA,proxyB,sweepB,t1);let done=false;let t2=tMax;let pushBackIter=0;for(;;){const indexA=b2TimeOfImpact_s_indexA;const indexB=b2TimeOfImpact_s_indexB;let s2=fcn.FindMinSeparation(indexA,indexB,t2);if(s2>target+tolerance){output.state=exports.b2TOIOutputState.e_separated;output.t=tMax;done=true;break;}if(s2>target-tolerance){t1=t2;break;}let s1=fcn.Evaluate(indexA[0],indexB[0],t1);if(s1<target-tolerance){output.state=exports.b2TOIOutputState.e_failed;output.t=t1;done=true;break;}if(s1<=target+tolerance){output.state=exports.b2TOIOutputState.e_touching;output.t=t1;done=true;break;}let rootIterCount=0;let a1=t1;let a2=t2;for(;;){let t=0;if(rootIterCount&1){t=a1+(target-s1)*(a2-a1)/(s2-s1);}else {t=0.5*(a1+a2);}++rootIterCount;++exports.b2_toiRootIters;const s=fcn.Evaluate(indexA[0],indexB[0],t);if(b2Abs(s-target)<tolerance){t2=t;break;}if(s>target){a1=t;s1=s;}else {a2=t;s2=s;}if(rootIterCount===50){break;}}exports.b2_toiMaxRootIters=b2Max(exports.b2_toiMaxRootIters,rootIterCount);++pushBackIter;if(pushBackIter===maxVertices){break;}}++iter;++exports.b2_toiIters;if(done){break;}if(iter===k_maxIterations){output.state=exports.b2TOIOutputState.e_failed;output.t=t1;break;}}exports.b2_toiMaxIters=b2Max(exports.b2_toiMaxIters,iter);const time=timer.GetMilliseconds();exports.b2_toiMaxTime=b2Max(exports.b2_toiMaxTime,time);exports.b2_toiTime+=time;}const b2CollideCircles_s_pA=new b2Vec2();const b2CollideCircles_s_pB=new b2Vec2();function b2CollideCircles(manifold,circleA,xfA,circleB,xfB){manifold.pointCount=0;const pA=b2Transform.MulXV(xfA,circleA.m_p,b2CollideCircles_s_pA);const pB=b2Transform.MulXV(xfB,circleB.m_p,b2CollideCircles_s_pB);const distSqr=b2Vec2.DistanceSquaredVV(pA,pB);const radius=circleA.m_radius+circleB.m_radius;if(distSqr>radius*radius){return;}manifold.type=exports.b2ManifoldType.e_circles;manifold.localPoint.Copy(circleA.m_p);manifold.localNormal.SetZero();manifold.pointCount=1;manifold.points[0].localPoint.Copy(circleB.m_p);manifold.points[0].id.key=0;}const b2CollidePolygonAndCircle_s_c=new b2Vec2();const b2CollidePolygonAndCircle_s_cLocal=new b2Vec2();const b2CollidePolygonAndCircle_s_faceCenter=new b2Vec2();function b2CollidePolygonAndCircle(manifold,polygonA,xfA,circleB,xfB){manifold.pointCount=0;const c=b2Transform.MulXV(xfB,circleB.m_p,b2CollidePolygonAndCircle_s_c);const cLocal=b2Transform.MulTXV(xfA,c,b2CollidePolygonAndCircle_s_cLocal);let normalIndex=0;let separation=-b2_maxFloat;const radius=polygonA.m_radius+circleB.m_radius;const vertexCount=polygonA.m_count;const vertices=polygonA.m_vertices;const normals=polygonA.m_normals;for(let i=0;i<vertexCount;++i){const s=b2Vec2.DotVV(normals[i],b2Vec2.SubVV(cLocal,vertices[i],b2Vec2.s_t0));if(s>radius){return;}if(s>separation){separation=s;normalIndex=i;}}const vertIndex1=normalIndex;const vertIndex2=(vertIndex1+1)%vertexCount;const v1=vertices[vertIndex1];const v2=vertices[vertIndex2];if(separation<b2_epsilon){manifold.pointCount=1;manifold.type=exports.b2ManifoldType.e_faceA;manifold.localNormal.Copy(normals[normalIndex]);b2Vec2.MidVV(v1,v2,manifold.localPoint);manifold.points[0].localPoint.Copy(circleB.m_p);manifold.points[0].id.key=0;return;}const u1=b2Vec2.DotVV(b2Vec2.SubVV(cLocal,v1,b2Vec2.s_t0),b2Vec2.SubVV(v2,v1,b2Vec2.s_t1));const u2=b2Vec2.DotVV(b2Vec2.SubVV(cLocal,v2,b2Vec2.s_t0),b2Vec2.SubVV(v1,v2,b2Vec2.s_t1));if(u1<=0){if(b2Vec2.DistanceSquaredVV(cLocal,v1)>radius*radius){return;}manifold.pointCount=1;manifold.type=exports.b2ManifoldType.e_faceA;b2Vec2.SubVV(cLocal,v1,manifold.localNormal).SelfNormalize();manifold.localPoint.Copy(v1);manifold.points[0].localPoint.Copy(circleB.m_p);manifold.points[0].id.key=0;}else if(u2<=0){if(b2Vec2.DistanceSquaredVV(cLocal,v2)>radius*radius){return;}manifold.pointCount=1;manifold.type=exports.b2ManifoldType.e_faceA;b2Vec2.SubVV(cLocal,v2,manifold.localNormal).SelfNormalize();manifold.localPoint.Copy(v2);manifold.points[0].localPoint.Copy(circleB.m_p);manifold.points[0].id.key=0;}else {const faceCenter=b2Vec2.MidVV(v1,v2,b2CollidePolygonAndCircle_s_faceCenter);const separation=b2Vec2.DotVV(b2Vec2.SubVV(cLocal,faceCenter,b2Vec2.s_t1),normals[vertIndex1]);if(separation>radius){return;}manifold.pointCount=1;manifold.type=exports.b2ManifoldType.e_faceA;manifold.localNormal.Copy(normals[vertIndex1]).SelfNormalize();manifold.localPoint.Copy(faceCenter);manifold.points[0].localPoint.Copy(circleB.m_p);manifold.points[0].id.key=0;}}const b2EdgeSeparation_s_normal1World=new b2Vec2();const b2EdgeSeparation_s_normal1=new b2Vec2();const b2EdgeSeparation_s_v1=new b2Vec2();const b2EdgeSeparation_s_v2=new b2Vec2();function b2EdgeSeparation(poly1,xf1,edge1,poly2,xf2){const vertices1=poly1.m_vertices;const normals1=poly1.m_normals;const count2=poly2.m_count;const vertices2=poly2.m_vertices;const normal1World=b2Rot.MulRV(xf1.q,normals1[edge1],b2EdgeSeparation_s_normal1World);const normal1=b2Rot.MulTRV(xf2.q,normal1World,b2EdgeSeparation_s_normal1);let index=0;let minDot=b2_maxFloat;for(let i=0;i<count2;++i){const dot=b2Vec2.DotVV(vertices2[i],normal1);if(dot<minDot){minDot=dot;index=i;}}const v1=b2Transform.MulXV(xf1,vertices1[edge1],b2EdgeSeparation_s_v1);const v2=b2Transform.MulXV(xf2,vertices2[index],b2EdgeSeparation_s_v2);const separation=b2Vec2.DotVV(b2Vec2.SubVV(v2,v1,b2Vec2.s_t0),normal1World);return separation;}const b2FindMaxSeparation_s_d=new b2Vec2();const b2FindMaxSeparation_s_dLocal1=new b2Vec2();function b2FindMaxSeparation(edgeIndex,poly1,xf1,poly2,xf2){const count1=poly1.m_count;const normals1=poly1.m_normals;const d=b2Vec2.SubVV(b2Transform.MulXV(xf2,poly2.m_centroid,b2Vec2.s_t0),b2Transform.MulXV(xf1,poly1.m_centroid,b2Vec2.s_t1),b2FindMaxSeparation_s_d);const dLocal1=b2Rot.MulTRV(xf1.q,d,b2FindMaxSeparation_s_dLocal1);let edge=0;let maxDot=-b2_maxFloat;for(let i=0;i<count1;++i){const dot=b2Vec2.DotVV(normals1[i],dLocal1);if(dot>maxDot){maxDot=dot;edge=i;}}let s=b2EdgeSeparation(poly1,xf1,edge,poly2,xf2);const prevEdge=(edge+count1-1)%count1;const sPrev=b2EdgeSeparation(poly1,xf1,prevEdge,poly2,xf2);const nextEdge=(edge+1)%count1;const sNext=b2EdgeSeparation(poly1,xf1,nextEdge,poly2,xf2);let bestEdge=0;let bestSeparation=0;let increment=0;if(sPrev>s&&sPrev>sNext){increment=-1;bestEdge=prevEdge;bestSeparation=sPrev;}else if(sNext>s){increment=1;bestEdge=nextEdge;bestSeparation=sNext;}else {edgeIndex[0]=edge;return s;}while(true){if(increment===-1){edge=(bestEdge+count1-1)%count1;}else {edge=(bestEdge+1)%count1;}s=b2EdgeSeparation(poly1,xf1,edge,poly2,xf2);if(s>bestSeparation){bestEdge=edge;bestSeparation=s;}else {break;}}edgeIndex[0]=bestEdge;return bestSeparation;}const b2FindIncidentEdge_s_normal1=new b2Vec2();function b2FindIncidentEdge(c,poly1,xf1,edge1,poly2,xf2){const normals1=poly1.m_normals;const count2=poly2.m_count;const vertices2=poly2.m_vertices;const normals2=poly2.m_normals;const normal1=b2Rot.MulTRV(xf2.q,b2Rot.MulRV(xf1.q,normals1[edge1],b2Vec2.s_t0),b2FindIncidentEdge_s_normal1);let index=0;let minDot=b2_maxFloat;for(let i=0;i<count2;++i){const dot=b2Vec2.DotVV(normal1,normals2[i]);if(dot<minDot){minDot=dot;index=i;}}const i1=index;const i2=(i1+1)%count2;const c0=c[0];b2Transform.MulXV(xf2,vertices2[i1],c0.v);const cf0=c0.id.cf;cf0.indexA=edge1;cf0.indexB=i1;cf0.typeA=exports.b2ContactFeatureType.e_face;cf0.typeB=exports.b2ContactFeatureType.e_vertex;const c1=c[1];b2Transform.MulXV(xf2,vertices2[i2],c1.v);const cf1=c1.id.cf;cf1.indexA=edge1;cf1.indexB=i2;cf1.typeA=exports.b2ContactFeatureType.e_face;cf1.typeB=exports.b2ContactFeatureType.e_vertex;}const b2CollidePolygons_s_incidentEdge=b2ClipVertex.MakeArray(2);const b2CollidePolygons_s_clipPoints1=b2ClipVertex.MakeArray(2);const b2CollidePolygons_s_clipPoints2=b2ClipVertex.MakeArray(2);const b2CollidePolygons_s_edgeA=[0];const b2CollidePolygons_s_edgeB=[0];const b2CollidePolygons_s_localTangent=new b2Vec2();const b2CollidePolygons_s_localNormal=new b2Vec2();const b2CollidePolygons_s_planePoint=new b2Vec2();const b2CollidePolygons_s_normal=new b2Vec2();const b2CollidePolygons_s_tangent=new b2Vec2();const b2CollidePolygons_s_ntangent=new b2Vec2();const b2CollidePolygons_s_v11=new b2Vec2();const b2CollidePolygons_s_v12=new b2Vec2();function b2CollidePolygons(manifold,polyA,xfA,polyB,xfB){manifold.pointCount=0;const totalRadius=polyA.m_radius+polyB.m_radius;const edgeA=b2CollidePolygons_s_edgeA;edgeA[0]=0;const separationA=b2FindMaxSeparation(edgeA,polyA,xfA,polyB,xfB);if(separationA>totalRadius){return;}const edgeB=b2CollidePolygons_s_edgeB;edgeB[0]=0;const separationB=b2FindMaxSeparation(edgeB,polyB,xfB,polyA,xfA);if(separationB>totalRadius){return;}let poly1;let poly2;let xf1,xf2;let edge1=0;let flip=0;const k_relativeTol=0.98;const k_absoluteTol=0.001;if(separationB>k_relativeTol*separationA+k_absoluteTol){poly1=polyB;poly2=polyA;xf1=xfB;xf2=xfA;edge1=edgeB[0];manifold.type=exports.b2ManifoldType.e_faceB;flip=1;}else {poly1=polyA;poly2=polyB;xf1=xfA;xf2=xfB;edge1=edgeA[0];manifold.type=exports.b2ManifoldType.e_faceA;flip=0;}const incidentEdge=b2CollidePolygons_s_incidentEdge;b2FindIncidentEdge(incidentEdge,poly1,xf1,edge1,poly2,xf2);const count1=poly1.m_count;const vertices1=poly1.m_vertices;const iv1=edge1;const iv2=(edge1+1)%count1;const local_v11=vertices1[iv1];const local_v12=vertices1[iv2];const localTangent=b2Vec2.SubVV(local_v12,local_v11,b2CollidePolygons_s_localTangent);localTangent.Normalize();const localNormal=b2Vec2.CrossVOne(localTangent,b2CollidePolygons_s_localNormal);const planePoint=b2Vec2.MidVV(local_v11,local_v12,b2CollidePolygons_s_planePoint);const tangent=b2Rot.MulRV(xf1.q,localTangent,b2CollidePolygons_s_tangent);const normal=b2Vec2.CrossVOne(tangent,b2CollidePolygons_s_normal);const v11=b2Transform.MulXV(xf1,local_v11,b2CollidePolygons_s_v11);const v12=b2Transform.MulXV(xf1,local_v12,b2CollidePolygons_s_v12);const frontOffset=b2Vec2.DotVV(normal,v11);const sideOffset1=-b2Vec2.DotVV(tangent,v11)+totalRadius;const sideOffset2=b2Vec2.DotVV(tangent,v12)+totalRadius;const clipPoints1=b2CollidePolygons_s_clipPoints1;const clipPoints2=b2CollidePolygons_s_clipPoints2;let np;const ntangent=b2Vec2.NegV(tangent,b2CollidePolygons_s_ntangent);np=b2ClipSegmentToLine(clipPoints1,incidentEdge,ntangent,sideOffset1,iv1);if(np<2){return;}np=b2ClipSegmentToLine(clipPoints2,clipPoints1,tangent,sideOffset2,iv2);if(np<2){return;}manifold.localNormal.Copy(localNormal);manifold.localPoint.Copy(planePoint);let pointCount=0;for(let i=0;i<b2_maxManifoldPoints;++i){const cv=clipPoints2[i];const separation=b2Vec2.DotVV(normal,cv.v)-frontOffset;if(separation<=totalRadius){const cp=manifold.points[pointCount];b2Transform.MulTXV(xf2,cv.v,cp.localPoint);cp.id.Copy(cv.id);if(flip){const cf=cp.id.cf;cp.id.cf.indexA=cf.indexB;cp.id.cf.indexB=cf.indexA;cp.id.cf.typeA=cf.typeB;cp.id.cf.typeB=cf.typeA;}++pointCount;}}manifold.pointCount=pointCount;}const b2CollideEdgeAndCircle_s_Q=new b2Vec2();const b2CollideEdgeAndCircle_s_e=new b2Vec2();const b2CollideEdgeAndCircle_s_d=new b2Vec2();const b2CollideEdgeAndCircle_s_e1=new b2Vec2();const b2CollideEdgeAndCircle_s_e2=new b2Vec2();const b2CollideEdgeAndCircle_s_P=new b2Vec2();const b2CollideEdgeAndCircle_s_n=new b2Vec2();const b2CollideEdgeAndCircle_s_id=new b2ContactID();function b2CollideEdgeAndCircle(manifold,edgeA,xfA,circleB,xfB){manifold.pointCount=0;const Q=b2Transform.MulTXV(xfA,b2Transform.MulXV(xfB,circleB.m_p,b2Vec2.s_t0),b2CollideEdgeAndCircle_s_Q);const A=edgeA.m_vertex1;const B=edgeA.m_vertex2;const e=b2Vec2.SubVV(B,A,b2CollideEdgeAndCircle_s_e);const u=b2Vec2.DotVV(e,b2Vec2.SubVV(B,Q,b2Vec2.s_t0));const v=b2Vec2.DotVV(e,b2Vec2.SubVV(Q,A,b2Vec2.s_t0));const radius=edgeA.m_radius+circleB.m_radius;const id=b2CollideEdgeAndCircle_s_id;id.cf.indexB=0;id.cf.typeB=exports.b2ContactFeatureType.e_vertex;if(v<=0){const P=A;const d=b2Vec2.SubVV(Q,P,b2CollideEdgeAndCircle_s_d);const dd=b2Vec2.DotVV(d,d);if(dd>radius*radius){return;}if(edgeA.m_hasVertex0){const A1=edgeA.m_vertex0;const B1=A;const e1=b2Vec2.SubVV(B1,A1,b2CollideEdgeAndCircle_s_e1);const u1=b2Vec2.DotVV(e1,b2Vec2.SubVV(B1,Q,b2Vec2.s_t0));if(u1>0){return;}}id.cf.indexA=0;id.cf.typeA=exports.b2ContactFeatureType.e_vertex;manifold.pointCount=1;manifold.type=exports.b2ManifoldType.e_circles;manifold.localNormal.SetZero();manifold.localPoint.Copy(P);manifold.points[0].id.Copy(id);manifold.points[0].localPoint.Copy(circleB.m_p);return;}if(u<=0){const P=B;const d=b2Vec2.SubVV(Q,P,b2CollideEdgeAndCircle_s_d);const dd=b2Vec2.DotVV(d,d);if(dd>radius*radius){return;}if(edgeA.m_hasVertex3){const B2=edgeA.m_vertex3;const A2=B;const e2=b2Vec2.SubVV(B2,A2,b2CollideEdgeAndCircle_s_e2);const v2=b2Vec2.DotVV(e2,b2Vec2.SubVV(Q,A2,b2Vec2.s_t0));if(v2>0){return;}}id.cf.indexA=1;id.cf.typeA=exports.b2ContactFeatureType.e_vertex;manifold.pointCount=1;manifold.type=exports.b2ManifoldType.e_circles;manifold.localNormal.SetZero();manifold.localPoint.Copy(P);manifold.points[0].id.Copy(id);manifold.points[0].localPoint.Copy(circleB.m_p);return;}const den=b2Vec2.DotVV(e,e);const P=b2CollideEdgeAndCircle_s_P;P.x=1/den*(u*A.x+v*B.x);P.y=1/den*(u*A.y+v*B.y);const d=b2Vec2.SubVV(Q,P,b2CollideEdgeAndCircle_s_d);const dd=b2Vec2.DotVV(d,d);if(dd>radius*radius){return;}const n=b2CollideEdgeAndCircle_s_n.Set(-e.y,e.x);if(b2Vec2.DotVV(n,b2Vec2.SubVV(Q,A,b2Vec2.s_t0))<0){n.Set(-n.x,-n.y);}n.Normalize();id.cf.indexA=0;id.cf.typeA=exports.b2ContactFeatureType.e_face;manifold.pointCount=1;manifold.type=exports.b2ManifoldType.e_faceA;manifold.localNormal.Copy(n);manifold.localPoint.Copy(A);manifold.points[0].id.Copy(id);manifold.points[0].localPoint.Copy(circleB.m_p);}var b2EPAxisType;(function(b2EPAxisType){b2EPAxisType[b2EPAxisType["e_unknown"]=0]="e_unknown";b2EPAxisType[b2EPAxisType["e_edgeA"]=1]="e_edgeA";b2EPAxisType[b2EPAxisType["e_edgeB"]=2]="e_edgeB";})(b2EPAxisType||(b2EPAxisType={}));class b2EPAxis{constructor(){this.type=b2EPAxisType.e_unknown;this.index=0;this.separation=0;}}class b2TempPolygon{constructor(){this.vertices=[];this.normals=[];this.count=0;}}class b2ReferenceFace{constructor(){this.i1=0;this.i2=0;this.v1=new b2Vec2();this.v2=new b2Vec2();this.normal=new b2Vec2();this.sideNormal1=new b2Vec2();this.sideOffset1=0;this.sideNormal2=new b2Vec2();this.sideOffset2=0;}}var b2EPColliderVertexType;(function(b2EPColliderVertexType){b2EPColliderVertexType[b2EPColliderVertexType["e_isolated"]=0]="e_isolated";b2EPColliderVertexType[b2EPColliderVertexType["e_concave"]=1]="e_concave";b2EPColliderVertexType[b2EPColliderVertexType["e_convex"]=2]="e_convex";})(b2EPColliderVertexType||(b2EPColliderVertexType={}));class b2EPCollider{constructor(){this.m_polygonB=new b2TempPolygon();this.m_xf=new b2Transform();this.m_centroidB=new b2Vec2();this.m_v0=new b2Vec2();this.m_v1=new b2Vec2();this.m_v2=new b2Vec2();this.m_v3=new b2Vec2();this.m_normal0=new b2Vec2();this.m_normal1=new b2Vec2();this.m_normal2=new b2Vec2();this.m_normal=new b2Vec2();this.m_type1=b2EPColliderVertexType.e_isolated;this.m_type2=b2EPColliderVertexType.e_isolated;this.m_lowerLimit=new b2Vec2();this.m_upperLimit=new b2Vec2();this.m_radius=0;this.m_front=false;}Collide(manifold,edgeA,xfA,polygonB,xfB){b2Transform.MulTXX(xfA,xfB,this.m_xf);b2Transform.MulXV(this.m_xf,polygonB.m_centroid,this.m_centroidB);this.m_v0.Copy(edgeA.m_vertex0);this.m_v1.Copy(edgeA.m_vertex1);this.m_v2.Copy(edgeA.m_vertex2);this.m_v3.Copy(edgeA.m_vertex3);const hasVertex0=edgeA.m_hasVertex0;const hasVertex3=edgeA.m_hasVertex3;const edge1=b2Vec2.SubVV(this.m_v2,this.m_v1,b2EPCollider.s_edge1);edge1.Normalize();this.m_normal1.Set(edge1.y,-edge1.x);const offset1=b2Vec2.DotVV(this.m_normal1,b2Vec2.SubVV(this.m_centroidB,this.m_v1,b2Vec2.s_t0));let offset0=0;let offset2=0;let convex1=false;let convex2=false;if(hasVertex0){const edge0=b2Vec2.SubVV(this.m_v1,this.m_v0,b2EPCollider.s_edge0);edge0.Normalize();this.m_normal0.Set(edge0.y,-edge0.x);convex1=b2Vec2.CrossVV(edge0,edge1)>=0;offset0=b2Vec2.DotVV(this.m_normal0,b2Vec2.SubVV(this.m_centroidB,this.m_v0,b2Vec2.s_t0));}if(hasVertex3){const edge2=b2Vec2.SubVV(this.m_v3,this.m_v2,b2EPCollider.s_edge2);edge2.Normalize();this.m_normal2.Set(edge2.y,-edge2.x);convex2=b2Vec2.CrossVV(edge1,edge2)>0;offset2=b2Vec2.DotVV(this.m_normal2,b2Vec2.SubVV(this.m_centroidB,this.m_v2,b2Vec2.s_t0));}if(hasVertex0&&hasVertex3){if(convex1&&convex2){this.m_front=offset0>=0||offset1>=0||offset2>=0;if(this.m_front){this.m_normal.Copy(this.m_normal1);this.m_lowerLimit.Copy(this.m_normal0);this.m_upperLimit.Copy(this.m_normal2);}else {this.m_normal.Copy(this.m_normal1).SelfNeg();this.m_lowerLimit.Copy(this.m_normal1).SelfNeg();this.m_upperLimit.Copy(this.m_normal1).SelfNeg();}}else if(convex1){this.m_front=offset0>=0||offset1>=0&&offset2>=0;if(this.m_front){this.m_normal.Copy(this.m_normal1);this.m_lowerLimit.Copy(this.m_normal0);this.m_upperLimit.Copy(this.m_normal1);}else {this.m_normal.Copy(this.m_normal1).SelfNeg();this.m_lowerLimit.Copy(this.m_normal2).SelfNeg();this.m_upperLimit.Copy(this.m_normal1).SelfNeg();}}else if(convex2){this.m_front=offset2>=0||offset0>=0&&offset1>=0;if(this.m_front){this.m_normal.Copy(this.m_normal1);this.m_lowerLimit.Copy(this.m_normal1);this.m_upperLimit.Copy(this.m_normal2);}else {this.m_normal.Copy(this.m_normal1).SelfNeg();this.m_lowerLimit.Copy(this.m_normal1).SelfNeg();this.m_upperLimit.Copy(this.m_normal0).SelfNeg();}}else {this.m_front=offset0>=0&&offset1>=0&&offset2>=0;if(this.m_front){this.m_normal.Copy(this.m_normal1);this.m_lowerLimit.Copy(this.m_normal1);this.m_upperLimit.Copy(this.m_normal1);}else {this.m_normal.Copy(this.m_normal1).SelfNeg();this.m_lowerLimit.Copy(this.m_normal2).SelfNeg();this.m_upperLimit.Copy(this.m_normal0).SelfNeg();}}}else if(hasVertex0){if(convex1){this.m_front=offset0>=0||offset1>=0;if(this.m_front){this.m_normal.Copy(this.m_normal1);this.m_lowerLimit.Copy(this.m_normal0);this.m_upperLimit.Copy(this.m_normal1).SelfNeg();}else {this.m_normal.Copy(this.m_normal1).SelfNeg();this.m_lowerLimit.Copy(this.m_normal1);this.m_upperLimit.Copy(this.m_normal1).SelfNeg();}}else {this.m_front=offset0>=0&&offset1>=0;if(this.m_front){this.m_normal.Copy(this.m_normal1);this.m_lowerLimit.Copy(this.m_normal1);this.m_upperLimit.Copy(this.m_normal1).SelfNeg();}else {this.m_normal.Copy(this.m_normal1).SelfNeg();this.m_lowerLimit.Copy(this.m_normal1);this.m_upperLimit.Copy(this.m_normal0).SelfNeg();}}}else if(hasVertex3){if(convex2){this.m_front=offset1>=0||offset2>=0;if(this.m_front){this.m_normal.Copy(this.m_normal1);this.m_lowerLimit.Copy(this.m_normal1).SelfNeg();this.m_upperLimit.Copy(this.m_normal2);}else {this.m_normal.Copy(this.m_normal1).SelfNeg();this.m_lowerLimit.Copy(this.m_normal1).SelfNeg();this.m_upperLimit.Copy(this.m_normal1);}}else {this.m_front=offset1>=0&&offset2>=0;if(this.m_front){this.m_normal.Copy(this.m_normal1);this.m_lowerLimit.Copy(this.m_normal1).SelfNeg();this.m_upperLimit.Copy(this.m_normal1);}else {this.m_normal.Copy(this.m_normal1).SelfNeg();this.m_lowerLimit.Copy(this.m_normal2).SelfNeg();this.m_upperLimit.Copy(this.m_normal1);}}}else {this.m_front=offset1>=0;if(this.m_front){this.m_normal.Copy(this.m_normal1);this.m_lowerLimit.Copy(this.m_normal1).SelfNeg();this.m_upperLimit.Copy(this.m_normal1).SelfNeg();}else {this.m_normal.Copy(this.m_normal1).SelfNeg();this.m_lowerLimit.Copy(this.m_normal1);this.m_upperLimit.Copy(this.m_normal1);}}this.m_polygonB.count=polygonB.m_count;for(let i=0;i<polygonB.m_count;++i){if(this.m_polygonB.vertices.length<=i){this.m_polygonB.vertices.push(new b2Vec2());}if(this.m_polygonB.normals.length<=i){this.m_polygonB.normals.push(new b2Vec2());}b2Transform.MulXV(this.m_xf,polygonB.m_vertices[i],this.m_polygonB.vertices[i]);b2Rot.MulRV(this.m_xf.q,polygonB.m_normals[i],this.m_polygonB.normals[i]);}this.m_radius=polygonB.m_radius+edgeA.m_radius;manifold.pointCount=0;const edgeAxis=this.ComputeEdgeSeparation(b2EPCollider.s_edgeAxis);if(edgeAxis.type===b2EPAxisType.e_unknown){return;}if(edgeAxis.separation>this.m_radius){return;}const polygonAxis=this.ComputePolygonSeparation(b2EPCollider.s_polygonAxis);if(polygonAxis.type!==b2EPAxisType.e_unknown&&polygonAxis.separation>this.m_radius){return;}const k_relativeTol=0.98;const k_absoluteTol=0.001;let primaryAxis;if(polygonAxis.type===b2EPAxisType.e_unknown){primaryAxis=edgeAxis;}else if(polygonAxis.separation>k_relativeTol*edgeAxis.separation+k_absoluteTol){primaryAxis=polygonAxis;}else {primaryAxis=edgeAxis;}const ie=b2EPCollider.s_ie;const rf=b2EPCollider.s_rf;if(primaryAxis.type===b2EPAxisType.e_edgeA){manifold.type=exports.b2ManifoldType.e_faceA;let bestIndex=0;let bestValue=b2Vec2.DotVV(this.m_normal,this.m_polygonB.normals[0]);for(let i=1;i<this.m_polygonB.count;++i){const value=b2Vec2.DotVV(this.m_normal,this.m_polygonB.normals[i]);if(value<bestValue){bestValue=value;bestIndex=i;}}const i1=bestIndex;const i2=(i1+1)%this.m_polygonB.count;const ie0=ie[0];ie0.v.Copy(this.m_polygonB.vertices[i1]);ie0.id.cf.indexA=0;ie0.id.cf.indexB=i1;ie0.id.cf.typeA=exports.b2ContactFeatureType.e_face;ie0.id.cf.typeB=exports.b2ContactFeatureType.e_vertex;const ie1=ie[1];ie1.v.Copy(this.m_polygonB.vertices[i2]);ie1.id.cf.indexA=0;ie1.id.cf.indexB=i2;ie1.id.cf.typeA=exports.b2ContactFeatureType.e_face;ie1.id.cf.typeB=exports.b2ContactFeatureType.e_vertex;if(this.m_front){rf.i1=0;rf.i2=1;rf.v1.Copy(this.m_v1);rf.v2.Copy(this.m_v2);rf.normal.Copy(this.m_normal1);}else {rf.i1=1;rf.i2=0;rf.v1.Copy(this.m_v2);rf.v2.Copy(this.m_v1);rf.normal.Copy(this.m_normal1).SelfNeg();}}else {manifold.type=exports.b2ManifoldType.e_faceB;const ie0=ie[0];ie0.v.Copy(this.m_v1);ie0.id.cf.indexA=0;ie0.id.cf.indexB=primaryAxis.index;ie0.id.cf.typeA=exports.b2ContactFeatureType.e_vertex;ie0.id.cf.typeB=exports.b2ContactFeatureType.e_face;const ie1=ie[1];ie1.v.Copy(this.m_v2);ie1.id.cf.indexA=0;ie1.id.cf.indexB=primaryAxis.index;ie1.id.cf.typeA=exports.b2ContactFeatureType.e_vertex;ie1.id.cf.typeB=exports.b2ContactFeatureType.e_face;rf.i1=primaryAxis.index;rf.i2=(rf.i1+1)%this.m_polygonB.count;rf.v1.Copy(this.m_polygonB.vertices[rf.i1]);rf.v2.Copy(this.m_polygonB.vertices[rf.i2]);rf.normal.Copy(this.m_polygonB.normals[rf.i1]);}rf.sideNormal1.Set(rf.normal.y,-rf.normal.x);rf.sideNormal2.Copy(rf.sideNormal1).SelfNeg();rf.sideOffset1=b2Vec2.DotVV(rf.sideNormal1,rf.v1);rf.sideOffset2=b2Vec2.DotVV(rf.sideNormal2,rf.v2);const clipPoints1=b2EPCollider.s_clipPoints1;const clipPoints2=b2EPCollider.s_clipPoints2;let np=0;np=b2ClipSegmentToLine(clipPoints1,ie,rf.sideNormal1,rf.sideOffset1,rf.i1);if(np<b2_maxManifoldPoints){return;}np=b2ClipSegmentToLine(clipPoints2,clipPoints1,rf.sideNormal2,rf.sideOffset2,rf.i2);if(np<b2_maxManifoldPoints){return;}if(primaryAxis.type===b2EPAxisType.e_edgeA){manifold.localNormal.Copy(rf.normal);manifold.localPoint.Copy(rf.v1);}else {manifold.localNormal.Copy(polygonB.m_normals[rf.i1]);manifold.localPoint.Copy(polygonB.m_vertices[rf.i1]);}let pointCount=0;for(let i=0;i<b2_maxManifoldPoints;++i){let separation;separation=b2Vec2.DotVV(rf.normal,b2Vec2.SubVV(clipPoints2[i].v,rf.v1,b2Vec2.s_t0));if(separation<=this.m_radius){const cp=manifold.points[pointCount];if(primaryAxis.type===b2EPAxisType.e_edgeA){b2Transform.MulTXV(this.m_xf,clipPoints2[i].v,cp.localPoint);cp.id.Copy(clipPoints2[i].id);}else {cp.localPoint.Copy(clipPoints2[i].v);cp.id.cf.typeA=clipPoints2[i].id.cf.typeB;cp.id.cf.typeB=clipPoints2[i].id.cf.typeA;cp.id.cf.indexA=clipPoints2[i].id.cf.indexB;cp.id.cf.indexB=clipPoints2[i].id.cf.indexA;}++pointCount;}}manifold.pointCount=pointCount;}ComputeEdgeSeparation(out){const axis=out;axis.type=b2EPAxisType.e_edgeA;axis.index=this.m_front?0:1;axis.separation=b2_maxFloat;for(let i=0;i<this.m_polygonB.count;++i){const s=b2Vec2.DotVV(this.m_normal,b2Vec2.SubVV(this.m_polygonB.vertices[i],this.m_v1,b2Vec2.s_t0));if(s<axis.separation){axis.separation=s;}}return axis;}ComputePolygonSeparation(out){const axis=out;axis.type=b2EPAxisType.e_unknown;axis.index=-1;axis.separation=-b2_maxFloat;const perp=b2EPCollider.s_perp.Set(-this.m_normal.y,this.m_normal.x);for(let i=0;i<this.m_polygonB.count;++i){const n=b2Vec2.NegV(this.m_polygonB.normals[i],b2EPCollider.s_n);const s1=b2Vec2.DotVV(n,b2Vec2.SubVV(this.m_polygonB.vertices[i],this.m_v1,b2Vec2.s_t0));const s2=b2Vec2.DotVV(n,b2Vec2.SubVV(this.m_polygonB.vertices[i],this.m_v2,b2Vec2.s_t0));const s=b2Min(s1,s2);if(s>this.m_radius){axis.type=b2EPAxisType.e_edgeB;axis.index=i;axis.separation=s;return axis;}if(b2Vec2.DotVV(n,perp)>=0){if(b2Vec2.DotVV(b2Vec2.SubVV(n,this.m_upperLimit,b2Vec2.s_t0),this.m_normal)<-b2_angularSlop){continue;}}else {if(b2Vec2.DotVV(b2Vec2.SubVV(n,this.m_lowerLimit,b2Vec2.s_t0),this.m_normal)<-b2_angularSlop){continue;}}if(s>axis.separation){axis.type=b2EPAxisType.e_edgeB;axis.index=i;axis.separation=s;}}return axis;}}b2EPCollider.s_edge1=new b2Vec2();b2EPCollider.s_edge0=new b2Vec2();b2EPCollider.s_edge2=new b2Vec2();b2EPCollider.s_ie=b2ClipVertex.MakeArray(2);b2EPCollider.s_rf=new b2ReferenceFace();b2EPCollider.s_clipPoints1=b2ClipVertex.MakeArray(2);b2EPCollider.s_clipPoints2=b2ClipVertex.MakeArray(2);b2EPCollider.s_edgeAxis=new b2EPAxis();b2EPCollider.s_polygonAxis=new b2EPAxis();b2EPCollider.s_n=new b2Vec2();b2EPCollider.s_perp=new b2Vec2();const b2CollideEdgeAndPolygon_s_collider=new b2EPCollider();function b2CollideEdgeAndPolygon(manifold,edgeA,xfA,polygonB,xfB){const collider=b2CollideEdgeAndPolygon_s_collider;collider.Collide(manifold,edgeA,xfA,polygonB,xfB);}class b2MassData{constructor(){this.mass=0;this.center=new b2Vec2(0,0);this.I=0;}}(function(b2ShapeType){b2ShapeType[b2ShapeType["e_unknown"]=-1]="e_unknown";b2ShapeType[b2ShapeType["e_circleShape"]=0]="e_circleShape";b2ShapeType[b2ShapeType["e_edgeShape"]=1]="e_edgeShape";b2ShapeType[b2ShapeType["e_polygonShape"]=2]="e_polygonShape";b2ShapeType[b2ShapeType["e_chainShape"]=3]="e_chainShape";b2ShapeType[b2ShapeType["e_shapeTypeCount"]=4]="e_shapeTypeCount";})(exports.b2ShapeType||(exports.b2ShapeType={}));class b2Shape{constructor(type,radius){this.m_type=exports.b2ShapeType.e_unknown;this.m_radius=0;this.m_type=type;this.m_radius=radius;}Copy(other){this.m_radius=other.m_radius;return this;}GetType(){return this.m_type;}}class b2CircleShape extends b2Shape{constructor(radius=0){super(exports.b2ShapeType.e_circleShape,radius);this.m_p=new b2Vec2();}Set(position,radius=this.m_radius){this.m_p.Copy(position);this.m_radius=radius;return this;}Clone(){return new b2CircleShape().Copy(this);}Copy(other){super.Copy(other);this.m_p.Copy(other.m_p);return this;}GetChildCount(){return 1;}TestPoint(transform,p){const center=b2Transform.MulXV(transform,this.m_p,b2CircleShape.TestPoint_s_center);const d=b2Vec2.SubVV(p,center,b2CircleShape.TestPoint_s_d);return b2Vec2.DotVV(d,d)<=b2Sq(this.m_radius);}ComputeDistance(xf,p,normal,childIndex){const center=b2Transform.MulXV(xf,this.m_p,b2CircleShape.ComputeDistance_s_center);b2Vec2.SubVV(p,center,normal);return normal.Normalize()-this.m_radius;}RayCast(output,input,transform,childIndex){const position=b2Transform.MulXV(transform,this.m_p,b2CircleShape.RayCast_s_position);const s=b2Vec2.SubVV(input.p1,position,b2CircleShape.RayCast_s_s);const b=b2Vec2.DotVV(s,s)-b2Sq(this.m_radius);const r=b2Vec2.SubVV(input.p2,input.p1,b2CircleShape.RayCast_s_r);const c=b2Vec2.DotVV(s,r);const rr=b2Vec2.DotVV(r,r);const sigma=c*c-rr*b;if(sigma<0||rr<b2_epsilon){return false;}let a=-(c+b2Sqrt(sigma));if(0<=a&&a<=input.maxFraction*rr){a/=rr;output.fraction=a;b2Vec2.AddVMulSV(s,a,r,output.normal).SelfNormalize();return true;}return false;}ComputeAABB(aabb,transform,childIndex){const p=b2Transform.MulXV(transform,this.m_p,b2CircleShape.ComputeAABB_s_p);aabb.lowerBound.Set(p.x-this.m_radius,p.y-this.m_radius);aabb.upperBound.Set(p.x+this.m_radius,p.y+this.m_radius);}ComputeMass(massData,density){const radius_sq=b2Sq(this.m_radius);massData.mass=density*b2_pi*radius_sq;massData.center.Copy(this.m_p);massData.I=massData.mass*(0.5*radius_sq+b2Vec2.DotVV(this.m_p,this.m_p));}SetupDistanceProxy(proxy,index){proxy.m_vertices=proxy.m_buffer;proxy.m_vertices[0].Copy(this.m_p);proxy.m_count=1;proxy.m_radius=this.m_radius;}ComputeSubmergedArea(normal,offset,xf,c){const p=b2Transform.MulXV(xf,this.m_p,new b2Vec2());const l=-(b2Vec2.DotVV(normal,p)-offset);if(l<-this.m_radius+b2_epsilon){return 0;}if(l>this.m_radius){c.Copy(p);return b2_pi*this.m_radius*this.m_radius;}const r2=this.m_radius*this.m_radius;const l2=l*l;const area=r2*(b2Asin(l/this.m_radius)+b2_pi/2)+l*b2Sqrt(r2-l2);const com=-2/3*b2Pow(r2-l2,1.5)/area;c.x=p.x+normal.x*com;c.y=p.y+normal.y*com;return area;}Dump(log){log("    const shape: b2CircleShape = new b2CircleShape();\n");log("    shape.m_radius = %.15f;\n",this.m_radius);log("    shape.m_p.Set(%.15f, %.15f);\n",this.m_p.x,this.m_p.y);}}b2CircleShape.TestPoint_s_center=new b2Vec2();b2CircleShape.TestPoint_s_d=new b2Vec2();b2CircleShape.ComputeDistance_s_center=new b2Vec2();b2CircleShape.RayCast_s_position=new b2Vec2();b2CircleShape.RayCast_s_s=new b2Vec2();b2CircleShape.RayCast_s_r=new b2Vec2();b2CircleShape.ComputeAABB_s_p=new b2Vec2();class b2PolygonShape extends b2Shape{constructor(){super(exports.b2ShapeType.e_polygonShape,b2_polygonRadius);this.m_centroid=new b2Vec2(0,0);this.m_vertices=[];this.m_normals=[];this.m_count=0;}Clone(){return new b2PolygonShape().Copy(this);}Copy(other){super.Copy(other);this.m_centroid.Copy(other.m_centroid);this.m_count=other.m_count;this.m_vertices=b2Vec2.MakeArray(this.m_count);this.m_normals=b2Vec2.MakeArray(this.m_count);for(let i=0;i<this.m_count;++i){this.m_vertices[i].Copy(other.m_vertices[i]);this.m_normals[i].Copy(other.m_normals[i]);}return this;}GetChildCount(){return 1;}Set(...args){if(typeof args[0][0]==="number"){const vertices=args[0];if(vertices.length%2!==0){throw new Error();}return this._Set(index=>({x:vertices[index*2],y:vertices[index*2+1]}),vertices.length/2);}else {const vertices=args[0];const count=args[1]||vertices.length;return this._Set(index=>vertices[index],count);}}_Set(vertices,count){if(count<3){return this.SetAsBox(1,1);}let n=count;const ps=[];for(let i=0;i<n;++i){const v=vertices(i);let unique=true;for(let j=0;j<ps.length;++j){if(b2Vec2.DistanceSquaredVV(v,ps[j])<0.5*b2_linearSlop*(0.5*b2_linearSlop)){unique=false;break;}}if(unique){ps.push(v);}}n=ps.length;if(n<3){return this.SetAsBox(1.0,1.0);}let i0=0;let x0=ps[0].x;for(let i=1;i<n;++i){const x=ps[i].x;if(x>x0||x===x0&&ps[i].y<ps[i0].y){i0=i;x0=x;}}const hull=[];let m=0;let ih=i0;for(;;){hull[m]=ih;let ie=0;for(let j=1;j<n;++j){if(ie===ih){ie=j;continue;}const r=b2Vec2.SubVV(ps[ie],ps[hull[m]],b2PolygonShape.Set_s_r);const v=b2Vec2.SubVV(ps[j],ps[hull[m]],b2PolygonShape.Set_s_v);const c=b2Vec2.CrossVV(r,v);if(c<0){ie=j;}if(c===0&&v.LengthSquared()>r.LengthSquared()){ie=j;}}++m;ih=ie;if(ie===i0){break;}}this.m_count=m;this.m_vertices=b2Vec2.MakeArray(this.m_count);this.m_normals=b2Vec2.MakeArray(this.m_count);for(let i=0;i<m;++i){this.m_vertices[i].Copy(ps[hull[i]]);}for(let i=0;i<m;++i){const vertexi1=this.m_vertices[i];const vertexi2=this.m_vertices[(i+1)%m];const edge=b2Vec2.SubVV(vertexi2,vertexi1,b2Vec2.s_t0);b2Vec2.CrossVOne(edge,this.m_normals[i]).SelfNormalize();}b2PolygonShape.ComputeCentroid(this.m_vertices,m,this.m_centroid);return this;}SetAsBox(hx,hy,center,angle=0){this.m_count=4;this.m_vertices=b2Vec2.MakeArray(this.m_count);this.m_normals=b2Vec2.MakeArray(this.m_count);this.m_vertices[0].Set(-hx,-hy);this.m_vertices[1].Set(hx,-hy);this.m_vertices[2].Set(hx,hy);this.m_vertices[3].Set(-hx,hy);this.m_normals[0].Set(0,-1);this.m_normals[1].Set(1,0);this.m_normals[2].Set(0,1);this.m_normals[3].Set(-1,0);this.m_centroid.SetZero();if(center){this.m_centroid.Copy(center);const xf=new b2Transform();xf.SetPosition(center);xf.SetRotationAngle(angle);for(let i=0;i<this.m_count;++i){b2Transform.MulXV(xf,this.m_vertices[i],this.m_vertices[i]);b2Rot.MulRV(xf.q,this.m_normals[i],this.m_normals[i]);}}return this;}TestPoint(xf,p){const pLocal=b2Transform.MulTXV(xf,p,b2PolygonShape.TestPoint_s_pLocal);for(let i=0;i<this.m_count;++i){const dot=b2Vec2.DotVV(this.m_normals[i],b2Vec2.SubVV(pLocal,this.m_vertices[i],b2Vec2.s_t0));if(dot>0){return false;}}return true;}ComputeDistance(xf,p,normal,childIndex){const pLocal=b2Transform.MulTXV(xf,p,b2PolygonShape.ComputeDistance_s_pLocal);let maxDistance=-b2_maxFloat;const normalForMaxDistance=b2PolygonShape.ComputeDistance_s_normalForMaxDistance.Copy(pLocal);for(let i=0;i<this.m_count;++i){const dot=b2Vec2.DotVV(this.m_normals[i],b2Vec2.SubVV(pLocal,this.m_vertices[i],b2Vec2.s_t0));if(dot>maxDistance){maxDistance=dot;normalForMaxDistance.Copy(this.m_normals[i]);}}if(maxDistance>0){const minDistance=b2PolygonShape.ComputeDistance_s_minDistance.Copy(normalForMaxDistance);let minDistance2=maxDistance*maxDistance;for(let i=0;i<this.m_count;++i){const distance=b2Vec2.SubVV(pLocal,this.m_vertices[i],b2PolygonShape.ComputeDistance_s_distance);const distance2=distance.LengthSquared();if(minDistance2>distance2){minDistance.Copy(distance);minDistance2=distance2;}}b2Rot.MulRV(xf.q,minDistance,normal);normal.Normalize();return Math.sqrt(minDistance2);}else {b2Rot.MulRV(xf.q,normalForMaxDistance,normal);return maxDistance;}}RayCast(output,input,xf,childIndex){const p1=b2Transform.MulTXV(xf,input.p1,b2PolygonShape.RayCast_s_p1);const p2=b2Transform.MulTXV(xf,input.p2,b2PolygonShape.RayCast_s_p2);const d=b2Vec2.SubVV(p2,p1,b2PolygonShape.RayCast_s_d);let lower=0,upper=input.maxFraction;let index=-1;for(let i=0;i<this.m_count;++i){const numerator=b2Vec2.DotVV(this.m_normals[i],b2Vec2.SubVV(this.m_vertices[i],p1,b2Vec2.s_t0));const denominator=b2Vec2.DotVV(this.m_normals[i],d);if(denominator===0){if(numerator<0){return false;}}else {if(denominator<0&&numerator<lower*denominator){lower=numerator/denominator;index=i;}else if(denominator>0&&numerator<upper*denominator){upper=numerator/denominator;}}if(upper<lower){return false;}}if(index>=0){output.fraction=lower;b2Rot.MulRV(xf.q,this.m_normals[index],output.normal);return true;}return false;}ComputeAABB(aabb,xf,childIndex){const lower=b2Transform.MulXV(xf,this.m_vertices[0],aabb.lowerBound);const upper=aabb.upperBound.Copy(lower);for(let i=0;i<this.m_count;++i){const v=b2Transform.MulXV(xf,this.m_vertices[i],b2PolygonShape.ComputeAABB_s_v);b2Vec2.MinV(v,lower,lower);b2Vec2.MaxV(v,upper,upper);}const r=this.m_radius;lower.SelfSubXY(r,r);upper.SelfAddXY(r,r);}ComputeMass(massData,density){const center=b2PolygonShape.ComputeMass_s_center.SetZero();let area=0;let I=0;const s=b2PolygonShape.ComputeMass_s_s.SetZero();for(let i=0;i<this.m_count;++i){s.SelfAdd(this.m_vertices[i]);}s.SelfMul(1/this.m_count);const k_inv3=1/3;for(let i=0;i<this.m_count;++i){const e1=b2Vec2.SubVV(this.m_vertices[i],s,b2PolygonShape.ComputeMass_s_e1);const e2=b2Vec2.SubVV(this.m_vertices[(i+1)%this.m_count],s,b2PolygonShape.ComputeMass_s_e2);const D=b2Vec2.CrossVV(e1,e2);const triangleArea=0.5*D;area+=triangleArea;center.SelfAdd(b2Vec2.MulSV(triangleArea*k_inv3,b2Vec2.AddVV(e1,e2,b2Vec2.s_t0),b2Vec2.s_t1));const ex1=e1.x;const ey1=e1.y;const ex2=e2.x;const ey2=e2.y;const intx2=ex1*ex1+ex2*ex1+ex2*ex2;const inty2=ey1*ey1+ey2*ey1+ey2*ey2;I+=0.25*k_inv3*D*(intx2+inty2);}massData.mass=density*area;center.SelfMul(1/area);b2Vec2.AddVV(center,s,massData.center);massData.I=density*I;massData.I+=massData.mass*(b2Vec2.DotVV(massData.center,massData.center)-b2Vec2.DotVV(center,center));}Validate(){for(let i=0;i<this.m_count;++i){const i1=i;const i2=(i+1)%this.m_count;const p=this.m_vertices[i1];const e=b2Vec2.SubVV(this.m_vertices[i2],p,b2PolygonShape.Validate_s_e);for(let j=0;j<this.m_count;++j){if(j===i1||j===i2){continue;}const v=b2Vec2.SubVV(this.m_vertices[j],p,b2PolygonShape.Validate_s_v);const c=b2Vec2.CrossVV(e,v);if(c<0){return false;}}}return true;}SetupDistanceProxy(proxy,index){proxy.m_vertices=this.m_vertices;proxy.m_count=this.m_count;proxy.m_radius=this.m_radius;}ComputeSubmergedArea(normal,offset,xf,c){const normalL=b2Rot.MulTRV(xf.q,normal,b2PolygonShape.ComputeSubmergedArea_s_normalL);const offsetL=offset-b2Vec2.DotVV(normal,xf.p);const depths=[];let diveCount=0;let intoIndex=-1;let outoIndex=-1;let lastSubmerged=false;for(let i=0;i<this.m_count;++i){depths[i]=b2Vec2.DotVV(normalL,this.m_vertices[i])-offsetL;const isSubmerged=depths[i]<-b2_epsilon;if(i>0){if(isSubmerged){if(!lastSubmerged){intoIndex=i-1;diveCount++;}}else {if(lastSubmerged){outoIndex=i-1;diveCount++;}}}lastSubmerged=isSubmerged;}switch(diveCount){case 0:if(lastSubmerged){const md=b2PolygonShape.ComputeSubmergedArea_s_md;this.ComputeMass(md,1);b2Transform.MulXV(xf,md.center,c);return md.mass;}else {return 0;}case 1:if(intoIndex===-1){intoIndex=this.m_count-1;}else {outoIndex=this.m_count-1;}break;}const intoIndex2=(intoIndex+1)%this.m_count;const outoIndex2=(outoIndex+1)%this.m_count;const intoLamdda=(0-depths[intoIndex])/(depths[intoIndex2]-depths[intoIndex]);const outoLamdda=(0-depths[outoIndex])/(depths[outoIndex2]-depths[outoIndex]);const intoVec=b2PolygonShape.ComputeSubmergedArea_s_intoVec.Set(this.m_vertices[intoIndex].x*(1-intoLamdda)+this.m_vertices[intoIndex2].x*intoLamdda,this.m_vertices[intoIndex].y*(1-intoLamdda)+this.m_vertices[intoIndex2].y*intoLamdda);const outoVec=b2PolygonShape.ComputeSubmergedArea_s_outoVec.Set(this.m_vertices[outoIndex].x*(1-outoLamdda)+this.m_vertices[outoIndex2].x*outoLamdda,this.m_vertices[outoIndex].y*(1-outoLamdda)+this.m_vertices[outoIndex2].y*outoLamdda);let area=0;const center=b2PolygonShape.ComputeSubmergedArea_s_center.SetZero();let p2=this.m_vertices[intoIndex2];let p3;let i=intoIndex2;while(i!==outoIndex2){i=(i+1)%this.m_count;if(i===outoIndex2){p3=outoVec;}else {p3=this.m_vertices[i];}const triangleArea=0.5*((p2.x-intoVec.x)*(p3.y-intoVec.y)-(p2.y-intoVec.y)*(p3.x-intoVec.x));area+=triangleArea;center.x+=triangleArea*(intoVec.x+p2.x+p3.x)/3;center.y+=triangleArea*(intoVec.y+p2.y+p3.y)/3;p2=p3;}center.SelfMul(1/area);b2Transform.MulXV(xf,center,c);return area;}Dump(log){log("    const shape: b2PolygonShape = new b2PolygonShape();\n");log("    const vs: b2Vec2[] = [];\n");for(let i=0;i<this.m_count;++i){log("    vs[%d] = new b2Vec2(%.15f, %.15f);\n",i,this.m_vertices[i].x,this.m_vertices[i].y);}log("    shape.Set(vs, %d);\n",this.m_count);}static ComputeCentroid(vs,count,out){const c=out;c.SetZero();let area=0;const pRef=b2PolygonShape.ComputeCentroid_s_pRef.SetZero();const inv3=1/3;for(let i=0;i<count;++i){const p1=pRef;const p2=vs[i];const p3=vs[(i+1)%count];const e1=b2Vec2.SubVV(p2,p1,b2PolygonShape.ComputeCentroid_s_e1);const e2=b2Vec2.SubVV(p3,p1,b2PolygonShape.ComputeCentroid_s_e2);const D=b2Vec2.CrossVV(e1,e2);const triangleArea=0.5*D;area+=triangleArea;c.x+=triangleArea*inv3*(p1.x+p2.x+p3.x);c.y+=triangleArea*inv3*(p1.y+p2.y+p3.y);}c.SelfMul(1/area);return c;}}b2PolygonShape.Set_s_r=new b2Vec2();b2PolygonShape.Set_s_v=new b2Vec2();b2PolygonShape.TestPoint_s_pLocal=new b2Vec2();b2PolygonShape.ComputeDistance_s_pLocal=new b2Vec2();b2PolygonShape.ComputeDistance_s_normalForMaxDistance=new b2Vec2();b2PolygonShape.ComputeDistance_s_minDistance=new b2Vec2();b2PolygonShape.ComputeDistance_s_distance=new b2Vec2();b2PolygonShape.RayCast_s_p1=new b2Vec2();b2PolygonShape.RayCast_s_p2=new b2Vec2();b2PolygonShape.RayCast_s_d=new b2Vec2();b2PolygonShape.ComputeAABB_s_v=new b2Vec2();b2PolygonShape.ComputeMass_s_center=new b2Vec2();b2PolygonShape.ComputeMass_s_s=new b2Vec2();b2PolygonShape.ComputeMass_s_e1=new b2Vec2();b2PolygonShape.ComputeMass_s_e2=new b2Vec2();b2PolygonShape.Validate_s_e=new b2Vec2();b2PolygonShape.Validate_s_v=new b2Vec2();b2PolygonShape.ComputeSubmergedArea_s_normalL=new b2Vec2();b2PolygonShape.ComputeSubmergedArea_s_md=new b2MassData();b2PolygonShape.ComputeSubmergedArea_s_intoVec=new b2Vec2();b2PolygonShape.ComputeSubmergedArea_s_outoVec=new b2Vec2();b2PolygonShape.ComputeSubmergedArea_s_center=new b2Vec2();b2PolygonShape.ComputeCentroid_s_pRef=new b2Vec2();b2PolygonShape.ComputeCentroid_s_e1=new b2Vec2();b2PolygonShape.ComputeCentroid_s_e2=new b2Vec2();class b2EdgeShape extends b2Shape{constructor(){super(exports.b2ShapeType.e_edgeShape,b2_polygonRadius);this.m_vertex1=new b2Vec2();this.m_vertex2=new b2Vec2();this.m_vertex0=new b2Vec2();this.m_vertex3=new b2Vec2();this.m_hasVertex0=false;this.m_hasVertex3=false;}Set(v1,v2){this.m_vertex1.Copy(v1);this.m_vertex2.Copy(v2);this.m_hasVertex0=false;this.m_hasVertex3=false;return this;}Clone(){return new b2EdgeShape().Copy(this);}Copy(other){super.Copy(other);this.m_vertex1.Copy(other.m_vertex1);this.m_vertex2.Copy(other.m_vertex2);this.m_vertex0.Copy(other.m_vertex0);this.m_vertex3.Copy(other.m_vertex3);this.m_hasVertex0=other.m_hasVertex0;this.m_hasVertex3=other.m_hasVertex3;return this;}GetChildCount(){return 1;}TestPoint(xf,p){return false;}ComputeDistance(xf,p,normal,childIndex){const v1=b2Transform.MulXV(xf,this.m_vertex1,b2EdgeShape.ComputeDistance_s_v1);const v2=b2Transform.MulXV(xf,this.m_vertex2,b2EdgeShape.ComputeDistance_s_v2);const d=b2Vec2.SubVV(p,v1,b2EdgeShape.ComputeDistance_s_d);const s=b2Vec2.SubVV(v2,v1,b2EdgeShape.ComputeDistance_s_s);const ds=b2Vec2.DotVV(d,s);if(ds>0){const s2=b2Vec2.DotVV(s,s);if(ds>s2){b2Vec2.SubVV(p,v2,d);}else {d.SelfMulSub(ds/s2,s);}}normal.Copy(d);return normal.Normalize();}RayCast(output,input,xf,childIndex){const p1=b2Transform.MulTXV(xf,input.p1,b2EdgeShape.RayCast_s_p1);const p2=b2Transform.MulTXV(xf,input.p2,b2EdgeShape.RayCast_s_p2);const d=b2Vec2.SubVV(p2,p1,b2EdgeShape.RayCast_s_d);const v1=this.m_vertex1;const v2=this.m_vertex2;const e=b2Vec2.SubVV(v2,v1,b2EdgeShape.RayCast_s_e);const normal=output.normal.Set(e.y,-e.x).SelfNormalize();const numerator=b2Vec2.DotVV(normal,b2Vec2.SubVV(v1,p1,b2Vec2.s_t0));const denominator=b2Vec2.DotVV(normal,d);if(denominator===0){return false;}const t=numerator/denominator;if(t<0||input.maxFraction<t){return false;}const q=b2Vec2.AddVMulSV(p1,t,d,b2EdgeShape.RayCast_s_q);const r=b2Vec2.SubVV(v2,v1,b2EdgeShape.RayCast_s_r);const rr=b2Vec2.DotVV(r,r);if(rr===0){return false;}const s=b2Vec2.DotVV(b2Vec2.SubVV(q,v1,b2Vec2.s_t0),r)/rr;if(s<0||1<s){return false;}output.fraction=t;b2Rot.MulRV(xf.q,output.normal,output.normal);if(numerator>0){output.normal.SelfNeg();}return true;}ComputeAABB(aabb,xf,childIndex){const v1=b2Transform.MulXV(xf,this.m_vertex1,b2EdgeShape.ComputeAABB_s_v1);const v2=b2Transform.MulXV(xf,this.m_vertex2,b2EdgeShape.ComputeAABB_s_v2);b2Vec2.MinV(v1,v2,aabb.lowerBound);b2Vec2.MaxV(v1,v2,aabb.upperBound);const r=this.m_radius;aabb.lowerBound.SelfSubXY(r,r);aabb.upperBound.SelfAddXY(r,r);}ComputeMass(massData,density){massData.mass=0;b2Vec2.MidVV(this.m_vertex1,this.m_vertex2,massData.center);massData.I=0;}SetupDistanceProxy(proxy,index){proxy.m_vertices=proxy.m_buffer;proxy.m_vertices[0].Copy(this.m_vertex1);proxy.m_vertices[1].Copy(this.m_vertex2);proxy.m_count=2;proxy.m_radius=this.m_radius;}ComputeSubmergedArea(normal,offset,xf,c){c.SetZero();return 0;}Dump(log){log("    const shape: b2EdgeShape = new b2EdgeShape();\n");log("    shape.m_radius = %.15f;\n",this.m_radius);log("    shape.m_vertex0.Set(%.15f, %.15f);\n",this.m_vertex0.x,this.m_vertex0.y);log("    shape.m_vertex1.Set(%.15f, %.15f);\n",this.m_vertex1.x,this.m_vertex1.y);log("    shape.m_vertex2.Set(%.15f, %.15f);\n",this.m_vertex2.x,this.m_vertex2.y);log("    shape.m_vertex3.Set(%.15f, %.15f);\n",this.m_vertex3.x,this.m_vertex3.y);log("    shape.m_hasVertex0 = %s;\n",this.m_hasVertex0);log("    shape.m_hasVertex3 = %s;\n",this.m_hasVertex3);}}b2EdgeShape.ComputeDistance_s_v1=new b2Vec2();b2EdgeShape.ComputeDistance_s_v2=new b2Vec2();b2EdgeShape.ComputeDistance_s_d=new b2Vec2();b2EdgeShape.ComputeDistance_s_s=new b2Vec2();b2EdgeShape.RayCast_s_p1=new b2Vec2();b2EdgeShape.RayCast_s_p2=new b2Vec2();b2EdgeShape.RayCast_s_d=new b2Vec2();b2EdgeShape.RayCast_s_e=new b2Vec2();b2EdgeShape.RayCast_s_q=new b2Vec2();b2EdgeShape.RayCast_s_r=new b2Vec2();b2EdgeShape.ComputeAABB_s_v1=new b2Vec2();b2EdgeShape.ComputeAABB_s_v2=new b2Vec2();class b2ChainShape extends b2Shape{constructor(){super(exports.b2ShapeType.e_chainShape,b2_polygonRadius);this.m_vertices=[];this.m_count=0;this.m_prevVertex=new b2Vec2();this.m_nextVertex=new b2Vec2();this.m_hasPrevVertex=false;this.m_hasNextVertex=false;}CreateLoop(...args){if(typeof args[0][0]==="number"){const vertices=args[0];if(vertices.length%2!==0){throw new Error();}return this._CreateLoop(index=>({x:vertices[index*2],y:vertices[index*2+1]}),vertices.length/2);}else {const vertices=args[0];const count=args[1]||vertices.length;return this._CreateLoop(index=>vertices[index],count);}}_CreateLoop(vertices,count){if(count<3){return this;}this.m_count=count+1;this.m_vertices=b2Vec2.MakeArray(this.m_count);for(let i=0;i<count;++i){this.m_vertices[i].Copy(vertices(i));}this.m_vertices[count].Copy(this.m_vertices[0]);this.m_prevVertex.Copy(this.m_vertices[this.m_count-2]);this.m_nextVertex.Copy(this.m_vertices[1]);this.m_hasPrevVertex=true;this.m_hasNextVertex=true;return this;}CreateChain(...args){if(typeof args[0][0]==="number"){const vertices=args[0];if(vertices.length%2!==0){throw new Error();}return this._CreateChain(index=>({x:vertices[index*2],y:vertices[index*2+1]}),vertices.length/2);}else {const vertices=args[0];const count=args[1]||vertices.length;return this._CreateChain(index=>vertices[index],count);}}_CreateChain(vertices,count){this.m_count=count;this.m_vertices=b2Vec2.MakeArray(count);for(let i=0;i<count;++i){this.m_vertices[i].Copy(vertices(i));}this.m_hasPrevVertex=false;this.m_hasNextVertex=false;this.m_prevVertex.SetZero();this.m_nextVertex.SetZero();return this;}SetPrevVertex(prevVertex){this.m_prevVertex.Copy(prevVertex);this.m_hasPrevVertex=true;return this;}SetNextVertex(nextVertex){this.m_nextVertex.Copy(nextVertex);this.m_hasNextVertex=true;return this;}Clone(){return new b2ChainShape().Copy(this);}Copy(other){super.Copy(other);this._CreateChain(index=>other.m_vertices[index],other.m_count);this.m_prevVertex.Copy(other.m_prevVertex);this.m_nextVertex.Copy(other.m_nextVertex);this.m_hasPrevVertex=other.m_hasPrevVertex;this.m_hasNextVertex=other.m_hasNextVertex;return this;}GetChildCount(){return this.m_count-1;}GetChildEdge(edge,index){edge.m_radius=this.m_radius;edge.m_vertex1.Copy(this.m_vertices[index]);edge.m_vertex2.Copy(this.m_vertices[index+1]);if(index>0){edge.m_vertex0.Copy(this.m_vertices[index-1]);edge.m_hasVertex0=true;}else {edge.m_vertex0.Copy(this.m_prevVertex);edge.m_hasVertex0=this.m_hasPrevVertex;}if(index<this.m_count-2){edge.m_vertex3.Copy(this.m_vertices[index+2]);edge.m_hasVertex3=true;}else {edge.m_vertex3.Copy(this.m_nextVertex);edge.m_hasVertex3=this.m_hasNextVertex;}}TestPoint(xf,p){return false;}ComputeDistance(xf,p,normal,childIndex){const edge=b2ChainShape.ComputeDistance_s_edgeShape;this.GetChildEdge(edge,childIndex);return edge.ComputeDistance(xf,p,normal,0);}RayCast(output,input,xf,childIndex){const edgeShape=b2ChainShape.RayCast_s_edgeShape;edgeShape.m_vertex1.Copy(this.m_vertices[childIndex]);edgeShape.m_vertex2.Copy(this.m_vertices[(childIndex+1)%this.m_count]);return edgeShape.RayCast(output,input,xf,0);}ComputeAABB(aabb,xf,childIndex){const vertexi1=this.m_vertices[childIndex];const vertexi2=this.m_vertices[(childIndex+1)%this.m_count];const v1=b2Transform.MulXV(xf,vertexi1,b2ChainShape.ComputeAABB_s_v1);const v2=b2Transform.MulXV(xf,vertexi2,b2ChainShape.ComputeAABB_s_v2);b2Vec2.MinV(v1,v2,aabb.lowerBound);b2Vec2.MaxV(v1,v2,aabb.upperBound);}ComputeMass(massData,density){massData.mass=0;massData.center.SetZero();massData.I=0;}SetupDistanceProxy(proxy,index){proxy.m_vertices=proxy.m_buffer;proxy.m_vertices[0].Copy(this.m_vertices[index]);if(index+1<this.m_count){proxy.m_vertices[1].Copy(this.m_vertices[index+1]);}else {proxy.m_vertices[1].Copy(this.m_vertices[0]);}proxy.m_count=2;proxy.m_radius=this.m_radius;}ComputeSubmergedArea(normal,offset,xf,c){c.SetZero();return 0;}Dump(log){log("    const shape: b2ChainShape = new b2ChainShape();\n");log("    const vs: b2Vec2[] = [];\n");for(let i=0;i<this.m_count;++i){log("    vs[%d] = new bVec2(%.15f, %.15f);\n",i,this.m_vertices[i].x,this.m_vertices[i].y);}log("    shape.CreateChain(vs, %d);\n",this.m_count);log("    shape.m_prevVertex.Set(%.15f, %.15f);\n",this.m_prevVertex.x,this.m_prevVertex.y);log("    shape.m_nextVertex.Set(%.15f, %.15f);\n",this.m_nextVertex.x,this.m_nextVertex.y);log("    shape.m_hasPrevVertex = %s;\n",this.m_hasPrevVertex?"true":"false");log("    shape.m_hasNextVertex = %s;\n",this.m_hasNextVertex?"true":"false");}}b2ChainShape.ComputeDistance_s_edgeShape=new b2EdgeShape();b2ChainShape.RayCast_s_edgeShape=new b2EdgeShape();b2ChainShape.ComputeAABB_s_v1=new b2Vec2();b2ChainShape.ComputeAABB_s_v2=new b2Vec2();class b2Filter{constructor(){this.categoryBits=0x0001;this.maskBits=0xFFFF;this.groupIndex=0;}Clone(){return new b2Filter().Copy(this);}Copy(other){this.categoryBits=other.categoryBits;this.maskBits=other.maskBits;this.groupIndex=other.groupIndex||0;return this;}}b2Filter.DEFAULT=new b2Filter();class b2FixtureDef{constructor(){this.userData=null;this.friction=0.2;this.restitution=0;this.density=0;this.isSensor=false;this.filter=new b2Filter();}}class b2FixtureProxy{constructor(fixture,childIndex){this.aabb=new b2AABB();this.childIndex=0;this.fixture=fixture;this.childIndex=childIndex;this.fixture.m_shape.ComputeAABB(this.aabb,this.fixture.m_body.GetTransform(),childIndex);this.treeNode=this.fixture.m_body.m_world.m_contactManager.m_broadPhase.CreateProxy(this.aabb,this);}Reset(){this.fixture.m_body.m_world.m_contactManager.m_broadPhase.DestroyProxy(this.treeNode);}Touch(){this.fixture.m_body.m_world.m_contactManager.m_broadPhase.TouchProxy(this.treeNode);}Synchronize(transform1,transform2,displacement){if(transform1===transform2){this.fixture.m_shape.ComputeAABB(this.aabb,transform1,this.childIndex);this.fixture.m_body.m_world.m_contactManager.m_broadPhase.MoveProxy(this.treeNode,this.aabb,displacement);}else {const aabb1=b2FixtureProxy.Synchronize_s_aabb1;const aabb2=b2FixtureProxy.Synchronize_s_aabb2;this.fixture.m_shape.ComputeAABB(aabb1,transform1,this.childIndex);this.fixture.m_shape.ComputeAABB(aabb2,transform2,this.childIndex);this.aabb.Combine2(aabb1,aabb2);this.fixture.m_body.m_world.m_contactManager.m_broadPhase.MoveProxy(this.treeNode,this.aabb,displacement);}}}b2FixtureProxy.Synchronize_s_aabb1=new b2AABB();b2FixtureProxy.Synchronize_s_aabb2=new b2AABB();class b2Fixture{constructor(body,def){this.m_density=0;this.m_next=null;this.m_friction=0;this.m_restitution=0;this.m_proxies=[];this.m_filter=new b2Filter();this.m_isSensor=false;this.m_userData=null;this.m_body=body;this.m_shape=def.shape.Clone();this.m_userData=b2Maybe(def.userData,null);this.m_friction=b2Maybe(def.friction,0.2);this.m_restitution=b2Maybe(def.restitution,0);this.m_filter.Copy(b2Maybe(def.filter,b2Filter.DEFAULT));this.m_isSensor=b2Maybe(def.isSensor,false);this.m_density=b2Maybe(def.density,0);}get m_proxyCount(){return this.m_proxies.length;}Reset(){}GetType(){return this.m_shape.GetType();}GetShape(){return this.m_shape;}SetSensor(sensor){if(sensor!==this.m_isSensor){this.m_body.SetAwake(true);this.m_isSensor=sensor;}}IsSensor(){return this.m_isSensor;}SetFilterData(filter){this.m_filter.Copy(filter);this.Refilter();}GetFilterData(){return this.m_filter;}Refilter(){let edge=this.m_body.GetContactList();while(edge){const contact=edge.contact;const fixtureA=contact.GetFixtureA();const fixtureB=contact.GetFixtureB();if(fixtureA===this||fixtureB===this){contact.FlagForFiltering();}edge=edge.next;}this.TouchProxies();}GetBody(){return this.m_body;}GetNext(){return this.m_next;}GetUserData(){return this.m_userData;}SetUserData(data){this.m_userData=data;}TestPoint(p){return this.m_shape.TestPoint(this.m_body.GetTransform(),p);}ComputeDistance(p,normal,childIndex){return this.m_shape.ComputeDistance(this.m_body.GetTransform(),p,normal,childIndex);}RayCast(output,input,childIndex){return this.m_shape.RayCast(output,input,this.m_body.GetTransform(),childIndex);}GetMassData(massData=new b2MassData()){this.m_shape.ComputeMass(massData,this.m_density);return massData;}SetDensity(density){this.m_density=density;}GetDensity(){return this.m_density;}GetFriction(){return this.m_friction;}SetFriction(friction){this.m_friction=friction;}GetRestitution(){return this.m_restitution;}SetRestitution(restitution){this.m_restitution=restitution;}GetAABB(childIndex){return this.m_proxies[childIndex].aabb;}Dump(log,bodyIndex){log("    const fd: b2FixtureDef = new b2FixtureDef();\n");log("    fd.friction = %.15f;\n",this.m_friction);log("    fd.restitution = %.15f;\n",this.m_restitution);log("    fd.density = %.15f;\n",this.m_density);log("    fd.isSensor = %s;\n",this.m_isSensor?"true":"false");log("    fd.filter.categoryBits = %d;\n",this.m_filter.categoryBits);log("    fd.filter.maskBits = %d;\n",this.m_filter.maskBits);log("    fd.filter.groupIndex = %d;\n",this.m_filter.groupIndex);this.m_shape.Dump(log);log("\n");log("    fd.shape = shape;\n");log("\n");log("    bodies[%d].CreateFixture(fd);\n",bodyIndex);}CreateProxies(){if(this.m_proxies.length!==0){throw new Error();}for(let i=0;i<this.m_shape.GetChildCount();++i){this.m_proxies[i]=new b2FixtureProxy(this,i);}}DestroyProxies(){for(const proxy of this.m_proxies){proxy.Reset();}this.m_proxies.length=0;}TouchProxies(){for(const proxy of this.m_proxies){proxy.Touch();}}SynchronizeProxies(transform1,transform2,displacement){for(const proxy of this.m_proxies){proxy.Synchronize(transform1,transform2,displacement);}}}(function(b2BodyType){b2BodyType[b2BodyType["b2_unknown"]=-1]="b2_unknown";b2BodyType[b2BodyType["b2_staticBody"]=0]="b2_staticBody";b2BodyType[b2BodyType["b2_kinematicBody"]=1]="b2_kinematicBody";b2BodyType[b2BodyType["b2_dynamicBody"]=2]="b2_dynamicBody";})(exports.b2BodyType||(exports.b2BodyType={}));class b2BodyDef{constructor(){this.type=exports.b2BodyType.b2_staticBody;this.position=new b2Vec2(0,0);this.angle=0;this.linearVelocity=new b2Vec2(0,0);this.angularVelocity=0;this.linearDamping=0;this.angularDamping=0;this.allowSleep=true;this.awake=true;this.fixedRotation=false;this.bullet=false;this.active=true;this.userData=null;this.gravityScale=1;}}class b2Body{constructor(bd,world){this.m_type=exports.b2BodyType.b2_staticBody;this.m_islandFlag=false;this.m_awakeFlag=false;this.m_autoSleepFlag=false;this.m_bulletFlag=false;this.m_fixedRotationFlag=false;this.m_activeFlag=false;this.m_toiFlag=false;this.m_islandIndex=0;this.m_xf=new b2Transform();this.m_xf0=new b2Transform();this.m_sweep=new b2Sweep();this.m_linearVelocity=new b2Vec2();this.m_angularVelocity=0;this.m_force=new b2Vec2();this.m_torque=0;this.m_prev=null;this.m_next=null;this.m_fixtureList=null;this.m_fixtureCount=0;this.m_jointList=null;this.m_contactList=null;this.m_mass=1;this.m_invMass=1;this.m_I=0;this.m_invI=0;this.m_linearDamping=0;this.m_angularDamping=0;this.m_gravityScale=1;this.m_sleepTime=0;this.m_userData=null;this.m_controllerList=null;this.m_controllerCount=0;this.m_bulletFlag=b2Maybe(bd.bullet,false);this.m_fixedRotationFlag=b2Maybe(bd.fixedRotation,false);this.m_autoSleepFlag=b2Maybe(bd.allowSleep,true);this.m_awakeFlag=b2Maybe(bd.awake,true);this.m_activeFlag=b2Maybe(bd.active,true);this.m_world=world;this.m_xf.p.Copy(b2Maybe(bd.position,b2Vec2.ZERO));this.m_xf.q.SetAngle(b2Maybe(bd.angle,0));this.m_xf0.Copy(this.m_xf);this.m_sweep.localCenter.SetZero();this.m_sweep.c0.Copy(this.m_xf.p);this.m_sweep.c.Copy(this.m_xf.p);this.m_sweep.a0=this.m_sweep.a=this.m_xf.q.GetAngle();this.m_sweep.alpha0=0;this.m_linearVelocity.Copy(b2Maybe(bd.linearVelocity,b2Vec2.ZERO));this.m_angularVelocity=b2Maybe(bd.angularVelocity,0);this.m_linearDamping=b2Maybe(bd.linearDamping,0);this.m_angularDamping=b2Maybe(bd.angularDamping,0);this.m_gravityScale=b2Maybe(bd.gravityScale,1);this.m_force.SetZero();this.m_torque=0;this.m_sleepTime=0;this.m_type=b2Maybe(bd.type,exports.b2BodyType.b2_staticBody);if(bd.type===exports.b2BodyType.b2_dynamicBody){this.m_mass=1;this.m_invMass=1;}else {this.m_mass=0;this.m_invMass=0;}this.m_I=0;this.m_invI=0;this.m_userData=bd.userData;this.m_fixtureList=null;this.m_fixtureCount=0;this.m_controllerList=null;this.m_controllerCount=0;}CreateFixture(a,b=0){if(a instanceof b2Shape){return this.CreateFixtureShapeDensity(a,b);}else {return this.CreateFixtureDef(a);}}CreateFixtureDef(def){if(this.m_world.IsLocked()){throw new Error();}const fixture=new b2Fixture(this,def);if(this.m_activeFlag){fixture.CreateProxies();}fixture.m_next=this.m_fixtureList;this.m_fixtureList=fixture;++this.m_fixtureCount;if(fixture.m_density>0){this.ResetMassData();}this.m_world.m_newFixture=true;return fixture;}CreateFixtureShapeDensity(shape,density=0){const def=b2Body.CreateFixtureShapeDensity_s_def;def.shape=shape;def.density=density;return this.CreateFixtureDef(def);}DestroyFixture(fixture){if(this.m_world.IsLocked()){throw new Error();}let node=this.m_fixtureList;let ppF=null;while(node!==null){if(node===fixture){if(ppF){ppF.m_next=fixture.m_next;}else {this.m_fixtureList=fixture.m_next;}break;}ppF=node;node=node.m_next;}let edge=this.m_contactList;while(edge){const c=edge.contact;edge=edge.next;const fixtureA=c.GetFixtureA();const fixtureB=c.GetFixtureB();if(fixture===fixtureA||fixture===fixtureB){this.m_world.m_contactManager.Destroy(c);}}if(this.m_activeFlag){fixture.DestroyProxies();}fixture.m_next=null;fixture.Reset();--this.m_fixtureCount;this.ResetMassData();}SetTransformVec(position,angle){this.SetTransformXY(position.x,position.y,angle);}SetTransformXY(x,y,angle){if(this.m_world.IsLocked()){throw new Error();}this.m_xf.q.SetAngle(angle);this.m_xf.p.Set(x,y);this.m_xf0.Copy(this.m_xf);b2Transform.MulXV(this.m_xf,this.m_sweep.localCenter,this.m_sweep.c);this.m_sweep.a=angle;this.m_sweep.c0.Copy(this.m_sweep.c);this.m_sweep.a0=angle;for(let f=this.m_fixtureList;f;f=f.m_next){f.SynchronizeProxies(this.m_xf,this.m_xf,b2Vec2.ZERO);}this.m_world.m_contactManager.FindNewContacts();}SetTransform(xf){this.SetTransformVec(xf.p,xf.GetAngle());}GetTransform(){return this.m_xf;}GetPosition(){return this.m_xf.p;}SetPosition(position){this.SetTransformVec(position,this.GetAngle());}SetPositionXY(x,y){this.SetTransformXY(x,y,this.GetAngle());}GetAngle(){return this.m_sweep.a;}SetAngle(angle){this.SetTransformVec(this.GetPosition(),angle);}GetWorldCenter(){return this.m_sweep.c;}GetLocalCenter(){return this.m_sweep.localCenter;}SetLinearVelocity(v){if(this.m_type===exports.b2BodyType.b2_staticBody){return;}if(b2Vec2.DotVV(v,v)>0){this.SetAwake(true);}this.m_linearVelocity.Copy(v);}GetLinearVelocity(){return this.m_linearVelocity;}SetAngularVelocity(w){if(this.m_type===exports.b2BodyType.b2_staticBody){return;}if(w*w>0){this.SetAwake(true);}this.m_angularVelocity=w;}GetAngularVelocity(){return this.m_angularVelocity;}GetDefinition(bd){bd.type=this.GetType();bd.allowSleep=this.m_autoSleepFlag;bd.angle=this.GetAngle();bd.angularDamping=this.m_angularDamping;bd.gravityScale=this.m_gravityScale;bd.angularVelocity=this.m_angularVelocity;bd.fixedRotation=this.m_fixedRotationFlag;bd.bullet=this.m_bulletFlag;bd.awake=this.m_awakeFlag;bd.linearDamping=this.m_linearDamping;bd.linearVelocity.Copy(this.GetLinearVelocity());bd.position.Copy(this.GetPosition());bd.userData=this.GetUserData();return bd;}ApplyForce(force,point,wake=true){if(this.m_type!==exports.b2BodyType.b2_dynamicBody){return;}if(wake&&!this.m_awakeFlag){this.SetAwake(true);}if(this.m_awakeFlag){this.m_force.x+=force.x;this.m_force.y+=force.y;this.m_torque+=(point.x-this.m_sweep.c.x)*force.y-(point.y-this.m_sweep.c.y)*force.x;}}ApplyForceToCenter(force,wake=true){if(this.m_type!==exports.b2BodyType.b2_dynamicBody){return;}if(wake&&!this.m_awakeFlag){this.SetAwake(true);}if(this.m_awakeFlag){this.m_force.x+=force.x;this.m_force.y+=force.y;}}ApplyTorque(torque,wake=true){if(this.m_type!==exports.b2BodyType.b2_dynamicBody){return;}if(wake&&!this.m_awakeFlag){this.SetAwake(true);}if(this.m_awakeFlag){this.m_torque+=torque;}}ApplyLinearImpulse(impulse,point,wake=true){if(this.m_type!==exports.b2BodyType.b2_dynamicBody){return;}if(wake&&!this.m_awakeFlag){this.SetAwake(true);}if(this.m_awakeFlag){this.m_linearVelocity.x+=this.m_invMass*impulse.x;this.m_linearVelocity.y+=this.m_invMass*impulse.y;this.m_angularVelocity+=this.m_invI*((point.x-this.m_sweep.c.x)*impulse.y-(point.y-this.m_sweep.c.y)*impulse.x);}}ApplyLinearImpulseToCenter(impulse,wake=true){if(this.m_type!==exports.b2BodyType.b2_dynamicBody){return;}if(wake&&!this.m_awakeFlag){this.SetAwake(true);}if(this.m_awakeFlag){this.m_linearVelocity.x+=this.m_invMass*impulse.x;this.m_linearVelocity.y+=this.m_invMass*impulse.y;}}ApplyAngularImpulse(impulse,wake=true){if(this.m_type!==exports.b2BodyType.b2_dynamicBody){return;}if(wake&&!this.m_awakeFlag){this.SetAwake(true);}if(this.m_awakeFlag){this.m_angularVelocity+=this.m_invI*impulse;}}GetMass(){return this.m_mass;}GetInertia(){return this.m_I+this.m_mass*b2Vec2.DotVV(this.m_sweep.localCenter,this.m_sweep.localCenter);}GetMassData(data){data.mass=this.m_mass;data.I=this.m_I+this.m_mass*b2Vec2.DotVV(this.m_sweep.localCenter,this.m_sweep.localCenter);data.center.Copy(this.m_sweep.localCenter);return data;}SetMassData(massData){if(this.m_world.IsLocked()){throw new Error();}if(this.m_type!==exports.b2BodyType.b2_dynamicBody){return;}this.m_invMass=0;this.m_I=0;this.m_invI=0;this.m_mass=massData.mass;if(this.m_mass<=0){this.m_mass=1;}this.m_invMass=1/this.m_mass;if(massData.I>0&&!this.m_fixedRotationFlag){this.m_I=massData.I-this.m_mass*b2Vec2.DotVV(massData.center,massData.center);this.m_invI=1/this.m_I;}const oldCenter=b2Body.SetMassData_s_oldCenter.Copy(this.m_sweep.c);this.m_sweep.localCenter.Copy(massData.center);b2Transform.MulXV(this.m_xf,this.m_sweep.localCenter,this.m_sweep.c);this.m_sweep.c0.Copy(this.m_sweep.c);b2Vec2.AddVCrossSV(this.m_linearVelocity,this.m_angularVelocity,b2Vec2.SubVV(this.m_sweep.c,oldCenter,b2Vec2.s_t0),this.m_linearVelocity);}ResetMassData(){this.m_mass=0;this.m_invMass=0;this.m_I=0;this.m_invI=0;this.m_sweep.localCenter.SetZero();if(this.m_type===exports.b2BodyType.b2_staticBody||this.m_type===exports.b2BodyType.b2_kinematicBody){this.m_sweep.c0.Copy(this.m_xf.p);this.m_sweep.c.Copy(this.m_xf.p);this.m_sweep.a0=this.m_sweep.a;return;}const localCenter=b2Body.ResetMassData_s_localCenter.SetZero();for(let f=this.m_fixtureList;f;f=f.m_next){if(f.m_density===0){continue;}const massData=f.GetMassData(b2Body.ResetMassData_s_massData);this.m_mass+=massData.mass;localCenter.x+=massData.center.x*massData.mass;localCenter.y+=massData.center.y*massData.mass;this.m_I+=massData.I;}if(this.m_mass>0){this.m_invMass=1/this.m_mass;localCenter.x*=this.m_invMass;localCenter.y*=this.m_invMass;}else {this.m_mass=1;this.m_invMass=1;}if(this.m_I>0&&!this.m_fixedRotationFlag){this.m_I-=this.m_mass*b2Vec2.DotVV(localCenter,localCenter);this.m_invI=1/this.m_I;}else {this.m_I=0;this.m_invI=0;}const oldCenter=b2Body.ResetMassData_s_oldCenter.Copy(this.m_sweep.c);this.m_sweep.localCenter.Copy(localCenter);b2Transform.MulXV(this.m_xf,this.m_sweep.localCenter,this.m_sweep.c);this.m_sweep.c0.Copy(this.m_sweep.c);b2Vec2.AddVCrossSV(this.m_linearVelocity,this.m_angularVelocity,b2Vec2.SubVV(this.m_sweep.c,oldCenter,b2Vec2.s_t0),this.m_linearVelocity);}GetWorldPoint(localPoint,out){return b2Transform.MulXV(this.m_xf,localPoint,out);}GetWorldVector(localVector,out){return b2Rot.MulRV(this.m_xf.q,localVector,out);}GetLocalPoint(worldPoint,out){return b2Transform.MulTXV(this.m_xf,worldPoint,out);}GetLocalVector(worldVector,out){return b2Rot.MulTRV(this.m_xf.q,worldVector,out);}GetLinearVelocityFromWorldPoint(worldPoint,out){return b2Vec2.AddVCrossSV(this.m_linearVelocity,this.m_angularVelocity,b2Vec2.SubVV(worldPoint,this.m_sweep.c,b2Vec2.s_t0),out);}GetLinearVelocityFromLocalPoint(localPoint,out){return this.GetLinearVelocityFromWorldPoint(this.GetWorldPoint(localPoint,out),out);}GetLinearDamping(){return this.m_linearDamping;}SetLinearDamping(linearDamping){this.m_linearDamping=linearDamping;}GetAngularDamping(){return this.m_angularDamping;}SetAngularDamping(angularDamping){this.m_angularDamping=angularDamping;}GetGravityScale(){return this.m_gravityScale;}SetGravityScale(scale){this.m_gravityScale=scale;}SetType(type){if(this.m_world.IsLocked()){throw new Error();}if(this.m_type===type){return;}this.m_type=type;this.ResetMassData();if(this.m_type===exports.b2BodyType.b2_staticBody){this.m_linearVelocity.SetZero();this.m_angularVelocity=0;this.m_sweep.a0=this.m_sweep.a;this.m_sweep.c0.Copy(this.m_sweep.c);this.SynchronizeFixtures();}this.SetAwake(true);this.m_force.SetZero();this.m_torque=0;let ce=this.m_contactList;while(ce){const ce0=ce;ce=ce.next;this.m_world.m_contactManager.Destroy(ce0.contact);}this.m_contactList=null;for(let f=this.m_fixtureList;f;f=f.m_next){f.TouchProxies();}}GetType(){return this.m_type;}SetBullet(flag){this.m_bulletFlag=flag;}IsBullet(){return this.m_bulletFlag;}SetSleepingAllowed(flag){this.m_autoSleepFlag=flag;if(!flag){this.SetAwake(true);}}IsSleepingAllowed(){return this.m_autoSleepFlag;}SetAwake(flag){if(flag){this.m_awakeFlag=true;this.m_sleepTime=0;}else {this.m_awakeFlag=false;this.m_sleepTime=0;this.m_linearVelocity.SetZero();this.m_angularVelocity=0;this.m_force.SetZero();this.m_torque=0;}}IsAwake(){return this.m_awakeFlag;}SetActive(flag){if(this.m_world.IsLocked()){throw new Error();}if(flag===this.IsActive()){return;}this.m_activeFlag=flag;if(flag){for(let f=this.m_fixtureList;f;f=f.m_next){f.CreateProxies();}}else {for(let f=this.m_fixtureList;f;f=f.m_next){f.DestroyProxies();}let ce=this.m_contactList;while(ce){const ce0=ce;ce=ce.next;this.m_world.m_contactManager.Destroy(ce0.contact);}this.m_contactList=null;}}IsActive(){return this.m_activeFlag;}SetFixedRotation(flag){if(this.m_fixedRotationFlag===flag){return;}this.m_fixedRotationFlag=flag;this.m_angularVelocity=0;this.ResetMassData();}IsFixedRotation(){return this.m_fixedRotationFlag;}GetFixtureList(){return this.m_fixtureList;}GetJointList(){return this.m_jointList;}GetContactList(){return this.m_contactList;}GetNext(){return this.m_next;}GetUserData(){return this.m_userData;}SetUserData(data){this.m_userData=data;}GetWorld(){return this.m_world;}Dump(log){const bodyIndex=this.m_islandIndex;log("{\n");log("  const bd: b2BodyDef = new b2BodyDef();\n");let type_str="";switch(this.m_type){case exports.b2BodyType.b2_staticBody:type_str="b2BodyType.b2_staticBody";break;case exports.b2BodyType.b2_kinematicBody:type_str="b2BodyType.b2_kinematicBody";break;case exports.b2BodyType.b2_dynamicBody:type_str="b2BodyType.b2_dynamicBody";break;}log("  bd.type = %s;\n",type_str);log("  bd.position.Set(%.15f, %.15f);\n",this.m_xf.p.x,this.m_xf.p.y);log("  bd.angle = %.15f;\n",this.m_sweep.a);log("  bd.linearVelocity.Set(%.15f, %.15f);\n",this.m_linearVelocity.x,this.m_linearVelocity.y);log("  bd.angularVelocity = %.15f;\n",this.m_angularVelocity);log("  bd.linearDamping = %.15f;\n",this.m_linearDamping);log("  bd.angularDamping = %.15f;\n",this.m_angularDamping);log("  bd.allowSleep = %s;\n",this.m_autoSleepFlag?"true":"false");log("  bd.awake = %s;\n",this.m_awakeFlag?"true":"false");log("  bd.fixedRotation = %s;\n",this.m_fixedRotationFlag?"true":"false");log("  bd.bullet = %s;\n",this.m_bulletFlag?"true":"false");log("  bd.active = %s;\n",this.m_activeFlag?"true":"false");log("  bd.gravityScale = %.15f;\n",this.m_gravityScale);log("\n");log("  bodies[%d] = this.m_world.CreateBody(bd);\n",this.m_islandIndex);log("\n");for(let f=this.m_fixtureList;f;f=f.m_next){log("  {\n");f.Dump(log,bodyIndex);log("  }\n");}log("}\n");}SynchronizeFixtures(){const xf1=b2Body.SynchronizeFixtures_s_xf1;xf1.q.SetAngle(this.m_sweep.a0);b2Rot.MulRV(xf1.q,this.m_sweep.localCenter,xf1.p);b2Vec2.SubVV(this.m_sweep.c0,xf1.p,xf1.p);const displacement=b2Vec2.SubVV(this.m_sweep.c,this.m_sweep.c0,b2Body.SynchronizeFixtures_s_displacement);for(let f=this.m_fixtureList;f;f=f.m_next){f.SynchronizeProxies(xf1,this.m_xf,displacement);}}SynchronizeTransform(){this.m_xf.q.SetAngle(this.m_sweep.a);b2Rot.MulRV(this.m_xf.q,this.m_sweep.localCenter,this.m_xf.p);b2Vec2.SubVV(this.m_sweep.c,this.m_xf.p,this.m_xf.p);}ShouldCollide(other){if(this.m_type===exports.b2BodyType.b2_staticBody&&other.m_type===exports.b2BodyType.b2_staticBody){return false;}return this.ShouldCollideConnected(other);}ShouldCollideConnected(other){for(let jn=this.m_jointList;jn;jn=jn.next){if(jn.other===other){if(!jn.joint.m_collideConnected){return false;}}}return true;}Advance(alpha){this.m_sweep.Advance(alpha);this.m_sweep.c.Copy(this.m_sweep.c0);this.m_sweep.a=this.m_sweep.a0;this.m_xf.q.SetAngle(this.m_sweep.a);b2Rot.MulRV(this.m_xf.q,this.m_sweep.localCenter,this.m_xf.p);b2Vec2.SubVV(this.m_sweep.c,this.m_xf.p,this.m_xf.p);}GetControllerList(){return this.m_controllerList;}GetControllerCount(){return this.m_controllerCount;}}b2Body.CreateFixtureShapeDensity_s_def=new b2FixtureDef();b2Body.SetMassData_s_oldCenter=new b2Vec2();b2Body.ResetMassData_s_localCenter=new b2Vec2();b2Body.ResetMassData_s_oldCenter=new b2Vec2();b2Body.ResetMassData_s_massData=new b2MassData();b2Body.SynchronizeFixtures_s_xf1=new b2Transform();b2Body.SynchronizeFixtures_s_displacement=new b2Vec2();(function(b2JointType){b2JointType[b2JointType["e_unknownJoint"]=0]="e_unknownJoint";b2JointType[b2JointType["e_revoluteJoint"]=1]="e_revoluteJoint";b2JointType[b2JointType["e_prismaticJoint"]=2]="e_prismaticJoint";b2JointType[b2JointType["e_distanceJoint"]=3]="e_distanceJoint";b2JointType[b2JointType["e_pulleyJoint"]=4]="e_pulleyJoint";b2JointType[b2JointType["e_mouseJoint"]=5]="e_mouseJoint";b2JointType[b2JointType["e_gearJoint"]=6]="e_gearJoint";b2JointType[b2JointType["e_wheelJoint"]=7]="e_wheelJoint";b2JointType[b2JointType["e_weldJoint"]=8]="e_weldJoint";b2JointType[b2JointType["e_frictionJoint"]=9]="e_frictionJoint";b2JointType[b2JointType["e_ropeJoint"]=10]="e_ropeJoint";b2JointType[b2JointType["e_motorJoint"]=11]="e_motorJoint";b2JointType[b2JointType["e_areaJoint"]=12]="e_areaJoint";})(exports.b2JointType||(exports.b2JointType={}));(function(b2LimitState){b2LimitState[b2LimitState["e_inactiveLimit"]=0]="e_inactiveLimit";b2LimitState[b2LimitState["e_atLowerLimit"]=1]="e_atLowerLimit";b2LimitState[b2LimitState["e_atUpperLimit"]=2]="e_atUpperLimit";b2LimitState[b2LimitState["e_equalLimits"]=3]="e_equalLimits";})(exports.b2LimitState||(exports.b2LimitState={}));class b2Jacobian{constructor(){this.linear=new b2Vec2();this.angularA=0;this.angularB=0;}SetZero(){this.linear.SetZero();this.angularA=0;this.angularB=0;return this;}Set(x,a1,a2){this.linear.Copy(x);this.angularA=a1;this.angularB=a2;return this;}}class b2JointEdge{constructor(joint){this._other=null;this.prev=null;this.next=null;this.joint=joint;}get other(){if(this._other===null){throw new Error();}return this._other;}set other(value){if(this._other!==null){throw new Error();}this._other=value;}Reset(){this._other=null;this.prev=null;this.next=null;}}class b2JointDef{constructor(type){this.type=exports.b2JointType.e_unknownJoint;this.userData=null;this.collideConnected=false;this.type=type;}}class b2Joint{constructor(def){this.m_type=exports.b2JointType.e_unknownJoint;this.m_prev=null;this.m_next=null;this.m_edgeA=new b2JointEdge(this);this.m_edgeB=new b2JointEdge(this);this.m_index=0;this.m_islandFlag=false;this.m_collideConnected=false;this.m_userData=null;this.m_type=def.type;this.m_edgeA.other=def.bodyB;this.m_edgeB.other=def.bodyA;this.m_bodyA=def.bodyA;this.m_bodyB=def.bodyB;this.m_collideConnected=b2Maybe(def.collideConnected,false);this.m_userData=b2Maybe(def.userData,null);}GetType(){return this.m_type;}GetBodyA(){return this.m_bodyA;}GetBodyB(){return this.m_bodyB;}GetNext(){return this.m_next;}GetUserData(){return this.m_userData;}SetUserData(data){this.m_userData=data;}IsActive(){return this.m_bodyA.IsActive()&&this.m_bodyB.IsActive();}GetCollideConnected(){return this.m_collideConnected;}Dump(log){log("// Dump is not supported for this joint type.\n");}ShiftOrigin(newOrigin){}}class b2DistanceJointDef extends b2JointDef{constructor(){super(exports.b2JointType.e_distanceJoint);this.localAnchorA=new b2Vec2();this.localAnchorB=new b2Vec2();this.length=1;this.frequencyHz=0;this.dampingRatio=0;}Initialize(b1,b2,anchor1,anchor2){this.bodyA=b1;this.bodyB=b2;this.bodyA.GetLocalPoint(anchor1,this.localAnchorA);this.bodyB.GetLocalPoint(anchor2,this.localAnchorB);this.length=b2Vec2.DistanceVV(anchor1,anchor2);this.frequencyHz=0;this.dampingRatio=0;}}class b2DistanceJoint extends b2Joint{constructor(def){super(def);this.m_frequencyHz=0;this.m_dampingRatio=0;this.m_bias=0;this.m_localAnchorA=new b2Vec2();this.m_localAnchorB=new b2Vec2();this.m_gamma=0;this.m_impulse=0;this.m_length=0;this.m_indexA=0;this.m_indexB=0;this.m_u=new b2Vec2();this.m_rA=new b2Vec2();this.m_rB=new b2Vec2();this.m_localCenterA=new b2Vec2();this.m_localCenterB=new b2Vec2();this.m_invMassA=0;this.m_invMassB=0;this.m_invIA=0;this.m_invIB=0;this.m_mass=0;this.m_qA=new b2Rot();this.m_qB=new b2Rot();this.m_lalcA=new b2Vec2();this.m_lalcB=new b2Vec2();this.m_frequencyHz=b2Maybe(def.frequencyHz,0);this.m_dampingRatio=b2Maybe(def.dampingRatio,0);this.m_localAnchorA.Copy(def.localAnchorA);this.m_localAnchorB.Copy(def.localAnchorB);this.m_length=def.length;}GetAnchorA(out){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,out);}GetAnchorB(out){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,out);}GetReactionForce(inv_dt,out){out.x=inv_dt*this.m_impulse*this.m_u.x;out.y=inv_dt*this.m_impulse*this.m_u.y;return out;}GetReactionTorque(inv_dt){return 0;}GetLocalAnchorA(){return this.m_localAnchorA;}GetLocalAnchorB(){return this.m_localAnchorB;}SetLength(length){this.m_length=length;}Length(){return this.m_length;}SetFrequency(hz){this.m_frequencyHz=hz;}GetFrequency(){return this.m_frequencyHz;}SetDampingRatio(ratio){this.m_dampingRatio=ratio;}GetDampingRatio(){return this.m_dampingRatio;}Dump(log){const indexA=this.m_bodyA.m_islandIndex;const indexB=this.m_bodyB.m_islandIndex;log("  const jd: b2DistanceJointDef = new b2DistanceJointDef();\n");log("  jd.bodyA = bodies[%d];\n",indexA);log("  jd.bodyB = bodies[%d];\n",indexB);log("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false");log("  jd.localAnchorA.Set(%.15f, %.15f);\n",this.m_localAnchorA.x,this.m_localAnchorA.y);log("  jd.localAnchorB.Set(%.15f, %.15f);\n",this.m_localAnchorB.x,this.m_localAnchorB.y);log("  jd.length = %.15f;\n",this.m_length);log("  jd.frequencyHz = %.15f;\n",this.m_frequencyHz);log("  jd.dampingRatio = %.15f;\n",this.m_dampingRatio);log("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index);}InitVelocityConstraints(data){this.m_indexA=this.m_bodyA.m_islandIndex;this.m_indexB=this.m_bodyB.m_islandIndex;this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);this.m_invMassA=this.m_bodyA.m_invMass;this.m_invMassB=this.m_bodyB.m_invMass;this.m_invIA=this.m_bodyA.m_invI;this.m_invIB=this.m_bodyB.m_invI;const cA=data.positions[this.m_indexA].c;const aA=data.positions[this.m_indexA].a;const vA=data.velocities[this.m_indexA].v;let wA=data.velocities[this.m_indexA].w;const cB=data.positions[this.m_indexB].c;const aB=data.positions[this.m_indexB].a;const vB=data.velocities[this.m_indexB].v;let wB=data.velocities[this.m_indexB].w;const qA=this.m_qA.SetAngle(aA),qB=this.m_qB.SetAngle(aB);b2Vec2.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);b2Rot.MulRV(qA,this.m_lalcA,this.m_rA);b2Vec2.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);b2Rot.MulRV(qB,this.m_lalcB,this.m_rB);this.m_u.x=cB.x+this.m_rB.x-cA.x-this.m_rA.x;this.m_u.y=cB.y+this.m_rB.y-cA.y-this.m_rA.y;const length=this.m_u.Length();if(length>b2_linearSlop){this.m_u.SelfMul(1/length);}else {this.m_u.SetZero();}const crAu=b2Vec2.CrossVV(this.m_rA,this.m_u);const crBu=b2Vec2.CrossVV(this.m_rB,this.m_u);let invMass=this.m_invMassA+this.m_invIA*crAu*crAu+this.m_invMassB+this.m_invIB*crBu*crBu;this.m_mass=invMass!==0?1/invMass:0;if(this.m_frequencyHz>0){const C=length-this.m_length;const omega=2*b2_pi*this.m_frequencyHz;const d=2*this.m_mass*this.m_dampingRatio*omega;const k=this.m_mass*omega*omega;const h=data.step.dt;this.m_gamma=h*(d+h*k);this.m_gamma=this.m_gamma!==0?1/this.m_gamma:0;this.m_bias=C*h*k*this.m_gamma;invMass+=this.m_gamma;this.m_mass=invMass!==0?1/invMass:0;}else {this.m_gamma=0;this.m_bias=0;}if(data.step.warmStarting){this.m_impulse*=data.step.dtRatio;const P=b2Vec2.MulSV(this.m_impulse,this.m_u,b2DistanceJoint.InitVelocityConstraints_s_P);vA.SelfMulSub(this.m_invMassA,P);wA-=this.m_invIA*b2Vec2.CrossVV(this.m_rA,P);vB.SelfMulAdd(this.m_invMassB,P);wB+=this.m_invIB*b2Vec2.CrossVV(this.m_rB,P);}else {this.m_impulse=0;}data.velocities[this.m_indexA].w=wA;data.velocities[this.m_indexB].w=wB;}SolveVelocityConstraints(data){const vA=data.velocities[this.m_indexA].v;let wA=data.velocities[this.m_indexA].w;const vB=data.velocities[this.m_indexB].v;let wB=data.velocities[this.m_indexB].w;const vpA=b2Vec2.AddVCrossSV(vA,wA,this.m_rA,b2DistanceJoint.SolveVelocityConstraints_s_vpA);const vpB=b2Vec2.AddVCrossSV(vB,wB,this.m_rB,b2DistanceJoint.SolveVelocityConstraints_s_vpB);const Cdot=b2Vec2.DotVV(this.m_u,b2Vec2.SubVV(vpB,vpA,b2Vec2.s_t0));const impulse=-this.m_mass*(Cdot+this.m_bias+this.m_gamma*this.m_impulse);this.m_impulse+=impulse;const P=b2Vec2.MulSV(impulse,this.m_u,b2DistanceJoint.SolveVelocityConstraints_s_P);vA.SelfMulSub(this.m_invMassA,P);wA-=this.m_invIA*b2Vec2.CrossVV(this.m_rA,P);vB.SelfMulAdd(this.m_invMassB,P);wB+=this.m_invIB*b2Vec2.CrossVV(this.m_rB,P);data.velocities[this.m_indexA].w=wA;data.velocities[this.m_indexB].w=wB;}SolvePositionConstraints(data){if(this.m_frequencyHz>0){return true;}const cA=data.positions[this.m_indexA].c;let aA=data.positions[this.m_indexA].a;const cB=data.positions[this.m_indexB].c;let aB=data.positions[this.m_indexB].a;const qA=this.m_qA.SetAngle(aA),qB=this.m_qB.SetAngle(aB);const rA=b2Rot.MulRV(qA,this.m_lalcA,this.m_rA);const rB=b2Rot.MulRV(qB,this.m_lalcB,this.m_rB);const u=this.m_u;u.x=cB.x+rB.x-cA.x-rA.x;u.y=cB.y+rB.y-cA.y-rA.y;const length=this.m_u.Normalize();let C=length-this.m_length;C=b2Clamp(C,-b2_maxLinearCorrection,b2_maxLinearCorrection);const impulse=-this.m_mass*C;const P=b2Vec2.MulSV(impulse,u,b2DistanceJoint.SolvePositionConstraints_s_P);cA.SelfMulSub(this.m_invMassA,P);aA-=this.m_invIA*b2Vec2.CrossVV(rA,P);cB.SelfMulAdd(this.m_invMassB,P);aB+=this.m_invIB*b2Vec2.CrossVV(rB,P);data.positions[this.m_indexA].a=aA;data.positions[this.m_indexB].a=aB;return b2Abs(C)<b2_linearSlop;}}b2DistanceJoint.InitVelocityConstraints_s_P=new b2Vec2();b2DistanceJoint.SolveVelocityConstraints_s_vpA=new b2Vec2();b2DistanceJoint.SolveVelocityConstraints_s_vpB=new b2Vec2();b2DistanceJoint.SolveVelocityConstraints_s_P=new b2Vec2();b2DistanceJoint.SolvePositionConstraints_s_P=new b2Vec2();class b2AreaJointDef extends b2JointDef{constructor(){super(exports.b2JointType.e_areaJoint);this.bodies=[];this.frequencyHz=0;this.dampingRatio=0;}AddBody(body){this.bodies.push(body);if(this.bodies.length===1){this.bodyA=body;}else if(this.bodies.length===2){this.bodyB=body;}}}class b2AreaJoint extends b2Joint{constructor(def){super(def);this.m_frequencyHz=0;this.m_dampingRatio=0;this.m_impulse=0;this.m_targetArea=0;this.m_delta=new b2Vec2();this.m_bodies=def.bodies;this.m_frequencyHz=b2Maybe(def.frequencyHz,0);this.m_dampingRatio=b2Maybe(def.dampingRatio,0);this.m_targetLengths=b2MakeNumberArray(def.bodies.length);this.m_normals=b2Vec2.MakeArray(def.bodies.length);this.m_joints=[];this.m_deltas=b2Vec2.MakeArray(def.bodies.length);const djd=new b2DistanceJointDef();djd.frequencyHz=this.m_frequencyHz;djd.dampingRatio=this.m_dampingRatio;this.m_targetArea=0;for(let i=0;i<this.m_bodies.length;++i){const body=this.m_bodies[i];const next=this.m_bodies[(i+1)%this.m_bodies.length];const body_c=body.GetWorldCenter();const next_c=next.GetWorldCenter();this.m_targetLengths[i]=b2Vec2.DistanceVV(body_c,next_c);this.m_targetArea+=b2Vec2.CrossVV(body_c,next_c);djd.Initialize(body,next,body_c,next_c);this.m_joints[i]=body.GetWorld().CreateJoint(djd);}this.m_targetArea*=0.5;}GetAnchorA(out){return out;}GetAnchorB(out){return out;}GetReactionForce(inv_dt,out){return out;}GetReactionTorque(inv_dt){return 0;}SetFrequency(hz){this.m_frequencyHz=hz;for(let i=0;i<this.m_joints.length;++i){this.m_joints[i].SetFrequency(hz);}}GetFrequency(){return this.m_frequencyHz;}SetDampingRatio(ratio){this.m_dampingRatio=ratio;for(let i=0;i<this.m_joints.length;++i){this.m_joints[i].SetDampingRatio(ratio);}}GetDampingRatio(){return this.m_dampingRatio;}Dump(log){log("Area joint dumping is not supported.\n");}InitVelocityConstraints(data){for(let i=0;i<this.m_bodies.length;++i){const prev=this.m_bodies[(i+this.m_bodies.length-1)%this.m_bodies.length];const next=this.m_bodies[(i+1)%this.m_bodies.length];const prev_c=data.positions[prev.m_islandIndex].c;const next_c=data.positions[next.m_islandIndex].c;const delta=this.m_deltas[i];b2Vec2.SubVV(next_c,prev_c,delta);}if(data.step.warmStarting){this.m_impulse*=data.step.dtRatio;for(let i=0;i<this.m_bodies.length;++i){const body=this.m_bodies[i];const body_v=data.velocities[body.m_islandIndex].v;const delta=this.m_deltas[i];body_v.x+=body.m_invMass*delta.y*0.5*this.m_impulse;body_v.y+=body.m_invMass*-delta.x*0.5*this.m_impulse;}}else {this.m_impulse=0;}}SolveVelocityConstraints(data){let dotMassSum=0;let crossMassSum=0;for(let i=0;i<this.m_bodies.length;++i){const body=this.m_bodies[i];const body_v=data.velocities[body.m_islandIndex].v;const delta=this.m_deltas[i];dotMassSum+=delta.LengthSquared()/body.GetMass();crossMassSum+=b2Vec2.CrossVV(body_v,delta);}const lambda=-2*crossMassSum/dotMassSum;this.m_impulse+=lambda;for(let i=0;i<this.m_bodies.length;++i){const body=this.m_bodies[i];const body_v=data.velocities[body.m_islandIndex].v;const delta=this.m_deltas[i];body_v.x+=body.m_invMass*delta.y*0.5*lambda;body_v.y+=body.m_invMass*-delta.x*0.5*lambda;}}SolvePositionConstraints(data){let perimeter=0;let area=0;for(let i=0;i<this.m_bodies.length;++i){const body=this.m_bodies[i];const next=this.m_bodies[(i+1)%this.m_bodies.length];const body_c=data.positions[body.m_islandIndex].c;const next_c=data.positions[next.m_islandIndex].c;const delta=b2Vec2.SubVV(next_c,body_c,this.m_delta);let dist=delta.Length();if(dist<b2_epsilon){dist=1;}this.m_normals[i].x=delta.y/dist;this.m_normals[i].y=-delta.x/dist;perimeter+=dist;area+=b2Vec2.CrossVV(body_c,next_c);}area*=0.5;const deltaArea=this.m_targetArea-area;const toExtrude=0.5*deltaArea/perimeter;let done=true;for(let i=0;i<this.m_bodies.length;++i){const body=this.m_bodies[i];const body_c=data.positions[body.m_islandIndex].c;const next_i=(i+1)%this.m_bodies.length;const delta=b2Vec2.AddVV(this.m_normals[i],this.m_normals[next_i],this.m_delta);delta.SelfMul(toExtrude);const norm_sq=delta.LengthSquared();if(norm_sq>b2Sq(b2_maxLinearCorrection)){delta.SelfMul(b2_maxLinearCorrection/b2Sqrt(norm_sq));}if(norm_sq>b2Sq(b2_linearSlop)){done=false;}body_c.x+=delta.x;body_c.y+=delta.y;}return done;}}class b2FrictionJointDef extends b2JointDef{constructor(){super(exports.b2JointType.e_frictionJoint);this.localAnchorA=new b2Vec2();this.localAnchorB=new b2Vec2();this.maxForce=0;this.maxTorque=0;}Initialize(bA,bB,anchor){this.bodyA=bA;this.bodyB=bB;this.bodyA.GetLocalPoint(anchor,this.localAnchorA);this.bodyB.GetLocalPoint(anchor,this.localAnchorB);}}class b2FrictionJoint extends b2Joint{constructor(def){super(def);this.m_localAnchorA=new b2Vec2();this.m_localAnchorB=new b2Vec2();this.m_linearImpulse=new b2Vec2();this.m_angularImpulse=0;this.m_maxForce=0;this.m_maxTorque=0;this.m_indexA=0;this.m_indexB=0;this.m_rA=new b2Vec2();this.m_rB=new b2Vec2();this.m_localCenterA=new b2Vec2();this.m_localCenterB=new b2Vec2();this.m_invMassA=0;this.m_invMassB=0;this.m_invIA=0;this.m_invIB=0;this.m_linearMass=new b2Mat22();this.m_angularMass=0;this.m_qA=new b2Rot();this.m_qB=new b2Rot();this.m_lalcA=new b2Vec2();this.m_lalcB=new b2Vec2();this.m_K=new b2Mat22();this.m_localAnchorA.Copy(def.localAnchorA);this.m_localAnchorB.Copy(def.localAnchorB);this.m_linearImpulse.SetZero();this.m_maxForce=b2Maybe(def.maxForce,0);this.m_maxTorque=b2Maybe(def.maxTorque,0);this.m_linearMass.SetZero();}InitVelocityConstraints(data){this.m_indexA=this.m_bodyA.m_islandIndex;this.m_indexB=this.m_bodyB.m_islandIndex;this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);this.m_invMassA=this.m_bodyA.m_invMass;this.m_invMassB=this.m_bodyB.m_invMass;this.m_invIA=this.m_bodyA.m_invI;this.m_invIB=this.m_bodyB.m_invI;const aA=data.positions[this.m_indexA].a;const vA=data.velocities[this.m_indexA].v;let wA=data.velocities[this.m_indexA].w;const aB=data.positions[this.m_indexB].a;const vB=data.velocities[this.m_indexB].v;let wB=data.velocities[this.m_indexB].w;const qA=this.m_qA.SetAngle(aA),qB=this.m_qB.SetAngle(aB);b2Vec2.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);const rA=b2Rot.MulRV(qA,this.m_lalcA,this.m_rA);b2Vec2.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);const rB=b2Rot.MulRV(qB,this.m_lalcB,this.m_rB);const mA=this.m_invMassA,mB=this.m_invMassB;const iA=this.m_invIA,iB=this.m_invIB;const K=this.m_K;K.ex.x=mA+mB+iA*rA.y*rA.y+iB*rB.y*rB.y;K.ex.y=-iA*rA.x*rA.y-iB*rB.x*rB.y;K.ey.x=K.ex.y;K.ey.y=mA+mB+iA*rA.x*rA.x+iB*rB.x*rB.x;K.GetInverse(this.m_linearMass);this.m_angularMass=iA+iB;if(this.m_angularMass>0){this.m_angularMass=1/this.m_angularMass;}if(data.step.warmStarting){this.m_linearImpulse.SelfMul(data.step.dtRatio);this.m_angularImpulse*=data.step.dtRatio;const P=this.m_linearImpulse;vA.SelfMulSub(mA,P);wA-=iA*(b2Vec2.CrossVV(this.m_rA,P)+this.m_angularImpulse);vB.SelfMulAdd(mB,P);wB+=iB*(b2Vec2.CrossVV(this.m_rB,P)+this.m_angularImpulse);}else {this.m_linearImpulse.SetZero();this.m_angularImpulse=0;}data.velocities[this.m_indexA].w=wA;data.velocities[this.m_indexB].w=wB;}SolveVelocityConstraints(data){const vA=data.velocities[this.m_indexA].v;let wA=data.velocities[this.m_indexA].w;const vB=data.velocities[this.m_indexB].v;let wB=data.velocities[this.m_indexB].w;const mA=this.m_invMassA,mB=this.m_invMassB;const iA=this.m_invIA,iB=this.m_invIB;const h=data.step.dt;{const Cdot=wB-wA;let impulse=-this.m_angularMass*Cdot;const oldImpulse=this.m_angularImpulse;const maxImpulse=h*this.m_maxTorque;this.m_angularImpulse=b2Clamp(this.m_angularImpulse+impulse,-maxImpulse,maxImpulse);impulse=this.m_angularImpulse-oldImpulse;wA-=iA*impulse;wB+=iB*impulse;}{const Cdot_v2=b2Vec2.SubVV(b2Vec2.AddVCrossSV(vB,wB,this.m_rB,b2Vec2.s_t0),b2Vec2.AddVCrossSV(vA,wA,this.m_rA,b2Vec2.s_t1),b2FrictionJoint.SolveVelocityConstraints_s_Cdot_v2);const impulseV=b2Mat22.MulMV(this.m_linearMass,Cdot_v2,b2FrictionJoint.SolveVelocityConstraints_s_impulseV).SelfNeg();const oldImpulseV=b2FrictionJoint.SolveVelocityConstraints_s_oldImpulseV.Copy(this.m_linearImpulse);this.m_linearImpulse.SelfAdd(impulseV);const maxImpulse=h*this.m_maxForce;if(this.m_linearImpulse.LengthSquared()>maxImpulse*maxImpulse){this.m_linearImpulse.Normalize();this.m_linearImpulse.SelfMul(maxImpulse);}b2Vec2.SubVV(this.m_linearImpulse,oldImpulseV,impulseV);vA.SelfMulSub(mA,impulseV);wA-=iA*b2Vec2.CrossVV(this.m_rA,impulseV);vB.SelfMulAdd(mB,impulseV);wB+=iB*b2Vec2.CrossVV(this.m_rB,impulseV);}data.velocities[this.m_indexA].w=wA;data.velocities[this.m_indexB].w=wB;}SolvePositionConstraints(data){return true;}GetAnchorA(out){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,out);}GetAnchorB(out){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,out);}GetReactionForce(inv_dt,out){out.x=inv_dt*this.m_linearImpulse.x;out.y=inv_dt*this.m_linearImpulse.y;return out;}GetReactionTorque(inv_dt){return inv_dt*this.m_angularImpulse;}GetLocalAnchorA(){return this.m_localAnchorA;}GetLocalAnchorB(){return this.m_localAnchorB;}SetMaxForce(force){this.m_maxForce=force;}GetMaxForce(){return this.m_maxForce;}SetMaxTorque(torque){this.m_maxTorque=torque;}GetMaxTorque(){return this.m_maxTorque;}Dump(log){const indexA=this.m_bodyA.m_islandIndex;const indexB=this.m_bodyB.m_islandIndex;log("  const jd: b2FrictionJointDef = new b2FrictionJointDef();\n");log("  jd.bodyA = bodies[%d];\n",indexA);log("  jd.bodyB = bodies[%d];\n",indexB);log("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false");log("  jd.localAnchorA.Set(%.15f, %.15f);\n",this.m_localAnchorA.x,this.m_localAnchorA.y);log("  jd.localAnchorB.Set(%.15f, %.15f);\n",this.m_localAnchorB.x,this.m_localAnchorB.y);log("  jd.maxForce = %.15f;\n",this.m_maxForce);log("  jd.maxTorque = %.15f;\n",this.m_maxTorque);log("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index);}}b2FrictionJoint.SolveVelocityConstraints_s_Cdot_v2=new b2Vec2();b2FrictionJoint.SolveVelocityConstraints_s_impulseV=new b2Vec2();b2FrictionJoint.SolveVelocityConstraints_s_oldImpulseV=new b2Vec2();class b2GearJointDef extends b2JointDef{constructor(){super(exports.b2JointType.e_gearJoint);this.ratio=1;}}class b2GearJoint extends b2Joint{constructor(def){super(def);this.m_typeA=exports.b2JointType.e_unknownJoint;this.m_typeB=exports.b2JointType.e_unknownJoint;this.m_localAnchorA=new b2Vec2();this.m_localAnchorB=new b2Vec2();this.m_localAnchorC=new b2Vec2();this.m_localAnchorD=new b2Vec2();this.m_localAxisC=new b2Vec2();this.m_localAxisD=new b2Vec2();this.m_referenceAngleA=0;this.m_referenceAngleB=0;this.m_constant=0;this.m_ratio=0;this.m_impulse=0;this.m_indexA=0;this.m_indexB=0;this.m_indexC=0;this.m_indexD=0;this.m_lcA=new b2Vec2();this.m_lcB=new b2Vec2();this.m_lcC=new b2Vec2();this.m_lcD=new b2Vec2();this.m_mA=0;this.m_mB=0;this.m_mC=0;this.m_mD=0;this.m_iA=0;this.m_iB=0;this.m_iC=0;this.m_iD=0;this.m_JvAC=new b2Vec2();this.m_JvBD=new b2Vec2();this.m_JwA=0;this.m_JwB=0;this.m_JwC=0;this.m_JwD=0;this.m_mass=0;this.m_qA=new b2Rot();this.m_qB=new b2Rot();this.m_qC=new b2Rot();this.m_qD=new b2Rot();this.m_lalcA=new b2Vec2();this.m_lalcB=new b2Vec2();this.m_lalcC=new b2Vec2();this.m_lalcD=new b2Vec2();this.m_joint1=def.joint1;this.m_joint2=def.joint2;this.m_typeA=this.m_joint1.GetType();this.m_typeB=this.m_joint2.GetType();let coordinateA,coordinateB;this.m_bodyC=this.m_joint1.GetBodyA();this.m_bodyA=this.m_joint1.GetBodyB();const xfA=this.m_bodyA.m_xf;const aA=this.m_bodyA.m_sweep.a;const xfC=this.m_bodyC.m_xf;const aC=this.m_bodyC.m_sweep.a;if(this.m_typeA===exports.b2JointType.e_revoluteJoint){const revolute=def.joint1;this.m_localAnchorC.Copy(revolute.m_localAnchorA);this.m_localAnchorA.Copy(revolute.m_localAnchorB);this.m_referenceAngleA=revolute.m_referenceAngle;this.m_localAxisC.SetZero();coordinateA=aA-aC-this.m_referenceAngleA;}else {const prismatic=def.joint1;this.m_localAnchorC.Copy(prismatic.m_localAnchorA);this.m_localAnchorA.Copy(prismatic.m_localAnchorB);this.m_referenceAngleA=prismatic.m_referenceAngle;this.m_localAxisC.Copy(prismatic.m_localXAxisA);const pC=this.m_localAnchorC;const pA=b2Rot.MulTRV(xfC.q,b2Vec2.AddVV(b2Rot.MulRV(xfA.q,this.m_localAnchorA,b2Vec2.s_t0),b2Vec2.SubVV(xfA.p,xfC.p,b2Vec2.s_t1),b2Vec2.s_t0),b2Vec2.s_t0);coordinateA=b2Vec2.DotVV(b2Vec2.SubVV(pA,pC,b2Vec2.s_t0),this.m_localAxisC);}this.m_bodyD=this.m_joint2.GetBodyA();this.m_bodyB=this.m_joint2.GetBodyB();const xfB=this.m_bodyB.m_xf;const aB=this.m_bodyB.m_sweep.a;const xfD=this.m_bodyD.m_xf;const aD=this.m_bodyD.m_sweep.a;if(this.m_typeB===exports.b2JointType.e_revoluteJoint){const revolute=def.joint2;this.m_localAnchorD.Copy(revolute.m_localAnchorA);this.m_localAnchorB.Copy(revolute.m_localAnchorB);this.m_referenceAngleB=revolute.m_referenceAngle;this.m_localAxisD.SetZero();coordinateB=aB-aD-this.m_referenceAngleB;}else {const prismatic=def.joint2;this.m_localAnchorD.Copy(prismatic.m_localAnchorA);this.m_localAnchorB.Copy(prismatic.m_localAnchorB);this.m_referenceAngleB=prismatic.m_referenceAngle;this.m_localAxisD.Copy(prismatic.m_localXAxisA);const pD=this.m_localAnchorD;const pB=b2Rot.MulTRV(xfD.q,b2Vec2.AddVV(b2Rot.MulRV(xfB.q,this.m_localAnchorB,b2Vec2.s_t0),b2Vec2.SubVV(xfB.p,xfD.p,b2Vec2.s_t1),b2Vec2.s_t0),b2Vec2.s_t0);coordinateB=b2Vec2.DotVV(b2Vec2.SubVV(pB,pD,b2Vec2.s_t0),this.m_localAxisD);}this.m_ratio=b2Maybe(def.ratio,1);this.m_constant=coordinateA+this.m_ratio*coordinateB;this.m_impulse=0;}InitVelocityConstraints(data){this.m_indexA=this.m_bodyA.m_islandIndex;this.m_indexB=this.m_bodyB.m_islandIndex;this.m_indexC=this.m_bodyC.m_islandIndex;this.m_indexD=this.m_bodyD.m_islandIndex;this.m_lcA.Copy(this.m_bodyA.m_sweep.localCenter);this.m_lcB.Copy(this.m_bodyB.m_sweep.localCenter);this.m_lcC.Copy(this.m_bodyC.m_sweep.localCenter);this.m_lcD.Copy(this.m_bodyD.m_sweep.localCenter);this.m_mA=this.m_bodyA.m_invMass;this.m_mB=this.m_bodyB.m_invMass;this.m_mC=this.m_bodyC.m_invMass;this.m_mD=this.m_bodyD.m_invMass;this.m_iA=this.m_bodyA.m_invI;this.m_iB=this.m_bodyB.m_invI;this.m_iC=this.m_bodyC.m_invI;this.m_iD=this.m_bodyD.m_invI;const aA=data.positions[this.m_indexA].a;const vA=data.velocities[this.m_indexA].v;let wA=data.velocities[this.m_indexA].w;const aB=data.positions[this.m_indexB].a;const vB=data.velocities[this.m_indexB].v;let wB=data.velocities[this.m_indexB].w;const aC=data.positions[this.m_indexC].a;const vC=data.velocities[this.m_indexC].v;let wC=data.velocities[this.m_indexC].w;const aD=data.positions[this.m_indexD].a;const vD=data.velocities[this.m_indexD].v;let wD=data.velocities[this.m_indexD].w;const qA=this.m_qA.SetAngle(aA),qB=this.m_qB.SetAngle(aB),qC=this.m_qC.SetAngle(aC),qD=this.m_qD.SetAngle(aD);this.m_mass=0;if(this.m_typeA===exports.b2JointType.e_revoluteJoint){this.m_JvAC.SetZero();this.m_JwA=1;this.m_JwC=1;this.m_mass+=this.m_iA+this.m_iC;}else {const u=b2Rot.MulRV(qC,this.m_localAxisC,b2GearJoint.InitVelocityConstraints_s_u);b2Vec2.SubVV(this.m_localAnchorC,this.m_lcC,this.m_lalcC);const rC=b2Rot.MulRV(qC,this.m_lalcC,b2GearJoint.InitVelocityConstraints_s_rC);b2Vec2.SubVV(this.m_localAnchorA,this.m_lcA,this.m_lalcA);const rA=b2Rot.MulRV(qA,this.m_lalcA,b2GearJoint.InitVelocityConstraints_s_rA);this.m_JvAC.Copy(u);this.m_JwC=b2Vec2.CrossVV(rC,u);this.m_JwA=b2Vec2.CrossVV(rA,u);this.m_mass+=this.m_mC+this.m_mA+this.m_iC*this.m_JwC*this.m_JwC+this.m_iA*this.m_JwA*this.m_JwA;}if(this.m_typeB===exports.b2JointType.e_revoluteJoint){this.m_JvBD.SetZero();this.m_JwB=this.m_ratio;this.m_JwD=this.m_ratio;this.m_mass+=this.m_ratio*this.m_ratio*(this.m_iB+this.m_iD);}else {const u=b2Rot.MulRV(qD,this.m_localAxisD,b2GearJoint.InitVelocityConstraints_s_u);b2Vec2.SubVV(this.m_localAnchorD,this.m_lcD,this.m_lalcD);const rD=b2Rot.MulRV(qD,this.m_lalcD,b2GearJoint.InitVelocityConstraints_s_rD);b2Vec2.SubVV(this.m_localAnchorB,this.m_lcB,this.m_lalcB);const rB=b2Rot.MulRV(qB,this.m_lalcB,b2GearJoint.InitVelocityConstraints_s_rB);b2Vec2.MulSV(this.m_ratio,u,this.m_JvBD);this.m_JwD=this.m_ratio*b2Vec2.CrossVV(rD,u);this.m_JwB=this.m_ratio*b2Vec2.CrossVV(rB,u);this.m_mass+=this.m_ratio*this.m_ratio*(this.m_mD+this.m_mB)+this.m_iD*this.m_JwD*this.m_JwD+this.m_iB*this.m_JwB*this.m_JwB;}this.m_mass=this.m_mass>0?1/this.m_mass:0;if(data.step.warmStarting){vA.SelfMulAdd(this.m_mA*this.m_impulse,this.m_JvAC);wA+=this.m_iA*this.m_impulse*this.m_JwA;vB.SelfMulAdd(this.m_mB*this.m_impulse,this.m_JvBD);wB+=this.m_iB*this.m_impulse*this.m_JwB;vC.SelfMulSub(this.m_mC*this.m_impulse,this.m_JvAC);wC-=this.m_iC*this.m_impulse*this.m_JwC;vD.SelfMulSub(this.m_mD*this.m_impulse,this.m_JvBD);wD-=this.m_iD*this.m_impulse*this.m_JwD;}else {this.m_impulse=0;}data.velocities[this.m_indexA].w=wA;data.velocities[this.m_indexB].w=wB;data.velocities[this.m_indexC].w=wC;data.velocities[this.m_indexD].w=wD;}SolveVelocityConstraints(data){const vA=data.velocities[this.m_indexA].v;let wA=data.velocities[this.m_indexA].w;const vB=data.velocities[this.m_indexB].v;let wB=data.velocities[this.m_indexB].w;const vC=data.velocities[this.m_indexC].v;let wC=data.velocities[this.m_indexC].w;const vD=data.velocities[this.m_indexD].v;let wD=data.velocities[this.m_indexD].w;let Cdot=b2Vec2.DotVV(this.m_JvAC,b2Vec2.SubVV(vA,vC,b2Vec2.s_t0))+b2Vec2.DotVV(this.m_JvBD,b2Vec2.SubVV(vB,vD,b2Vec2.s_t0));Cdot+=this.m_JwA*wA-this.m_JwC*wC+(this.m_JwB*wB-this.m_JwD*wD);const impulse=-this.m_mass*Cdot;this.m_impulse+=impulse;vA.SelfMulAdd(this.m_mA*impulse,this.m_JvAC);wA+=this.m_iA*impulse*this.m_JwA;vB.SelfMulAdd(this.m_mB*impulse,this.m_JvBD);wB+=this.m_iB*impulse*this.m_JwB;vC.SelfMulSub(this.m_mC*impulse,this.m_JvAC);wC-=this.m_iC*impulse*this.m_JwC;vD.SelfMulSub(this.m_mD*impulse,this.m_JvBD);wD-=this.m_iD*impulse*this.m_JwD;data.velocities[this.m_indexA].w=wA;data.velocities[this.m_indexB].w=wB;data.velocities[this.m_indexC].w=wC;data.velocities[this.m_indexD].w=wD;}SolvePositionConstraints(data){const cA=data.positions[this.m_indexA].c;let aA=data.positions[this.m_indexA].a;const cB=data.positions[this.m_indexB].c;let aB=data.positions[this.m_indexB].a;const cC=data.positions[this.m_indexC].c;let aC=data.positions[this.m_indexC].a;const cD=data.positions[this.m_indexD].c;let aD=data.positions[this.m_indexD].a;const qA=this.m_qA.SetAngle(aA),qB=this.m_qB.SetAngle(aB),qC=this.m_qC.SetAngle(aC),qD=this.m_qD.SetAngle(aD);const linearError=0;let coordinateA,coordinateB;const JvAC=this.m_JvAC,JvBD=this.m_JvBD;let JwA,JwB,JwC,JwD;let mass=0;if(this.m_typeA===exports.b2JointType.e_revoluteJoint){JvAC.SetZero();JwA=1;JwC=1;mass+=this.m_iA+this.m_iC;coordinateA=aA-aC-this.m_referenceAngleA;}else {const u=b2Rot.MulRV(qC,this.m_localAxisC,b2GearJoint.SolvePositionConstraints_s_u);const rC=b2Rot.MulRV(qC,this.m_lalcC,b2GearJoint.SolvePositionConstraints_s_rC);const rA=b2Rot.MulRV(qA,this.m_lalcA,b2GearJoint.SolvePositionConstraints_s_rA);JvAC.Copy(u);JwC=b2Vec2.CrossVV(rC,u);JwA=b2Vec2.CrossVV(rA,u);mass+=this.m_mC+this.m_mA+this.m_iC*JwC*JwC+this.m_iA*JwA*JwA;const pC=this.m_lalcC;const pA=b2Rot.MulTRV(qC,b2Vec2.AddVV(rA,b2Vec2.SubVV(cA,cC,b2Vec2.s_t0),b2Vec2.s_t0),b2Vec2.s_t0);coordinateA=b2Vec2.DotVV(b2Vec2.SubVV(pA,pC,b2Vec2.s_t0),this.m_localAxisC);}if(this.m_typeB===exports.b2JointType.e_revoluteJoint){JvBD.SetZero();JwB=this.m_ratio;JwD=this.m_ratio;mass+=this.m_ratio*this.m_ratio*(this.m_iB+this.m_iD);coordinateB=aB-aD-this.m_referenceAngleB;}else {const u=b2Rot.MulRV(qD,this.m_localAxisD,b2GearJoint.SolvePositionConstraints_s_u);const rD=b2Rot.MulRV(qD,this.m_lalcD,b2GearJoint.SolvePositionConstraints_s_rD);const rB=b2Rot.MulRV(qB,this.m_lalcB,b2GearJoint.SolvePositionConstraints_s_rB);b2Vec2.MulSV(this.m_ratio,u,JvBD);JwD=this.m_ratio*b2Vec2.CrossVV(rD,u);JwB=this.m_ratio*b2Vec2.CrossVV(rB,u);mass+=this.m_ratio*this.m_ratio*(this.m_mD+this.m_mB)+this.m_iD*JwD*JwD+this.m_iB*JwB*JwB;const pD=this.m_lalcD;const pB=b2Rot.MulTRV(qD,b2Vec2.AddVV(rB,b2Vec2.SubVV(cB,cD,b2Vec2.s_t0),b2Vec2.s_t0),b2Vec2.s_t0);coordinateB=b2Vec2.DotVV(b2Vec2.SubVV(pB,pD,b2Vec2.s_t0),this.m_localAxisD);}const C=coordinateA+this.m_ratio*coordinateB-this.m_constant;let impulse=0;if(mass>0){impulse=-C/mass;}cA.SelfMulAdd(this.m_mA*impulse,JvAC);aA+=this.m_iA*impulse*JwA;cB.SelfMulAdd(this.m_mB*impulse,JvBD);aB+=this.m_iB*impulse*JwB;cC.SelfMulSub(this.m_mC*impulse,JvAC);aC-=this.m_iC*impulse*JwC;cD.SelfMulSub(this.m_mD*impulse,JvBD);aD-=this.m_iD*impulse*JwD;data.positions[this.m_indexA].a=aA;data.positions[this.m_indexB].a=aB;data.positions[this.m_indexC].a=aC;data.positions[this.m_indexD].a=aD;return linearError<b2_linearSlop;}GetAnchorA(out){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,out);}GetAnchorB(out){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,out);}GetReactionForce(inv_dt,out){return b2Vec2.MulSV(inv_dt*this.m_impulse,this.m_JvAC,out);}GetReactionTorque(inv_dt){return inv_dt*this.m_impulse*this.m_JwA;}GetJoint1(){return this.m_joint1;}GetJoint2(){return this.m_joint2;}GetRatio(){return this.m_ratio;}SetRatio(ratio){this.m_ratio=ratio;}Dump(log){const indexA=this.m_bodyA.m_islandIndex;const indexB=this.m_bodyB.m_islandIndex;const index1=this.m_joint1.m_index;const index2=this.m_joint2.m_index;log("  const jd: b2GearJointDef = new b2GearJointDef();\n");log("  jd.bodyA = bodies[%d];\n",indexA);log("  jd.bodyB = bodies[%d];\n",indexB);log("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false");log("  jd.joint1 = joints[%d];\n",index1);log("  jd.joint2 = joints[%d];\n",index2);log("  jd.ratio = %.15f;\n",this.m_ratio);log("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index);}}b2GearJoint.InitVelocityConstraints_s_u=new b2Vec2();b2GearJoint.InitVelocityConstraints_s_rA=new b2Vec2();b2GearJoint.InitVelocityConstraints_s_rB=new b2Vec2();b2GearJoint.InitVelocityConstraints_s_rC=new b2Vec2();b2GearJoint.InitVelocityConstraints_s_rD=new b2Vec2();b2GearJoint.SolvePositionConstraints_s_u=new b2Vec2();b2GearJoint.SolvePositionConstraints_s_rA=new b2Vec2();b2GearJoint.SolvePositionConstraints_s_rB=new b2Vec2();b2GearJoint.SolvePositionConstraints_s_rC=new b2Vec2();b2GearJoint.SolvePositionConstraints_s_rD=new b2Vec2();class b2MotorJointDef extends b2JointDef{constructor(){super(exports.b2JointType.e_motorJoint);this.linearOffset=new b2Vec2(0,0);this.angularOffset=0;this.maxForce=1;this.maxTorque=1;this.correctionFactor=0.3;}Initialize(bA,bB){this.bodyA=bA;this.bodyB=bB;this.bodyA.GetLocalPoint(this.bodyB.GetPosition(),this.linearOffset);const angleA=this.bodyA.GetAngle();const angleB=this.bodyB.GetAngle();this.angularOffset=angleB-angleA;}}class b2MotorJoint extends b2Joint{constructor(def){super(def);this.m_linearOffset=new b2Vec2();this.m_angularOffset=0;this.m_linearImpulse=new b2Vec2();this.m_angularImpulse=0;this.m_maxForce=0;this.m_maxTorque=0;this.m_correctionFactor=0.3;this.m_indexA=0;this.m_indexB=0;this.m_rA=new b2Vec2();this.m_rB=new b2Vec2();this.m_localCenterA=new b2Vec2();this.m_localCenterB=new b2Vec2();this.m_linearError=new b2Vec2();this.m_angularError=0;this.m_invMassA=0;this.m_invMassB=0;this.m_invIA=0;this.m_invIB=0;this.m_linearMass=new b2Mat22();this.m_angularMass=0;this.m_qA=new b2Rot();this.m_qB=new b2Rot();this.m_K=new b2Mat22();this.m_linearOffset.Copy(b2Maybe(def.linearOffset,b2Vec2.ZERO));this.m_linearImpulse.SetZero();this.m_maxForce=b2Maybe(def.maxForce,0);this.m_maxTorque=b2Maybe(def.maxTorque,0);this.m_correctionFactor=b2Maybe(def.correctionFactor,0.3);}GetAnchorA(out){const pos=this.m_bodyA.GetPosition();out.x=pos.x;out.y=pos.y;return out;}GetAnchorB(out){const pos=this.m_bodyB.GetPosition();out.x=pos.x;out.y=pos.y;return out;}GetReactionForce(inv_dt,out){return b2Vec2.MulSV(inv_dt,this.m_linearImpulse,out);}GetReactionTorque(inv_dt){return inv_dt*this.m_angularImpulse;}SetLinearOffset(linearOffset){if(!b2Vec2.IsEqualToV(linearOffset,this.m_linearOffset)){this.m_bodyA.SetAwake(true);this.m_bodyB.SetAwake(true);this.m_linearOffset.Copy(linearOffset);}}GetLinearOffset(){return this.m_linearOffset;}SetAngularOffset(angularOffset){if(angularOffset!==this.m_angularOffset){this.m_bodyA.SetAwake(true);this.m_bodyB.SetAwake(true);this.m_angularOffset=angularOffset;}}GetAngularOffset(){return this.m_angularOffset;}SetMaxForce(force){this.m_maxForce=force;}GetMaxForce(){return this.m_maxForce;}SetMaxTorque(torque){this.m_maxTorque=torque;}GetMaxTorque(){return this.m_maxTorque;}InitVelocityConstraints(data){this.m_indexA=this.m_bodyA.m_islandIndex;this.m_indexB=this.m_bodyB.m_islandIndex;this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);this.m_invMassA=this.m_bodyA.m_invMass;this.m_invMassB=this.m_bodyB.m_invMass;this.m_invIA=this.m_bodyA.m_invI;this.m_invIB=this.m_bodyB.m_invI;const cA=data.positions[this.m_indexA].c;const aA=data.positions[this.m_indexA].a;const vA=data.velocities[this.m_indexA].v;let wA=data.velocities[this.m_indexA].w;const cB=data.positions[this.m_indexB].c;const aB=data.positions[this.m_indexB].a;const vB=data.velocities[this.m_indexB].v;let wB=data.velocities[this.m_indexB].w;const qA=this.m_qA.SetAngle(aA),qB=this.m_qB.SetAngle(aB);const rA=b2Rot.MulRV(qA,b2Vec2.SubVV(this.m_linearOffset,this.m_localCenterA,b2Vec2.s_t0),this.m_rA);const rB=b2Rot.MulRV(qB,b2Vec2.NegV(this.m_localCenterB,b2Vec2.s_t0),this.m_rB);const mA=this.m_invMassA,mB=this.m_invMassB;const iA=this.m_invIA,iB=this.m_invIB;const K=this.m_K;K.ex.x=mA+mB+iA*rA.y*rA.y+iB*rB.y*rB.y;K.ex.y=-iA*rA.x*rA.y-iB*rB.x*rB.y;K.ey.x=K.ex.y;K.ey.y=mA+mB+iA*rA.x*rA.x+iB*rB.x*rB.x;K.GetInverse(this.m_linearMass);this.m_angularMass=iA+iB;if(this.m_angularMass>0){this.m_angularMass=1/this.m_angularMass;}b2Vec2.SubVV(b2Vec2.AddVV(cB,rB,b2Vec2.s_t0),b2Vec2.AddVV(cA,rA,b2Vec2.s_t1),this.m_linearError);this.m_angularError=aB-aA-this.m_angularOffset;if(data.step.warmStarting){this.m_linearImpulse.SelfMul(data.step.dtRatio);this.m_angularImpulse*=data.step.dtRatio;const P=this.m_linearImpulse;vA.SelfMulSub(mA,P);wA-=iA*(b2Vec2.CrossVV(rA,P)+this.m_angularImpulse);vB.SelfMulAdd(mB,P);wB+=iB*(b2Vec2.CrossVV(rB,P)+this.m_angularImpulse);}else {this.m_linearImpulse.SetZero();this.m_angularImpulse=0;}data.velocities[this.m_indexA].w=wA;data.velocities[this.m_indexB].w=wB;}SolveVelocityConstraints(data){const vA=data.velocities[this.m_indexA].v;let wA=data.velocities[this.m_indexA].w;const vB=data.velocities[this.m_indexB].v;let wB=data.velocities[this.m_indexB].w;const mA=this.m_invMassA,mB=this.m_invMassB;const iA=this.m_invIA,iB=this.m_invIB;const h=data.step.dt;const inv_h=data.step.inv_dt;{const Cdot=wB-wA+inv_h*this.m_correctionFactor*this.m_angularError;let impulse=-this.m_angularMass*Cdot;const oldImpulse=this.m_angularImpulse;const maxImpulse=h*this.m_maxTorque;this.m_angularImpulse=b2Clamp(this.m_angularImpulse+impulse,-maxImpulse,maxImpulse);impulse=this.m_angularImpulse-oldImpulse;wA-=iA*impulse;wB+=iB*impulse;}{const rA=this.m_rA;const rB=this.m_rB;const Cdot_v2=b2Vec2.AddVV(b2Vec2.SubVV(b2Vec2.AddVV(vB,b2Vec2.CrossSV(wB,rB,b2Vec2.s_t0),b2Vec2.s_t0),b2Vec2.AddVV(vA,b2Vec2.CrossSV(wA,rA,b2Vec2.s_t1),b2Vec2.s_t1),b2Vec2.s_t2),b2Vec2.MulSV(inv_h*this.m_correctionFactor,this.m_linearError,b2Vec2.s_t3),b2MotorJoint.SolveVelocityConstraints_s_Cdot_v2);const impulse_v2=b2Mat22.MulMV(this.m_linearMass,Cdot_v2,b2MotorJoint.SolveVelocityConstraints_s_impulse_v2).SelfNeg();const oldImpulse_v2=b2MotorJoint.SolveVelocityConstraints_s_oldImpulse_v2.Copy(this.m_linearImpulse);this.m_linearImpulse.SelfAdd(impulse_v2);const maxImpulse=h*this.m_maxForce;if(this.m_linearImpulse.LengthSquared()>maxImpulse*maxImpulse){this.m_linearImpulse.Normalize();this.m_linearImpulse.SelfMul(maxImpulse);}b2Vec2.SubVV(this.m_linearImpulse,oldImpulse_v2,impulse_v2);vA.SelfMulSub(mA,impulse_v2);wA-=iA*b2Vec2.CrossVV(rA,impulse_v2);vB.SelfMulAdd(mB,impulse_v2);wB+=iB*b2Vec2.CrossVV(rB,impulse_v2);}data.velocities[this.m_indexA].w=wA;data.velocities[this.m_indexB].w=wB;}SolvePositionConstraints(data){return true;}Dump(log){const indexA=this.m_bodyA.m_islandIndex;const indexB=this.m_bodyB.m_islandIndex;log("  const jd: b2MotorJointDef = new b2MotorJointDef();\n");log("  jd.bodyA = bodies[%d];\n",indexA);log("  jd.bodyB = bodies[%d];\n",indexB);log("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false");log("  jd.linearOffset.Set(%.15f, %.15f);\n",this.m_linearOffset.x,this.m_linearOffset.y);log("  jd.angularOffset = %.15f;\n",this.m_angularOffset);log("  jd.maxForce = %.15f;\n",this.m_maxForce);log("  jd.maxTorque = %.15f;\n",this.m_maxTorque);log("  jd.correctionFactor = %.15f;\n",this.m_correctionFactor);log("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index);}}b2MotorJoint.SolveVelocityConstraints_s_Cdot_v2=new b2Vec2();b2MotorJoint.SolveVelocityConstraints_s_impulse_v2=new b2Vec2();b2MotorJoint.SolveVelocityConstraints_s_oldImpulse_v2=new b2Vec2();class b2MouseJointDef extends b2JointDef{constructor(){super(exports.b2JointType.e_mouseJoint);this.target=new b2Vec2();this.maxForce=0;this.frequencyHz=5;this.dampingRatio=0.7;}}class b2MouseJoint extends b2Joint{constructor(def){super(def);this.m_localAnchorB=new b2Vec2();this.m_targetA=new b2Vec2();this.m_frequencyHz=0;this.m_dampingRatio=0;this.m_beta=0;this.m_impulse=new b2Vec2();this.m_maxForce=0;this.m_gamma=0;this.m_indexA=0;this.m_indexB=0;this.m_rB=new b2Vec2();this.m_localCenterB=new b2Vec2();this.m_invMassB=0;this.m_invIB=0;this.m_mass=new b2Mat22();this.m_C=new b2Vec2();this.m_qB=new b2Rot();this.m_lalcB=new b2Vec2();this.m_K=new b2Mat22();this.m_targetA.Copy(b2Maybe(def.target,b2Vec2.ZERO));b2Transform.MulTXV(this.m_bodyB.GetTransform(),this.m_targetA,this.m_localAnchorB);this.m_maxForce=b2Maybe(def.maxForce,0);this.m_impulse.SetZero();this.m_frequencyHz=b2Maybe(def.frequencyHz,0);this.m_dampingRatio=b2Maybe(def.dampingRatio,0);this.m_beta=0;this.m_gamma=0;}SetTarget(target){if(!this.m_bodyB.IsAwake()){this.m_bodyB.SetAwake(true);}this.m_targetA.Copy(target);}GetTarget(){return this.m_targetA;}SetMaxForce(maxForce){this.m_maxForce=maxForce;}GetMaxForce(){return this.m_maxForce;}SetFrequency(hz){this.m_frequencyHz=hz;}GetFrequency(){return this.m_frequencyHz;}SetDampingRatio(ratio){this.m_dampingRatio=ratio;}GetDampingRatio(){return this.m_dampingRatio;}InitVelocityConstraints(data){this.m_indexB=this.m_bodyB.m_islandIndex;this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);this.m_invMassB=this.m_bodyB.m_invMass;this.m_invIB=this.m_bodyB.m_invI;const cB=data.positions[this.m_indexB].c;const aB=data.positions[this.m_indexB].a;const vB=data.velocities[this.m_indexB].v;let wB=data.velocities[this.m_indexB].w;const qB=this.m_qB.SetAngle(aB);const mass=this.m_bodyB.GetMass();const omega=2*b2_pi*this.m_frequencyHz;const d=2*mass*this.m_dampingRatio*omega;const k=mass*(omega*omega);const h=data.step.dt;this.m_gamma=h*(d+h*k);if(this.m_gamma!==0){this.m_gamma=1/this.m_gamma;}this.m_beta=h*k*this.m_gamma;b2Vec2.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);b2Rot.MulRV(qB,this.m_lalcB,this.m_rB);const K=this.m_K;K.ex.x=this.m_invMassB+this.m_invIB*this.m_rB.y*this.m_rB.y+this.m_gamma;K.ex.y=-this.m_invIB*this.m_rB.x*this.m_rB.y;K.ey.x=K.ex.y;K.ey.y=this.m_invMassB+this.m_invIB*this.m_rB.x*this.m_rB.x+this.m_gamma;K.GetInverse(this.m_mass);this.m_C.x=cB.x+this.m_rB.x-this.m_targetA.x;this.m_C.y=cB.y+this.m_rB.y-this.m_targetA.y;this.m_C.SelfMul(this.m_beta);wB*=0.98;if(data.step.warmStarting){this.m_impulse.SelfMul(data.step.dtRatio);vB.x+=this.m_invMassB*this.m_impulse.x;vB.y+=this.m_invMassB*this.m_impulse.y;wB+=this.m_invIB*b2Vec2.CrossVV(this.m_rB,this.m_impulse);}else {this.m_impulse.SetZero();}data.velocities[this.m_indexB].w=wB;}SolveVelocityConstraints(data){const vB=data.velocities[this.m_indexB].v;let wB=data.velocities[this.m_indexB].w;const Cdot=b2Vec2.AddVCrossSV(vB,wB,this.m_rB,b2MouseJoint.SolveVelocityConstraints_s_Cdot);const impulse=b2Mat22.MulMV(this.m_mass,b2Vec2.AddVV(Cdot,b2Vec2.AddVV(this.m_C,b2Vec2.MulSV(this.m_gamma,this.m_impulse,b2Vec2.s_t0),b2Vec2.s_t0),b2Vec2.s_t0).SelfNeg(),b2MouseJoint.SolveVelocityConstraints_s_impulse);const oldImpulse=b2MouseJoint.SolveVelocityConstraints_s_oldImpulse.Copy(this.m_impulse);this.m_impulse.SelfAdd(impulse);const maxImpulse=data.step.dt*this.m_maxForce;if(this.m_impulse.LengthSquared()>maxImpulse*maxImpulse){this.m_impulse.SelfMul(maxImpulse/this.m_impulse.Length());}b2Vec2.SubVV(this.m_impulse,oldImpulse,impulse);vB.SelfMulAdd(this.m_invMassB,impulse);wB+=this.m_invIB*b2Vec2.CrossVV(this.m_rB,impulse);data.velocities[this.m_indexB].w=wB;}SolvePositionConstraints(data){return true;}GetAnchorA(out){out.x=this.m_targetA.x;out.y=this.m_targetA.y;return out;}GetAnchorB(out){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,out);}GetReactionForce(inv_dt,out){return b2Vec2.MulSV(inv_dt,this.m_impulse,out);}GetReactionTorque(inv_dt){return 0;}Dump(log){log("Mouse joint dumping is not supported.\n");}ShiftOrigin(newOrigin){this.m_targetA.SelfSub(newOrigin);}}b2MouseJoint.SolveVelocityConstraints_s_Cdot=new b2Vec2();b2MouseJoint.SolveVelocityConstraints_s_impulse=new b2Vec2();b2MouseJoint.SolveVelocityConstraints_s_oldImpulse=new b2Vec2();class b2PrismaticJointDef extends b2JointDef{constructor(){super(exports.b2JointType.e_prismaticJoint);this.localAnchorA=new b2Vec2();this.localAnchorB=new b2Vec2();this.localAxisA=new b2Vec2(1,0);this.referenceAngle=0;this.enableLimit=false;this.lowerTranslation=0;this.upperTranslation=0;this.enableMotor=false;this.maxMotorForce=0;this.motorSpeed=0;}Initialize(bA,bB,anchor,axis){this.bodyA=bA;this.bodyB=bB;this.bodyA.GetLocalPoint(anchor,this.localAnchorA);this.bodyB.GetLocalPoint(anchor,this.localAnchorB);this.bodyA.GetLocalVector(axis,this.localAxisA);this.referenceAngle=this.bodyB.GetAngle()-this.bodyA.GetAngle();}}class b2PrismaticJoint extends b2Joint{constructor(def){super(def);this.m_localAnchorA=new b2Vec2();this.m_localAnchorB=new b2Vec2();this.m_localXAxisA=new b2Vec2();this.m_localYAxisA=new b2Vec2();this.m_referenceAngle=0;this.m_impulse=new b2Vec3(0,0,0);this.m_motorImpulse=0;this.m_lowerTranslation=0;this.m_upperTranslation=0;this.m_maxMotorForce=0;this.m_motorSpeed=0;this.m_enableLimit=false;this.m_enableMotor=false;this.m_limitState=exports.b2LimitState.e_inactiveLimit;this.m_indexA=0;this.m_indexB=0;this.m_localCenterA=new b2Vec2();this.m_localCenterB=new b2Vec2();this.m_invMassA=0;this.m_invMassB=0;this.m_invIA=0;this.m_invIB=0;this.m_axis=new b2Vec2(0,0);this.m_perp=new b2Vec2(0,0);this.m_s1=0;this.m_s2=0;this.m_a1=0;this.m_a2=0;this.m_K=new b2Mat33();this.m_K3=new b2Mat33();this.m_K2=new b2Mat22();this.m_motorMass=0;this.m_qA=new b2Rot();this.m_qB=new b2Rot();this.m_lalcA=new b2Vec2();this.m_lalcB=new b2Vec2();this.m_rA=new b2Vec2();this.m_rB=new b2Vec2();this.m_localAnchorA.Copy(b2Maybe(def.localAnchorA,b2Vec2.ZERO));this.m_localAnchorB.Copy(b2Maybe(def.localAnchorB,b2Vec2.ZERO));this.m_localXAxisA.Copy(b2Maybe(def.localAxisA,new b2Vec2(1,0))).SelfNormalize();b2Vec2.CrossOneV(this.m_localXAxisA,this.m_localYAxisA);this.m_referenceAngle=b2Maybe(def.referenceAngle,0);this.m_lowerTranslation=b2Maybe(def.lowerTranslation,0);this.m_upperTranslation=b2Maybe(def.upperTranslation,0);this.m_maxMotorForce=b2Maybe(def.maxMotorForce,0);this.m_motorSpeed=b2Maybe(def.motorSpeed,0);this.m_enableLimit=b2Maybe(def.enableLimit,false);this.m_enableMotor=b2Maybe(def.enableMotor,false);}InitVelocityConstraints(data){this.m_indexA=this.m_bodyA.m_islandIndex;this.m_indexB=this.m_bodyB.m_islandIndex;this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);this.m_invMassA=this.m_bodyA.m_invMass;this.m_invMassB=this.m_bodyB.m_invMass;this.m_invIA=this.m_bodyA.m_invI;this.m_invIB=this.m_bodyB.m_invI;const cA=data.positions[this.m_indexA].c;const aA=data.positions[this.m_indexA].a;const vA=data.velocities[this.m_indexA].v;let wA=data.velocities[this.m_indexA].w;const cB=data.positions[this.m_indexB].c;const aB=data.positions[this.m_indexB].a;const vB=data.velocities[this.m_indexB].v;let wB=data.velocities[this.m_indexB].w;const qA=this.m_qA.SetAngle(aA),qB=this.m_qB.SetAngle(aB);b2Vec2.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);const rA=b2Rot.MulRV(qA,this.m_lalcA,this.m_rA);b2Vec2.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);const rB=b2Rot.MulRV(qB,this.m_lalcB,this.m_rB);const d=b2Vec2.AddVV(b2Vec2.SubVV(cB,cA,b2Vec2.s_t0),b2Vec2.SubVV(rB,rA,b2Vec2.s_t1),b2PrismaticJoint.InitVelocityConstraints_s_d);const mA=this.m_invMassA,mB=this.m_invMassB;const iA=this.m_invIA,iB=this.m_invIB;{b2Rot.MulRV(qA,this.m_localXAxisA,this.m_axis);this.m_a1=b2Vec2.CrossVV(b2Vec2.AddVV(d,rA,b2Vec2.s_t0),this.m_axis);this.m_a2=b2Vec2.CrossVV(rB,this.m_axis);this.m_motorMass=mA+mB+iA*this.m_a1*this.m_a1+iB*this.m_a2*this.m_a2;if(this.m_motorMass>0){this.m_motorMass=1/this.m_motorMass;}}{b2Rot.MulRV(qA,this.m_localYAxisA,this.m_perp);this.m_s1=b2Vec2.CrossVV(b2Vec2.AddVV(d,rA,b2Vec2.s_t0),this.m_perp);this.m_s2=b2Vec2.CrossVV(rB,this.m_perp);this.m_K.ex.x=mA+mB+iA*this.m_s1*this.m_s1+iB*this.m_s2*this.m_s2;this.m_K.ex.y=iA*this.m_s1+iB*this.m_s2;this.m_K.ex.z=iA*this.m_s1*this.m_a1+iB*this.m_s2*this.m_a2;this.m_K.ey.x=this.m_K.ex.y;this.m_K.ey.y=iA+iB;if(this.m_K.ey.y===0){this.m_K.ey.y=1;}this.m_K.ey.z=iA*this.m_a1+iB*this.m_a2;this.m_K.ez.x=this.m_K.ex.z;this.m_K.ez.y=this.m_K.ey.z;this.m_K.ez.z=mA+mB+iA*this.m_a1*this.m_a1+iB*this.m_a2*this.m_a2;}if(this.m_enableLimit){const jointTranslation=b2Vec2.DotVV(this.m_axis,d);if(b2Abs(this.m_upperTranslation-this.m_lowerTranslation)<2*b2_linearSlop){this.m_limitState=exports.b2LimitState.e_equalLimits;}else if(jointTranslation<=this.m_lowerTranslation){if(this.m_limitState!==exports.b2LimitState.e_atLowerLimit){this.m_limitState=exports.b2LimitState.e_atLowerLimit;this.m_impulse.z=0;}}else if(jointTranslation>=this.m_upperTranslation){if(this.m_limitState!==exports.b2LimitState.e_atUpperLimit){this.m_limitState=exports.b2LimitState.e_atUpperLimit;this.m_impulse.z=0;}}else {this.m_limitState=exports.b2LimitState.e_inactiveLimit;this.m_impulse.z=0;}}else {this.m_limitState=exports.b2LimitState.e_inactiveLimit;this.m_impulse.z=0;}if(!this.m_enableMotor){this.m_motorImpulse=0;}if(data.step.warmStarting){this.m_impulse.SelfMul(data.step.dtRatio);this.m_motorImpulse*=data.step.dtRatio;const P=b2Vec2.AddVV(b2Vec2.MulSV(this.m_impulse.x,this.m_perp,b2Vec2.s_t0),b2Vec2.MulSV(this.m_motorImpulse+this.m_impulse.z,this.m_axis,b2Vec2.s_t1),b2PrismaticJoint.InitVelocityConstraints_s_P);const LA=this.m_impulse.x*this.m_s1+this.m_impulse.y+(this.m_motorImpulse+this.m_impulse.z)*this.m_a1;const LB=this.m_impulse.x*this.m_s2+this.m_impulse.y+(this.m_motorImpulse+this.m_impulse.z)*this.m_a2;vA.SelfMulSub(mA,P);wA-=iA*LA;vB.SelfMulAdd(mB,P);wB+=iB*LB;}else {this.m_impulse.SetZero();this.m_motorImpulse=0;}data.velocities[this.m_indexA].w=wA;data.velocities[this.m_indexB].w=wB;}SolveVelocityConstraints(data){const vA=data.velocities[this.m_indexA].v;let wA=data.velocities[this.m_indexA].w;const vB=data.velocities[this.m_indexB].v;let wB=data.velocities[this.m_indexB].w;const mA=this.m_invMassA,mB=this.m_invMassB;const iA=this.m_invIA,iB=this.m_invIB;if(this.m_enableMotor&&this.m_limitState!==exports.b2LimitState.e_equalLimits){const Cdot=b2Vec2.DotVV(this.m_axis,b2Vec2.SubVV(vB,vA,b2Vec2.s_t0))+this.m_a2*wB-this.m_a1*wA;let impulse=this.m_motorMass*(this.m_motorSpeed-Cdot);const oldImpulse=this.m_motorImpulse;const maxImpulse=data.step.dt*this.m_maxMotorForce;this.m_motorImpulse=b2Clamp(this.m_motorImpulse+impulse,-maxImpulse,maxImpulse);impulse=this.m_motorImpulse-oldImpulse;const P=b2Vec2.MulSV(impulse,this.m_axis,b2PrismaticJoint.SolveVelocityConstraints_s_P);const LA=impulse*this.m_a1;const LB=impulse*this.m_a2;vA.SelfMulSub(mA,P);wA-=iA*LA;vB.SelfMulAdd(mB,P);wB+=iB*LB;}const Cdot1_x=b2Vec2.DotVV(this.m_perp,b2Vec2.SubVV(vB,vA,b2Vec2.s_t0))+this.m_s2*wB-this.m_s1*wA;const Cdot1_y=wB-wA;if(this.m_enableLimit&&this.m_limitState!==exports.b2LimitState.e_inactiveLimit){const Cdot2=b2Vec2.DotVV(this.m_axis,b2Vec2.SubVV(vB,vA,b2Vec2.s_t0))+this.m_a2*wB-this.m_a1*wA;const f1=b2PrismaticJoint.SolveVelocityConstraints_s_f1.Copy(this.m_impulse);const df3=this.m_K.Solve33(-Cdot1_x,-Cdot1_y,-Cdot2,b2PrismaticJoint.SolveVelocityConstraints_s_df3);this.m_impulse.SelfAdd(df3);if(this.m_limitState===exports.b2LimitState.e_atLowerLimit){this.m_impulse.z=b2Max(this.m_impulse.z,0);}else if(this.m_limitState===exports.b2LimitState.e_atUpperLimit){this.m_impulse.z=b2Min(this.m_impulse.z,0);}const b_x=-Cdot1_x-(this.m_impulse.z-f1.z)*this.m_K.ez.x;const b_y=-Cdot1_y-(this.m_impulse.z-f1.z)*this.m_K.ez.y;const f2r=this.m_K.Solve22(b_x,b_y,b2PrismaticJoint.SolveVelocityConstraints_s_f2r);f2r.x+=f1.x;f2r.y+=f1.y;this.m_impulse.x=f2r.x;this.m_impulse.y=f2r.y;df3.x=this.m_impulse.x-f1.x;df3.y=this.m_impulse.y-f1.y;df3.z=this.m_impulse.z-f1.z;const P=b2Vec2.AddVV(b2Vec2.MulSV(df3.x,this.m_perp,b2Vec2.s_t0),b2Vec2.MulSV(df3.z,this.m_axis,b2Vec2.s_t1),b2PrismaticJoint.SolveVelocityConstraints_s_P);const LA=df3.x*this.m_s1+df3.y+df3.z*this.m_a1;const LB=df3.x*this.m_s2+df3.y+df3.z*this.m_a2;vA.SelfMulSub(mA,P);wA-=iA*LA;vB.SelfMulAdd(mB,P);wB+=iB*LB;}else {const df2=this.m_K.Solve22(-Cdot1_x,-Cdot1_y,b2PrismaticJoint.SolveVelocityConstraints_s_df2);this.m_impulse.x+=df2.x;this.m_impulse.y+=df2.y;const P=b2Vec2.MulSV(df2.x,this.m_perp,b2PrismaticJoint.SolveVelocityConstraints_s_P);const LA=df2.x*this.m_s1+df2.y;const LB=df2.x*this.m_s2+df2.y;vA.SelfMulSub(mA,P);wA-=iA*LA;vB.SelfMulAdd(mB,P);wB+=iB*LB;}data.velocities[this.m_indexA].w=wA;data.velocities[this.m_indexB].w=wB;}SolvePositionConstraints(data){const cA=data.positions[this.m_indexA].c;let aA=data.positions[this.m_indexA].a;const cB=data.positions[this.m_indexB].c;let aB=data.positions[this.m_indexB].a;const qA=this.m_qA.SetAngle(aA),qB=this.m_qB.SetAngle(aB);const mA=this.m_invMassA,mB=this.m_invMassB;const iA=this.m_invIA,iB=this.m_invIB;const rA=b2Rot.MulRV(qA,this.m_lalcA,this.m_rA);const rB=b2Rot.MulRV(qB,this.m_lalcB,this.m_rB);const d=b2Vec2.SubVV(b2Vec2.AddVV(cB,rB,b2Vec2.s_t0),b2Vec2.AddVV(cA,rA,b2Vec2.s_t1),b2PrismaticJoint.SolvePositionConstraints_s_d);const axis=b2Rot.MulRV(qA,this.m_localXAxisA,this.m_axis);const a1=b2Vec2.CrossVV(b2Vec2.AddVV(d,rA,b2Vec2.s_t0),axis);const a2=b2Vec2.CrossVV(rB,axis);const perp=b2Rot.MulRV(qA,this.m_localYAxisA,this.m_perp);const s1=b2Vec2.CrossVV(b2Vec2.AddVV(d,rA,b2Vec2.s_t0),perp);const s2=b2Vec2.CrossVV(rB,perp);let impulse=b2PrismaticJoint.SolvePositionConstraints_s_impulse;const C1_x=b2Vec2.DotVV(perp,d);const C1_y=aB-aA-this.m_referenceAngle;let linearError=b2Abs(C1_x);const angularError=b2Abs(C1_y);let active=false;let C2=0;if(this.m_enableLimit){const translation=b2Vec2.DotVV(axis,d);if(b2Abs(this.m_upperTranslation-this.m_lowerTranslation)<2*b2_linearSlop){C2=b2Clamp(translation,-b2_maxLinearCorrection,b2_maxLinearCorrection);linearError=b2Max(linearError,b2Abs(translation));active=true;}else if(translation<=this.m_lowerTranslation){C2=b2Clamp(translation-this.m_lowerTranslation+b2_linearSlop,-b2_maxLinearCorrection,0);linearError=b2Max(linearError,this.m_lowerTranslation-translation);active=true;}else if(translation>=this.m_upperTranslation){C2=b2Clamp(translation-this.m_upperTranslation-b2_linearSlop,0,b2_maxLinearCorrection);linearError=b2Max(linearError,translation-this.m_upperTranslation);active=true;}}if(active){const k11=mA+mB+iA*s1*s1+iB*s2*s2;const k12=iA*s1+iB*s2;const k13=iA*s1*a1+iB*s2*a2;let k22=iA+iB;if(k22===0){k22=1;}const k23=iA*a1+iB*a2;const k33=mA+mB+iA*a1*a1+iB*a2*a2;const K=this.m_K3;K.ex.SetXYZ(k11,k12,k13);K.ey.SetXYZ(k12,k22,k23);K.ez.SetXYZ(k13,k23,k33);impulse=K.Solve33(-C1_x,-C1_y,-C2,impulse);}else {const k11=mA+mB+iA*s1*s1+iB*s2*s2;const k12=iA*s1+iB*s2;let k22=iA+iB;if(k22===0){k22=1;}const K2=this.m_K2;K2.ex.Set(k11,k12);K2.ey.Set(k12,k22);const impulse1=K2.Solve(-C1_x,-C1_y,b2PrismaticJoint.SolvePositionConstraints_s_impulse1);impulse.x=impulse1.x;impulse.y=impulse1.y;impulse.z=0;}const P=b2Vec2.AddVV(b2Vec2.MulSV(impulse.x,perp,b2Vec2.s_t0),b2Vec2.MulSV(impulse.z,axis,b2Vec2.s_t1),b2PrismaticJoint.SolvePositionConstraints_s_P);const LA=impulse.x*s1+impulse.y+impulse.z*a1;const LB=impulse.x*s2+impulse.y+impulse.z*a2;cA.SelfMulSub(mA,P);aA-=iA*LA;cB.SelfMulAdd(mB,P);aB+=iB*LB;data.positions[this.m_indexA].a=aA;data.positions[this.m_indexB].a=aB;return linearError<=b2_linearSlop&&angularError<=b2_angularSlop;}GetAnchorA(out){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,out);}GetAnchorB(out){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,out);}GetReactionForce(inv_dt,out){out.x=inv_dt*(this.m_impulse.x*this.m_perp.x+(this.m_motorImpulse+this.m_impulse.z)*this.m_axis.x);out.y=inv_dt*(this.m_impulse.x*this.m_perp.y+(this.m_motorImpulse+this.m_impulse.z)*this.m_axis.y);return out;}GetReactionTorque(inv_dt){return inv_dt*this.m_impulse.y;}GetLocalAnchorA(){return this.m_localAnchorA;}GetLocalAnchorB(){return this.m_localAnchorB;}GetLocalAxisA(){return this.m_localXAxisA;}GetReferenceAngle(){return this.m_referenceAngle;}GetJointTranslation(){const pA=this.m_bodyA.GetWorldPoint(this.m_localAnchorA,b2PrismaticJoint.GetJointTranslation_s_pA);const pB=this.m_bodyB.GetWorldPoint(this.m_localAnchorB,b2PrismaticJoint.GetJointTranslation_s_pB);const d=b2Vec2.SubVV(pB,pA,b2PrismaticJoint.GetJointTranslation_s_d);const axis=this.m_bodyA.GetWorldVector(this.m_localXAxisA,b2PrismaticJoint.GetJointTranslation_s_axis);const translation=b2Vec2.DotVV(d,axis);return translation;}GetJointSpeed(){const bA=this.m_bodyA;const bB=this.m_bodyB;b2Vec2.SubVV(this.m_localAnchorA,bA.m_sweep.localCenter,this.m_lalcA);const rA=b2Rot.MulRV(bA.m_xf.q,this.m_lalcA,this.m_rA);b2Vec2.SubVV(this.m_localAnchorB,bB.m_sweep.localCenter,this.m_lalcB);const rB=b2Rot.MulRV(bB.m_xf.q,this.m_lalcB,this.m_rB);const pA=b2Vec2.AddVV(bA.m_sweep.c,rA,b2Vec2.s_t0);const pB=b2Vec2.AddVV(bB.m_sweep.c,rB,b2Vec2.s_t1);const d=b2Vec2.SubVV(pB,pA,b2Vec2.s_t2);const axis=bA.GetWorldVector(this.m_localXAxisA,this.m_axis);const vA=bA.m_linearVelocity;const vB=bB.m_linearVelocity;const wA=bA.m_angularVelocity;const wB=bB.m_angularVelocity;const speed=b2Vec2.DotVV(d,b2Vec2.CrossSV(wA,axis,b2Vec2.s_t0))+b2Vec2.DotVV(axis,b2Vec2.SubVV(b2Vec2.AddVCrossSV(vB,wB,rB,b2Vec2.s_t0),b2Vec2.AddVCrossSV(vA,wA,rA,b2Vec2.s_t1),b2Vec2.s_t0));return speed;}IsLimitEnabled(){return this.m_enableLimit;}EnableLimit(flag){if(flag!==this.m_enableLimit){this.m_bodyA.SetAwake(true);this.m_bodyB.SetAwake(true);this.m_enableLimit=flag;this.m_impulse.z=0;}}GetLowerLimit(){return this.m_lowerTranslation;}GetUpperLimit(){return this.m_upperTranslation;}SetLimits(lower,upper){if(lower!==this.m_lowerTranslation||upper!==this.m_upperTranslation){this.m_bodyA.SetAwake(true);this.m_bodyB.SetAwake(true);this.m_lowerTranslation=lower;this.m_upperTranslation=upper;this.m_impulse.z=0;}}IsMotorEnabled(){return this.m_enableMotor;}EnableMotor(flag){if(flag!==this.m_enableMotor){this.m_bodyA.SetAwake(true);this.m_bodyB.SetAwake(true);this.m_enableMotor=flag;}}SetMotorSpeed(speed){if(speed!==this.m_motorSpeed){this.m_bodyA.SetAwake(true);this.m_bodyB.SetAwake(true);this.m_motorSpeed=speed;}}GetMotorSpeed(){return this.m_motorSpeed;}SetMaxMotorForce(force){if(force!==this.m_maxMotorForce){this.m_bodyA.SetAwake(true);this.m_bodyB.SetAwake(true);this.m_maxMotorForce=force;}}GetMaxMotorForce(){return this.m_maxMotorForce;}GetMotorForce(inv_dt){return inv_dt*this.m_motorImpulse;}Dump(log){const indexA=this.m_bodyA.m_islandIndex;const indexB=this.m_bodyB.m_islandIndex;log("  const jd: b2PrismaticJointDef = new b2PrismaticJointDef();\n");log("  jd.bodyA = bodies[%d];\n",indexA);log("  jd.bodyB = bodies[%d];\n",indexB);log("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false");log("  jd.localAnchorA.Set(%.15f, %.15f);\n",this.m_localAnchorA.x,this.m_localAnchorA.y);log("  jd.localAnchorB.Set(%.15f, %.15f);\n",this.m_localAnchorB.x,this.m_localAnchorB.y);log("  jd.localAxisA.Set(%.15f, %.15f);\n",this.m_localXAxisA.x,this.m_localXAxisA.y);log("  jd.referenceAngle = %.15f;\n",this.m_referenceAngle);log("  jd.enableLimit = %s;\n",this.m_enableLimit?"true":"false");log("  jd.lowerTranslation = %.15f;\n",this.m_lowerTranslation);log("  jd.upperTranslation = %.15f;\n",this.m_upperTranslation);log("  jd.enableMotor = %s;\n",this.m_enableMotor?"true":"false");log("  jd.motorSpeed = %.15f;\n",this.m_motorSpeed);log("  jd.maxMotorForce = %.15f;\n",this.m_maxMotorForce);log("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index);}}b2PrismaticJoint.InitVelocityConstraints_s_d=new b2Vec2();b2PrismaticJoint.InitVelocityConstraints_s_P=new b2Vec2();b2PrismaticJoint.SolveVelocityConstraints_s_P=new b2Vec2();b2PrismaticJoint.SolveVelocityConstraints_s_f2r=new b2Vec2();b2PrismaticJoint.SolveVelocityConstraints_s_f1=new b2Vec3();b2PrismaticJoint.SolveVelocityConstraints_s_df3=new b2Vec3();b2PrismaticJoint.SolveVelocityConstraints_s_df2=new b2Vec2();b2PrismaticJoint.SolvePositionConstraints_s_d=new b2Vec2();b2PrismaticJoint.SolvePositionConstraints_s_impulse=new b2Vec3();b2PrismaticJoint.SolvePositionConstraints_s_impulse1=new b2Vec2();b2PrismaticJoint.SolvePositionConstraints_s_P=new b2Vec2();b2PrismaticJoint.GetJointTranslation_s_pA=new b2Vec2();b2PrismaticJoint.GetJointTranslation_s_pB=new b2Vec2();b2PrismaticJoint.GetJointTranslation_s_d=new b2Vec2();b2PrismaticJoint.GetJointTranslation_s_axis=new b2Vec2();const b2_minPulleyLength=2;class b2PulleyJointDef extends b2JointDef{constructor(){super(exports.b2JointType.e_pulleyJoint);this.groundAnchorA=new b2Vec2(-1,1);this.groundAnchorB=new b2Vec2(1,1);this.localAnchorA=new b2Vec2(-1,0);this.localAnchorB=new b2Vec2(1,0);this.lengthA=0;this.lengthB=0;this.ratio=1;this.collideConnected=true;}Initialize(bA,bB,groundA,groundB,anchorA,anchorB,r){this.bodyA=bA;this.bodyB=bB;this.groundAnchorA.Copy(groundA);this.groundAnchorB.Copy(groundB);this.bodyA.GetLocalPoint(anchorA,this.localAnchorA);this.bodyB.GetLocalPoint(anchorB,this.localAnchorB);this.lengthA=b2Vec2.DistanceVV(anchorA,groundA);this.lengthB=b2Vec2.DistanceVV(anchorB,groundB);this.ratio=r;}}class b2PulleyJoint extends b2Joint{constructor(def){super(def);this.m_groundAnchorA=new b2Vec2();this.m_groundAnchorB=new b2Vec2();this.m_lengthA=0;this.m_lengthB=0;this.m_localAnchorA=new b2Vec2();this.m_localAnchorB=new b2Vec2();this.m_constant=0;this.m_ratio=0;this.m_impulse=0;this.m_indexA=0;this.m_indexB=0;this.m_uA=new b2Vec2();this.m_uB=new b2Vec2();this.m_rA=new b2Vec2();this.m_rB=new b2Vec2();this.m_localCenterA=new b2Vec2();this.m_localCenterB=new b2Vec2();this.m_invMassA=0;this.m_invMassB=0;this.m_invIA=0;this.m_invIB=0;this.m_mass=0;this.m_qA=new b2Rot();this.m_qB=new b2Rot();this.m_lalcA=new b2Vec2();this.m_lalcB=new b2Vec2();this.m_groundAnchorA.Copy(b2Maybe(def.groundAnchorA,new b2Vec2(-1,1)));this.m_groundAnchorB.Copy(b2Maybe(def.groundAnchorB,new b2Vec2(1,0)));this.m_localAnchorA.Copy(b2Maybe(def.localAnchorA,new b2Vec2(-1,0)));this.m_localAnchorB.Copy(b2Maybe(def.localAnchorB,new b2Vec2(1,0)));this.m_lengthA=b2Maybe(def.lengthA,0);this.m_lengthB=b2Maybe(def.lengthB,0);this.m_ratio=b2Maybe(def.ratio,1);this.m_constant=b2Maybe(def.lengthA,0)+this.m_ratio*b2Maybe(def.lengthB,0);this.m_impulse=0;}InitVelocityConstraints(data){this.m_indexA=this.m_bodyA.m_islandIndex;this.m_indexB=this.m_bodyB.m_islandIndex;this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);this.m_invMassA=this.m_bodyA.m_invMass;this.m_invMassB=this.m_bodyB.m_invMass;this.m_invIA=this.m_bodyA.m_invI;this.m_invIB=this.m_bodyB.m_invI;const cA=data.positions[this.m_indexA].c;const aA=data.positions[this.m_indexA].a;const vA=data.velocities[this.m_indexA].v;let wA=data.velocities[this.m_indexA].w;const cB=data.positions[this.m_indexB].c;const aB=data.positions[this.m_indexB].a;const vB=data.velocities[this.m_indexB].v;let wB=data.velocities[this.m_indexB].w;const qA=this.m_qA.SetAngle(aA),qB=this.m_qB.SetAngle(aB);b2Vec2.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);b2Rot.MulRV(qA,this.m_lalcA,this.m_rA);b2Vec2.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);b2Rot.MulRV(qB,this.m_lalcB,this.m_rB);this.m_uA.Copy(cA).SelfAdd(this.m_rA).SelfSub(this.m_groundAnchorA);this.m_uB.Copy(cB).SelfAdd(this.m_rB).SelfSub(this.m_groundAnchorB);const lengthA=this.m_uA.Length();const lengthB=this.m_uB.Length();if(lengthA>10*b2_linearSlop){this.m_uA.SelfMul(1/lengthA);}else {this.m_uA.SetZero();}if(lengthB>10*b2_linearSlop){this.m_uB.SelfMul(1/lengthB);}else {this.m_uB.SetZero();}const ruA=b2Vec2.CrossVV(this.m_rA,this.m_uA);const ruB=b2Vec2.CrossVV(this.m_rB,this.m_uB);const mA=this.m_invMassA+this.m_invIA*ruA*ruA;const mB=this.m_invMassB+this.m_invIB*ruB*ruB;this.m_mass=mA+this.m_ratio*this.m_ratio*mB;if(this.m_mass>0){this.m_mass=1/this.m_mass;}if(data.step.warmStarting){this.m_impulse*=data.step.dtRatio;const PA=b2Vec2.MulSV(-this.m_impulse,this.m_uA,b2PulleyJoint.InitVelocityConstraints_s_PA);const PB=b2Vec2.MulSV(-this.m_ratio*this.m_impulse,this.m_uB,b2PulleyJoint.InitVelocityConstraints_s_PB);vA.SelfMulAdd(this.m_invMassA,PA);wA+=this.m_invIA*b2Vec2.CrossVV(this.m_rA,PA);vB.SelfMulAdd(this.m_invMassB,PB);wB+=this.m_invIB*b2Vec2.CrossVV(this.m_rB,PB);}else {this.m_impulse=0;}data.velocities[this.m_indexA].w=wA;data.velocities[this.m_indexB].w=wB;}SolveVelocityConstraints(data){const vA=data.velocities[this.m_indexA].v;let wA=data.velocities[this.m_indexA].w;const vB=data.velocities[this.m_indexB].v;let wB=data.velocities[this.m_indexB].w;const vpA=b2Vec2.AddVCrossSV(vA,wA,this.m_rA,b2PulleyJoint.SolveVelocityConstraints_s_vpA);const vpB=b2Vec2.AddVCrossSV(vB,wB,this.m_rB,b2PulleyJoint.SolveVelocityConstraints_s_vpB);const Cdot=-b2Vec2.DotVV(this.m_uA,vpA)-this.m_ratio*b2Vec2.DotVV(this.m_uB,vpB);const impulse=-this.m_mass*Cdot;this.m_impulse+=impulse;const PA=b2Vec2.MulSV(-impulse,this.m_uA,b2PulleyJoint.SolveVelocityConstraints_s_PA);const PB=b2Vec2.MulSV(-this.m_ratio*impulse,this.m_uB,b2PulleyJoint.SolveVelocityConstraints_s_PB);vA.SelfMulAdd(this.m_invMassA,PA);wA+=this.m_invIA*b2Vec2.CrossVV(this.m_rA,PA);vB.SelfMulAdd(this.m_invMassB,PB);wB+=this.m_invIB*b2Vec2.CrossVV(this.m_rB,PB);data.velocities[this.m_indexA].w=wA;data.velocities[this.m_indexB].w=wB;}SolvePositionConstraints(data){const cA=data.positions[this.m_indexA].c;let aA=data.positions[this.m_indexA].a;const cB=data.positions[this.m_indexB].c;let aB=data.positions[this.m_indexB].a;const qA=this.m_qA.SetAngle(aA),qB=this.m_qB.SetAngle(aB);b2Vec2.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);const rA=b2Rot.MulRV(qA,this.m_lalcA,this.m_rA);b2Vec2.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);const rB=b2Rot.MulRV(qB,this.m_lalcB,this.m_rB);const uA=this.m_uA.Copy(cA).SelfAdd(rA).SelfSub(this.m_groundAnchorA);const uB=this.m_uB.Copy(cB).SelfAdd(rB).SelfSub(this.m_groundAnchorB);const lengthA=uA.Length();const lengthB=uB.Length();if(lengthA>10*b2_linearSlop){uA.SelfMul(1/lengthA);}else {uA.SetZero();}if(lengthB>10*b2_linearSlop){uB.SelfMul(1/lengthB);}else {uB.SetZero();}const ruA=b2Vec2.CrossVV(rA,uA);const ruB=b2Vec2.CrossVV(rB,uB);const mA=this.m_invMassA+this.m_invIA*ruA*ruA;const mB=this.m_invMassB+this.m_invIB*ruB*ruB;let mass=mA+this.m_ratio*this.m_ratio*mB;if(mass>0){mass=1/mass;}const C=this.m_constant-lengthA-this.m_ratio*lengthB;const linearError=b2Abs(C);const impulse=-mass*C;const PA=b2Vec2.MulSV(-impulse,uA,b2PulleyJoint.SolvePositionConstraints_s_PA);const PB=b2Vec2.MulSV(-this.m_ratio*impulse,uB,b2PulleyJoint.SolvePositionConstraints_s_PB);cA.SelfMulAdd(this.m_invMassA,PA);aA+=this.m_invIA*b2Vec2.CrossVV(rA,PA);cB.SelfMulAdd(this.m_invMassB,PB);aB+=this.m_invIB*b2Vec2.CrossVV(rB,PB);data.positions[this.m_indexA].a=aA;data.positions[this.m_indexB].a=aB;return linearError<b2_linearSlop;}GetAnchorA(out){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,out);}GetAnchorB(out){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,out);}GetReactionForce(inv_dt,out){out.x=inv_dt*this.m_impulse*this.m_uB.x;out.y=inv_dt*this.m_impulse*this.m_uB.y;return out;}GetReactionTorque(inv_dt){return 0;}GetGroundAnchorA(){return this.m_groundAnchorA;}GetGroundAnchorB(){return this.m_groundAnchorB;}GetLengthA(){return this.m_lengthA;}GetLengthB(){return this.m_lengthB;}GetRatio(){return this.m_ratio;}GetCurrentLengthA(){const p=this.m_bodyA.GetWorldPoint(this.m_localAnchorA,b2PulleyJoint.GetCurrentLengthA_s_p);const s=this.m_groundAnchorA;return b2Vec2.DistanceVV(p,s);}GetCurrentLengthB(){const p=this.m_bodyB.GetWorldPoint(this.m_localAnchorB,b2PulleyJoint.GetCurrentLengthB_s_p);const s=this.m_groundAnchorB;return b2Vec2.DistanceVV(p,s);}Dump(log){const indexA=this.m_bodyA.m_islandIndex;const indexB=this.m_bodyB.m_islandIndex;log("  const jd: b2PulleyJointDef = new b2PulleyJointDef();\n");log("  jd.bodyA = bodies[%d];\n",indexA);log("  jd.bodyB = bodies[%d];\n",indexB);log("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false");log("  jd.groundAnchorA.Set(%.15f, %.15f);\n",this.m_groundAnchorA.x,this.m_groundAnchorA.y);log("  jd.groundAnchorB.Set(%.15f, %.15f);\n",this.m_groundAnchorB.x,this.m_groundAnchorB.y);log("  jd.localAnchorA.Set(%.15f, %.15f);\n",this.m_localAnchorA.x,this.m_localAnchorA.y);log("  jd.localAnchorB.Set(%.15f, %.15f);\n",this.m_localAnchorB.x,this.m_localAnchorB.y);log("  jd.lengthA = %.15f;\n",this.m_lengthA);log("  jd.lengthB = %.15f;\n",this.m_lengthB);log("  jd.ratio = %.15f;\n",this.m_ratio);log("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index);}ShiftOrigin(newOrigin){this.m_groundAnchorA.SelfSub(newOrigin);this.m_groundAnchorB.SelfSub(newOrigin);}}b2PulleyJoint.InitVelocityConstraints_s_PA=new b2Vec2();b2PulleyJoint.InitVelocityConstraints_s_PB=new b2Vec2();b2PulleyJoint.SolveVelocityConstraints_s_vpA=new b2Vec2();b2PulleyJoint.SolveVelocityConstraints_s_vpB=new b2Vec2();b2PulleyJoint.SolveVelocityConstraints_s_PA=new b2Vec2();b2PulleyJoint.SolveVelocityConstraints_s_PB=new b2Vec2();b2PulleyJoint.SolvePositionConstraints_s_PA=new b2Vec2();b2PulleyJoint.SolvePositionConstraints_s_PB=new b2Vec2();b2PulleyJoint.GetCurrentLengthA_s_p=new b2Vec2();b2PulleyJoint.GetCurrentLengthB_s_p=new b2Vec2();class b2RevoluteJointDef extends b2JointDef{constructor(){super(exports.b2JointType.e_revoluteJoint);this.localAnchorA=new b2Vec2(0,0);this.localAnchorB=new b2Vec2(0,0);this.referenceAngle=0;this.enableLimit=false;this.lowerAngle=0;this.upperAngle=0;this.enableMotor=false;this.motorSpeed=0;this.maxMotorTorque=0;}Initialize(bA,bB,anchor){this.bodyA=bA;this.bodyB=bB;this.bodyA.GetLocalPoint(anchor,this.localAnchorA);this.bodyB.GetLocalPoint(anchor,this.localAnchorB);this.referenceAngle=this.bodyB.GetAngle()-this.bodyA.GetAngle();}}class b2RevoluteJoint extends b2Joint{constructor(def){super(def);this.m_localAnchorA=new b2Vec2();this.m_localAnchorB=new b2Vec2();this.m_impulse=new b2Vec3();this.m_motorImpulse=0;this.m_enableMotor=false;this.m_maxMotorTorque=0;this.m_motorSpeed=0;this.m_enableLimit=false;this.m_referenceAngle=0;this.m_lowerAngle=0;this.m_upperAngle=0;this.m_indexA=0;this.m_indexB=0;this.m_rA=new b2Vec2();this.m_rB=new b2Vec2();this.m_localCenterA=new b2Vec2();this.m_localCenterB=new b2Vec2();this.m_invMassA=0;this.m_invMassB=0;this.m_invIA=0;this.m_invIB=0;this.m_mass=new b2Mat33();this.m_motorMass=0;this.m_limitState=exports.b2LimitState.e_inactiveLimit;this.m_qA=new b2Rot();this.m_qB=new b2Rot();this.m_lalcA=new b2Vec2();this.m_lalcB=new b2Vec2();this.m_K=new b2Mat22();this.m_localAnchorA.Copy(b2Maybe(def.localAnchorA,b2Vec2.ZERO));this.m_localAnchorB.Copy(b2Maybe(def.localAnchorB,b2Vec2.ZERO));this.m_referenceAngle=b2Maybe(def.referenceAngle,0);this.m_impulse.SetZero();this.m_motorImpulse=0;this.m_lowerAngle=b2Maybe(def.lowerAngle,0);this.m_upperAngle=b2Maybe(def.upperAngle,0);this.m_maxMotorTorque=b2Maybe(def.maxMotorTorque,0);this.m_motorSpeed=b2Maybe(def.motorSpeed,0);this.m_enableLimit=b2Maybe(def.enableLimit,false);this.m_enableMotor=b2Maybe(def.enableMotor,false);this.m_limitState=exports.b2LimitState.e_inactiveLimit;}InitVelocityConstraints(data){this.m_indexA=this.m_bodyA.m_islandIndex;this.m_indexB=this.m_bodyB.m_islandIndex;this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);this.m_invMassA=this.m_bodyA.m_invMass;this.m_invMassB=this.m_bodyB.m_invMass;this.m_invIA=this.m_bodyA.m_invI;this.m_invIB=this.m_bodyB.m_invI;const aA=data.positions[this.m_indexA].a;const vA=data.velocities[this.m_indexA].v;let wA=data.velocities[this.m_indexA].w;const aB=data.positions[this.m_indexB].a;const vB=data.velocities[this.m_indexB].v;let wB=data.velocities[this.m_indexB].w;const qA=this.m_qA.SetAngle(aA),qB=this.m_qB.SetAngle(aB);b2Vec2.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);b2Rot.MulRV(qA,this.m_lalcA,this.m_rA);b2Vec2.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);b2Rot.MulRV(qB,this.m_lalcB,this.m_rB);const mA=this.m_invMassA,mB=this.m_invMassB;const iA=this.m_invIA,iB=this.m_invIB;const fixedRotation=iA+iB===0;this.m_mass.ex.x=mA+mB+this.m_rA.y*this.m_rA.y*iA+this.m_rB.y*this.m_rB.y*iB;this.m_mass.ey.x=-this.m_rA.y*this.m_rA.x*iA-this.m_rB.y*this.m_rB.x*iB;this.m_mass.ez.x=-this.m_rA.y*iA-this.m_rB.y*iB;this.m_mass.ex.y=this.m_mass.ey.x;this.m_mass.ey.y=mA+mB+this.m_rA.x*this.m_rA.x*iA+this.m_rB.x*this.m_rB.x*iB;this.m_mass.ez.y=this.m_rA.x*iA+this.m_rB.x*iB;this.m_mass.ex.z=this.m_mass.ez.x;this.m_mass.ey.z=this.m_mass.ez.y;this.m_mass.ez.z=iA+iB;this.m_motorMass=iA+iB;if(this.m_motorMass>0){this.m_motorMass=1/this.m_motorMass;}if(!this.m_enableMotor||fixedRotation){this.m_motorImpulse=0;}if(this.m_enableLimit&&!fixedRotation){const jointAngle=aB-aA-this.m_referenceAngle;if(b2Abs(this.m_upperAngle-this.m_lowerAngle)<2*b2_angularSlop){this.m_limitState=exports.b2LimitState.e_equalLimits;}else if(jointAngle<=this.m_lowerAngle){if(this.m_limitState!==exports.b2LimitState.e_atLowerLimit){this.m_impulse.z=0;}this.m_limitState=exports.b2LimitState.e_atLowerLimit;}else if(jointAngle>=this.m_upperAngle){if(this.m_limitState!==exports.b2LimitState.e_atUpperLimit){this.m_impulse.z=0;}this.m_limitState=exports.b2LimitState.e_atUpperLimit;}else {this.m_limitState=exports.b2LimitState.e_inactiveLimit;this.m_impulse.z=0;}}else {this.m_limitState=exports.b2LimitState.e_inactiveLimit;}if(data.step.warmStarting){this.m_impulse.SelfMul(data.step.dtRatio);this.m_motorImpulse*=data.step.dtRatio;const P=b2RevoluteJoint.InitVelocityConstraints_s_P.Set(this.m_impulse.x,this.m_impulse.y);vA.SelfMulSub(mA,P);wA-=iA*(b2Vec2.CrossVV(this.m_rA,P)+this.m_motorImpulse+this.m_impulse.z);vB.SelfMulAdd(mB,P);wB+=iB*(b2Vec2.CrossVV(this.m_rB,P)+this.m_motorImpulse+this.m_impulse.z);}else {this.m_impulse.SetZero();this.m_motorImpulse=0;}data.velocities[this.m_indexA].w=wA;data.velocities[this.m_indexB].w=wB;}SolveVelocityConstraints(data){const vA=data.velocities[this.m_indexA].v;let wA=data.velocities[this.m_indexA].w;const vB=data.velocities[this.m_indexB].v;let wB=data.velocities[this.m_indexB].w;const mA=this.m_invMassA,mB=this.m_invMassB;const iA=this.m_invIA,iB=this.m_invIB;const fixedRotation=iA+iB===0;if(this.m_enableMotor&&this.m_limitState!==exports.b2LimitState.e_equalLimits&&!fixedRotation){const Cdot=wB-wA-this.m_motorSpeed;let impulse=-this.m_motorMass*Cdot;const oldImpulse=this.m_motorImpulse;const maxImpulse=data.step.dt*this.m_maxMotorTorque;this.m_motorImpulse=b2Clamp(this.m_motorImpulse+impulse,-maxImpulse,maxImpulse);impulse=this.m_motorImpulse-oldImpulse;wA-=iA*impulse;wB+=iB*impulse;}if(this.m_enableLimit&&this.m_limitState!==exports.b2LimitState.e_inactiveLimit&&!fixedRotation){const Cdot1=b2Vec2.SubVV(b2Vec2.AddVCrossSV(vB,wB,this.m_rB,b2Vec2.s_t0),b2Vec2.AddVCrossSV(vA,wA,this.m_rA,b2Vec2.s_t1),b2RevoluteJoint.SolveVelocityConstraints_s_Cdot1);const Cdot2=wB-wA;const impulse_v3=this.m_mass.Solve33(Cdot1.x,Cdot1.y,Cdot2,b2RevoluteJoint.SolveVelocityConstraints_s_impulse_v3).SelfNeg();if(this.m_limitState===exports.b2LimitState.e_equalLimits){this.m_impulse.SelfAdd(impulse_v3);}else if(this.m_limitState===exports.b2LimitState.e_atLowerLimit){const newImpulse=this.m_impulse.z+impulse_v3.z;if(newImpulse<0){const rhs_x=-Cdot1.x+this.m_impulse.z*this.m_mass.ez.x;const rhs_y=-Cdot1.y+this.m_impulse.z*this.m_mass.ez.y;const reduced_v2=this.m_mass.Solve22(rhs_x,rhs_y,b2RevoluteJoint.SolveVelocityConstraints_s_reduced_v2);impulse_v3.x=reduced_v2.x;impulse_v3.y=reduced_v2.y;impulse_v3.z=-this.m_impulse.z;this.m_impulse.x+=reduced_v2.x;this.m_impulse.y+=reduced_v2.y;this.m_impulse.z=0;}else {this.m_impulse.SelfAdd(impulse_v3);}}else if(this.m_limitState===exports.b2LimitState.e_atUpperLimit){const newImpulse=this.m_impulse.z+impulse_v3.z;if(newImpulse>0){const rhs_x=-Cdot1.x+this.m_impulse.z*this.m_mass.ez.x;const rhs_y=-Cdot1.y+this.m_impulse.z*this.m_mass.ez.y;const reduced_v2=this.m_mass.Solve22(rhs_x,rhs_y,b2RevoluteJoint.SolveVelocityConstraints_s_reduced_v2);impulse_v3.x=reduced_v2.x;impulse_v3.y=reduced_v2.y;impulse_v3.z=-this.m_impulse.z;this.m_impulse.x+=reduced_v2.x;this.m_impulse.y+=reduced_v2.y;this.m_impulse.z=0;}else {this.m_impulse.SelfAdd(impulse_v3);}}const P=b2RevoluteJoint.SolveVelocityConstraints_s_P.Set(impulse_v3.x,impulse_v3.y);vA.SelfMulSub(mA,P);wA-=iA*(b2Vec2.CrossVV(this.m_rA,P)+impulse_v3.z);vB.SelfMulAdd(mB,P);wB+=iB*(b2Vec2.CrossVV(this.m_rB,P)+impulse_v3.z);}else {const Cdot_v2=b2Vec2.SubVV(b2Vec2.AddVCrossSV(vB,wB,this.m_rB,b2Vec2.s_t0),b2Vec2.AddVCrossSV(vA,wA,this.m_rA,b2Vec2.s_t1),b2RevoluteJoint.SolveVelocityConstraints_s_Cdot_v2);const impulse_v2=this.m_mass.Solve22(-Cdot_v2.x,-Cdot_v2.y,b2RevoluteJoint.SolveVelocityConstraints_s_impulse_v2);this.m_impulse.x+=impulse_v2.x;this.m_impulse.y+=impulse_v2.y;vA.SelfMulSub(mA,impulse_v2);wA-=iA*b2Vec2.CrossVV(this.m_rA,impulse_v2);vB.SelfMulAdd(mB,impulse_v2);wB+=iB*b2Vec2.CrossVV(this.m_rB,impulse_v2);}data.velocities[this.m_indexA].w=wA;data.velocities[this.m_indexB].w=wB;}SolvePositionConstraints(data){const cA=data.positions[this.m_indexA].c;let aA=data.positions[this.m_indexA].a;const cB=data.positions[this.m_indexB].c;let aB=data.positions[this.m_indexB].a;const qA=this.m_qA.SetAngle(aA),qB=this.m_qB.SetAngle(aB);let angularError=0;let positionError=0;const fixedRotation=this.m_invIA+this.m_invIB===0;if(this.m_enableLimit&&this.m_limitState!==exports.b2LimitState.e_inactiveLimit&&!fixedRotation){const angle=aB-aA-this.m_referenceAngle;let limitImpulse=0;if(this.m_limitState===exports.b2LimitState.e_equalLimits){const C=b2Clamp(angle-this.m_lowerAngle,-b2_maxAngularCorrection,b2_maxAngularCorrection);limitImpulse=-this.m_motorMass*C;angularError=b2Abs(C);}else if(this.m_limitState===exports.b2LimitState.e_atLowerLimit){let C=angle-this.m_lowerAngle;angularError=-C;C=b2Clamp(C+b2_angularSlop,-b2_maxAngularCorrection,0);limitImpulse=-this.m_motorMass*C;}else if(this.m_limitState===exports.b2LimitState.e_atUpperLimit){let C=angle-this.m_upperAngle;angularError=C;C=b2Clamp(C-b2_angularSlop,0,b2_maxAngularCorrection);limitImpulse=-this.m_motorMass*C;}aA-=this.m_invIA*limitImpulse;aB+=this.m_invIB*limitImpulse;}{qA.SetAngle(aA);qB.SetAngle(aB);b2Vec2.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);const rA=b2Rot.MulRV(qA,this.m_lalcA,this.m_rA);b2Vec2.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);const rB=b2Rot.MulRV(qB,this.m_lalcB,this.m_rB);const C_v2=b2Vec2.SubVV(b2Vec2.AddVV(cB,rB,b2Vec2.s_t0),b2Vec2.AddVV(cA,rA,b2Vec2.s_t1),b2RevoluteJoint.SolvePositionConstraints_s_C_v2);positionError=C_v2.Length();const mA=this.m_invMassA,mB=this.m_invMassB;const iA=this.m_invIA,iB=this.m_invIB;const K=this.m_K;K.ex.x=mA+mB+iA*rA.y*rA.y+iB*rB.y*rB.y;K.ex.y=-iA*rA.x*rA.y-iB*rB.x*rB.y;K.ey.x=K.ex.y;K.ey.y=mA+mB+iA*rA.x*rA.x+iB*rB.x*rB.x;const impulse=K.Solve(C_v2.x,C_v2.y,b2RevoluteJoint.SolvePositionConstraints_s_impulse).SelfNeg();cA.SelfMulSub(mA,impulse);aA-=iA*b2Vec2.CrossVV(rA,impulse);cB.SelfMulAdd(mB,impulse);aB+=iB*b2Vec2.CrossVV(rB,impulse);}data.positions[this.m_indexA].a=aA;data.positions[this.m_indexB].a=aB;return positionError<=b2_linearSlop&&angularError<=b2_angularSlop;}GetAnchorA(out){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,out);}GetAnchorB(out){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,out);}GetReactionForce(inv_dt,out){out.x=inv_dt*this.m_impulse.x;out.y=inv_dt*this.m_impulse.y;return out;}GetReactionTorque(inv_dt){return inv_dt*this.m_impulse.z;}GetLocalAnchorA(){return this.m_localAnchorA;}GetLocalAnchorB(){return this.m_localAnchorB;}GetReferenceAngle(){return this.m_referenceAngle;}GetJointAngle(){return this.m_bodyB.m_sweep.a-this.m_bodyA.m_sweep.a-this.m_referenceAngle;}GetJointSpeed(){return this.m_bodyB.m_angularVelocity-this.m_bodyA.m_angularVelocity;}IsMotorEnabled(){return this.m_enableMotor;}EnableMotor(flag){if(flag!==this.m_enableMotor){this.m_bodyA.SetAwake(true);this.m_bodyB.SetAwake(true);this.m_enableMotor=flag;}}GetMotorTorque(inv_dt){return inv_dt*this.m_motorImpulse;}GetMotorSpeed(){return this.m_motorSpeed;}SetMaxMotorTorque(torque){if(torque!==this.m_maxMotorTorque){this.m_bodyA.SetAwake(true);this.m_bodyB.SetAwake(true);this.m_maxMotorTorque=torque;}}GetMaxMotorTorque(){return this.m_maxMotorTorque;}IsLimitEnabled(){return this.m_enableLimit;}EnableLimit(flag){if(flag!==this.m_enableLimit){this.m_bodyA.SetAwake(true);this.m_bodyB.SetAwake(true);this.m_enableLimit=flag;this.m_impulse.z=0;}}GetLowerLimit(){return this.m_lowerAngle;}GetUpperLimit(){return this.m_upperAngle;}SetLimits(lower,upper){if(lower!==this.m_lowerAngle||upper!==this.m_upperAngle){this.m_bodyA.SetAwake(true);this.m_bodyB.SetAwake(true);this.m_impulse.z=0;this.m_lowerAngle=lower;this.m_upperAngle=upper;}}SetMotorSpeed(speed){if(speed!==this.m_motorSpeed){this.m_bodyA.SetAwake(true);this.m_bodyB.SetAwake(true);this.m_motorSpeed=speed;}}Dump(log){const indexA=this.m_bodyA.m_islandIndex;const indexB=this.m_bodyB.m_islandIndex;log("  const jd: b2RevoluteJointDef = new b2RevoluteJointDef();\n");log("  jd.bodyA = bodies[%d];\n",indexA);log("  jd.bodyB = bodies[%d];\n",indexB);log("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false");log("  jd.localAnchorA.Set(%.15f, %.15f);\n",this.m_localAnchorA.x,this.m_localAnchorA.y);log("  jd.localAnchorB.Set(%.15f, %.15f);\n",this.m_localAnchorB.x,this.m_localAnchorB.y);log("  jd.referenceAngle = %.15f;\n",this.m_referenceAngle);log("  jd.enableLimit = %s;\n",this.m_enableLimit?"true":"false");log("  jd.lowerAngle = %.15f;\n",this.m_lowerAngle);log("  jd.upperAngle = %.15f;\n",this.m_upperAngle);log("  jd.enableMotor = %s;\n",this.m_enableMotor?"true":"false");log("  jd.motorSpeed = %.15f;\n",this.m_motorSpeed);log("  jd.maxMotorTorque = %.15f;\n",this.m_maxMotorTorque);log("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index);}}b2RevoluteJoint.InitVelocityConstraints_s_P=new b2Vec2();b2RevoluteJoint.SolveVelocityConstraints_s_P=new b2Vec2();b2RevoluteJoint.SolveVelocityConstraints_s_Cdot_v2=new b2Vec2();b2RevoluteJoint.SolveVelocityConstraints_s_Cdot1=new b2Vec2();b2RevoluteJoint.SolveVelocityConstraints_s_impulse_v3=new b2Vec3();b2RevoluteJoint.SolveVelocityConstraints_s_reduced_v2=new b2Vec2();b2RevoluteJoint.SolveVelocityConstraints_s_impulse_v2=new b2Vec2();b2RevoluteJoint.SolvePositionConstraints_s_C_v2=new b2Vec2();b2RevoluteJoint.SolvePositionConstraints_s_impulse=new b2Vec2();class b2RopeJointDef extends b2JointDef{constructor(){super(exports.b2JointType.e_ropeJoint);this.localAnchorA=new b2Vec2(-1,0);this.localAnchorB=new b2Vec2(1,0);this.maxLength=0;}}class b2RopeJoint extends b2Joint{constructor(def){super(def);this.m_localAnchorA=new b2Vec2();this.m_localAnchorB=new b2Vec2();this.m_maxLength=0;this.m_length=0;this.m_impulse=0;this.m_indexA=0;this.m_indexB=0;this.m_u=new b2Vec2();this.m_rA=new b2Vec2();this.m_rB=new b2Vec2();this.m_localCenterA=new b2Vec2();this.m_localCenterB=new b2Vec2();this.m_invMassA=0;this.m_invMassB=0;this.m_invIA=0;this.m_invIB=0;this.m_mass=0;this.m_state=exports.b2LimitState.e_inactiveLimit;this.m_qA=new b2Rot();this.m_qB=new b2Rot();this.m_lalcA=new b2Vec2();this.m_lalcB=new b2Vec2();this.m_localAnchorA.Copy(b2Maybe(def.localAnchorA,new b2Vec2(-1,0)));this.m_localAnchorB.Copy(b2Maybe(def.localAnchorB,new b2Vec2(1,0)));this.m_maxLength=b2Maybe(def.maxLength,0);}InitVelocityConstraints(data){this.m_indexA=this.m_bodyA.m_islandIndex;this.m_indexB=this.m_bodyB.m_islandIndex;this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);this.m_invMassA=this.m_bodyA.m_invMass;this.m_invMassB=this.m_bodyB.m_invMass;this.m_invIA=this.m_bodyA.m_invI;this.m_invIB=this.m_bodyB.m_invI;const cA=data.positions[this.m_indexA].c;const aA=data.positions[this.m_indexA].a;const vA=data.velocities[this.m_indexA].v;let wA=data.velocities[this.m_indexA].w;const cB=data.positions[this.m_indexB].c;const aB=data.positions[this.m_indexB].a;const vB=data.velocities[this.m_indexB].v;let wB=data.velocities[this.m_indexB].w;const qA=this.m_qA.SetAngle(aA),qB=this.m_qB.SetAngle(aB);b2Vec2.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);b2Rot.MulRV(qA,this.m_lalcA,this.m_rA);b2Vec2.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);b2Rot.MulRV(qB,this.m_lalcB,this.m_rB);this.m_u.Copy(cB).SelfAdd(this.m_rB).SelfSub(cA).SelfSub(this.m_rA);this.m_length=this.m_u.Length();const C=this.m_length-this.m_maxLength;if(C>0){this.m_state=exports.b2LimitState.e_atUpperLimit;}else {this.m_state=exports.b2LimitState.e_inactiveLimit;}if(this.m_length>b2_linearSlop){this.m_u.SelfMul(1/this.m_length);}else {this.m_u.SetZero();this.m_mass=0;this.m_impulse=0;return;}const crA=b2Vec2.CrossVV(this.m_rA,this.m_u);const crB=b2Vec2.CrossVV(this.m_rB,this.m_u);const invMass=this.m_invMassA+this.m_invIA*crA*crA+this.m_invMassB+this.m_invIB*crB*crB;this.m_mass=invMass!==0?1/invMass:0;if(data.step.warmStarting){this.m_impulse*=data.step.dtRatio;const P=b2Vec2.MulSV(this.m_impulse,this.m_u,b2RopeJoint.InitVelocityConstraints_s_P);vA.SelfMulSub(this.m_invMassA,P);wA-=this.m_invIA*b2Vec2.CrossVV(this.m_rA,P);vB.SelfMulAdd(this.m_invMassB,P);wB+=this.m_invIB*b2Vec2.CrossVV(this.m_rB,P);}else {this.m_impulse=0;}data.velocities[this.m_indexA].w=wA;data.velocities[this.m_indexB].w=wB;}SolveVelocityConstraints(data){const vA=data.velocities[this.m_indexA].v;let wA=data.velocities[this.m_indexA].w;const vB=data.velocities[this.m_indexB].v;let wB=data.velocities[this.m_indexB].w;const vpA=b2Vec2.AddVCrossSV(vA,wA,this.m_rA,b2RopeJoint.SolveVelocityConstraints_s_vpA);const vpB=b2Vec2.AddVCrossSV(vB,wB,this.m_rB,b2RopeJoint.SolveVelocityConstraints_s_vpB);const C=this.m_length-this.m_maxLength;let Cdot=b2Vec2.DotVV(this.m_u,b2Vec2.SubVV(vpB,vpA,b2Vec2.s_t0));if(C<0){Cdot+=data.step.inv_dt*C;}let impulse=-this.m_mass*Cdot;const oldImpulse=this.m_impulse;this.m_impulse=b2Min(0,this.m_impulse+impulse);impulse=this.m_impulse-oldImpulse;const P=b2Vec2.MulSV(impulse,this.m_u,b2RopeJoint.SolveVelocityConstraints_s_P);vA.SelfMulSub(this.m_invMassA,P);wA-=this.m_invIA*b2Vec2.CrossVV(this.m_rA,P);vB.SelfMulAdd(this.m_invMassB,P);wB+=this.m_invIB*b2Vec2.CrossVV(this.m_rB,P);data.velocities[this.m_indexA].w=wA;data.velocities[this.m_indexB].w=wB;}SolvePositionConstraints(data){const cA=data.positions[this.m_indexA].c;let aA=data.positions[this.m_indexA].a;const cB=data.positions[this.m_indexB].c;let aB=data.positions[this.m_indexB].a;const qA=this.m_qA.SetAngle(aA),qB=this.m_qB.SetAngle(aB);b2Vec2.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);const rA=b2Rot.MulRV(qA,this.m_lalcA,this.m_rA);b2Vec2.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);const rB=b2Rot.MulRV(qB,this.m_lalcB,this.m_rB);const u=this.m_u.Copy(cB).SelfAdd(rB).SelfSub(cA).SelfSub(rA);const length=u.Normalize();let C=length-this.m_maxLength;C=b2Clamp(C,0,b2_maxLinearCorrection);const impulse=-this.m_mass*C;const P=b2Vec2.MulSV(impulse,u,b2RopeJoint.SolvePositionConstraints_s_P);cA.SelfMulSub(this.m_invMassA,P);aA-=this.m_invIA*b2Vec2.CrossVV(rA,P);cB.SelfMulAdd(this.m_invMassB,P);aB+=this.m_invIB*b2Vec2.CrossVV(rB,P);data.positions[this.m_indexA].a=aA;data.positions[this.m_indexB].a=aB;return length-this.m_maxLength<b2_linearSlop;}GetAnchorA(out){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,out);}GetAnchorB(out){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,out);}GetReactionForce(inv_dt,out){return b2Vec2.MulSV(inv_dt*this.m_impulse,this.m_u,out);}GetReactionTorque(inv_dt){return 0;}GetLocalAnchorA(){return this.m_localAnchorA;}GetLocalAnchorB(){return this.m_localAnchorB;}SetMaxLength(length){this.m_maxLength=length;}GetMaxLength(){return this.m_maxLength;}GetLimitState(){return this.m_state;}Dump(log){const indexA=this.m_bodyA.m_islandIndex;const indexB=this.m_bodyB.m_islandIndex;log("  const jd: b2RopeJointDef = new b2RopeJointDef();\n");log("  jd.bodyA = bodies[%d];\n",indexA);log("  jd.bodyB = bodies[%d];\n",indexB);log("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false");log("  jd.localAnchorA.Set(%.15f, %.15f);\n",this.m_localAnchorA.x,this.m_localAnchorA.y);log("  jd.localAnchorB.Set(%.15f, %.15f);\n",this.m_localAnchorB.x,this.m_localAnchorB.y);log("  jd.maxLength = %.15f;\n",this.m_maxLength);log("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index);}}b2RopeJoint.InitVelocityConstraints_s_P=new b2Vec2();b2RopeJoint.SolveVelocityConstraints_s_vpA=new b2Vec2();b2RopeJoint.SolveVelocityConstraints_s_vpB=new b2Vec2();b2RopeJoint.SolveVelocityConstraints_s_P=new b2Vec2();b2RopeJoint.SolvePositionConstraints_s_P=new b2Vec2();class b2WeldJointDef extends b2JointDef{constructor(){super(exports.b2JointType.e_weldJoint);this.localAnchorA=new b2Vec2();this.localAnchorB=new b2Vec2();this.referenceAngle=0;this.frequencyHz=0;this.dampingRatio=0;}Initialize(bA,bB,anchor){this.bodyA=bA;this.bodyB=bB;this.bodyA.GetLocalPoint(anchor,this.localAnchorA);this.bodyB.GetLocalPoint(anchor,this.localAnchorB);this.referenceAngle=this.bodyB.GetAngle()-this.bodyA.GetAngle();}}class b2WeldJoint extends b2Joint{constructor(def){super(def);this.m_frequencyHz=0;this.m_dampingRatio=0;this.m_bias=0;this.m_localAnchorA=new b2Vec2();this.m_localAnchorB=new b2Vec2();this.m_referenceAngle=0;this.m_gamma=0;this.m_impulse=new b2Vec3(0,0,0);this.m_indexA=0;this.m_indexB=0;this.m_rA=new b2Vec2();this.m_rB=new b2Vec2();this.m_localCenterA=new b2Vec2();this.m_localCenterB=new b2Vec2();this.m_invMassA=0;this.m_invMassB=0;this.m_invIA=0;this.m_invIB=0;this.m_mass=new b2Mat33();this.m_qA=new b2Rot();this.m_qB=new b2Rot();this.m_lalcA=new b2Vec2();this.m_lalcB=new b2Vec2();this.m_K=new b2Mat33();this.m_frequencyHz=b2Maybe(def.frequencyHz,0);this.m_dampingRatio=b2Maybe(def.dampingRatio,0);this.m_localAnchorA.Copy(b2Maybe(def.localAnchorA,b2Vec2.ZERO));this.m_localAnchorB.Copy(b2Maybe(def.localAnchorB,b2Vec2.ZERO));this.m_referenceAngle=b2Maybe(def.referenceAngle,0);this.m_impulse.SetZero();}InitVelocityConstraints(data){this.m_indexA=this.m_bodyA.m_islandIndex;this.m_indexB=this.m_bodyB.m_islandIndex;this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);this.m_invMassA=this.m_bodyA.m_invMass;this.m_invMassB=this.m_bodyB.m_invMass;this.m_invIA=this.m_bodyA.m_invI;this.m_invIB=this.m_bodyB.m_invI;const aA=data.positions[this.m_indexA].a;const vA=data.velocities[this.m_indexA].v;let wA=data.velocities[this.m_indexA].w;const aB=data.positions[this.m_indexB].a;const vB=data.velocities[this.m_indexB].v;let wB=data.velocities[this.m_indexB].w;const qA=this.m_qA.SetAngle(aA),qB=this.m_qB.SetAngle(aB);b2Vec2.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);b2Rot.MulRV(qA,this.m_lalcA,this.m_rA);b2Vec2.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);b2Rot.MulRV(qB,this.m_lalcB,this.m_rB);const mA=this.m_invMassA,mB=this.m_invMassB;const iA=this.m_invIA,iB=this.m_invIB;const K=this.m_K;K.ex.x=mA+mB+this.m_rA.y*this.m_rA.y*iA+this.m_rB.y*this.m_rB.y*iB;K.ey.x=-this.m_rA.y*this.m_rA.x*iA-this.m_rB.y*this.m_rB.x*iB;K.ez.x=-this.m_rA.y*iA-this.m_rB.y*iB;K.ex.y=K.ey.x;K.ey.y=mA+mB+this.m_rA.x*this.m_rA.x*iA+this.m_rB.x*this.m_rB.x*iB;K.ez.y=this.m_rA.x*iA+this.m_rB.x*iB;K.ex.z=K.ez.x;K.ey.z=K.ez.y;K.ez.z=iA+iB;if(this.m_frequencyHz>0){K.GetInverse22(this.m_mass);let invM=iA+iB;const m=invM>0?1/invM:0;const C=aB-aA-this.m_referenceAngle;const omega=2*b2_pi*this.m_frequencyHz;const d=2*m*this.m_dampingRatio*omega;const k=m*omega*omega;const h=data.step.dt;this.m_gamma=h*(d+h*k);this.m_gamma=this.m_gamma!==0?1/this.m_gamma:0;this.m_bias=C*h*k*this.m_gamma;invM+=this.m_gamma;this.m_mass.ez.z=invM!==0?1/invM:0;}else {K.GetSymInverse33(this.m_mass);this.m_gamma=0;this.m_bias=0;}if(data.step.warmStarting){this.m_impulse.SelfMul(data.step.dtRatio);const P=b2WeldJoint.InitVelocityConstraints_s_P.Set(this.m_impulse.x,this.m_impulse.y);vA.SelfMulSub(mA,P);wA-=iA*(b2Vec2.CrossVV(this.m_rA,P)+this.m_impulse.z);vB.SelfMulAdd(mB,P);wB+=iB*(b2Vec2.CrossVV(this.m_rB,P)+this.m_impulse.z);}else {this.m_impulse.SetZero();}data.velocities[this.m_indexA].w=wA;data.velocities[this.m_indexB].w=wB;}SolveVelocityConstraints(data){const vA=data.velocities[this.m_indexA].v;let wA=data.velocities[this.m_indexA].w;const vB=data.velocities[this.m_indexB].v;let wB=data.velocities[this.m_indexB].w;const mA=this.m_invMassA,mB=this.m_invMassB;const iA=this.m_invIA,iB=this.m_invIB;if(this.m_frequencyHz>0){const Cdot2=wB-wA;const impulse2=-this.m_mass.ez.z*(Cdot2+this.m_bias+this.m_gamma*this.m_impulse.z);this.m_impulse.z+=impulse2;wA-=iA*impulse2;wB+=iB*impulse2;const Cdot1=b2Vec2.SubVV(b2Vec2.AddVCrossSV(vB,wB,this.m_rB,b2Vec2.s_t0),b2Vec2.AddVCrossSV(vA,wA,this.m_rA,b2Vec2.s_t1),b2WeldJoint.SolveVelocityConstraints_s_Cdot1);const impulse1=b2Mat33.MulM33XY(this.m_mass,Cdot1.x,Cdot1.y,b2WeldJoint.SolveVelocityConstraints_s_impulse1).SelfNeg();this.m_impulse.x+=impulse1.x;this.m_impulse.y+=impulse1.y;const P=impulse1;vA.SelfMulSub(mA,P);wA-=iA*b2Vec2.CrossVV(this.m_rA,P);vB.SelfMulAdd(mB,P);wB+=iB*b2Vec2.CrossVV(this.m_rB,P);}else {const Cdot1=b2Vec2.SubVV(b2Vec2.AddVCrossSV(vB,wB,this.m_rB,b2Vec2.s_t0),b2Vec2.AddVCrossSV(vA,wA,this.m_rA,b2Vec2.s_t1),b2WeldJoint.SolveVelocityConstraints_s_Cdot1);const Cdot2=wB-wA;const impulse=b2Mat33.MulM33XYZ(this.m_mass,Cdot1.x,Cdot1.y,Cdot2,b2WeldJoint.SolveVelocityConstraints_s_impulse).SelfNeg();this.m_impulse.SelfAdd(impulse);const P=b2WeldJoint.SolveVelocityConstraints_s_P.Set(impulse.x,impulse.y);vA.SelfMulSub(mA,P);wA-=iA*(b2Vec2.CrossVV(this.m_rA,P)+impulse.z);vB.SelfMulAdd(mB,P);wB+=iB*(b2Vec2.CrossVV(this.m_rB,P)+impulse.z);}data.velocities[this.m_indexA].w=wA;data.velocities[this.m_indexB].w=wB;}SolvePositionConstraints(data){const cA=data.positions[this.m_indexA].c;let aA=data.positions[this.m_indexA].a;const cB=data.positions[this.m_indexB].c;let aB=data.positions[this.m_indexB].a;const qA=this.m_qA.SetAngle(aA),qB=this.m_qB.SetAngle(aB);const mA=this.m_invMassA,mB=this.m_invMassB;const iA=this.m_invIA,iB=this.m_invIB;b2Vec2.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);const rA=b2Rot.MulRV(qA,this.m_lalcA,this.m_rA);b2Vec2.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);const rB=b2Rot.MulRV(qB,this.m_lalcB,this.m_rB);let positionError,angularError;const K=this.m_K;K.ex.x=mA+mB+rA.y*rA.y*iA+rB.y*rB.y*iB;K.ey.x=-rA.y*rA.x*iA-rB.y*rB.x*iB;K.ez.x=-rA.y*iA-rB.y*iB;K.ex.y=K.ey.x;K.ey.y=mA+mB+rA.x*rA.x*iA+rB.x*rB.x*iB;K.ez.y=rA.x*iA+rB.x*iB;K.ex.z=K.ez.x;K.ey.z=K.ez.y;K.ez.z=iA+iB;if(this.m_frequencyHz>0){const C1=b2Vec2.SubVV(b2Vec2.AddVV(cB,rB,b2Vec2.s_t0),b2Vec2.AddVV(cA,rA,b2Vec2.s_t1),b2WeldJoint.SolvePositionConstraints_s_C1);positionError=C1.Length();angularError=0;const P=K.Solve22(C1.x,C1.y,b2WeldJoint.SolvePositionConstraints_s_P).SelfNeg();cA.SelfMulSub(mA,P);aA-=iA*b2Vec2.CrossVV(rA,P);cB.SelfMulAdd(mB,P);aB+=iB*b2Vec2.CrossVV(rB,P);}else {const C1=b2Vec2.SubVV(b2Vec2.AddVV(cB,rB,b2Vec2.s_t0),b2Vec2.AddVV(cA,rA,b2Vec2.s_t1),b2WeldJoint.SolvePositionConstraints_s_C1);const C2=aB-aA-this.m_referenceAngle;positionError=C1.Length();angularError=b2Abs(C2);const impulse=K.Solve33(C1.x,C1.y,C2,b2WeldJoint.SolvePositionConstraints_s_impulse).SelfNeg();const P=b2WeldJoint.SolvePositionConstraints_s_P.Set(impulse.x,impulse.y);cA.SelfMulSub(mA,P);aA-=iA*(b2Vec2.CrossVV(this.m_rA,P)+impulse.z);cB.SelfMulAdd(mB,P);aB+=iB*(b2Vec2.CrossVV(this.m_rB,P)+impulse.z);}data.positions[this.m_indexA].a=aA;data.positions[this.m_indexB].a=aB;return positionError<=b2_linearSlop&&angularError<=b2_angularSlop;}GetAnchorA(out){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,out);}GetAnchorB(out){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,out);}GetReactionForce(inv_dt,out){out.x=inv_dt*this.m_impulse.x;out.y=inv_dt*this.m_impulse.y;return out;}GetReactionTorque(inv_dt){return inv_dt*this.m_impulse.z;}GetLocalAnchorA(){return this.m_localAnchorA;}GetLocalAnchorB(){return this.m_localAnchorB;}GetReferenceAngle(){return this.m_referenceAngle;}SetFrequency(hz){this.m_frequencyHz=hz;}GetFrequency(){return this.m_frequencyHz;}SetDampingRatio(ratio){this.m_dampingRatio=ratio;}GetDampingRatio(){return this.m_dampingRatio;}Dump(log){const indexA=this.m_bodyA.m_islandIndex;const indexB=this.m_bodyB.m_islandIndex;log("  const jd: b2WeldJointDef = new b2WeldJointDef();\n");log("  jd.bodyA = bodies[%d];\n",indexA);log("  jd.bodyB = bodies[%d];\n",indexB);log("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false");log("  jd.localAnchorA.Set(%.15f, %.15f);\n",this.m_localAnchorA.x,this.m_localAnchorA.y);log("  jd.localAnchorB.Set(%.15f, %.15f);\n",this.m_localAnchorB.x,this.m_localAnchorB.y);log("  jd.referenceAngle = %.15f;\n",this.m_referenceAngle);log("  jd.frequencyHz = %.15f;\n",this.m_frequencyHz);log("  jd.dampingRatio = %.15f;\n",this.m_dampingRatio);log("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index);}}b2WeldJoint.InitVelocityConstraints_s_P=new b2Vec2();b2WeldJoint.SolveVelocityConstraints_s_Cdot1=new b2Vec2();b2WeldJoint.SolveVelocityConstraints_s_impulse1=new b2Vec2();b2WeldJoint.SolveVelocityConstraints_s_impulse=new b2Vec3();b2WeldJoint.SolveVelocityConstraints_s_P=new b2Vec2();b2WeldJoint.SolvePositionConstraints_s_C1=new b2Vec2();b2WeldJoint.SolvePositionConstraints_s_P=new b2Vec2();b2WeldJoint.SolvePositionConstraints_s_impulse=new b2Vec3();class b2WheelJointDef extends b2JointDef{constructor(){super(exports.b2JointType.e_wheelJoint);this.localAnchorA=new b2Vec2(0,0);this.localAnchorB=new b2Vec2(0,0);this.localAxisA=new b2Vec2(1,0);this.enableMotor=false;this.maxMotorTorque=0;this.motorSpeed=0;this.frequencyHz=2;this.dampingRatio=0.7;}Initialize(bA,bB,anchor,axis){this.bodyA=bA;this.bodyB=bB;this.bodyA.GetLocalPoint(anchor,this.localAnchorA);this.bodyB.GetLocalPoint(anchor,this.localAnchorB);this.bodyA.GetLocalVector(axis,this.localAxisA);}}class b2WheelJoint extends b2Joint{constructor(def){super(def);this.m_frequencyHz=0;this.m_dampingRatio=0;this.m_localAnchorA=new b2Vec2();this.m_localAnchorB=new b2Vec2();this.m_localXAxisA=new b2Vec2();this.m_localYAxisA=new b2Vec2();this.m_impulse=0;this.m_motorImpulse=0;this.m_springImpulse=0;this.m_maxMotorTorque=0;this.m_motorSpeed=0;this.m_enableMotor=false;this.m_indexA=0;this.m_indexB=0;this.m_localCenterA=new b2Vec2();this.m_localCenterB=new b2Vec2();this.m_invMassA=0;this.m_invMassB=0;this.m_invIA=0;this.m_invIB=0;this.m_ax=new b2Vec2();this.m_ay=new b2Vec2();this.m_sAx=0;this.m_sBx=0;this.m_sAy=0;this.m_sBy=0;this.m_mass=0;this.m_motorMass=0;this.m_springMass=0;this.m_bias=0;this.m_gamma=0;this.m_qA=new b2Rot();this.m_qB=new b2Rot();this.m_lalcA=new b2Vec2();this.m_lalcB=new b2Vec2();this.m_rA=new b2Vec2();this.m_rB=new b2Vec2();this.m_frequencyHz=b2Maybe(def.frequencyHz,2);this.m_dampingRatio=b2Maybe(def.dampingRatio,0.7);this.m_localAnchorA.Copy(b2Maybe(def.localAnchorA,b2Vec2.ZERO));this.m_localAnchorB.Copy(b2Maybe(def.localAnchorB,b2Vec2.ZERO));this.m_localXAxisA.Copy(b2Maybe(def.localAxisA,b2Vec2.UNITX));b2Vec2.CrossOneV(this.m_localXAxisA,this.m_localYAxisA);this.m_maxMotorTorque=b2Maybe(def.maxMotorTorque,0);this.m_motorSpeed=b2Maybe(def.motorSpeed,0);this.m_enableMotor=b2Maybe(def.enableMotor,false);this.m_ax.SetZero();this.m_ay.SetZero();}GetMotorSpeed(){return this.m_motorSpeed;}GetMaxMotorTorque(){return this.m_maxMotorTorque;}SetSpringFrequencyHz(hz){this.m_frequencyHz=hz;}GetSpringFrequencyHz(){return this.m_frequencyHz;}SetSpringDampingRatio(ratio){this.m_dampingRatio=ratio;}GetSpringDampingRatio(){return this.m_dampingRatio;}InitVelocityConstraints(data){this.m_indexA=this.m_bodyA.m_islandIndex;this.m_indexB=this.m_bodyB.m_islandIndex;this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);this.m_invMassA=this.m_bodyA.m_invMass;this.m_invMassB=this.m_bodyB.m_invMass;this.m_invIA=this.m_bodyA.m_invI;this.m_invIB=this.m_bodyB.m_invI;const mA=this.m_invMassA,mB=this.m_invMassB;const iA=this.m_invIA,iB=this.m_invIB;const cA=data.positions[this.m_indexA].c;const aA=data.positions[this.m_indexA].a;const vA=data.velocities[this.m_indexA].v;let wA=data.velocities[this.m_indexA].w;const cB=data.positions[this.m_indexB].c;const aB=data.positions[this.m_indexB].a;const vB=data.velocities[this.m_indexB].v;let wB=data.velocities[this.m_indexB].w;const qA=this.m_qA.SetAngle(aA),qB=this.m_qB.SetAngle(aB);b2Vec2.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);const rA=b2Rot.MulRV(qA,this.m_lalcA,this.m_rA);b2Vec2.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);const rB=b2Rot.MulRV(qB,this.m_lalcB,this.m_rB);const d=b2Vec2.SubVV(b2Vec2.AddVV(cB,rB,b2Vec2.s_t0),b2Vec2.AddVV(cA,rA,b2Vec2.s_t1),b2WheelJoint.InitVelocityConstraints_s_d);{b2Rot.MulRV(qA,this.m_localYAxisA,this.m_ay);this.m_sAy=b2Vec2.CrossVV(b2Vec2.AddVV(d,rA,b2Vec2.s_t0),this.m_ay);this.m_sBy=b2Vec2.CrossVV(rB,this.m_ay);this.m_mass=mA+mB+iA*this.m_sAy*this.m_sAy+iB*this.m_sBy*this.m_sBy;if(this.m_mass>0){this.m_mass=1/this.m_mass;}}this.m_springMass=0;this.m_bias=0;this.m_gamma=0;if(this.m_frequencyHz>0){b2Rot.MulRV(qA,this.m_localXAxisA,this.m_ax);this.m_sAx=b2Vec2.CrossVV(b2Vec2.AddVV(d,rA,b2Vec2.s_t0),this.m_ax);this.m_sBx=b2Vec2.CrossVV(rB,this.m_ax);const invMass=mA+mB+iA*this.m_sAx*this.m_sAx+iB*this.m_sBx*this.m_sBx;if(invMass>0){this.m_springMass=1/invMass;const C=b2Vec2.DotVV(d,this.m_ax);const omega=2*b2_pi*this.m_frequencyHz;const damp=2*this.m_springMass*this.m_dampingRatio*omega;const k=this.m_springMass*omega*omega;const h=data.step.dt;this.m_gamma=h*(damp+h*k);if(this.m_gamma>0){this.m_gamma=1/this.m_gamma;}this.m_bias=C*h*k*this.m_gamma;this.m_springMass=invMass+this.m_gamma;if(this.m_springMass>0){this.m_springMass=1/this.m_springMass;}}}else {this.m_springImpulse=0;}if(this.m_enableMotor){this.m_motorMass=iA+iB;if(this.m_motorMass>0){this.m_motorMass=1/this.m_motorMass;}}else {this.m_motorMass=0;this.m_motorImpulse=0;}if(data.step.warmStarting){this.m_impulse*=data.step.dtRatio;this.m_springImpulse*=data.step.dtRatio;this.m_motorImpulse*=data.step.dtRatio;const P=b2Vec2.AddVV(b2Vec2.MulSV(this.m_impulse,this.m_ay,b2Vec2.s_t0),b2Vec2.MulSV(this.m_springImpulse,this.m_ax,b2Vec2.s_t1),b2WheelJoint.InitVelocityConstraints_s_P);const LA=this.m_impulse*this.m_sAy+this.m_springImpulse*this.m_sAx+this.m_motorImpulse;const LB=this.m_impulse*this.m_sBy+this.m_springImpulse*this.m_sBx+this.m_motorImpulse;vA.SelfMulSub(this.m_invMassA,P);wA-=this.m_invIA*LA;vB.SelfMulAdd(this.m_invMassB,P);wB+=this.m_invIB*LB;}else {this.m_impulse=0;this.m_springImpulse=0;this.m_motorImpulse=0;}data.velocities[this.m_indexA].w=wA;data.velocities[this.m_indexB].w=wB;}SolveVelocityConstraints(data){const mA=this.m_invMassA,mB=this.m_invMassB;const iA=this.m_invIA,iB=this.m_invIB;const vA=data.velocities[this.m_indexA].v;let wA=data.velocities[this.m_indexA].w;const vB=data.velocities[this.m_indexB].v;let wB=data.velocities[this.m_indexB].w;{const Cdot=b2Vec2.DotVV(this.m_ax,b2Vec2.SubVV(vB,vA,b2Vec2.s_t0))+this.m_sBx*wB-this.m_sAx*wA;const impulse=-this.m_springMass*(Cdot+this.m_bias+this.m_gamma*this.m_springImpulse);this.m_springImpulse+=impulse;const P=b2Vec2.MulSV(impulse,this.m_ax,b2WheelJoint.SolveVelocityConstraints_s_P);const LA=impulse*this.m_sAx;const LB=impulse*this.m_sBx;vA.SelfMulSub(mA,P);wA-=iA*LA;vB.SelfMulAdd(mB,P);wB+=iB*LB;}{const Cdot=wB-wA-this.m_motorSpeed;let impulse=-this.m_motorMass*Cdot;const oldImpulse=this.m_motorImpulse;const maxImpulse=data.step.dt*this.m_maxMotorTorque;this.m_motorImpulse=b2Clamp(this.m_motorImpulse+impulse,-maxImpulse,maxImpulse);impulse=this.m_motorImpulse-oldImpulse;wA-=iA*impulse;wB+=iB*impulse;}{const Cdot=b2Vec2.DotVV(this.m_ay,b2Vec2.SubVV(vB,vA,b2Vec2.s_t0))+this.m_sBy*wB-this.m_sAy*wA;const impulse=-this.m_mass*Cdot;this.m_impulse+=impulse;const P=b2Vec2.MulSV(impulse,this.m_ay,b2WheelJoint.SolveVelocityConstraints_s_P);const LA=impulse*this.m_sAy;const LB=impulse*this.m_sBy;vA.SelfMulSub(mA,P);wA-=iA*LA;vB.SelfMulAdd(mB,P);wB+=iB*LB;}data.velocities[this.m_indexA].w=wA;data.velocities[this.m_indexB].w=wB;}SolvePositionConstraints(data){const cA=data.positions[this.m_indexA].c;let aA=data.positions[this.m_indexA].a;const cB=data.positions[this.m_indexB].c;let aB=data.positions[this.m_indexB].a;const qA=this.m_qA.SetAngle(aA),qB=this.m_qB.SetAngle(aB);b2Vec2.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);const rA=b2Rot.MulRV(qA,this.m_lalcA,this.m_rA);b2Vec2.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);const rB=b2Rot.MulRV(qB,this.m_lalcB,this.m_rB);const d=b2Vec2.AddVV(b2Vec2.SubVV(cB,cA,b2Vec2.s_t0),b2Vec2.SubVV(rB,rA,b2Vec2.s_t1),b2WheelJoint.SolvePositionConstraints_s_d);const ay=b2Rot.MulRV(qA,this.m_localYAxisA,this.m_ay);const sAy=b2Vec2.CrossVV(b2Vec2.AddVV(d,rA,b2Vec2.s_t0),ay);const sBy=b2Vec2.CrossVV(rB,ay);const C=b2Vec2.DotVV(d,this.m_ay);const k=this.m_invMassA+this.m_invMassB+this.m_invIA*this.m_sAy*this.m_sAy+this.m_invIB*this.m_sBy*this.m_sBy;let impulse;if(k!==0){impulse=-C/k;}else {impulse=0;}const P=b2Vec2.MulSV(impulse,ay,b2WheelJoint.SolvePositionConstraints_s_P);const LA=impulse*sAy;const LB=impulse*sBy;cA.SelfMulSub(this.m_invMassA,P);aA-=this.m_invIA*LA;cB.SelfMulAdd(this.m_invMassB,P);aB+=this.m_invIB*LB;data.positions[this.m_indexA].a=aA;data.positions[this.m_indexB].a=aB;return b2Abs(C)<=b2_linearSlop;}GetDefinition(def){return def;}GetAnchorA(out){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,out);}GetAnchorB(out){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,out);}GetReactionForce(inv_dt,out){out.x=inv_dt*(this.m_impulse*this.m_ay.x+this.m_springImpulse*this.m_ax.x);out.y=inv_dt*(this.m_impulse*this.m_ay.y+this.m_springImpulse*this.m_ax.y);return out;}GetReactionTorque(inv_dt){return inv_dt*this.m_motorImpulse;}GetLocalAnchorA(){return this.m_localAnchorA;}GetLocalAnchorB(){return this.m_localAnchorB;}GetLocalAxisA(){return this.m_localXAxisA;}GetJointTranslation(){return this.GetPrismaticJointTranslation();}GetJointLinearSpeed(){return this.GetPrismaticJointSpeed();}GetJointAngle(){return this.GetRevoluteJointAngle();}GetJointAngularSpeed(){return this.GetRevoluteJointSpeed();}GetPrismaticJointTranslation(){const bA=this.m_bodyA;const bB=this.m_bodyB;const pA=bA.GetWorldPoint(this.m_localAnchorA,new b2Vec2());const pB=bB.GetWorldPoint(this.m_localAnchorB,new b2Vec2());const d=b2Vec2.SubVV(pB,pA,new b2Vec2());const axis=bA.GetWorldVector(this.m_localXAxisA,new b2Vec2());const translation=b2Vec2.DotVV(d,axis);return translation;}GetPrismaticJointSpeed(){const bA=this.m_bodyA;const bB=this.m_bodyB;b2Vec2.SubVV(this.m_localAnchorA,bA.m_sweep.localCenter,this.m_lalcA);const rA=b2Rot.MulRV(bA.m_xf.q,this.m_lalcA,this.m_rA);b2Vec2.SubVV(this.m_localAnchorB,bB.m_sweep.localCenter,this.m_lalcB);const rB=b2Rot.MulRV(bB.m_xf.q,this.m_lalcB,this.m_rB);const pA=b2Vec2.AddVV(bA.m_sweep.c,rA,b2Vec2.s_t0);const pB=b2Vec2.AddVV(bB.m_sweep.c,rB,b2Vec2.s_t1);const d=b2Vec2.SubVV(pB,pA,b2Vec2.s_t2);const axis=bA.GetWorldVector(this.m_localXAxisA,new b2Vec2());const vA=bA.m_linearVelocity;const vB=bB.m_linearVelocity;const wA=bA.m_angularVelocity;const wB=bB.m_angularVelocity;const speed=b2Vec2.DotVV(d,b2Vec2.CrossSV(wA,axis,b2Vec2.s_t0))+b2Vec2.DotVV(axis,b2Vec2.SubVV(b2Vec2.AddVCrossSV(vB,wB,rB,b2Vec2.s_t0),b2Vec2.AddVCrossSV(vA,wA,rA,b2Vec2.s_t1),b2Vec2.s_t0));return speed;}GetRevoluteJointAngle(){return this.m_bodyB.m_sweep.a-this.m_bodyA.m_sweep.a;}GetRevoluteJointSpeed(){const wA=this.m_bodyA.m_angularVelocity;const wB=this.m_bodyB.m_angularVelocity;return wB-wA;}IsMotorEnabled(){return this.m_enableMotor;}EnableMotor(flag){if(flag!==this.m_enableMotor){this.m_bodyA.SetAwake(true);this.m_bodyB.SetAwake(true);this.m_enableMotor=flag;}}SetMotorSpeed(speed){if(speed!==this.m_motorSpeed){this.m_bodyA.SetAwake(true);this.m_bodyB.SetAwake(true);this.m_motorSpeed=speed;}}SetMaxMotorTorque(force){if(force!==this.m_maxMotorTorque){this.m_bodyA.SetAwake(true);this.m_bodyB.SetAwake(true);this.m_maxMotorTorque=force;}}GetMotorTorque(inv_dt){return inv_dt*this.m_motorImpulse;}Dump(log){const indexA=this.m_bodyA.m_islandIndex;const indexB=this.m_bodyB.m_islandIndex;log("  const jd: b2WheelJointDef = new b2WheelJointDef();\n");log("  jd.bodyA = bodies[%d];\n",indexA);log("  jd.bodyB = bodies[%d];\n",indexB);log("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false");log("  jd.localAnchorA.Set(%.15f, %.15f);\n",this.m_localAnchorA.x,this.m_localAnchorA.y);log("  jd.localAnchorB.Set(%.15f, %.15f);\n",this.m_localAnchorB.x,this.m_localAnchorB.y);log("  jd.localAxisA.Set(%.15f, %.15f);\n",this.m_localXAxisA.x,this.m_localXAxisA.y);log("  jd.enableMotor = %s;\n",this.m_enableMotor?"true":"false");log("  jd.motorSpeed = %.15f;\n",this.m_motorSpeed);log("  jd.maxMotorTorque = %.15f;\n",this.m_maxMotorTorque);log("  jd.frequencyHz = %.15f;\n",this.m_frequencyHz);log("  jd.dampingRatio = %.15f;\n",this.m_dampingRatio);log("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index);}}b2WheelJoint.InitVelocityConstraints_s_d=new b2Vec2();b2WheelJoint.InitVelocityConstraints_s_P=new b2Vec2();b2WheelJoint.SolveVelocityConstraints_s_P=new b2Vec2();b2WheelJoint.SolvePositionConstraints_s_d=new b2Vec2();b2WheelJoint.SolvePositionConstraints_s_P=new b2Vec2();function b2MixFriction(friction1,friction2){return b2Sqrt(friction1*friction2);}function b2MixRestitution(restitution1,restitution2){return restitution1>restitution2?restitution1:restitution2;}class b2ContactEdge{constructor(contact){this._other=null;this.prev=null;this.next=null;this.contact=contact;}get other(){if(this._other===null){throw new Error();}return this._other;}set other(value){if(this._other!==null){throw new Error();}this._other=value;}Reset(){this._other=null;this.prev=null;this.next=null;}}class b2Contact{constructor(){this.m_islandFlag=false;this.m_touchingFlag=false;this.m_enabledFlag=false;this.m_filterFlag=false;this.m_bulletHitFlag=false;this.m_toiFlag=false;this.m_prev=null;this.m_next=null;this.m_nodeA=new b2ContactEdge(this);this.m_nodeB=new b2ContactEdge(this);this.m_indexA=0;this.m_indexB=0;this.m_manifold=new b2Manifold();this.m_toiCount=0;this.m_toi=0;this.m_friction=0;this.m_restitution=0;this.m_tangentSpeed=0;this.m_oldManifold=new b2Manifold();}GetManifold(){return this.m_manifold;}GetWorldManifold(worldManifold){const bodyA=this.m_fixtureA.GetBody();const bodyB=this.m_fixtureB.GetBody();const shapeA=this.GetShapeA();const shapeB=this.GetShapeB();worldManifold.Initialize(this.m_manifold,bodyA.GetTransform(),shapeA.m_radius,bodyB.GetTransform(),shapeB.m_radius);}IsTouching(){return this.m_touchingFlag;}SetEnabled(flag){this.m_enabledFlag=flag;}IsEnabled(){return this.m_enabledFlag;}GetNext(){return this.m_next;}GetFixtureA(){return this.m_fixtureA;}GetChildIndexA(){return this.m_indexA;}GetShapeA(){return this.m_fixtureA.GetShape();}GetFixtureB(){return this.m_fixtureB;}GetChildIndexB(){return this.m_indexB;}GetShapeB(){return this.m_fixtureB.GetShape();}FlagForFiltering(){this.m_filterFlag=true;}SetFriction(friction){this.m_friction=friction;}GetFriction(){return this.m_friction;}ResetFriction(){this.m_friction=b2MixFriction(this.m_fixtureA.m_friction,this.m_fixtureB.m_friction);}SetRestitution(restitution){this.m_restitution=restitution;}GetRestitution(){return this.m_restitution;}ResetRestitution(){this.m_restitution=b2MixRestitution(this.m_fixtureA.m_restitution,this.m_fixtureB.m_restitution);}SetTangentSpeed(speed){this.m_tangentSpeed=speed;}GetTangentSpeed(){return this.m_tangentSpeed;}Reset(fixtureA,indexA,fixtureB,indexB){this.m_islandFlag=false;this.m_touchingFlag=false;this.m_enabledFlag=true;this.m_filterFlag=false;this.m_bulletHitFlag=false;this.m_toiFlag=false;this.m_fixtureA=fixtureA;this.m_fixtureB=fixtureB;this.m_indexA=indexA;this.m_indexB=indexB;this.m_manifold.pointCount=0;this.m_prev=null;this.m_next=null;this.m_nodeA.Reset();this.m_nodeB.Reset();this.m_toiCount=0;this.m_friction=b2MixFriction(this.m_fixtureA.m_friction,this.m_fixtureB.m_friction);this.m_restitution=b2MixRestitution(this.m_fixtureA.m_restitution,this.m_fixtureB.m_restitution);}Update(listener){const tManifold=this.m_oldManifold;this.m_oldManifold=this.m_manifold;this.m_manifold=tManifold;this.m_enabledFlag=true;let touching=false;const wasTouching=this.m_touchingFlag;const sensorA=this.m_fixtureA.IsSensor();const sensorB=this.m_fixtureB.IsSensor();const sensor=sensorA||sensorB;const bodyA=this.m_fixtureA.GetBody();const bodyB=this.m_fixtureB.GetBody();const xfA=bodyA.GetTransform();const xfB=bodyB.GetTransform();if(sensor){const shapeA=this.GetShapeA();const shapeB=this.GetShapeB();touching=b2TestOverlapShape(shapeA,this.m_indexA,shapeB,this.m_indexB,xfA,xfB);this.m_manifold.pointCount=0;}else {this.Evaluate(this.m_manifold,xfA,xfB);touching=this.m_manifold.pointCount>0;for(let i=0;i<this.m_manifold.pointCount;++i){const mp2=this.m_manifold.points[i];mp2.normalImpulse=0;mp2.tangentImpulse=0;const id2=mp2.id;for(let j=0;j<this.m_oldManifold.pointCount;++j){const mp1=this.m_oldManifold.points[j];if(mp1.id.key===id2.key){mp2.normalImpulse=mp1.normalImpulse;mp2.tangentImpulse=mp1.tangentImpulse;break;}}}if(touching!==wasTouching){bodyA.SetAwake(true);bodyB.SetAwake(true);}}this.m_touchingFlag=touching;if(!wasTouching&&touching&&listener){listener.BeginContact(this);}if(wasTouching&&!touching&&listener){listener.EndContact(this);}if(!sensor&&touching&&listener){listener.PreSolve(this,this.m_oldManifold);}}ComputeTOI(sweepA,sweepB){const input=b2Contact.ComputeTOI_s_input;input.proxyA.SetShape(this.GetShapeA(),this.m_indexA);input.proxyB.SetShape(this.GetShapeB(),this.m_indexB);input.sweepA.Copy(sweepA);input.sweepB.Copy(sweepB);input.tMax=b2_linearSlop;const output=b2Contact.ComputeTOI_s_output;b2TimeOfImpact(output,input);return output.t;}}b2Contact.ComputeTOI_s_input=new b2TOIInput();b2Contact.ComputeTOI_s_output=new b2TOIOutput();class b2CircleContact extends b2Contact{static Create(){return new b2CircleContact();}static Destroy(contact){}Evaluate(manifold,xfA,xfB){b2CollideCircles(manifold,this.GetShapeA(),xfA,this.GetShapeB(),xfB);}}class b2PolygonContact extends b2Contact{static Create(){return new b2PolygonContact();}static Destroy(contact){}Evaluate(manifold,xfA,xfB){b2CollidePolygons(manifold,this.GetShapeA(),xfA,this.GetShapeB(),xfB);}}class b2PolygonAndCircleContact extends b2Contact{static Create(){return new b2PolygonAndCircleContact();}static Destroy(contact){}Evaluate(manifold,xfA,xfB){b2CollidePolygonAndCircle(manifold,this.GetShapeA(),xfA,this.GetShapeB(),xfB);}}class b2EdgeAndCircleContact extends b2Contact{static Create(){return new b2EdgeAndCircleContact();}static Destroy(contact){}Evaluate(manifold,xfA,xfB){b2CollideEdgeAndCircle(manifold,this.GetShapeA(),xfA,this.GetShapeB(),xfB);}}class b2EdgeAndPolygonContact extends b2Contact{static Create(){return new b2EdgeAndPolygonContact();}static Destroy(contact){}Evaluate(manifold,xfA,xfB){b2CollideEdgeAndPolygon(manifold,this.GetShapeA(),xfA,this.GetShapeB(),xfB);}}class b2ChainAndCircleContact extends b2Contact{static Create(){return new b2ChainAndCircleContact();}static Destroy(contact){}Evaluate(manifold,xfA,xfB){const edge=b2ChainAndCircleContact.Evaluate_s_edge;this.GetShapeA().GetChildEdge(edge,this.m_indexA);b2CollideEdgeAndCircle(manifold,edge,xfA,this.GetShapeB(),xfB);}}b2ChainAndCircleContact.Evaluate_s_edge=new b2EdgeShape();class b2ChainAndPolygonContact extends b2Contact{static Create(){return new b2ChainAndPolygonContact();}static Destroy(contact){}Evaluate(manifold,xfA,xfB){const edge=b2ChainAndPolygonContact.Evaluate_s_edge;this.GetShapeA().GetChildEdge(edge,this.m_indexA);b2CollideEdgeAndPolygon(manifold,edge,xfA,this.GetShapeB(),xfB);}}b2ChainAndPolygonContact.Evaluate_s_edge=new b2EdgeShape();class b2ContactRegister{constructor(){this.pool=[];this.createFcn=null;this.destroyFcn=null;this.primary=false;}}class b2ContactFactory{constructor(){this.m_registers=[];this.InitializeRegisters();}AddType(createFcn,destroyFcn,typeA,typeB){const pool=[];function poolCreateFcn(){return pool.pop()||createFcn();}function poolDestroyFcn(contact){pool.push(contact);}this.m_registers[typeA][typeB].pool=pool;this.m_registers[typeA][typeB].createFcn=poolCreateFcn;this.m_registers[typeA][typeB].destroyFcn=poolDestroyFcn;this.m_registers[typeA][typeB].primary=true;if(typeA!==typeB){this.m_registers[typeB][typeA].pool=pool;this.m_registers[typeB][typeA].createFcn=poolCreateFcn;this.m_registers[typeB][typeA].destroyFcn=poolDestroyFcn;this.m_registers[typeB][typeA].primary=false;}}InitializeRegisters(){for(let i=0;i<exports.b2ShapeType.e_shapeTypeCount;i++){this.m_registers[i]=[];for(let j=0;j<exports.b2ShapeType.e_shapeTypeCount;j++){this.m_registers[i][j]=new b2ContactRegister();}}this.AddType(b2CircleContact.Create,b2CircleContact.Destroy,exports.b2ShapeType.e_circleShape,exports.b2ShapeType.e_circleShape);this.AddType(b2PolygonAndCircleContact.Create,b2PolygonAndCircleContact.Destroy,exports.b2ShapeType.e_polygonShape,exports.b2ShapeType.e_circleShape);this.AddType(b2PolygonContact.Create,b2PolygonContact.Destroy,exports.b2ShapeType.e_polygonShape,exports.b2ShapeType.e_polygonShape);this.AddType(b2EdgeAndCircleContact.Create,b2EdgeAndCircleContact.Destroy,exports.b2ShapeType.e_edgeShape,exports.b2ShapeType.e_circleShape);this.AddType(b2EdgeAndPolygonContact.Create,b2EdgeAndPolygonContact.Destroy,exports.b2ShapeType.e_edgeShape,exports.b2ShapeType.e_polygonShape);this.AddType(b2ChainAndCircleContact.Create,b2ChainAndCircleContact.Destroy,exports.b2ShapeType.e_chainShape,exports.b2ShapeType.e_circleShape);this.AddType(b2ChainAndPolygonContact.Create,b2ChainAndPolygonContact.Destroy,exports.b2ShapeType.e_chainShape,exports.b2ShapeType.e_polygonShape);}Create(fixtureA,indexA,fixtureB,indexB){const typeA=fixtureA.GetType();const typeB=fixtureB.GetType();const reg=this.m_registers[typeA][typeB];if(reg.createFcn){const c=reg.createFcn();if(reg.primary){c.Reset(fixtureA,indexA,fixtureB,indexB);}else {c.Reset(fixtureB,indexB,fixtureA,indexA);}return c;}else {return null;}}Destroy(contact){const typeA=contact.m_fixtureA.GetType();const typeB=contact.m_fixtureB.GetType();const reg=this.m_registers[typeA][typeB];if(reg.destroyFcn){reg.destroyFcn(contact);}}}class b2DestructionListener{SayGoodbyeJoint(joint){}SayGoodbyeFixture(fixture){}SayGoodbyeParticleGroup(group){}SayGoodbyeParticle(system,index){}}class b2ContactFilter{ShouldCollide(fixtureA,fixtureB){const bodyA=fixtureA.GetBody();const bodyB=fixtureB.GetBody();if(bodyB.GetType()===exports.b2BodyType.b2_staticBody&&bodyA.GetType()===exports.b2BodyType.b2_staticBody){return false;}if(!bodyB.ShouldCollideConnected(bodyA)){return false;}const filter1=fixtureA.GetFilterData();const filter2=fixtureB.GetFilterData();if(filter1.groupIndex===filter2.groupIndex&&filter1.groupIndex!==0){return filter1.groupIndex>0;}const collide=(filter1.maskBits&filter2.categoryBits)!==0&&(filter1.categoryBits&filter2.maskBits)!==0;return collide;}ShouldCollideFixtureParticle(fixture,system,index){return true;}ShouldCollideParticleParticle(system,indexA,indexB){return true;}}b2ContactFilter.b2_defaultFilter=new b2ContactFilter();class b2ContactImpulse{constructor(){this.normalImpulses=b2MakeNumberArray(b2_maxManifoldPoints);this.tangentImpulses=b2MakeNumberArray(b2_maxManifoldPoints);this.count=0;}}class b2ContactListener{BeginContact(contact){}EndContact(contact){}BeginContactFixtureParticle(system,contact){}EndContactFixtureParticle(system,contact){}BeginContactParticleParticle(system,contact){}EndContactParticleParticle(system,contact){}PreSolve(contact,oldManifold){}PostSolve(contact,impulse){}}b2ContactListener.b2_defaultListener=new b2ContactListener();class b2QueryCallback{ReportFixture(fixture){return true;}ReportParticle(system,index){return false;}ShouldQueryParticleSystem(system){return true;}}class b2RayCastCallback{ReportFixture(fixture,point,normal,fraction){return fraction;}ReportParticle(system,index,point,normal,fraction){return 0;}ShouldQueryParticleSystem(system){return true;}}class b2ContactManager{constructor(){this.m_broadPhase=new b2BroadPhase();this.m_contactList=null;this.m_contactCount=0;this.m_contactFilter=b2ContactFilter.b2_defaultFilter;this.m_contactListener=b2ContactListener.b2_defaultListener;this.m_contactFactory=new b2ContactFactory();}AddPair(proxyA,proxyB){let fixtureA=proxyA.fixture;let fixtureB=proxyB.fixture;let indexA=proxyA.childIndex;let indexB=proxyB.childIndex;let bodyA=fixtureA.GetBody();let bodyB=fixtureB.GetBody();if(bodyA===bodyB){return;}let edge=bodyB.GetContactList();while(edge){if(edge.other===bodyA){const fA=edge.contact.GetFixtureA();const fB=edge.contact.GetFixtureB();const iA=edge.contact.GetChildIndexA();const iB=edge.contact.GetChildIndexB();if(fA===fixtureA&&fB===fixtureB&&iA===indexA&&iB===indexB){return;}if(fA===fixtureB&&fB===fixtureA&&iA===indexB&&iB===indexA){return;}}edge=edge.next;}if(this.m_contactFilter&&!this.m_contactFilter.ShouldCollide(fixtureA,fixtureB)){return;}const c=this.m_contactFactory.Create(fixtureA,indexA,fixtureB,indexB);if(c===null){return;}fixtureA=c.GetFixtureA();fixtureB=c.GetFixtureB();indexA=c.GetChildIndexA();indexB=c.GetChildIndexB();bodyA=fixtureA.m_body;bodyB=fixtureB.m_body;c.m_prev=null;c.m_next=this.m_contactList;if(this.m_contactList!==null){this.m_contactList.m_prev=c;}this.m_contactList=c;c.m_nodeA.other=bodyB;c.m_nodeA.prev=null;c.m_nodeA.next=bodyA.m_contactList;if(bodyA.m_contactList!==null){bodyA.m_contactList.prev=c.m_nodeA;}bodyA.m_contactList=c.m_nodeA;c.m_nodeB.other=bodyA;c.m_nodeB.prev=null;c.m_nodeB.next=bodyB.m_contactList;if(bodyB.m_contactList!==null){bodyB.m_contactList.prev=c.m_nodeB;}bodyB.m_contactList=c.m_nodeB;if(!fixtureA.IsSensor()&&!fixtureB.IsSensor()){bodyA.SetAwake(true);bodyB.SetAwake(true);}++this.m_contactCount;}FindNewContacts(){this.m_broadPhase.UpdatePairs((proxyA,proxyB)=>{this.AddPair(proxyA,proxyB);});}Destroy(c){const fixtureA=c.GetFixtureA();const fixtureB=c.GetFixtureB();const bodyA=fixtureA.GetBody();const bodyB=fixtureB.GetBody();if(this.m_contactListener&&c.IsTouching()){this.m_contactListener.EndContact(c);}if(c.m_prev){c.m_prev.m_next=c.m_next;}if(c.m_next){c.m_next.m_prev=c.m_prev;}if(c===this.m_contactList){this.m_contactList=c.m_next;}if(c.m_nodeA.prev){c.m_nodeA.prev.next=c.m_nodeA.next;}if(c.m_nodeA.next){c.m_nodeA.next.prev=c.m_nodeA.prev;}if(c.m_nodeA===bodyA.m_contactList){bodyA.m_contactList=c.m_nodeA.next;}if(c.m_nodeB.prev){c.m_nodeB.prev.next=c.m_nodeB.next;}if(c.m_nodeB.next){c.m_nodeB.next.prev=c.m_nodeB.prev;}if(c.m_nodeB===bodyB.m_contactList){bodyB.m_contactList=c.m_nodeB.next;}if(c.m_manifold.pointCount>0&&!fixtureA.IsSensor()&&!fixtureB.IsSensor()){fixtureA.GetBody().SetAwake(true);fixtureB.GetBody().SetAwake(true);}this.m_contactFactory.Destroy(c);--this.m_contactCount;}Collide(){let c=this.m_contactList;while(c){const fixtureA=c.GetFixtureA();const fixtureB=c.GetFixtureB();const indexA=c.GetChildIndexA();const indexB=c.GetChildIndexB();const bodyA=fixtureA.GetBody();const bodyB=fixtureB.GetBody();if(c.m_filterFlag){if(this.m_contactFilter&&!this.m_contactFilter.ShouldCollide(fixtureA,fixtureB)){const cNuke=c;c=cNuke.m_next;this.Destroy(cNuke);continue;}c.m_filterFlag=false;}const activeA=bodyA.IsAwake()&&bodyA.m_type!==exports.b2BodyType.b2_staticBody;const activeB=bodyB.IsAwake()&&bodyB.m_type!==exports.b2BodyType.b2_staticBody;if(!activeA&&!activeB){c=c.m_next;continue;}const treeNodeA=fixtureA.m_proxies[indexA].treeNode;const treeNodeB=fixtureB.m_proxies[indexB].treeNode;const overlap=b2TestOverlapAABB(treeNodeA.aabb,treeNodeB.aabb);if(!overlap){const cNuke=c;c=cNuke.m_next;this.Destroy(cNuke);continue;}c.Update(this.m_contactListener);c=c.m_next;}}}class b2Profile{constructor(){this.step=0;this.collide=0;this.solve=0;this.solveInit=0;this.solveVelocity=0;this.solvePosition=0;this.broadphase=0;this.solveTOI=0;}Reset(){this.step=0;this.collide=0;this.solve=0;this.solveInit=0;this.solveVelocity=0;this.solvePosition=0;this.broadphase=0;this.solveTOI=0;return this;}}class b2TimeStep{constructor(){this.dt=0;this.inv_dt=0;this.dtRatio=0;this.velocityIterations=0;this.positionIterations=0;this.particleIterations=0;this.warmStarting=false;}Copy(step){this.dt=step.dt;this.inv_dt=step.inv_dt;this.dtRatio=step.dtRatio;this.positionIterations=step.positionIterations;this.velocityIterations=step.velocityIterations;this.particleIterations=step.particleIterations;this.warmStarting=step.warmStarting;return this;}}class b2Position{constructor(){this.c=new b2Vec2();this.a=0;}static MakeArray(length){return b2MakeArray(length,i=>new b2Position());}}class b2Velocity{constructor(){this.v=new b2Vec2();this.w=0;}static MakeArray(length){return b2MakeArray(length,i=>new b2Velocity());}}class b2SolverData{constructor(){this.step=new b2TimeStep();}}let g_blockSolve=false;class b2VelocityConstraintPoint{constructor(){this.rA=new b2Vec2();this.rB=new b2Vec2();this.normalImpulse=0;this.tangentImpulse=0;this.normalMass=0;this.tangentMass=0;this.velocityBias=0;}static MakeArray(length){return b2MakeArray(length,i=>new b2VelocityConstraintPoint());}}class b2ContactVelocityConstraint{constructor(){this.points=b2VelocityConstraintPoint.MakeArray(b2_maxManifoldPoints);this.normal=new b2Vec2();this.tangent=new b2Vec2();this.normalMass=new b2Mat22();this.K=new b2Mat22();this.indexA=0;this.indexB=0;this.invMassA=0;this.invMassB=0;this.invIA=0;this.invIB=0;this.friction=0;this.restitution=0;this.tangentSpeed=0;this.pointCount=0;this.contactIndex=0;}static MakeArray(length){return b2MakeArray(length,i=>new b2ContactVelocityConstraint());}}class b2ContactPositionConstraint{constructor(){this.localPoints=b2Vec2.MakeArray(b2_maxManifoldPoints);this.localNormal=new b2Vec2();this.localPoint=new b2Vec2();this.indexA=0;this.indexB=0;this.invMassA=0;this.invMassB=0;this.localCenterA=new b2Vec2();this.localCenterB=new b2Vec2();this.invIA=0;this.invIB=0;this.type=exports.b2ManifoldType.e_unknown;this.radiusA=0;this.radiusB=0;this.pointCount=0;}static MakeArray(length){return b2MakeArray(length,i=>new b2ContactPositionConstraint());}}class b2ContactSolverDef{constructor(){this.step=new b2TimeStep();this.count=0;}}class b2PositionSolverManifold{constructor(){this.normal=new b2Vec2();this.point=new b2Vec2();this.separation=0;}Initialize(pc,xfA,xfB,index){const pointA=b2PositionSolverManifold.Initialize_s_pointA;const pointB=b2PositionSolverManifold.Initialize_s_pointB;const planePoint=b2PositionSolverManifold.Initialize_s_planePoint;const clipPoint=b2PositionSolverManifold.Initialize_s_clipPoint;switch(pc.type){case exports.b2ManifoldType.e_circles:{b2Transform.MulXV(xfA,pc.localPoint,pointA);b2Transform.MulXV(xfB,pc.localPoints[0],pointB);b2Vec2.SubVV(pointB,pointA,this.normal).SelfNormalize();b2Vec2.MidVV(pointA,pointB,this.point);this.separation=b2Vec2.DotVV(b2Vec2.SubVV(pointB,pointA,b2Vec2.s_t0),this.normal)-pc.radiusA-pc.radiusB;break;}case exports.b2ManifoldType.e_faceA:{b2Rot.MulRV(xfA.q,pc.localNormal,this.normal);b2Transform.MulXV(xfA,pc.localPoint,planePoint);b2Transform.MulXV(xfB,pc.localPoints[index],clipPoint);this.separation=b2Vec2.DotVV(b2Vec2.SubVV(clipPoint,planePoint,b2Vec2.s_t0),this.normal)-pc.radiusA-pc.radiusB;this.point.Copy(clipPoint);break;}case exports.b2ManifoldType.e_faceB:{b2Rot.MulRV(xfB.q,pc.localNormal,this.normal);b2Transform.MulXV(xfB,pc.localPoint,planePoint);b2Transform.MulXV(xfA,pc.localPoints[index],clipPoint);this.separation=b2Vec2.DotVV(b2Vec2.SubVV(clipPoint,planePoint,b2Vec2.s_t0),this.normal)-pc.radiusA-pc.radiusB;this.point.Copy(clipPoint);this.normal.SelfNeg();break;}}}}b2PositionSolverManifold.Initialize_s_pointA=new b2Vec2();b2PositionSolverManifold.Initialize_s_pointB=new b2Vec2();b2PositionSolverManifold.Initialize_s_planePoint=new b2Vec2();b2PositionSolverManifold.Initialize_s_clipPoint=new b2Vec2();class b2ContactSolver{constructor(){this.m_step=new b2TimeStep();this.m_positionConstraints=b2ContactPositionConstraint.MakeArray(1024);this.m_velocityConstraints=b2ContactVelocityConstraint.MakeArray(1024);this.m_count=0;}Initialize(def){this.m_step.Copy(def.step);this.m_count=def.count;if(this.m_positionConstraints.length<this.m_count){const new_length=b2Max(this.m_positionConstraints.length*2,this.m_count);while(this.m_positionConstraints.length<new_length){this.m_positionConstraints[this.m_positionConstraints.length]=new b2ContactPositionConstraint();}}if(this.m_velocityConstraints.length<this.m_count){const new_length=b2Max(this.m_velocityConstraints.length*2,this.m_count);while(this.m_velocityConstraints.length<new_length){this.m_velocityConstraints[this.m_velocityConstraints.length]=new b2ContactVelocityConstraint();}}this.m_positions=def.positions;this.m_velocities=def.velocities;this.m_contacts=def.contacts;for(let i=0;i<this.m_count;++i){const contact=this.m_contacts[i];const fixtureA=contact.m_fixtureA;const fixtureB=contact.m_fixtureB;const shapeA=fixtureA.GetShape();const shapeB=fixtureB.GetShape();const radiusA=shapeA.m_radius;const radiusB=shapeB.m_radius;const bodyA=fixtureA.GetBody();const bodyB=fixtureB.GetBody();const manifold=contact.GetManifold();const pointCount=manifold.pointCount;const vc=this.m_velocityConstraints[i];vc.friction=contact.m_friction;vc.restitution=contact.m_restitution;vc.tangentSpeed=contact.m_tangentSpeed;vc.indexA=bodyA.m_islandIndex;vc.indexB=bodyB.m_islandIndex;vc.invMassA=bodyA.m_invMass;vc.invMassB=bodyB.m_invMass;vc.invIA=bodyA.m_invI;vc.invIB=bodyB.m_invI;vc.contactIndex=i;vc.pointCount=pointCount;vc.K.SetZero();vc.normalMass.SetZero();const pc=this.m_positionConstraints[i];pc.indexA=bodyA.m_islandIndex;pc.indexB=bodyB.m_islandIndex;pc.invMassA=bodyA.m_invMass;pc.invMassB=bodyB.m_invMass;pc.localCenterA.Copy(bodyA.m_sweep.localCenter);pc.localCenterB.Copy(bodyB.m_sweep.localCenter);pc.invIA=bodyA.m_invI;pc.invIB=bodyB.m_invI;pc.localNormal.Copy(manifold.localNormal);pc.localPoint.Copy(manifold.localPoint);pc.pointCount=pointCount;pc.radiusA=radiusA;pc.radiusB=radiusB;pc.type=manifold.type;for(let j=0;j<pointCount;++j){const cp=manifold.points[j];const vcp=vc.points[j];if(this.m_step.warmStarting){vcp.normalImpulse=this.m_step.dtRatio*cp.normalImpulse;vcp.tangentImpulse=this.m_step.dtRatio*cp.tangentImpulse;}else {vcp.normalImpulse=0;vcp.tangentImpulse=0;}vcp.rA.SetZero();vcp.rB.SetZero();vcp.normalMass=0;vcp.tangentMass=0;vcp.velocityBias=0;pc.localPoints[j].Copy(cp.localPoint);}}return this;}InitializeVelocityConstraints(){const xfA=b2ContactSolver.InitializeVelocityConstraints_s_xfA;const xfB=b2ContactSolver.InitializeVelocityConstraints_s_xfB;const worldManifold=b2ContactSolver.InitializeVelocityConstraints_s_worldManifold;const k_maxConditionNumber=1000;for(let i=0;i<this.m_count;++i){const vc=this.m_velocityConstraints[i];const pc=this.m_positionConstraints[i];const radiusA=pc.radiusA;const radiusB=pc.radiusB;const manifold=this.m_contacts[vc.contactIndex].GetManifold();const indexA=vc.indexA;const indexB=vc.indexB;const mA=vc.invMassA;const mB=vc.invMassB;const iA=vc.invIA;const iB=vc.invIB;const localCenterA=pc.localCenterA;const localCenterB=pc.localCenterB;const cA=this.m_positions[indexA].c;const aA=this.m_positions[indexA].a;const vA=this.m_velocities[indexA].v;const wA=this.m_velocities[indexA].w;const cB=this.m_positions[indexB].c;const aB=this.m_positions[indexB].a;const vB=this.m_velocities[indexB].v;const wB=this.m_velocities[indexB].w;xfA.q.SetAngle(aA);xfB.q.SetAngle(aB);b2Vec2.SubVV(cA,b2Rot.MulRV(xfA.q,localCenterA,b2Vec2.s_t0),xfA.p);b2Vec2.SubVV(cB,b2Rot.MulRV(xfB.q,localCenterB,b2Vec2.s_t0),xfB.p);worldManifold.Initialize(manifold,xfA,radiusA,xfB,radiusB);vc.normal.Copy(worldManifold.normal);b2Vec2.CrossVOne(vc.normal,vc.tangent);const pointCount=vc.pointCount;for(let j=0;j<pointCount;++j){const vcp=vc.points[j];b2Vec2.SubVV(worldManifold.points[j],cA,vcp.rA);b2Vec2.SubVV(worldManifold.points[j],cB,vcp.rB);const rnA=b2Vec2.CrossVV(vcp.rA,vc.normal);const rnB=b2Vec2.CrossVV(vcp.rB,vc.normal);const kNormal=mA+mB+iA*rnA*rnA+iB*rnB*rnB;vcp.normalMass=kNormal>0?1/kNormal:0;const tangent=vc.tangent;const rtA=b2Vec2.CrossVV(vcp.rA,tangent);const rtB=b2Vec2.CrossVV(vcp.rB,tangent);const kTangent=mA+mB+iA*rtA*rtA+iB*rtB*rtB;vcp.tangentMass=kTangent>0?1/kTangent:0;vcp.velocityBias=0;const vRel=b2Vec2.DotVV(vc.normal,b2Vec2.SubVV(b2Vec2.AddVCrossSV(vB,wB,vcp.rB,b2Vec2.s_t0),b2Vec2.AddVCrossSV(vA,wA,vcp.rA,b2Vec2.s_t1),b2Vec2.s_t0));if(vRel<-b2_velocityThreshold){vcp.velocityBias+=-vc.restitution*vRel;}}if(vc.pointCount===2&&g_blockSolve){const vcp1=vc.points[0];const vcp2=vc.points[1];const rn1A=b2Vec2.CrossVV(vcp1.rA,vc.normal);const rn1B=b2Vec2.CrossVV(vcp1.rB,vc.normal);const rn2A=b2Vec2.CrossVV(vcp2.rA,vc.normal);const rn2B=b2Vec2.CrossVV(vcp2.rB,vc.normal);const k11=mA+mB+iA*rn1A*rn1A+iB*rn1B*rn1B;const k22=mA+mB+iA*rn2A*rn2A+iB*rn2B*rn2B;const k12=mA+mB+iA*rn1A*rn2A+iB*rn1B*rn2B;if(k11*k11<k_maxConditionNumber*(k11*k22-k12*k12)){vc.K.ex.Set(k11,k12);vc.K.ey.Set(k12,k22);vc.K.GetInverse(vc.normalMass);}else {vc.pointCount=1;}}}}WarmStart(){const P=b2ContactSolver.WarmStart_s_P;for(let i=0;i<this.m_count;++i){const vc=this.m_velocityConstraints[i];const indexA=vc.indexA;const indexB=vc.indexB;const mA=vc.invMassA;const iA=vc.invIA;const mB=vc.invMassB;const iB=vc.invIB;const pointCount=vc.pointCount;const vA=this.m_velocities[indexA].v;let wA=this.m_velocities[indexA].w;const vB=this.m_velocities[indexB].v;let wB=this.m_velocities[indexB].w;const normal=vc.normal;const tangent=vc.tangent;for(let j=0;j<pointCount;++j){const vcp=vc.points[j];b2Vec2.AddVV(b2Vec2.MulSV(vcp.normalImpulse,normal,b2Vec2.s_t0),b2Vec2.MulSV(vcp.tangentImpulse,tangent,b2Vec2.s_t1),P);wA-=iA*b2Vec2.CrossVV(vcp.rA,P);vA.SelfMulSub(mA,P);wB+=iB*b2Vec2.CrossVV(vcp.rB,P);vB.SelfMulAdd(mB,P);}this.m_velocities[indexA].w=wA;this.m_velocities[indexB].w=wB;}}SolveVelocityConstraints(){const dv=b2ContactSolver.SolveVelocityConstraints_s_dv;const dv1=b2ContactSolver.SolveVelocityConstraints_s_dv1;const dv2=b2ContactSolver.SolveVelocityConstraints_s_dv2;const P=b2ContactSolver.SolveVelocityConstraints_s_P;const a=b2ContactSolver.SolveVelocityConstraints_s_a;const b=b2ContactSolver.SolveVelocityConstraints_s_b;const x=b2ContactSolver.SolveVelocityConstraints_s_x;const d=b2ContactSolver.SolveVelocityConstraints_s_d;const P1=b2ContactSolver.SolveVelocityConstraints_s_P1;const P2=b2ContactSolver.SolveVelocityConstraints_s_P2;const P1P2=b2ContactSolver.SolveVelocityConstraints_s_P1P2;for(let i=0;i<this.m_count;++i){const vc=this.m_velocityConstraints[i];const indexA=vc.indexA;const indexB=vc.indexB;const mA=vc.invMassA;const iA=vc.invIA;const mB=vc.invMassB;const iB=vc.invIB;const pointCount=vc.pointCount;const vA=this.m_velocities[indexA].v;let wA=this.m_velocities[indexA].w;const vB=this.m_velocities[indexB].v;let wB=this.m_velocities[indexB].w;const normal=vc.normal;const tangent=vc.tangent;const friction=vc.friction;for(let j=0;j<pointCount;++j){const vcp=vc.points[j];b2Vec2.SubVV(b2Vec2.AddVCrossSV(vB,wB,vcp.rB,b2Vec2.s_t0),b2Vec2.AddVCrossSV(vA,wA,vcp.rA,b2Vec2.s_t1),dv);const vt=b2Vec2.DotVV(dv,tangent)-vc.tangentSpeed;let lambda=vcp.tangentMass*-vt;const maxFriction=friction*vcp.normalImpulse;const newImpulse=b2Clamp(vcp.tangentImpulse+lambda,-maxFriction,maxFriction);lambda=newImpulse-vcp.tangentImpulse;vcp.tangentImpulse=newImpulse;b2Vec2.MulSV(lambda,tangent,P);vA.SelfMulSub(mA,P);wA-=iA*b2Vec2.CrossVV(vcp.rA,P);vB.SelfMulAdd(mB,P);wB+=iB*b2Vec2.CrossVV(vcp.rB,P);}if(vc.pointCount===1||g_blockSolve===false){for(let j=0;j<pointCount;++j){const vcp=vc.points[j];b2Vec2.SubVV(b2Vec2.AddVCrossSV(vB,wB,vcp.rB,b2Vec2.s_t0),b2Vec2.AddVCrossSV(vA,wA,vcp.rA,b2Vec2.s_t1),dv);const vn=b2Vec2.DotVV(dv,normal);let lambda=-vcp.normalMass*(vn-vcp.velocityBias);const newImpulse=b2Max(vcp.normalImpulse+lambda,0);lambda=newImpulse-vcp.normalImpulse;vcp.normalImpulse=newImpulse;b2Vec2.MulSV(lambda,normal,P);vA.SelfMulSub(mA,P);wA-=iA*b2Vec2.CrossVV(vcp.rA,P);vB.SelfMulAdd(mB,P);wB+=iB*b2Vec2.CrossVV(vcp.rB,P);}}else {const cp1=vc.points[0];const cp2=vc.points[1];a.Set(cp1.normalImpulse,cp2.normalImpulse);b2Vec2.SubVV(b2Vec2.AddVCrossSV(vB,wB,cp1.rB,b2Vec2.s_t0),b2Vec2.AddVCrossSV(vA,wA,cp1.rA,b2Vec2.s_t1),dv1);b2Vec2.SubVV(b2Vec2.AddVCrossSV(vB,wB,cp2.rB,b2Vec2.s_t0),b2Vec2.AddVCrossSV(vA,wA,cp2.rA,b2Vec2.s_t1),dv2);let vn1=b2Vec2.DotVV(dv1,normal);let vn2=b2Vec2.DotVV(dv2,normal);b.x=vn1-cp1.velocityBias;b.y=vn2-cp2.velocityBias;b.SelfSub(b2Mat22.MulMV(vc.K,a,b2Vec2.s_t0));for(;;){b2Mat22.MulMV(vc.normalMass,b,x).SelfNeg();if(x.x>=0&&x.y>=0){b2Vec2.SubVV(x,a,d);b2Vec2.MulSV(d.x,normal,P1);b2Vec2.MulSV(d.y,normal,P2);b2Vec2.AddVV(P1,P2,P1P2);vA.SelfMulSub(mA,P1P2);wA-=iA*(b2Vec2.CrossVV(cp1.rA,P1)+b2Vec2.CrossVV(cp2.rA,P2));vB.SelfMulAdd(mB,P1P2);wB+=iB*(b2Vec2.CrossVV(cp1.rB,P1)+b2Vec2.CrossVV(cp2.rB,P2));cp1.normalImpulse=x.x;cp2.normalImpulse=x.y;break;}x.x=-cp1.normalMass*b.x;x.y=0;vn1=0;vn2=vc.K.ex.y*x.x+b.y;if(x.x>=0&&vn2>=0){b2Vec2.SubVV(x,a,d);b2Vec2.MulSV(d.x,normal,P1);b2Vec2.MulSV(d.y,normal,P2);b2Vec2.AddVV(P1,P2,P1P2);vA.SelfMulSub(mA,P1P2);wA-=iA*(b2Vec2.CrossVV(cp1.rA,P1)+b2Vec2.CrossVV(cp2.rA,P2));vB.SelfMulAdd(mB,P1P2);wB+=iB*(b2Vec2.CrossVV(cp1.rB,P1)+b2Vec2.CrossVV(cp2.rB,P2));cp1.normalImpulse=x.x;cp2.normalImpulse=x.y;break;}x.x=0;x.y=-cp2.normalMass*b.y;vn1=vc.K.ey.x*x.y+b.x;vn2=0;if(x.y>=0&&vn1>=0){b2Vec2.SubVV(x,a,d);b2Vec2.MulSV(d.x,normal,P1);b2Vec2.MulSV(d.y,normal,P2);b2Vec2.AddVV(P1,P2,P1P2);vA.SelfMulSub(mA,P1P2);wA-=iA*(b2Vec2.CrossVV(cp1.rA,P1)+b2Vec2.CrossVV(cp2.rA,P2));vB.SelfMulAdd(mB,P1P2);wB+=iB*(b2Vec2.CrossVV(cp1.rB,P1)+b2Vec2.CrossVV(cp2.rB,P2));cp1.normalImpulse=x.x;cp2.normalImpulse=x.y;break;}x.x=0;x.y=0;vn1=b.x;vn2=b.y;if(vn1>=0&&vn2>=0){b2Vec2.SubVV(x,a,d);b2Vec2.MulSV(d.x,normal,P1);b2Vec2.MulSV(d.y,normal,P2);b2Vec2.AddVV(P1,P2,P1P2);vA.SelfMulSub(mA,P1P2);wA-=iA*(b2Vec2.CrossVV(cp1.rA,P1)+b2Vec2.CrossVV(cp2.rA,P2));vB.SelfMulAdd(mB,P1P2);wB+=iB*(b2Vec2.CrossVV(cp1.rB,P1)+b2Vec2.CrossVV(cp2.rB,P2));cp1.normalImpulse=x.x;cp2.normalImpulse=x.y;break;}break;}}this.m_velocities[indexA].w=wA;this.m_velocities[indexB].w=wB;}}StoreImpulses(){for(let i=0;i<this.m_count;++i){const vc=this.m_velocityConstraints[i];const manifold=this.m_contacts[vc.contactIndex].GetManifold();for(let j=0;j<vc.pointCount;++j){manifold.points[j].normalImpulse=vc.points[j].normalImpulse;manifold.points[j].tangentImpulse=vc.points[j].tangentImpulse;}}}SolvePositionConstraints(){const xfA=b2ContactSolver.SolvePositionConstraints_s_xfA;const xfB=b2ContactSolver.SolvePositionConstraints_s_xfB;const psm=b2ContactSolver.SolvePositionConstraints_s_psm;const rA=b2ContactSolver.SolvePositionConstraints_s_rA;const rB=b2ContactSolver.SolvePositionConstraints_s_rB;const P=b2ContactSolver.SolvePositionConstraints_s_P;let minSeparation=0;for(let i=0;i<this.m_count;++i){const pc=this.m_positionConstraints[i];const indexA=pc.indexA;const indexB=pc.indexB;const localCenterA=pc.localCenterA;const mA=pc.invMassA;const iA=pc.invIA;const localCenterB=pc.localCenterB;const mB=pc.invMassB;const iB=pc.invIB;const pointCount=pc.pointCount;const cA=this.m_positions[indexA].c;let aA=this.m_positions[indexA].a;const cB=this.m_positions[indexB].c;let aB=this.m_positions[indexB].a;for(let j=0;j<pointCount;++j){xfA.q.SetAngle(aA);xfB.q.SetAngle(aB);b2Vec2.SubVV(cA,b2Rot.MulRV(xfA.q,localCenterA,b2Vec2.s_t0),xfA.p);b2Vec2.SubVV(cB,b2Rot.MulRV(xfB.q,localCenterB,b2Vec2.s_t0),xfB.p);psm.Initialize(pc,xfA,xfB,j);const normal=psm.normal;const point=psm.point;const separation=psm.separation;b2Vec2.SubVV(point,cA,rA);b2Vec2.SubVV(point,cB,rB);minSeparation=b2Min(minSeparation,separation);const C=b2Clamp(b2_baumgarte*(separation+b2_linearSlop),-b2_maxLinearCorrection,0);const rnA=b2Vec2.CrossVV(rA,normal);const rnB=b2Vec2.CrossVV(rB,normal);const K=mA+mB+iA*rnA*rnA+iB*rnB*rnB;const impulse=K>0?-C/K:0;b2Vec2.MulSV(impulse,normal,P);cA.SelfMulSub(mA,P);aA-=iA*b2Vec2.CrossVV(rA,P);cB.SelfMulAdd(mB,P);aB+=iB*b2Vec2.CrossVV(rB,P);}this.m_positions[indexA].a=aA;this.m_positions[indexB].a=aB;}return minSeparation>-3*b2_linearSlop;}SolveTOIPositionConstraints(toiIndexA,toiIndexB){const xfA=b2ContactSolver.SolveTOIPositionConstraints_s_xfA;const xfB=b2ContactSolver.SolveTOIPositionConstraints_s_xfB;const psm=b2ContactSolver.SolveTOIPositionConstraints_s_psm;const rA=b2ContactSolver.SolveTOIPositionConstraints_s_rA;const rB=b2ContactSolver.SolveTOIPositionConstraints_s_rB;const P=b2ContactSolver.SolveTOIPositionConstraints_s_P;let minSeparation=0;for(let i=0;i<this.m_count;++i){const pc=this.m_positionConstraints[i];const indexA=pc.indexA;const indexB=pc.indexB;const localCenterA=pc.localCenterA;const localCenterB=pc.localCenterB;const pointCount=pc.pointCount;let mA=0;let iA=0;if(indexA===toiIndexA||indexA===toiIndexB){mA=pc.invMassA;iA=pc.invIA;}let mB=0;let iB=0;if(indexB===toiIndexA||indexB===toiIndexB){mB=pc.invMassB;iB=pc.invIB;}const cA=this.m_positions[indexA].c;let aA=this.m_positions[indexA].a;const cB=this.m_positions[indexB].c;let aB=this.m_positions[indexB].a;for(let j=0;j<pointCount;++j){xfA.q.SetAngle(aA);xfB.q.SetAngle(aB);b2Vec2.SubVV(cA,b2Rot.MulRV(xfA.q,localCenterA,b2Vec2.s_t0),xfA.p);b2Vec2.SubVV(cB,b2Rot.MulRV(xfB.q,localCenterB,b2Vec2.s_t0),xfB.p);psm.Initialize(pc,xfA,xfB,j);const normal=psm.normal;const point=psm.point;const separation=psm.separation;b2Vec2.SubVV(point,cA,rA);b2Vec2.SubVV(point,cB,rB);minSeparation=b2Min(minSeparation,separation);const C=b2Clamp(b2_toiBaumgarte*(separation+b2_linearSlop),-b2_maxLinearCorrection,0);const rnA=b2Vec2.CrossVV(rA,normal);const rnB=b2Vec2.CrossVV(rB,normal);const K=mA+mB+iA*rnA*rnA+iB*rnB*rnB;const impulse=K>0?-C/K:0;b2Vec2.MulSV(impulse,normal,P);cA.SelfMulSub(mA,P);aA-=iA*b2Vec2.CrossVV(rA,P);cB.SelfMulAdd(mB,P);aB+=iB*b2Vec2.CrossVV(rB,P);}this.m_positions[indexA].a=aA;this.m_positions[indexB].a=aB;}return minSeparation>=-1.5*b2_linearSlop;}}b2ContactSolver.InitializeVelocityConstraints_s_xfA=new b2Transform();b2ContactSolver.InitializeVelocityConstraints_s_xfB=new b2Transform();b2ContactSolver.InitializeVelocityConstraints_s_worldManifold=new b2WorldManifold();b2ContactSolver.WarmStart_s_P=new b2Vec2();b2ContactSolver.SolveVelocityConstraints_s_dv=new b2Vec2();b2ContactSolver.SolveVelocityConstraints_s_dv1=new b2Vec2();b2ContactSolver.SolveVelocityConstraints_s_dv2=new b2Vec2();b2ContactSolver.SolveVelocityConstraints_s_P=new b2Vec2();b2ContactSolver.SolveVelocityConstraints_s_a=new b2Vec2();b2ContactSolver.SolveVelocityConstraints_s_b=new b2Vec2();b2ContactSolver.SolveVelocityConstraints_s_x=new b2Vec2();b2ContactSolver.SolveVelocityConstraints_s_d=new b2Vec2();b2ContactSolver.SolveVelocityConstraints_s_P1=new b2Vec2();b2ContactSolver.SolveVelocityConstraints_s_P2=new b2Vec2();b2ContactSolver.SolveVelocityConstraints_s_P1P2=new b2Vec2();b2ContactSolver.SolvePositionConstraints_s_xfA=new b2Transform();b2ContactSolver.SolvePositionConstraints_s_xfB=new b2Transform();b2ContactSolver.SolvePositionConstraints_s_psm=new b2PositionSolverManifold();b2ContactSolver.SolvePositionConstraints_s_rA=new b2Vec2();b2ContactSolver.SolvePositionConstraints_s_rB=new b2Vec2();b2ContactSolver.SolvePositionConstraints_s_P=new b2Vec2();b2ContactSolver.SolveTOIPositionConstraints_s_xfA=new b2Transform();b2ContactSolver.SolveTOIPositionConstraints_s_xfB=new b2Transform();b2ContactSolver.SolveTOIPositionConstraints_s_psm=new b2PositionSolverManifold();b2ContactSolver.SolveTOIPositionConstraints_s_rA=new b2Vec2();b2ContactSolver.SolveTOIPositionConstraints_s_rB=new b2Vec2();b2ContactSolver.SolveTOIPositionConstraints_s_P=new b2Vec2();class b2Island{constructor(){this.m_bodies=[];this.m_contacts=[];this.m_joints=[];this.m_positions=b2Position.MakeArray(1024);this.m_velocities=b2Velocity.MakeArray(1024);this.m_bodyCount=0;this.m_jointCount=0;this.m_contactCount=0;this.m_bodyCapacity=0;this.m_contactCapacity=0;this.m_jointCapacity=0;}Initialize(bodyCapacity,contactCapacity,jointCapacity,listener){this.m_bodyCapacity=bodyCapacity;this.m_contactCapacity=contactCapacity;this.m_jointCapacity=jointCapacity;this.m_bodyCount=0;this.m_contactCount=0;this.m_jointCount=0;this.m_listener=listener;if(this.m_positions.length<bodyCapacity){const new_length=b2Max(this.m_positions.length*2,bodyCapacity);while(this.m_positions.length<new_length){this.m_positions[this.m_positions.length]=new b2Position();}}if(this.m_velocities.length<bodyCapacity){const new_length=b2Max(this.m_velocities.length*2,bodyCapacity);while(this.m_velocities.length<new_length){this.m_velocities[this.m_velocities.length]=new b2Velocity();}}}Clear(){this.m_bodyCount=0;this.m_contactCount=0;this.m_jointCount=0;}AddBody(body){body.m_islandIndex=this.m_bodyCount;this.m_bodies[this.m_bodyCount++]=body;}AddContact(contact){this.m_contacts[this.m_contactCount++]=contact;}AddJoint(joint){this.m_joints[this.m_jointCount++]=joint;}Solve(profile,step,gravity,allowSleep){const timer=b2Island.s_timer.Reset();const h=step.dt;for(let i=0;i<this.m_bodyCount;++i){const b=this.m_bodies[i];this.m_positions[i].c.Copy(b.m_sweep.c);const a=b.m_sweep.a;const v=this.m_velocities[i].v.Copy(b.m_linearVelocity);let w=b.m_angularVelocity;b.m_sweep.c0.Copy(b.m_sweep.c);b.m_sweep.a0=b.m_sweep.a;if(b.m_type===exports.b2BodyType.b2_dynamicBody){v.x+=h*(b.m_gravityScale*gravity.x+b.m_invMass*b.m_force.x);v.y+=h*(b.m_gravityScale*gravity.y+b.m_invMass*b.m_force.y);w+=h*b.m_invI*b.m_torque;v.SelfMul(1.0/(1.0+h*b.m_linearDamping));w*=1.0/(1.0+h*b.m_angularDamping);}this.m_positions[i].a=a;this.m_velocities[i].w=w;}timer.Reset();const solverData=b2Island.s_solverData;solverData.step.Copy(step);solverData.positions=this.m_positions;solverData.velocities=this.m_velocities;const contactSolverDef=b2Island.s_contactSolverDef;contactSolverDef.step.Copy(step);contactSolverDef.contacts=this.m_contacts;contactSolverDef.count=this.m_contactCount;contactSolverDef.positions=this.m_positions;contactSolverDef.velocities=this.m_velocities;const contactSolver=b2Island.s_contactSolver.Initialize(contactSolverDef);contactSolver.InitializeVelocityConstraints();if(step.warmStarting){contactSolver.WarmStart();}for(let i=0;i<this.m_jointCount;++i){this.m_joints[i].InitVelocityConstraints(solverData);}profile.solveInit=timer.GetMilliseconds();timer.Reset();for(let i=0;i<step.velocityIterations;++i){for(let j=0;j<this.m_jointCount;++j){this.m_joints[j].SolveVelocityConstraints(solverData);}contactSolver.SolveVelocityConstraints();}contactSolver.StoreImpulses();profile.solveVelocity=timer.GetMilliseconds();for(let i=0;i<this.m_bodyCount;++i){const c=this.m_positions[i].c;let a=this.m_positions[i].a;const v=this.m_velocities[i].v;let w=this.m_velocities[i].w;const translation=b2Vec2.MulSV(h,v,b2Island.s_translation);if(b2Vec2.DotVV(translation,translation)>b2_maxTranslationSquared){const ratio=b2_maxTranslation/translation.Length();v.SelfMul(ratio);}const rotation=h*w;if(rotation*rotation>b2_maxRotationSquared){const ratio=b2_maxRotation/b2Abs(rotation);w*=ratio;}c.x+=h*v.x;c.y+=h*v.y;a+=h*w;this.m_positions[i].a=a;this.m_velocities[i].w=w;}timer.Reset();let positionSolved=false;for(let i=0;i<step.positionIterations;++i){const contactsOkay=contactSolver.SolvePositionConstraints();let jointsOkay=true;for(let j=0;j<this.m_jointCount;++j){const jointOkay=this.m_joints[j].SolvePositionConstraints(solverData);jointsOkay=jointsOkay&&jointOkay;}if(contactsOkay&&jointsOkay){positionSolved=true;break;}}for(let i=0;i<this.m_bodyCount;++i){const body=this.m_bodies[i];body.m_sweep.c.Copy(this.m_positions[i].c);body.m_sweep.a=this.m_positions[i].a;body.m_linearVelocity.Copy(this.m_velocities[i].v);body.m_angularVelocity=this.m_velocities[i].w;body.SynchronizeTransform();}profile.solvePosition=timer.GetMilliseconds();this.Report(contactSolver.m_velocityConstraints);if(allowSleep){let minSleepTime=b2_maxFloat;const linTolSqr=b2_linearSleepTolerance*b2_linearSleepTolerance;const angTolSqr=b2_angularSleepTolerance*b2_angularSleepTolerance;for(let i=0;i<this.m_bodyCount;++i){const b=this.m_bodies[i];if(b.GetType()===exports.b2BodyType.b2_staticBody){continue;}if(!b.m_autoSleepFlag||b.m_angularVelocity*b.m_angularVelocity>angTolSqr||b2Vec2.DotVV(b.m_linearVelocity,b.m_linearVelocity)>linTolSqr){b.m_sleepTime=0;minSleepTime=0;}else {b.m_sleepTime+=h;minSleepTime=b2Min(minSleepTime,b.m_sleepTime);}}if(minSleepTime>=b2_timeToSleep&&positionSolved){for(let i=0;i<this.m_bodyCount;++i){const b=this.m_bodies[i];b.SetAwake(false);}}}}SolveTOI(subStep,toiIndexA,toiIndexB){for(let i=0;i<this.m_bodyCount;++i){const b=this.m_bodies[i];this.m_positions[i].c.Copy(b.m_sweep.c);this.m_positions[i].a=b.m_sweep.a;this.m_velocities[i].v.Copy(b.m_linearVelocity);this.m_velocities[i].w=b.m_angularVelocity;}const contactSolverDef=b2Island.s_contactSolverDef;contactSolverDef.contacts=this.m_contacts;contactSolverDef.count=this.m_contactCount;contactSolverDef.step.Copy(subStep);contactSolverDef.positions=this.m_positions;contactSolverDef.velocities=this.m_velocities;const contactSolver=b2Island.s_contactSolver.Initialize(contactSolverDef);for(let i=0;i<subStep.positionIterations;++i){const contactsOkay=contactSolver.SolveTOIPositionConstraints(toiIndexA,toiIndexB);if(contactsOkay){break;}}this.m_bodies[toiIndexA].m_sweep.c0.Copy(this.m_positions[toiIndexA].c);this.m_bodies[toiIndexA].m_sweep.a0=this.m_positions[toiIndexA].a;this.m_bodies[toiIndexB].m_sweep.c0.Copy(this.m_positions[toiIndexB].c);this.m_bodies[toiIndexB].m_sweep.a0=this.m_positions[toiIndexB].a;contactSolver.InitializeVelocityConstraints();for(let i=0;i<subStep.velocityIterations;++i){contactSolver.SolveVelocityConstraints();}const h=subStep.dt;for(let i=0;i<this.m_bodyCount;++i){const c=this.m_positions[i].c;let a=this.m_positions[i].a;const v=this.m_velocities[i].v;let w=this.m_velocities[i].w;const translation=b2Vec2.MulSV(h,v,b2Island.s_translation);if(b2Vec2.DotVV(translation,translation)>b2_maxTranslationSquared){const ratio=b2_maxTranslation/translation.Length();v.SelfMul(ratio);}const rotation=h*w;if(rotation*rotation>b2_maxRotationSquared){const ratio=b2_maxRotation/b2Abs(rotation);w*=ratio;}c.SelfMulAdd(h,v);a+=h*w;this.m_positions[i].a=a;this.m_velocities[i].w=w;const body=this.m_bodies[i];body.m_sweep.c.Copy(c);body.m_sweep.a=a;body.m_linearVelocity.Copy(v);body.m_angularVelocity=w;body.SynchronizeTransform();}this.Report(contactSolver.m_velocityConstraints);}Report(constraints){if(this.m_listener===null){return;}for(let i=0;i<this.m_contactCount;++i){const c=this.m_contacts[i];if(!c){continue;}const vc=constraints[i];const impulse=b2Island.s_impulse;impulse.count=vc.pointCount;for(let j=0;j<vc.pointCount;++j){impulse.normalImpulses[j]=vc.points[j].normalImpulse;impulse.tangentImpulses[j]=vc.points[j].tangentImpulse;}this.m_listener.PostSolve(c,impulse);}}}b2Island.s_timer=new b2Timer();b2Island.s_solverData=new b2SolverData();b2Island.s_contactSolverDef=new b2ContactSolverDef();b2Island.s_contactSolver=new b2ContactSolver();b2Island.s_translation=new b2Vec2();b2Island.s_impulse=new b2ContactImpulse();(function(b2ParticleFlag){b2ParticleFlag[b2ParticleFlag["b2_waterParticle"]=0]="b2_waterParticle";b2ParticleFlag[b2ParticleFlag["b2_zombieParticle"]=2]="b2_zombieParticle";b2ParticleFlag[b2ParticleFlag["b2_wallParticle"]=4]="b2_wallParticle";b2ParticleFlag[b2ParticleFlag["b2_springParticle"]=8]="b2_springParticle";b2ParticleFlag[b2ParticleFlag["b2_elasticParticle"]=16]="b2_elasticParticle";b2ParticleFlag[b2ParticleFlag["b2_viscousParticle"]=32]="b2_viscousParticle";b2ParticleFlag[b2ParticleFlag["b2_powderParticle"]=64]="b2_powderParticle";b2ParticleFlag[b2ParticleFlag["b2_tensileParticle"]=128]="b2_tensileParticle";b2ParticleFlag[b2ParticleFlag["b2_colorMixingParticle"]=256]="b2_colorMixingParticle";b2ParticleFlag[b2ParticleFlag["b2_destructionListenerParticle"]=512]="b2_destructionListenerParticle";b2ParticleFlag[b2ParticleFlag["b2_barrierParticle"]=1024]="b2_barrierParticle";b2ParticleFlag[b2ParticleFlag["b2_staticPressureParticle"]=2048]="b2_staticPressureParticle";b2ParticleFlag[b2ParticleFlag["b2_reactiveParticle"]=4096]="b2_reactiveParticle";b2ParticleFlag[b2ParticleFlag["b2_repulsiveParticle"]=8192]="b2_repulsiveParticle";b2ParticleFlag[b2ParticleFlag["b2_fixtureContactListenerParticle"]=16384]="b2_fixtureContactListenerParticle";b2ParticleFlag[b2ParticleFlag["b2_particleContactListenerParticle"]=32768]="b2_particleContactListenerParticle";b2ParticleFlag[b2ParticleFlag["b2_fixtureContactFilterParticle"]=65536]="b2_fixtureContactFilterParticle";b2ParticleFlag[b2ParticleFlag["b2_particleContactFilterParticle"]=131072]="b2_particleContactFilterParticle";})(exports.b2ParticleFlag||(exports.b2ParticleFlag={}));class b2ParticleDef{constructor(){this.flags=0;this.position=new b2Vec2();this.velocity=new b2Vec2();this.color=new b2Color(0,0,0,0);this.lifetime=0.0;this.userData=null;this.group=null;}}function b2CalculateParticleIterations(gravity,radius,timeStep){const B2_MAX_RECOMMENDED_PARTICLE_ITERATIONS=8;const B2_RADIUS_THRESHOLD=0.01;const iterations=Math.ceil(Math.sqrt(gravity/(B2_RADIUS_THRESHOLD*radius))*timeStep);return b2Clamp(iterations,1,B2_MAX_RECOMMENDED_PARTICLE_ITERATIONS);}class b2ParticleHandle{constructor(){this.m_index=b2_invalidParticleIndex;}GetIndex(){return this.m_index;}SetIndex(index){this.m_index=index;}}(function(b2ParticleGroupFlag){b2ParticleGroupFlag[b2ParticleGroupFlag["b2_solidParticleGroup"]=1]="b2_solidParticleGroup";b2ParticleGroupFlag[b2ParticleGroupFlag["b2_rigidParticleGroup"]=2]="b2_rigidParticleGroup";b2ParticleGroupFlag[b2ParticleGroupFlag["b2_particleGroupCanBeEmpty"]=4]="b2_particleGroupCanBeEmpty";b2ParticleGroupFlag[b2ParticleGroupFlag["b2_particleGroupWillBeDestroyed"]=8]="b2_particleGroupWillBeDestroyed";b2ParticleGroupFlag[b2ParticleGroupFlag["b2_particleGroupNeedsUpdateDepth"]=16]="b2_particleGroupNeedsUpdateDepth";b2ParticleGroupFlag[b2ParticleGroupFlag["b2_particleGroupInternalMask"]=24]="b2_particleGroupInternalMask";})(exports.b2ParticleGroupFlag||(exports.b2ParticleGroupFlag={}));class b2ParticleGroupDef{constructor(){this.flags=0;this.groupFlags=0;this.position=new b2Vec2();this.angle=0.0;this.linearVelocity=new b2Vec2();this.angularVelocity=0.0;this.color=new b2Color();this.strength=1.0;this.shapeCount=0;this.stride=0;this.particleCount=0;this.lifetime=0;this.userData=null;this.group=null;}}class b2ParticleGroup{constructor(system){this.m_firstIndex=0;this.m_lastIndex=0;this.m_groupFlags=0;this.m_strength=1.0;this.m_prev=null;this.m_next=null;this.m_timestamp=-1;this.m_mass=0.0;this.m_inertia=0.0;this.m_center=new b2Vec2();this.m_linearVelocity=new b2Vec2();this.m_angularVelocity=0.0;this.m_transform=new b2Transform();this.m_userData=null;this.m_system=system;}GetNext(){return this.m_next;}GetParticleSystem(){return this.m_system;}GetParticleCount(){return this.m_lastIndex-this.m_firstIndex;}GetBufferIndex(){return this.m_firstIndex;}ContainsParticle(index){return this.m_firstIndex<=index&&index<this.m_lastIndex;}GetAllParticleFlags(){if(!this.m_system.m_flagsBuffer.data){throw new Error();}let flags=0;for(let i=this.m_firstIndex;i<this.m_lastIndex;i++){flags|=this.m_system.m_flagsBuffer.data[i];}return flags;}GetGroupFlags(){return this.m_groupFlags;}SetGroupFlags(flags){flags|=this.m_groupFlags&exports.b2ParticleGroupFlag.b2_particleGroupInternalMask;this.m_system.SetGroupFlags(this,flags);}GetMass(){this.UpdateStatistics();return this.m_mass;}GetInertia(){this.UpdateStatistics();return this.m_inertia;}GetCenter(){this.UpdateStatistics();return this.m_center;}GetLinearVelocity(){this.UpdateStatistics();return this.m_linearVelocity;}GetAngularVelocity(){this.UpdateStatistics();return this.m_angularVelocity;}GetTransform(){return this.m_transform;}GetPosition(){return this.m_transform.p;}GetAngle(){return this.m_transform.q.GetAngle();}GetLinearVelocityFromWorldPoint(worldPoint,out){const s_t0=b2ParticleGroup.GetLinearVelocityFromWorldPoint_s_t0;this.UpdateStatistics();return b2Vec2.AddVCrossSV(this.m_linearVelocity,this.m_angularVelocity,b2Vec2.SubVV(worldPoint,this.m_center,s_t0),out);}GetUserData(){return this.m_userData;}SetUserData(data){this.m_userData=data;}ApplyForce(force){this.m_system.ApplyForce(this.m_firstIndex,this.m_lastIndex,force);}ApplyLinearImpulse(impulse){this.m_system.ApplyLinearImpulse(this.m_firstIndex,this.m_lastIndex,impulse);}DestroyParticles(callDestructionListener){if(this.m_system.m_world.IsLocked()){throw new Error();}for(let i=this.m_firstIndex;i<this.m_lastIndex;i++){this.m_system.DestroyParticle(i,callDestructionListener);}}UpdateStatistics(){if(!this.m_system.m_positionBuffer.data){throw new Error();}if(!this.m_system.m_velocityBuffer.data){throw new Error();}const p=new b2Vec2();const v=new b2Vec2();if(this.m_timestamp!==this.m_system.m_timestamp){const m=this.m_system.GetParticleMass();this.m_mass=m*(this.m_lastIndex-this.m_firstIndex);this.m_center.SetZero();this.m_linearVelocity.SetZero();for(let i=this.m_firstIndex;i<this.m_lastIndex;i++){this.m_center.SelfMulAdd(m,this.m_system.m_positionBuffer.data[i]);this.m_linearVelocity.SelfMulAdd(m,this.m_system.m_velocityBuffer.data[i]);}if(this.m_mass>0){const inv_mass=1/this.m_mass;this.m_center.SelfMul(inv_mass);this.m_linearVelocity.SelfMul(inv_mass);}this.m_inertia=0;this.m_angularVelocity=0;for(let i=this.m_firstIndex;i<this.m_lastIndex;i++){b2Vec2.SubVV(this.m_system.m_positionBuffer.data[i],this.m_center,p);b2Vec2.SubVV(this.m_system.m_velocityBuffer.data[i],this.m_linearVelocity,v);this.m_inertia+=m*b2Vec2.DotVV(p,p);this.m_angularVelocity+=m*b2Vec2.CrossVV(p,v);}if(this.m_inertia>0){this.m_angularVelocity*=1/this.m_inertia;}this.m_timestamp=this.m_system.m_timestamp;}}}b2ParticleGroup.GetLinearVelocityFromWorldPoint_s_t0=new b2Vec2();class b2StackQueue{constructor(capacity){this.m_buffer=[];this.m_front=0;this.m_back=0;this.m_buffer.fill(null,0,capacity);}get m_capacity(){return this.m_buffer.length;}Push(item){if(this.m_back>=this.m_capacity){for(let i=this.m_front;i<this.m_back;i++){this.m_buffer[i-this.m_front]=this.m_buffer[i];}this.m_back-=this.m_front;this.m_front=0;}this.m_buffer[this.m_back]=item;this.m_back++;}Pop(){this.m_buffer[this.m_front]=null;this.m_front++;}Empty(){return this.m_front===this.m_back;}Front(){const item=this.m_buffer[this.m_front];if(!item){throw new Error();}return item;}}class b2VoronoiDiagram{constructor(generatorCapacity){this.m_generatorCapacity=0;this.m_generatorCount=0;this.m_countX=0;this.m_countY=0;this.m_diagram=[];this.m_generatorBuffer=b2MakeArray(generatorCapacity,index=>new b2VoronoiDiagram_Generator());this.m_generatorCapacity=generatorCapacity;}AddGenerator(center,tag,necessary){const g=this.m_generatorBuffer[this.m_generatorCount++];g.center.Copy(center);g.tag=tag;g.necessary=necessary;}Generate(radius,margin){const inverseRadius=1/radius;const lower=new b2Vec2(+b2_maxFloat,+b2_maxFloat);const upper=new b2Vec2(-b2_maxFloat,-b2_maxFloat);let necessary_count=0;for(let k=0;k<this.m_generatorCount;k++){const g=this.m_generatorBuffer[k];if(g.necessary){b2Vec2.MinV(lower,g.center,lower);b2Vec2.MaxV(upper,g.center,upper);++necessary_count;}}if(necessary_count===0){this.m_countX=0;this.m_countY=0;return;}lower.x-=margin;lower.y-=margin;upper.x+=margin;upper.y+=margin;this.m_countX=1+Math.floor(inverseRadius*(upper.x-lower.x));this.m_countY=1+Math.floor(inverseRadius*(upper.y-lower.y));this.m_diagram=[];const queue=new b2StackQueue(4*this.m_countX*this.m_countY);for(let k=0;k<this.m_generatorCount;k++){const g=this.m_generatorBuffer[k];g.center.SelfSub(lower).SelfMul(inverseRadius);const x=Math.floor(g.center.x);const y=Math.floor(g.center.y);if(x>=0&&y>=0&&x<this.m_countX&&y<this.m_countY){queue.Push(new b2VoronoiDiagram_Task(x,y,x+y*this.m_countX,g));}}while(!queue.Empty()){const task=queue.Front();const x=task.m_x;const y=task.m_y;const i=task.m_i;const g=task.m_generator;queue.Pop();if(!this.m_diagram[i]){this.m_diagram[i]=g;if(x>0){queue.Push(new b2VoronoiDiagram_Task(x-1,y,i-1,g));}if(y>0){queue.Push(new b2VoronoiDiagram_Task(x,y-1,i-this.m_countX,g));}if(x<this.m_countX-1){queue.Push(new b2VoronoiDiagram_Task(x+1,y,i+1,g));}if(y<this.m_countY-1){queue.Push(new b2VoronoiDiagram_Task(x,y+1,i+this.m_countX,g));}}}for(let y=0;y<this.m_countY;y++){for(let x=0;x<this.m_countX-1;x++){const i=x+y*this.m_countX;const a=this.m_diagram[i];const b=this.m_diagram[i+1];if(a!==b){queue.Push(new b2VoronoiDiagram_Task(x,y,i,b));queue.Push(new b2VoronoiDiagram_Task(x+1,y,i+1,a));}}}for(let y=0;y<this.m_countY-1;y++){for(let x=0;x<this.m_countX;x++){const i=x+y*this.m_countX;const a=this.m_diagram[i];const b=this.m_diagram[i+this.m_countX];if(a!==b){queue.Push(new b2VoronoiDiagram_Task(x,y,i,b));queue.Push(new b2VoronoiDiagram_Task(x,y+1,i+this.m_countX,a));}}}while(!queue.Empty()){const task=queue.Front();const x=task.m_x;const y=task.m_y;const i=task.m_i;const k=task.m_generator;queue.Pop();const a=this.m_diagram[i];const b=k;if(a!==b){const ax=a.center.x-x;const ay=a.center.y-y;const bx=b.center.x-x;const by=b.center.y-y;const a2=ax*ax+ay*ay;const b2=bx*bx+by*by;if(a2>b2){this.m_diagram[i]=b;if(x>0){queue.Push(new b2VoronoiDiagram_Task(x-1,y,i-1,b));}if(y>0){queue.Push(new b2VoronoiDiagram_Task(x,y-1,i-this.m_countX,b));}if(x<this.m_countX-1){queue.Push(new b2VoronoiDiagram_Task(x+1,y,i+1,b));}if(y<this.m_countY-1){queue.Push(new b2VoronoiDiagram_Task(x,y+1,i+this.m_countX,b));}}}}}GetNodes(callback){for(let y=0;y<this.m_countY-1;y++){for(let x=0;x<this.m_countX-1;x++){const i=x+y*this.m_countX;const a=this.m_diagram[i];const b=this.m_diagram[i+1];const c=this.m_diagram[i+this.m_countX];const d=this.m_diagram[i+1+this.m_countX];if(b!==c){if(a!==b&&a!==c&&(a.necessary||b.necessary||c.necessary)){callback(a.tag,b.tag,c.tag);}if(d!==b&&d!==c&&(a.necessary||b.necessary||c.necessary)){callback(b.tag,d.tag,c.tag);}}}}}}class b2VoronoiDiagram_Generator{constructor(){this.center=new b2Vec2();this.tag=0;this.necessary=false;}}class b2VoronoiDiagram_Task{constructor(x,y,i,g){this.m_x=x;this.m_y=y;this.m_i=i;this.m_generator=g;}}function std_iter_swap$1(array,a,b){const tmp=array[a];array[a]=array[b];array[b]=tmp;}function default_compare$1(a,b){return a<b;}function std_sort$1(array,first=0,len=array.length-first,cmp=default_compare$1){let left=first;const stack=[];let pos=0;for(;;){for(;left+1<len;len++){const pivot=array[left+Math.floor(Math.random()*(len-left))];stack[pos++]=len;for(let right=left-1;;){while(cmp(array[++right],pivot)){}while(cmp(pivot,array[--len])){}if(right>=len){break;}std_iter_swap$1(array,right,len);}}if(pos===0){break;}left=len;len=stack[--pos];}return array;}function std_stable_sort(array,first=0,len=array.length-first,cmp=default_compare$1){return std_sort$1(array,first,len,cmp);}function std_remove_if(array,predicate,length=array.length){let l=0;for(let c=0;c<length;++c){if(predicate(array[c])){continue;}if(c===l){++l;continue;}std_iter_swap$1(array,l++,c);}return l;}function std_lower_bound(array,first,last,val,cmp){let count=last-first;while(count>0){const step=Math.floor(count/2);let it=first+step;if(cmp(array[it],val)){first=++it;count-=step+1;}else {count=step;}}return first;}function std_upper_bound(array,first,last,val,cmp){let count=last-first;while(count>0){const step=Math.floor(count/2);let it=first+step;if(!cmp(val,array[it])){first=++it;count-=step+1;}else {count=step;}}return first;}function std_rotate(array,first,n_first,last){let next=n_first;while(first!==next){std_iter_swap$1(array,first++,next++);if(next===last){next=n_first;}else if(first===n_first){n_first=next;}}}function std_unique(array,first,last,cmp){if(first===last){return last;}let result=first;while(++first!==last){if(!cmp(array[result],array[first])){std_iter_swap$1(array,++result,first);}}return ++result;}class b2GrowableBuffer{constructor(allocator){this.data=[];this.count=0;this.capacity=0;this.allocator=allocator;}Append(){if(this.count>=this.capacity){this.Grow();}return this.count++;}Reserve(newCapacity){if(this.capacity>=newCapacity){return;}for(let i=this.capacity;i<newCapacity;++i){this.data[i]=this.allocator();}this.capacity=newCapacity;}Grow(){const newCapacity=this.capacity?2*this.capacity:b2_minParticleSystemBufferCapacity;this.Reserve(newCapacity);}Free(){if(this.data.length===0){return;}this.data=[];this.capacity=0;this.count=0;}Shorten(newEnd){}Data(){return this.data;}GetCount(){return this.count;}SetCount(newCount){this.count=newCount;}GetCapacity(){return this.capacity;}RemoveIf(pred){this.count=std_remove_if(this.data,pred,this.count);}Unique(pred){this.count=std_unique(this.data,0,this.count,pred);}}class b2FixtureParticleQueryCallback extends b2QueryCallback{constructor(system){super();this.m_system=system;}ShouldQueryParticleSystem(system){return false;}ReportFixture(fixture){if(fixture.IsSensor()){return true;}const shape=fixture.GetShape();const childCount=shape.GetChildCount();for(let childIndex=0;childIndex<childCount;childIndex++){const aabb=fixture.GetAABB(childIndex);const enumerator=this.m_system.GetInsideBoundsEnumerator(aabb);let index;while((index=enumerator.GetNext())>=0){this.ReportFixtureAndParticle(fixture,childIndex,index);}}return true;}ReportParticle(system,index){return false;}ReportFixtureAndParticle(fixture,childIndex,index){}}class b2ParticleContact{constructor(){this.indexA=0;this.indexB=0;this.weight=0;this.normal=new b2Vec2();this.flags=0;}SetIndices(a,b){this.indexA=a;this.indexB=b;}SetWeight(w){this.weight=w;}SetNormal(n){this.normal.Copy(n);}SetFlags(f){this.flags=f;}GetIndexA(){return this.indexA;}GetIndexB(){return this.indexB;}GetWeight(){return this.weight;}GetNormal(){return this.normal;}GetFlags(){return this.flags;}IsEqual(rhs){return this.indexA===rhs.indexA&&this.indexB===rhs.indexB&&this.flags===rhs.flags&&this.weight===rhs.weight&&this.normal.x===rhs.normal.x&&this.normal.y===rhs.normal.y;}IsNotEqual(rhs){return !this.IsEqual(rhs);}ApproximatelyEqual(rhs){const MAX_WEIGHT_DIFF=0.01;const MAX_NORMAL_DIFF_SQ=0.01*0.01;return this.indexA===rhs.indexA&&this.indexB===rhs.indexB&&this.flags===rhs.flags&&b2Abs(this.weight-rhs.weight)<MAX_WEIGHT_DIFF&&b2Vec2.DistanceSquaredVV(this.normal,rhs.normal)<MAX_NORMAL_DIFF_SQ;}}class b2ParticleBodyContact{constructor(){this.index=0;this.weight=0.0;this.normal=new b2Vec2();this.mass=0.0;}}class b2ParticlePair{constructor(){this.indexA=0;this.indexB=0;this.flags=0;this.strength=0.0;this.distance=0.0;}}class b2ParticleTriad{constructor(){this.indexA=0;this.indexB=0;this.indexC=0;this.flags=0;this.strength=0.0;this.pa=new b2Vec2(0.0,0.0);this.pb=new b2Vec2(0.0,0.0);this.pc=new b2Vec2(0.0,0.0);this.ka=0.0;this.kb=0.0;this.kc=0.0;this.s=0.0;}}class b2ParticleSystemDef{constructor(){this.strictContactCheck=false;this.density=1.0;this.gravityScale=1.0;this.radius=1.0;this.maxCount=0;this.pressureStrength=0.005;this.dampingStrength=1.0;this.elasticStrength=0.25;this.springStrength=0.25;this.viscousStrength=0.25;this.surfaceTensionPressureStrength=0.2;this.surfaceTensionNormalStrength=0.2;this.repulsiveStrength=1.0;this.powderStrength=0.5;this.ejectionStrength=0.5;this.staticPressureStrength=0.2;this.staticPressureRelaxation=0.2;this.staticPressureIterations=8;this.colorMixingStrength=0.5;this.destroyByAge=true;this.lifetimeGranularity=1.0/60.0;}Copy(def){this.strictContactCheck=def.strictContactCheck;this.density=def.density;this.gravityScale=def.gravityScale;this.radius=def.radius;this.maxCount=def.maxCount;this.pressureStrength=def.pressureStrength;this.dampingStrength=def.dampingStrength;this.elasticStrength=def.elasticStrength;this.springStrength=def.springStrength;this.viscousStrength=def.viscousStrength;this.surfaceTensionPressureStrength=def.surfaceTensionPressureStrength;this.surfaceTensionNormalStrength=def.surfaceTensionNormalStrength;this.repulsiveStrength=def.repulsiveStrength;this.powderStrength=def.powderStrength;this.ejectionStrength=def.ejectionStrength;this.staticPressureStrength=def.staticPressureStrength;this.staticPressureRelaxation=def.staticPressureRelaxation;this.staticPressureIterations=def.staticPressureIterations;this.colorMixingStrength=def.colorMixingStrength;this.destroyByAge=def.destroyByAge;this.lifetimeGranularity=def.lifetimeGranularity;return this;}Clone(){return new b2ParticleSystemDef().Copy(this);}}class b2ParticleSystem{constructor(def,world){this.m_paused=false;this.m_timestamp=0;this.m_allParticleFlags=0;this.m_needsUpdateAllParticleFlags=false;this.m_allGroupFlags=0;this.m_needsUpdateAllGroupFlags=false;this.m_hasForce=false;this.m_iterationIndex=0;this.m_inverseDensity=0.0;this.m_particleDiameter=0.0;this.m_inverseDiameter=0.0;this.m_squaredDiameter=0.0;this.m_count=0;this.m_internalAllocatedCapacity=0;this.m_handleIndexBuffer=new b2ParticleSystem_UserOverridableBuffer();this.m_flagsBuffer=new b2ParticleSystem_UserOverridableBuffer();this.m_positionBuffer=new b2ParticleSystem_UserOverridableBuffer();this.m_velocityBuffer=new b2ParticleSystem_UserOverridableBuffer();this.m_forceBuffer=[];this.m_weightBuffer=[];this.m_staticPressureBuffer=[];this.m_accumulationBuffer=[];this.m_accumulation2Buffer=[];this.m_depthBuffer=[];this.m_colorBuffer=new b2ParticleSystem_UserOverridableBuffer();this.m_groupBuffer=[];this.m_userDataBuffer=new b2ParticleSystem_UserOverridableBuffer();this.m_stuckThreshold=0;this.m_lastBodyContactStepBuffer=new b2ParticleSystem_UserOverridableBuffer();this.m_bodyContactCountBuffer=new b2ParticleSystem_UserOverridableBuffer();this.m_consecutiveContactStepsBuffer=new b2ParticleSystem_UserOverridableBuffer();this.m_stuckParticleBuffer=new b2GrowableBuffer(()=>0);this.m_proxyBuffer=new b2GrowableBuffer(()=>new b2ParticleSystem_Proxy());this.m_contactBuffer=new b2GrowableBuffer(()=>new b2ParticleContact());this.m_bodyContactBuffer=new b2GrowableBuffer(()=>new b2ParticleBodyContact());this.m_pairBuffer=new b2GrowableBuffer(()=>new b2ParticlePair());this.m_triadBuffer=new b2GrowableBuffer(()=>new b2ParticleTriad());this.m_expirationTimeBuffer=new b2ParticleSystem_UserOverridableBuffer();this.m_indexByExpirationTimeBuffer=new b2ParticleSystem_UserOverridableBuffer();this.m_timeElapsed=0;this.m_expirationTimeBufferRequiresSorting=false;this.m_groupCount=0;this.m_groupList=null;this.m_def=new b2ParticleSystemDef();this.m_prev=null;this.m_next=null;this.UpdateBodyContacts_callback=null;this.SolveCollision_callback=null;this.SetStrictContactCheck(def.strictContactCheck);this.SetDensity(def.density);this.SetGravityScale(def.gravityScale);this.SetRadius(def.radius);this.SetMaxParticleCount(def.maxCount);this.m_def=def.Clone();this.m_world=world;this.SetDestructionByAge(this.m_def.destroyByAge);}static computeTag(x,y){return (y+b2ParticleSystem.yOffset>>>0<<b2ParticleSystem.yShift)+(b2ParticleSystem.xScale*x+b2ParticleSystem.xOffset>>>0)>>>0;}static computeRelativeTag(tag,x,y){return tag+(y<<b2ParticleSystem.yShift)+(x<<b2ParticleSystem.xShift)>>>0;}Drop(){while(this.m_groupList){this.DestroyParticleGroup(this.m_groupList);}this.FreeUserOverridableBuffer(this.m_handleIndexBuffer);this.FreeUserOverridableBuffer(this.m_flagsBuffer);this.FreeUserOverridableBuffer(this.m_lastBodyContactStepBuffer);this.FreeUserOverridableBuffer(this.m_bodyContactCountBuffer);this.FreeUserOverridableBuffer(this.m_consecutiveContactStepsBuffer);this.FreeUserOverridableBuffer(this.m_positionBuffer);this.FreeUserOverridableBuffer(this.m_velocityBuffer);this.FreeUserOverridableBuffer(this.m_colorBuffer);this.FreeUserOverridableBuffer(this.m_userDataBuffer);this.FreeUserOverridableBuffer(this.m_expirationTimeBuffer);this.FreeUserOverridableBuffer(this.m_indexByExpirationTimeBuffer);this.FreeBuffer(this.m_forceBuffer,this.m_internalAllocatedCapacity);this.FreeBuffer(this.m_weightBuffer,this.m_internalAllocatedCapacity);this.FreeBuffer(this.m_staticPressureBuffer,this.m_internalAllocatedCapacity);this.FreeBuffer(this.m_accumulationBuffer,this.m_internalAllocatedCapacity);this.FreeBuffer(this.m_accumulation2Buffer,this.m_internalAllocatedCapacity);this.FreeBuffer(this.m_depthBuffer,this.m_internalAllocatedCapacity);this.FreeBuffer(this.m_groupBuffer,this.m_internalAllocatedCapacity);}CreateParticle(def){if(this.m_world.IsLocked()){throw new Error();}if(this.m_count>=this.m_internalAllocatedCapacity){const capacity=this.m_count?2*this.m_count:b2_minParticleSystemBufferCapacity;this.ReallocateInternalAllocatedBuffers(capacity);}if(this.m_count>=this.m_internalAllocatedCapacity){if(this.m_def.destroyByAge){this.DestroyOldestParticle(0,false);this.SolveZombie();}else {return b2_invalidParticleIndex;}}const index=this.m_count++;this.m_flagsBuffer.data[index]=0;if(this.m_lastBodyContactStepBuffer.data){this.m_lastBodyContactStepBuffer.data[index]=0;}if(this.m_bodyContactCountBuffer.data){this.m_bodyContactCountBuffer.data[index]=0;}if(this.m_consecutiveContactStepsBuffer.data){this.m_consecutiveContactStepsBuffer.data[index]=0;}this.m_positionBuffer.data[index]=(this.m_positionBuffer.data[index]||new b2Vec2()).Copy(b2Maybe(def.position,b2Vec2.ZERO));this.m_velocityBuffer.data[index]=(this.m_velocityBuffer.data[index]||new b2Vec2()).Copy(b2Maybe(def.velocity,b2Vec2.ZERO));this.m_weightBuffer[index]=0;this.m_forceBuffer[index]=(this.m_forceBuffer[index]||new b2Vec2()).SetZero();if(this.m_staticPressureBuffer){this.m_staticPressureBuffer[index]=0;}if(this.m_depthBuffer){this.m_depthBuffer[index]=0;}const color=new b2Color().Copy(b2Maybe(def.color,b2Color.ZERO));if(this.m_colorBuffer.data||!color.IsZero()){this.m_colorBuffer.data=this.RequestBuffer(this.m_colorBuffer.data);this.m_colorBuffer.data[index]=(this.m_colorBuffer.data[index]||new b2Color()).Copy(color);}if(this.m_userDataBuffer.data||def.userData){this.m_userDataBuffer.data=this.RequestBuffer(this.m_userDataBuffer.data);this.m_userDataBuffer.data[index]=def.userData;}if(this.m_handleIndexBuffer.data){this.m_handleIndexBuffer.data[index]=null;}const proxy=this.m_proxyBuffer.data[this.m_proxyBuffer.Append()];const lifetime=b2Maybe(def.lifetime,0.0);const finiteLifetime=lifetime>0.0;if(this.m_expirationTimeBuffer.data||finiteLifetime){this.SetParticleLifetime(index,finiteLifetime?lifetime:this.ExpirationTimeToLifetime(-this.GetQuantizedTimeElapsed()));this.m_indexByExpirationTimeBuffer.data[index]=index;}proxy.index=index;const group=b2Maybe(def.group,null);this.m_groupBuffer[index]=group;if(group){if(group.m_firstIndex<group.m_lastIndex){this.RotateBuffer(group.m_firstIndex,group.m_lastIndex,index);group.m_lastIndex=index+1;}else {group.m_firstIndex=index;group.m_lastIndex=index+1;}}this.SetParticleFlags(index,b2Maybe(def.flags,0));return index;}GetParticleHandleFromIndex(index){this.m_handleIndexBuffer.data=this.RequestBuffer(this.m_handleIndexBuffer.data);let handle=this.m_handleIndexBuffer.data[index];if(handle){return handle;}handle=new b2ParticleHandle();handle.SetIndex(index);this.m_handleIndexBuffer.data[index]=handle;return handle;}DestroyParticle(index,callDestructionListener=false){let flags=exports.b2ParticleFlag.b2_zombieParticle;if(callDestructionListener){flags|=exports.b2ParticleFlag.b2_destructionListenerParticle;}this.SetParticleFlags(index,this.m_flagsBuffer.data[index]|flags);}DestroyOldestParticle(index,callDestructionListener=false){const particleCount=this.GetParticleCount();const oldestFiniteLifetimeParticle=this.m_indexByExpirationTimeBuffer.data[particleCount-(index+1)];const oldestInfiniteLifetimeParticle=this.m_indexByExpirationTimeBuffer.data[index];this.DestroyParticle(this.m_expirationTimeBuffer.data[oldestFiniteLifetimeParticle]>0.0?oldestFiniteLifetimeParticle:oldestInfiniteLifetimeParticle,callDestructionListener);}DestroyParticlesInShape(shape,xf,callDestructionListener=false){const s_aabb=b2ParticleSystem.DestroyParticlesInShape_s_aabb;if(this.m_world.IsLocked()){throw new Error();}const callback=new b2ParticleSystem_DestroyParticlesInShapeCallback(this,shape,xf,callDestructionListener);const aabb=s_aabb;shape.ComputeAABB(aabb,xf,0);this.m_world.QueryAABB(callback,aabb);return callback.Destroyed();}CreateParticleGroup(groupDef){const s_transform=b2ParticleSystem.CreateParticleGroup_s_transform;if(this.m_world.IsLocked()){throw new Error();}const transform=s_transform;transform.SetPositionAngle(b2Maybe(groupDef.position,b2Vec2.ZERO),b2Maybe(groupDef.angle,0));const firstIndex=this.m_count;if(groupDef.shape){this.CreateParticlesWithShapeForGroup(groupDef.shape,groupDef,transform);}if(groupDef.shapes){this.CreateParticlesWithShapesForGroup(groupDef.shapes,b2Maybe(groupDef.shapeCount,groupDef.shapes.length),groupDef,transform);}if(groupDef.positionData){const count=b2Maybe(groupDef.particleCount,groupDef.positionData.length);for(let i=0;i<count;i++){const p=groupDef.positionData[i];this.CreateParticleForGroup(groupDef,transform,p);}}const lastIndex=this.m_count;let group=new b2ParticleGroup(this);group.m_firstIndex=firstIndex;group.m_lastIndex=lastIndex;group.m_strength=b2Maybe(groupDef.strength,1);group.m_userData=groupDef.userData;group.m_transform.Copy(transform);group.m_prev=null;group.m_next=this.m_groupList;if(this.m_groupList){this.m_groupList.m_prev=group;}this.m_groupList=group;++this.m_groupCount;for(let i=firstIndex;i<lastIndex;i++){this.m_groupBuffer[i]=group;}this.SetGroupFlags(group,b2Maybe(groupDef.groupFlags,0));const filter=new b2ParticleSystem_ConnectionFilter();this.UpdateContacts(true);this.UpdatePairsAndTriads(firstIndex,lastIndex,filter);if(groupDef.group){this.JoinParticleGroups(groupDef.group,group);group=groupDef.group;}return group;}JoinParticleGroups(groupA,groupB){if(this.m_world.IsLocked()){throw new Error();}this.RotateBuffer(groupB.m_firstIndex,groupB.m_lastIndex,this.m_count);this.RotateBuffer(groupA.m_firstIndex,groupA.m_lastIndex,groupB.m_firstIndex);const filter=new b2ParticleSystem_JoinParticleGroupsFilter(groupB.m_firstIndex);this.UpdateContacts(true);this.UpdatePairsAndTriads(groupA.m_firstIndex,groupB.m_lastIndex,filter);for(let i=groupB.m_firstIndex;i<groupB.m_lastIndex;i++){this.m_groupBuffer[i]=groupA;}const groupFlags=groupA.m_groupFlags|groupB.m_groupFlags;this.SetGroupFlags(groupA,groupFlags);groupA.m_lastIndex=groupB.m_lastIndex;groupB.m_firstIndex=groupB.m_lastIndex;this.DestroyParticleGroup(groupB);}SplitParticleGroup(group){this.UpdateContacts(true);const particleCount=group.GetParticleCount();const nodeBuffer=b2MakeArray(particleCount,index=>new b2ParticleSystem_ParticleListNode());b2ParticleSystem.InitializeParticleLists(group,nodeBuffer);this.MergeParticleListsInContact(group,nodeBuffer);const survivingList=b2ParticleSystem.FindLongestParticleList(group,nodeBuffer);this.MergeZombieParticleListNodes(group,nodeBuffer,survivingList);this.CreateParticleGroupsFromParticleList(group,nodeBuffer,survivingList);this.UpdatePairsAndTriadsWithParticleList(group,nodeBuffer);}GetParticleGroupList(){return this.m_groupList;}GetParticleGroupCount(){return this.m_groupCount;}GetParticleCount(){return this.m_count;}GetMaxParticleCount(){return this.m_def.maxCount;}SetMaxParticleCount(count){this.m_def.maxCount=count;}GetAllParticleFlags(){return this.m_allParticleFlags;}GetAllGroupFlags(){return this.m_allGroupFlags;}SetPaused(paused){this.m_paused=paused;}GetPaused(){return this.m_paused;}SetDensity(density){this.m_def.density=density;this.m_inverseDensity=1/this.m_def.density;}GetDensity(){return this.m_def.density;}SetGravityScale(gravityScale){this.m_def.gravityScale=gravityScale;}GetGravityScale(){return this.m_def.gravityScale;}SetDamping(damping){this.m_def.dampingStrength=damping;}GetDamping(){return this.m_def.dampingStrength;}SetStaticPressureIterations(iterations){this.m_def.staticPressureIterations=iterations;}GetStaticPressureIterations(){return this.m_def.staticPressureIterations;}SetRadius(radius){this.m_particleDiameter=2*radius;this.m_squaredDiameter=this.m_particleDiameter*this.m_particleDiameter;this.m_inverseDiameter=1/this.m_particleDiameter;}GetRadius(){return this.m_particleDiameter/2;}GetPositionBuffer(){return this.m_positionBuffer.data;}GetVelocityBuffer(){return this.m_velocityBuffer.data;}GetColorBuffer(){this.m_colorBuffer.data=this.RequestBuffer(this.m_colorBuffer.data);return this.m_colorBuffer.data;}GetGroupBuffer(){return this.m_groupBuffer;}GetWeightBuffer(){return this.m_weightBuffer;}GetUserDataBuffer(){this.m_userDataBuffer.data=this.RequestBuffer(this.m_userDataBuffer.data);return this.m_userDataBuffer.data;}GetFlagsBuffer(){return this.m_flagsBuffer.data;}SetParticleFlags(index,newFlags){const oldFlags=this.m_flagsBuffer.data[index];if(oldFlags&~newFlags){this.m_needsUpdateAllParticleFlags=true;}if(~this.m_allParticleFlags&newFlags){if(newFlags&exports.b2ParticleFlag.b2_tensileParticle){this.m_accumulation2Buffer=this.RequestBuffer(this.m_accumulation2Buffer);}if(newFlags&exports.b2ParticleFlag.b2_colorMixingParticle){this.m_colorBuffer.data=this.RequestBuffer(this.m_colorBuffer.data);}this.m_allParticleFlags|=newFlags;}this.m_flagsBuffer.data[index]=newFlags;}GetParticleFlags(index){return this.m_flagsBuffer.data[index];}SetFlagsBuffer(buffer){this.SetUserOverridableBuffer(this.m_flagsBuffer,buffer);}SetPositionBuffer(buffer){if(buffer instanceof Float32Array){if(buffer.length%2!==0){throw new Error();}const count=buffer.length/2;const array=new Array(count);for(let i=0;i<count;++i){array[i]=new b2Vec2(buffer.subarray(i*2,i*2+2));}buffer=array;}this.SetUserOverridableBuffer(this.m_positionBuffer,buffer);}SetVelocityBuffer(buffer){if(buffer instanceof Float32Array){if(buffer.length%2!==0){throw new Error();}const count=buffer.length/2;const array=new Array(count);for(let i=0;i<count;++i){array[i]=new b2Vec2(buffer.subarray(i*2,i*2+2));}buffer=array;}this.SetUserOverridableBuffer(this.m_velocityBuffer,buffer);}SetColorBuffer(buffer){if(buffer instanceof Float32Array){if(buffer.length%4!==0){throw new Error();}const count=buffer.length/4;const array=new Array(count);for(let i=0;i<count;++i){array[i]=new b2Color(buffer.subarray(i*4,i*4+4));}buffer=array;}this.SetUserOverridableBuffer(this.m_colorBuffer,buffer);}SetUserDataBuffer(buffer){this.SetUserOverridableBuffer(this.m_userDataBuffer,buffer);}GetContacts(){return this.m_contactBuffer.data;}GetContactCount(){return this.m_contactBuffer.count;}GetBodyContacts(){return this.m_bodyContactBuffer.data;}GetBodyContactCount(){return this.m_bodyContactBuffer.count;}GetPairs(){return this.m_pairBuffer.data;}GetPairCount(){return this.m_pairBuffer.count;}GetTriads(){return this.m_triadBuffer.data;}GetTriadCount(){return this.m_triadBuffer.count;}SetStuckThreshold(steps){this.m_stuckThreshold=steps;if(steps>0){this.m_lastBodyContactStepBuffer.data=this.RequestBuffer(this.m_lastBodyContactStepBuffer.data);this.m_bodyContactCountBuffer.data=this.RequestBuffer(this.m_bodyContactCountBuffer.data);this.m_consecutiveContactStepsBuffer.data=this.RequestBuffer(this.m_consecutiveContactStepsBuffer.data);}}GetStuckCandidates(){return this.m_stuckParticleBuffer.Data();}GetStuckCandidateCount(){return this.m_stuckParticleBuffer.GetCount();}ComputeCollisionEnergy(){const s_v=b2ParticleSystem.ComputeCollisionEnergy_s_v;const vel_data=this.m_velocityBuffer.data;let sum_v2=0;for(let k=0;k<this.m_contactBuffer.count;k++){const contact=this.m_contactBuffer.data[k];const a=contact.indexA;const b=contact.indexB;const n=contact.normal;const v=b2Vec2.SubVV(vel_data[b],vel_data[a],s_v);const vn=b2Vec2.DotVV(v,n);if(vn<0){sum_v2+=vn*vn;}}return 0.5*this.GetParticleMass()*sum_v2;}SetStrictContactCheck(enabled){this.m_def.strictContactCheck=enabled;}GetStrictContactCheck(){return this.m_def.strictContactCheck;}SetParticleLifetime(index,lifetime){const initializeExpirationTimes=this.m_indexByExpirationTimeBuffer.data===null;this.m_expirationTimeBuffer.data=this.RequestBuffer(this.m_expirationTimeBuffer.data);this.m_indexByExpirationTimeBuffer.data=this.RequestBuffer(this.m_indexByExpirationTimeBuffer.data);if(initializeExpirationTimes){const particleCount=this.GetParticleCount();for(let i=0;i<particleCount;++i){this.m_indexByExpirationTimeBuffer.data[i]=i;}}const quantizedLifetime=lifetime/this.m_def.lifetimeGranularity;const newExpirationTime=quantizedLifetime>0.0?this.GetQuantizedTimeElapsed()+quantizedLifetime:quantizedLifetime;if(newExpirationTime!==this.m_expirationTimeBuffer.data[index]){this.m_expirationTimeBuffer.data[index]=newExpirationTime;this.m_expirationTimeBufferRequiresSorting=true;}}GetParticleLifetime(index){return this.ExpirationTimeToLifetime(this.GetExpirationTimeBuffer()[index]);}SetDestructionByAge(enable){if(enable){this.GetExpirationTimeBuffer();}this.m_def.destroyByAge=enable;}GetDestructionByAge(){return this.m_def.destroyByAge;}GetExpirationTimeBuffer(){this.m_expirationTimeBuffer.data=this.RequestBuffer(this.m_expirationTimeBuffer.data);return this.m_expirationTimeBuffer.data;}ExpirationTimeToLifetime(expirationTime){return (expirationTime>0?expirationTime-this.GetQuantizedTimeElapsed():expirationTime)*this.m_def.lifetimeGranularity;}GetIndexByExpirationTimeBuffer(){if(this.GetParticleCount()){this.SetParticleLifetime(0,this.GetParticleLifetime(0));}else {this.m_indexByExpirationTimeBuffer.data=this.RequestBuffer(this.m_indexByExpirationTimeBuffer.data);}return this.m_indexByExpirationTimeBuffer.data;}ParticleApplyLinearImpulse(index,impulse){this.ApplyLinearImpulse(index,index+1,impulse);}ApplyLinearImpulse(firstIndex,lastIndex,impulse){const vel_data=this.m_velocityBuffer.data;const numParticles=lastIndex-firstIndex;const totalMass=numParticles*this.GetParticleMass();const velocityDelta=new b2Vec2().Copy(impulse).SelfMul(1/totalMass);for(let i=firstIndex;i<lastIndex;i++){vel_data[i].SelfAdd(velocityDelta);}}static IsSignificantForce(force){return force.x!==0||force.y!==0;}ParticleApplyForce(index,force){if(b2ParticleSystem.IsSignificantForce(force)&&this.ForceCanBeApplied(this.m_flagsBuffer.data[index])){this.PrepareForceBuffer();this.m_forceBuffer[index].SelfAdd(force);}}ApplyForce(firstIndex,lastIndex,force){const distributedForce=new b2Vec2().Copy(force).SelfMul(1/(lastIndex-firstIndex));if(b2ParticleSystem.IsSignificantForce(distributedForce)){this.PrepareForceBuffer();for(let i=firstIndex;i<lastIndex;i++){this.m_forceBuffer[i].SelfAdd(distributedForce);}}}GetNext(){return this.m_next;}QueryAABB(callback,aabb){if(this.m_proxyBuffer.count===0){return;}const beginProxy=0;const endProxy=this.m_proxyBuffer.count;const firstProxy=std_lower_bound(this.m_proxyBuffer.data,beginProxy,endProxy,b2ParticleSystem.computeTag(this.m_inverseDiameter*aabb.lowerBound.x,this.m_inverseDiameter*aabb.lowerBound.y),b2ParticleSystem_Proxy.CompareProxyTag);const lastProxy=std_upper_bound(this.m_proxyBuffer.data,firstProxy,endProxy,b2ParticleSystem.computeTag(this.m_inverseDiameter*aabb.upperBound.x,this.m_inverseDiameter*aabb.upperBound.y),b2ParticleSystem_Proxy.CompareTagProxy);const pos_data=this.m_positionBuffer.data;for(let k=firstProxy;k<lastProxy;++k){const proxy=this.m_proxyBuffer.data[k];const i=proxy.index;const p=pos_data[i];if(aabb.lowerBound.x<p.x&&p.x<aabb.upperBound.x&&aabb.lowerBound.y<p.y&&p.y<aabb.upperBound.y){if(!callback.ReportParticle(this,i)){break;}}}}QueryShapeAABB(callback,shape,xf,childIndex=0){const s_aabb=b2ParticleSystem.QueryShapeAABB_s_aabb;const aabb=s_aabb;shape.ComputeAABB(aabb,xf,childIndex);this.QueryAABB(callback,aabb);}QueryPointAABB(callback,point,slop=b2_linearSlop){const s_aabb=b2ParticleSystem.QueryPointAABB_s_aabb;const aabb=s_aabb;aabb.lowerBound.Set(point.x-slop,point.y-slop);aabb.upperBound.Set(point.x+slop,point.y+slop);this.QueryAABB(callback,aabb);}RayCast(callback,point1,point2){const s_aabb=b2ParticleSystem.RayCast_s_aabb;const s_p=b2ParticleSystem.RayCast_s_p;const s_v=b2ParticleSystem.RayCast_s_v;const s_n=b2ParticleSystem.RayCast_s_n;const s_point=b2ParticleSystem.RayCast_s_point;if(this.m_proxyBuffer.count===0){return;}const pos_data=this.m_positionBuffer.data;const aabb=s_aabb;b2Vec2.MinV(point1,point2,aabb.lowerBound);b2Vec2.MaxV(point1,point2,aabb.upperBound);let fraction=1;const v=b2Vec2.SubVV(point2,point1,s_v);const v2=b2Vec2.DotVV(v,v);const enumerator=this.GetInsideBoundsEnumerator(aabb);let i;while((i=enumerator.GetNext())>=0){const p=b2Vec2.SubVV(point1,pos_data[i],s_p);const pv=b2Vec2.DotVV(p,v);const p2=b2Vec2.DotVV(p,p);const determinant=pv*pv-v2*(p2-this.m_squaredDiameter);if(determinant>=0){const sqrtDeterminant=b2Sqrt(determinant);let t=(-pv-sqrtDeterminant)/v2;if(t>fraction){continue;}if(t<0){t=(-pv+sqrtDeterminant)/v2;if(t<0||t>fraction){continue;}}const n=b2Vec2.AddVMulSV(p,t,v,s_n);n.Normalize();const f=callback.ReportParticle(this,i,b2Vec2.AddVMulSV(point1,t,v,s_point),n,t);fraction=b2Min(fraction,f);if(fraction<=0){break;}}}}ComputeAABB(aabb){const particleCount=this.GetParticleCount();aabb.lowerBound.x=+b2_maxFloat;aabb.lowerBound.y=+b2_maxFloat;aabb.upperBound.x=-b2_maxFloat;aabb.upperBound.y=-b2_maxFloat;const pos_data=this.m_positionBuffer.data;for(let i=0;i<particleCount;i++){const p=pos_data[i];b2Vec2.MinV(aabb.lowerBound,p,aabb.lowerBound);b2Vec2.MaxV(aabb.upperBound,p,aabb.upperBound);}aabb.lowerBound.x-=this.m_particleDiameter;aabb.lowerBound.y-=this.m_particleDiameter;aabb.upperBound.x+=this.m_particleDiameter;aabb.upperBound.y+=this.m_particleDiameter;}FreeBuffer(b,capacity){if(b===null){return;}b.length=0;}FreeUserOverridableBuffer(b){if(b.userSuppliedCapacity===0){this.FreeBuffer(b.data,this.m_internalAllocatedCapacity);}}ReallocateBuffer3(oldBuffer,oldCapacity,newCapacity){if(newCapacity<=oldCapacity){throw new Error();}const newBuffer=oldBuffer?oldBuffer.slice():[];newBuffer.length=newCapacity;return newBuffer;}ReallocateBuffer5(buffer,userSuppliedCapacity,oldCapacity,newCapacity,deferred){if(newCapacity<=oldCapacity){throw new Error();}if(!(!userSuppliedCapacity||newCapacity<=userSuppliedCapacity)){throw new Error();}if((!deferred||buffer)&&!userSuppliedCapacity){buffer=this.ReallocateBuffer3(buffer,oldCapacity,newCapacity);}return buffer;}ReallocateBuffer4(buffer,oldCapacity,newCapacity,deferred){return this.ReallocateBuffer5(buffer.data,buffer.userSuppliedCapacity,oldCapacity,newCapacity,deferred);}RequestBuffer(buffer){if(!buffer){if(this.m_internalAllocatedCapacity===0){this.ReallocateInternalAllocatedBuffers(b2_minParticleSystemBufferCapacity);}buffer=[];buffer.length=this.m_internalAllocatedCapacity;}return buffer;}ReallocateHandleBuffers(newCapacity){this.m_handleIndexBuffer.data=this.ReallocateBuffer4(this.m_handleIndexBuffer,this.m_internalAllocatedCapacity,newCapacity,true);}ReallocateInternalAllocatedBuffers(capacity){function LimitCapacity(capacity,maxCount){return maxCount&&capacity>maxCount?maxCount:capacity;}capacity=LimitCapacity(capacity,this.m_def.maxCount);capacity=LimitCapacity(capacity,this.m_flagsBuffer.userSuppliedCapacity);capacity=LimitCapacity(capacity,this.m_positionBuffer.userSuppliedCapacity);capacity=LimitCapacity(capacity,this.m_velocityBuffer.userSuppliedCapacity);capacity=LimitCapacity(capacity,this.m_colorBuffer.userSuppliedCapacity);capacity=LimitCapacity(capacity,this.m_userDataBuffer.userSuppliedCapacity);if(this.m_internalAllocatedCapacity<capacity){this.ReallocateHandleBuffers(capacity);this.m_flagsBuffer.data=this.ReallocateBuffer4(this.m_flagsBuffer,this.m_internalAllocatedCapacity,capacity,false);const stuck=this.m_stuckThreshold>0;this.m_lastBodyContactStepBuffer.data=this.ReallocateBuffer4(this.m_lastBodyContactStepBuffer,this.m_internalAllocatedCapacity,capacity,stuck);this.m_bodyContactCountBuffer.data=this.ReallocateBuffer4(this.m_bodyContactCountBuffer,this.m_internalAllocatedCapacity,capacity,stuck);this.m_consecutiveContactStepsBuffer.data=this.ReallocateBuffer4(this.m_consecutiveContactStepsBuffer,this.m_internalAllocatedCapacity,capacity,stuck);this.m_positionBuffer.data=this.ReallocateBuffer4(this.m_positionBuffer,this.m_internalAllocatedCapacity,capacity,false);this.m_velocityBuffer.data=this.ReallocateBuffer4(this.m_velocityBuffer,this.m_internalAllocatedCapacity,capacity,false);this.m_forceBuffer=this.ReallocateBuffer5(this.m_forceBuffer,0,this.m_internalAllocatedCapacity,capacity,false);this.m_weightBuffer=this.ReallocateBuffer5(this.m_weightBuffer,0,this.m_internalAllocatedCapacity,capacity,false);this.m_staticPressureBuffer=this.ReallocateBuffer5(this.m_staticPressureBuffer,0,this.m_internalAllocatedCapacity,capacity,true);this.m_accumulationBuffer=this.ReallocateBuffer5(this.m_accumulationBuffer,0,this.m_internalAllocatedCapacity,capacity,false);this.m_accumulation2Buffer=this.ReallocateBuffer5(this.m_accumulation2Buffer,0,this.m_internalAllocatedCapacity,capacity,true);this.m_depthBuffer=this.ReallocateBuffer5(this.m_depthBuffer,0,this.m_internalAllocatedCapacity,capacity,true);this.m_colorBuffer.data=this.ReallocateBuffer4(this.m_colorBuffer,this.m_internalAllocatedCapacity,capacity,true);this.m_groupBuffer=this.ReallocateBuffer5(this.m_groupBuffer,0,this.m_internalAllocatedCapacity,capacity,false);this.m_userDataBuffer.data=this.ReallocateBuffer4(this.m_userDataBuffer,this.m_internalAllocatedCapacity,capacity,true);this.m_expirationTimeBuffer.data=this.ReallocateBuffer4(this.m_expirationTimeBuffer,this.m_internalAllocatedCapacity,capacity,true);this.m_indexByExpirationTimeBuffer.data=this.ReallocateBuffer4(this.m_indexByExpirationTimeBuffer,this.m_internalAllocatedCapacity,capacity,false);this.m_internalAllocatedCapacity=capacity;}}CreateParticleForGroup(groupDef,xf,p){const particleDef=new b2ParticleDef();particleDef.flags=b2Maybe(groupDef.flags,0);b2Transform.MulXV(xf,p,particleDef.position);b2Vec2.AddVV(b2Maybe(groupDef.linearVelocity,b2Vec2.ZERO),b2Vec2.CrossSV(b2Maybe(groupDef.angularVelocity,0),b2Vec2.SubVV(particleDef.position,b2Maybe(groupDef.position,b2Vec2.ZERO),b2Vec2.s_t0),b2Vec2.s_t0),particleDef.velocity);particleDef.color.Copy(b2Maybe(groupDef.color,b2Color.ZERO));particleDef.lifetime=b2Maybe(groupDef.lifetime,0);particleDef.userData=groupDef.userData;this.CreateParticle(particleDef);}CreateParticlesStrokeShapeForGroup(shape,groupDef,xf){const s_edge=b2ParticleSystem.CreateParticlesStrokeShapeForGroup_s_edge;const s_d=b2ParticleSystem.CreateParticlesStrokeShapeForGroup_s_d;const s_p=b2ParticleSystem.CreateParticlesStrokeShapeForGroup_s_p;let stride=b2Maybe(groupDef.stride,0);if(stride===0){stride=this.GetParticleStride();}let positionOnEdge=0;const childCount=shape.GetChildCount();for(let childIndex=0;childIndex<childCount;childIndex++){let edge=null;if(shape.GetType()===exports.b2ShapeType.e_edgeShape){edge=shape;}else {edge=s_edge;shape.GetChildEdge(edge,childIndex);}const d=b2Vec2.SubVV(edge.m_vertex2,edge.m_vertex1,s_d);const edgeLength=d.Length();while(positionOnEdge<edgeLength){const p=b2Vec2.AddVMulSV(edge.m_vertex1,positionOnEdge/edgeLength,d,s_p);this.CreateParticleForGroup(groupDef,xf,p);positionOnEdge+=stride;}positionOnEdge-=edgeLength;}}CreateParticlesFillShapeForGroup(shape,groupDef,xf){const s_aabb=b2ParticleSystem.CreateParticlesFillShapeForGroup_s_aabb;const s_p=b2ParticleSystem.CreateParticlesFillShapeForGroup_s_p;let stride=b2Maybe(groupDef.stride,0);if(stride===0){stride=this.GetParticleStride();}const identity=b2Transform.IDENTITY;const aabb=s_aabb;shape.ComputeAABB(aabb,identity,0);for(let y=Math.floor(aabb.lowerBound.y/stride)*stride;y<aabb.upperBound.y;y+=stride){for(let x=Math.floor(aabb.lowerBound.x/stride)*stride;x<aabb.upperBound.x;x+=stride){const p=s_p.Set(x,y);if(shape.TestPoint(identity,p)){this.CreateParticleForGroup(groupDef,xf,p);}}}}CreateParticlesWithShapeForGroup(shape,groupDef,xf){switch(shape.GetType()){case exports.b2ShapeType.e_edgeShape:case exports.b2ShapeType.e_chainShape:this.CreateParticlesStrokeShapeForGroup(shape,groupDef,xf);break;case exports.b2ShapeType.e_polygonShape:case exports.b2ShapeType.e_circleShape:this.CreateParticlesFillShapeForGroup(shape,groupDef,xf);break;}}CreateParticlesWithShapesForGroup(shapes,shapeCount,groupDef,xf){const compositeShape=new b2ParticleSystem_CompositeShape(shapes,shapeCount);this.CreateParticlesFillShapeForGroup(compositeShape,groupDef,xf);}CloneParticle(oldIndex,group){const def=new b2ParticleDef();def.flags=this.m_flagsBuffer.data[oldIndex];def.position.Copy(this.m_positionBuffer.data[oldIndex]);def.velocity.Copy(this.m_velocityBuffer.data[oldIndex]);if(this.m_colorBuffer.data){def.color.Copy(this.m_colorBuffer.data[oldIndex]);}if(this.m_userDataBuffer.data){def.userData=this.m_userDataBuffer.data[oldIndex];}def.group=group;const newIndex=this.CreateParticle(def);if(this.m_handleIndexBuffer.data){const handle=this.m_handleIndexBuffer.data[oldIndex];if(handle){handle.SetIndex(newIndex);}this.m_handleIndexBuffer.data[newIndex]=handle;this.m_handleIndexBuffer.data[oldIndex]=null;}if(this.m_lastBodyContactStepBuffer.data){this.m_lastBodyContactStepBuffer.data[newIndex]=this.m_lastBodyContactStepBuffer.data[oldIndex];}if(this.m_bodyContactCountBuffer.data){this.m_bodyContactCountBuffer.data[newIndex]=this.m_bodyContactCountBuffer.data[oldIndex];}if(this.m_consecutiveContactStepsBuffer.data){this.m_consecutiveContactStepsBuffer.data[newIndex]=this.m_consecutiveContactStepsBuffer.data[oldIndex];}if(this.m_hasForce){this.m_forceBuffer[newIndex].Copy(this.m_forceBuffer[oldIndex]);}if(this.m_staticPressureBuffer){this.m_staticPressureBuffer[newIndex]=this.m_staticPressureBuffer[oldIndex];}if(this.m_depthBuffer){this.m_depthBuffer[newIndex]=this.m_depthBuffer[oldIndex];}if(this.m_expirationTimeBuffer.data){this.m_expirationTimeBuffer.data[newIndex]=this.m_expirationTimeBuffer.data[oldIndex];}return newIndex;}DestroyParticlesInGroup(group,callDestructionListener=false){for(let i=group.m_firstIndex;i<group.m_lastIndex;i++){this.DestroyParticle(i,callDestructionListener);}}DestroyParticleGroup(group){if(this.m_world.m_destructionListener){this.m_world.m_destructionListener.SayGoodbyeParticleGroup(group);}this.SetGroupFlags(group,0);for(let i=group.m_firstIndex;i<group.m_lastIndex;i++){this.m_groupBuffer[i]=null;}if(group.m_prev){group.m_prev.m_next=group.m_next;}if(group.m_next){group.m_next.m_prev=group.m_prev;}if(group===this.m_groupList){this.m_groupList=group.m_next;}--this.m_groupCount;}static ParticleCanBeConnected(flags,group){return (flags&(exports.b2ParticleFlag.b2_wallParticle|exports.b2ParticleFlag.b2_springParticle|exports.b2ParticleFlag.b2_elasticParticle))!==0||group!==null&&(group.GetGroupFlags()&exports.b2ParticleGroupFlag.b2_rigidParticleGroup)!==0;}UpdatePairsAndTriads(firstIndex,lastIndex,filter){const s_dab=b2ParticleSystem.UpdatePairsAndTriads_s_dab;const s_dbc=b2ParticleSystem.UpdatePairsAndTriads_s_dbc;const s_dca=b2ParticleSystem.UpdatePairsAndTriads_s_dca;const pos_data=this.m_positionBuffer.data;let particleFlags=0;for(let i=firstIndex;i<lastIndex;i++){particleFlags|=this.m_flagsBuffer.data[i];}if(particleFlags&b2ParticleSystem.k_pairFlags){for(let k=0;k<this.m_contactBuffer.count;k++){const contact=this.m_contactBuffer.data[k];const a=contact.indexA;const b=contact.indexB;const af=this.m_flagsBuffer.data[a];const bf=this.m_flagsBuffer.data[b];const groupA=this.m_groupBuffer[a];const groupB=this.m_groupBuffer[b];if(a>=firstIndex&&a<lastIndex&&b>=firstIndex&&b<lastIndex&&!((af|bf)&exports.b2ParticleFlag.b2_zombieParticle)&&(af|bf)&b2ParticleSystem.k_pairFlags&&(filter.IsNecessary(a)||filter.IsNecessary(b))&&b2ParticleSystem.ParticleCanBeConnected(af,groupA)&&b2ParticleSystem.ParticleCanBeConnected(bf,groupB)&&filter.ShouldCreatePair(a,b)){const pair=this.m_pairBuffer.data[this.m_pairBuffer.Append()];pair.indexA=a;pair.indexB=b;pair.flags=contact.flags;pair.strength=b2Min(groupA?groupA.m_strength:1,groupB?groupB.m_strength:1);pair.distance=b2Vec2.DistanceVV(pos_data[a],pos_data[b]);}std_stable_sort(this.m_pairBuffer.data,0,this.m_pairBuffer.count,b2ParticleSystem.ComparePairIndices);this.m_pairBuffer.Unique(b2ParticleSystem.MatchPairIndices);}}if(particleFlags&b2ParticleSystem.k_triadFlags){const diagram=new b2VoronoiDiagram(lastIndex-firstIndex);for(let i=firstIndex;i<lastIndex;i++){const flags=this.m_flagsBuffer.data[i];const group=this.m_groupBuffer[i];if(!(flags&exports.b2ParticleFlag.b2_zombieParticle)&&b2ParticleSystem.ParticleCanBeConnected(flags,group)){diagram.AddGenerator(pos_data[i],i,filter.IsNecessary(i));}}const stride=this.GetParticleStride();diagram.Generate(stride/2,stride*2);const system=this;const callback=(a,b,c)=>{const af=system.m_flagsBuffer.data[a];const bf=system.m_flagsBuffer.data[b];const cf=system.m_flagsBuffer.data[c];if((af|bf|cf)&b2ParticleSystem.k_triadFlags&&filter.ShouldCreateTriad(a,b,c)){const pa=pos_data[a];const pb=pos_data[b];const pc=pos_data[c];const dab=b2Vec2.SubVV(pa,pb,s_dab);const dbc=b2Vec2.SubVV(pb,pc,s_dbc);const dca=b2Vec2.SubVV(pc,pa,s_dca);const maxDistanceSquared=b2_maxTriadDistanceSquared*system.m_squaredDiameter;if(b2Vec2.DotVV(dab,dab)>maxDistanceSquared||b2Vec2.DotVV(dbc,dbc)>maxDistanceSquared||b2Vec2.DotVV(dca,dca)>maxDistanceSquared){return;}const groupA=system.m_groupBuffer[a];const groupB=system.m_groupBuffer[b];const groupC=system.m_groupBuffer[c];const triad=system.m_triadBuffer.data[system.m_triadBuffer.Append()];triad.indexA=a;triad.indexB=b;triad.indexC=c;triad.flags=af|bf|cf;triad.strength=b2Min(b2Min(groupA?groupA.m_strength:1,groupB?groupB.m_strength:1),groupC?groupC.m_strength:1);const midPoint_x=(pa.x+pb.x+pc.x)/3.0;const midPoint_y=(pa.y+pb.y+pc.y)/3.0;triad.pa.x=pa.x-midPoint_x;triad.pa.y=pa.y-midPoint_y;triad.pb.x=pb.x-midPoint_x;triad.pb.y=pb.y-midPoint_y;triad.pc.x=pc.x-midPoint_x;triad.pc.y=pc.y-midPoint_y;triad.ka=-b2Vec2.DotVV(dca,dab);triad.kb=-b2Vec2.DotVV(dab,dbc);triad.kc=-b2Vec2.DotVV(dbc,dca);triad.s=b2Vec2.CrossVV(pa,pb)+b2Vec2.CrossVV(pb,pc)+b2Vec2.CrossVV(pc,pa);}};diagram.GetNodes(callback);std_stable_sort(this.m_triadBuffer.data,0,this.m_triadBuffer.count,b2ParticleSystem.CompareTriadIndices);this.m_triadBuffer.Unique(b2ParticleSystem.MatchTriadIndices);}}UpdatePairsAndTriadsWithReactiveParticles(){const filter=new b2ParticleSystem_ReactiveFilter(this.m_flagsBuffer);this.UpdatePairsAndTriads(0,this.m_count,filter);for(let i=0;i<this.m_count;i++){this.m_flagsBuffer.data[i]&=~exports.b2ParticleFlag.b2_reactiveParticle;}this.m_allParticleFlags&=~exports.b2ParticleFlag.b2_reactiveParticle;}static ComparePairIndices(a,b){const diffA=a.indexA-b.indexA;if(diffA!==0){return diffA<0;}return a.indexB<b.indexB;}static MatchPairIndices(a,b){return a.indexA===b.indexA&&a.indexB===b.indexB;}static CompareTriadIndices(a,b){const diffA=a.indexA-b.indexA;if(diffA!==0){return diffA<0;}const diffB=a.indexB-b.indexB;if(diffB!==0){return diffB<0;}return a.indexC<b.indexC;}static MatchTriadIndices(a,b){return a.indexA===b.indexA&&a.indexB===b.indexB&&a.indexC===b.indexC;}static InitializeParticleLists(group,nodeBuffer){const bufferIndex=group.GetBufferIndex();const particleCount=group.GetParticleCount();for(let i=0;i<particleCount;i++){const node=nodeBuffer[i];node.list=node;node.next=null;node.count=1;node.index=i+bufferIndex;}}MergeParticleListsInContact(group,nodeBuffer){const bufferIndex=group.GetBufferIndex();for(let k=0;k<this.m_contactBuffer.count;k++){const contact=this.m_contactBuffer.data[k];const a=contact.indexA;const b=contact.indexB;if(!group.ContainsParticle(a)||!group.ContainsParticle(b)){continue;}let listA=nodeBuffer[a-bufferIndex].list;let listB=nodeBuffer[b-bufferIndex].list;if(listA===listB){continue;}if(listA.count<listB.count){const _tmp=listA;listA=listB;listB=_tmp;}b2ParticleSystem.MergeParticleLists(listA,listB);}}static MergeParticleLists(listA,listB){for(let b=listB;;){b.list=listA;const nextB=b.next;if(nextB){b=nextB;}else {b.next=listA.next;break;}}listA.next=listB;listA.count+=listB.count;listB.count=0;}static FindLongestParticleList(group,nodeBuffer){const particleCount=group.GetParticleCount();let result=nodeBuffer[0];for(let i=0;i<particleCount;i++){const node=nodeBuffer[i];if(result.count<node.count){result=node;}}return result;}MergeZombieParticleListNodes(group,nodeBuffer,survivingList){const particleCount=group.GetParticleCount();for(let i=0;i<particleCount;i++){const node=nodeBuffer[i];if(node!==survivingList&&this.m_flagsBuffer.data[node.index]&exports.b2ParticleFlag.b2_zombieParticle){b2ParticleSystem.MergeParticleListAndNode(survivingList,node);}}}static MergeParticleListAndNode(list,node){node.list=list;node.next=list.next;list.next=node;list.count++;node.count=0;}CreateParticleGroupsFromParticleList(group,nodeBuffer,survivingList){const particleCount=group.GetParticleCount();const def=new b2ParticleGroupDef();def.groupFlags=group.GetGroupFlags();def.userData=group.GetUserData();for(let i=0;i<particleCount;i++){const list=nodeBuffer[i];if(!list.count||list===survivingList){continue;}const newGroup=this.CreateParticleGroup(def);for(let node=list;node;node=node.next){const oldIndex=node.index;const newIndex=this.CloneParticle(oldIndex,newGroup);this.m_flagsBuffer.data[oldIndex]|=exports.b2ParticleFlag.b2_zombieParticle;node.index=newIndex;}}}UpdatePairsAndTriadsWithParticleList(group,nodeBuffer){const bufferIndex=group.GetBufferIndex();for(let k=0;k<this.m_pairBuffer.count;k++){const pair=this.m_pairBuffer.data[k];const a=pair.indexA;const b=pair.indexB;if(group.ContainsParticle(a)){pair.indexA=nodeBuffer[a-bufferIndex].index;}if(group.ContainsParticle(b)){pair.indexB=nodeBuffer[b-bufferIndex].index;}}for(let k=0;k<this.m_triadBuffer.count;k++){const triad=this.m_triadBuffer.data[k];const a=triad.indexA;const b=triad.indexB;const c=triad.indexC;if(group.ContainsParticle(a)){triad.indexA=nodeBuffer[a-bufferIndex].index;}if(group.ContainsParticle(b)){triad.indexB=nodeBuffer[b-bufferIndex].index;}if(group.ContainsParticle(c)){triad.indexC=nodeBuffer[c-bufferIndex].index;}}}ComputeDepth(){const contactGroups=[];let contactGroupsCount=0;for(let k=0;k<this.m_contactBuffer.count;k++){const contact=this.m_contactBuffer.data[k];const a=contact.indexA;const b=contact.indexB;const groupA=this.m_groupBuffer[a];const groupB=this.m_groupBuffer[b];if(groupA&&groupA===groupB&&groupA.m_groupFlags&exports.b2ParticleGroupFlag.b2_particleGroupNeedsUpdateDepth){contactGroups[contactGroupsCount++]=contact;}}const groupsToUpdate=[];let groupsToUpdateCount=0;for(let group=this.m_groupList;group;group=group.GetNext()){if(group.m_groupFlags&exports.b2ParticleGroupFlag.b2_particleGroupNeedsUpdateDepth){groupsToUpdate[groupsToUpdateCount++]=group;this.SetGroupFlags(group,group.m_groupFlags&~exports.b2ParticleGroupFlag.b2_particleGroupNeedsUpdateDepth);for(let i=group.m_firstIndex;i<group.m_lastIndex;i++){this.m_accumulationBuffer[i]=0;}}}for(let k=0;k<contactGroupsCount;k++){const contact=contactGroups[k];const a=contact.indexA;const b=contact.indexB;const w=contact.weight;this.m_accumulationBuffer[a]+=w;this.m_accumulationBuffer[b]+=w;}for(let i=0;i<groupsToUpdateCount;i++){const group=groupsToUpdate[i];for(let i=group.m_firstIndex;i<group.m_lastIndex;i++){const w=this.m_accumulationBuffer[i];this.m_depthBuffer[i]=w<0.8?0:b2_maxFloat;}}const iterationCount=b2Sqrt(this.m_count)>>0;for(let t=0;t<iterationCount;t++){let updated=false;for(let k=0;k<contactGroupsCount;k++){const contact=contactGroups[k];const a=contact.indexA;const b=contact.indexB;const r=1-contact.weight;const ap0=this.m_depthBuffer[a];const bp0=this.m_depthBuffer[b];const ap1=bp0+r;const bp1=ap0+r;if(ap0>ap1){this.m_depthBuffer[a]=ap1;updated=true;}if(bp0>bp1){this.m_depthBuffer[b]=bp1;updated=true;}}if(!updated){break;}}for(let i=0;i<groupsToUpdateCount;i++){const group=groupsToUpdate[i];for(let i=group.m_firstIndex;i<group.m_lastIndex;i++){if(this.m_depthBuffer[i]<b2_maxFloat){this.m_depthBuffer[i]*=this.m_particleDiameter;}else {this.m_depthBuffer[i]=0;}}}}GetInsideBoundsEnumerator(aabb){const lowerTag=b2ParticleSystem.computeTag(this.m_inverseDiameter*aabb.lowerBound.x-1,this.m_inverseDiameter*aabb.lowerBound.y-1);const upperTag=b2ParticleSystem.computeTag(this.m_inverseDiameter*aabb.upperBound.x+1,this.m_inverseDiameter*aabb.upperBound.y+1);const beginProxy=0;const endProxy=this.m_proxyBuffer.count;const firstProxy=std_lower_bound(this.m_proxyBuffer.data,beginProxy,endProxy,lowerTag,b2ParticleSystem_Proxy.CompareProxyTag);const lastProxy=std_upper_bound(this.m_proxyBuffer.data,beginProxy,endProxy,upperTag,b2ParticleSystem_Proxy.CompareTagProxy);return new b2ParticleSystem_InsideBoundsEnumerator(this,lowerTag,upperTag,firstProxy,lastProxy);}UpdateAllParticleFlags(){this.m_allParticleFlags=0;for(let i=0;i<this.m_count;i++){this.m_allParticleFlags|=this.m_flagsBuffer.data[i];}this.m_needsUpdateAllParticleFlags=false;}UpdateAllGroupFlags(){this.m_allGroupFlags=0;for(let group=this.m_groupList;group;group=group.GetNext()){this.m_allGroupFlags|=group.m_groupFlags;}this.m_needsUpdateAllGroupFlags=false;}AddContact(a,b,contacts){const flags_data=this.m_flagsBuffer.data;const pos_data=this.m_positionBuffer.data;const d=b2Vec2.SubVV(pos_data[b],pos_data[a],b2ParticleSystem.AddContact_s_d);const distBtParticlesSq=b2Vec2.DotVV(d,d);if(0<distBtParticlesSq&&distBtParticlesSq<this.m_squaredDiameter){const invD=b2InvSqrt(distBtParticlesSq);const contact=this.m_contactBuffer.data[this.m_contactBuffer.Append()];contact.indexA=a;contact.indexB=b;contact.flags=flags_data[a]|flags_data[b];contact.weight=1-distBtParticlesSq*invD*this.m_inverseDiameter;contact.normal.x=invD*d.x;contact.normal.y=invD*d.y;}}FindContacts_Reference(contacts){const beginProxy=0;const endProxy=this.m_proxyBuffer.count;this.m_contactBuffer.count=0;for(let a=beginProxy,c=beginProxy;a<endProxy;a++){const rightTag=b2ParticleSystem.computeRelativeTag(this.m_proxyBuffer.data[a].tag,1,0);for(let b=a+1;b<endProxy;b++){if(rightTag<this.m_proxyBuffer.data[b].tag){break;}this.AddContact(this.m_proxyBuffer.data[a].index,this.m_proxyBuffer.data[b].index,this.m_contactBuffer);}const bottomLeftTag=b2ParticleSystem.computeRelativeTag(this.m_proxyBuffer.data[a].tag,-1,1);for(;c<endProxy;c++){if(bottomLeftTag<=this.m_proxyBuffer.data[c].tag){break;}}const bottomRightTag=b2ParticleSystem.computeRelativeTag(this.m_proxyBuffer.data[a].tag,1,1);for(let b=c;b<endProxy;b++){if(bottomRightTag<this.m_proxyBuffer.data[b].tag){break;}this.AddContact(this.m_proxyBuffer.data[a].index,this.m_proxyBuffer.data[b].index,this.m_contactBuffer);}}}FindContacts(contacts){this.FindContacts_Reference(contacts);}UpdateProxies_Reference(proxies){const pos_data=this.m_positionBuffer.data;const inv_diam=this.m_inverseDiameter;for(let k=0;k<this.m_proxyBuffer.count;++k){const proxy=this.m_proxyBuffer.data[k];const i=proxy.index;const p=pos_data[i];proxy.tag=b2ParticleSystem.computeTag(inv_diam*p.x,inv_diam*p.y);}}UpdateProxies(proxies){this.UpdateProxies_Reference(proxies);}SortProxies(proxies){std_sort$1(this.m_proxyBuffer.data,0,this.m_proxyBuffer.count,b2ParticleSystem_Proxy.CompareProxyProxy);}FilterContacts(contacts){const contactFilter=this.GetParticleContactFilter();if(contactFilter===null){return;}const system=this;const predicate=contact=>{return (contact.flags&exports.b2ParticleFlag.b2_particleContactFilterParticle)!==0&&!contactFilter.ShouldCollideParticleParticle(system,contact.indexA,contact.indexB);};this.m_contactBuffer.RemoveIf(predicate);}NotifyContactListenerPreContact(particlePairs){const contactListener=this.GetParticleContactListener();if(contactListener===null){return;}particlePairs.Initialize(this.m_contactBuffer,this.m_flagsBuffer);throw new Error();}NotifyContactListenerPostContact(particlePairs){const contactListener=this.GetParticleContactListener();if(contactListener===null){return;}for(let k=0;k<this.m_contactBuffer.count;++k){const contact=this.m_contactBuffer.data[k];{contactListener.BeginContactParticleParticle(this,contact);}}throw new Error();}static b2ParticleContactIsZombie(contact){return (contact.flags&exports.b2ParticleFlag.b2_zombieParticle)===exports.b2ParticleFlag.b2_zombieParticle;}UpdateContacts(exceptZombie){this.UpdateProxies(this.m_proxyBuffer);this.SortProxies(this.m_proxyBuffer);const particlePairs=new b2ParticlePairSet();this.NotifyContactListenerPreContact(particlePairs);this.FindContacts(this.m_contactBuffer);this.FilterContacts(this.m_contactBuffer);this.NotifyContactListenerPostContact(particlePairs);if(exceptZombie){this.m_contactBuffer.RemoveIf(b2ParticleSystem.b2ParticleContactIsZombie);}}NotifyBodyContactListenerPreContact(fixtureSet){const contactListener=this.GetFixtureContactListener();if(contactListener===null){return;}fixtureSet.Initialize(this.m_bodyContactBuffer,this.m_flagsBuffer);throw new Error();}NotifyBodyContactListenerPostContact(fixtureSet){const contactListener=this.GetFixtureContactListener();if(contactListener===null){return;}for(let k=0;k<this.m_bodyContactBuffer.count;k++){const contact=this.m_bodyContactBuffer.data[k];{contactListener.BeginContactFixtureParticle(this,contact);}}throw new Error();}UpdateBodyContacts(){const s_aabb=b2ParticleSystem.UpdateBodyContacts_s_aabb;const fixtureSet=new b2ParticleSystem_FixtureParticleSet();this.NotifyBodyContactListenerPreContact(fixtureSet);if(this.m_stuckThreshold>0){const particleCount=this.GetParticleCount();for(let i=0;i<particleCount;i++){this.m_bodyContactCountBuffer.data[i]=0;if(this.m_timestamp>this.m_lastBodyContactStepBuffer.data[i]+1){this.m_consecutiveContactStepsBuffer.data[i]=0;}}}this.m_bodyContactBuffer.SetCount(0);this.m_stuckParticleBuffer.SetCount(0);const aabb=s_aabb;this.ComputeAABB(aabb);if(this.UpdateBodyContacts_callback===null){this.UpdateBodyContacts_callback=new b2ParticleSystem_UpdateBodyContactsCallback(this);}const callback=this.UpdateBodyContacts_callback;callback.m_contactFilter=this.GetFixtureContactFilter();this.m_world.QueryAABB(callback,aabb);if(this.m_def.strictContactCheck){this.RemoveSpuriousBodyContacts();}this.NotifyBodyContactListenerPostContact(fixtureSet);}Solve(step){const s_subStep=b2ParticleSystem.Solve_s_subStep;if(this.m_count===0){return;}if(this.m_expirationTimeBuffer.data){this.SolveLifetimes(step);}if(this.m_allParticleFlags&exports.b2ParticleFlag.b2_zombieParticle){this.SolveZombie();}if(this.m_needsUpdateAllParticleFlags){this.UpdateAllParticleFlags();}if(this.m_needsUpdateAllGroupFlags){this.UpdateAllGroupFlags();}if(this.m_paused){return;}for(this.m_iterationIndex=0;this.m_iterationIndex<step.particleIterations;this.m_iterationIndex++){++this.m_timestamp;const subStep=s_subStep.Copy(step);subStep.dt/=step.particleIterations;subStep.inv_dt*=step.particleIterations;this.UpdateContacts(false);this.UpdateBodyContacts();this.ComputeWeight();if(this.m_allGroupFlags&exports.b2ParticleGroupFlag.b2_particleGroupNeedsUpdateDepth){this.ComputeDepth();}if(this.m_allParticleFlags&exports.b2ParticleFlag.b2_reactiveParticle){this.UpdatePairsAndTriadsWithReactiveParticles();}if(this.m_hasForce){this.SolveForce(subStep);}if(this.m_allParticleFlags&exports.b2ParticleFlag.b2_viscousParticle){this.SolveViscous();}if(this.m_allParticleFlags&exports.b2ParticleFlag.b2_repulsiveParticle){this.SolveRepulsive(subStep);}if(this.m_allParticleFlags&exports.b2ParticleFlag.b2_powderParticle){this.SolvePowder(subStep);}if(this.m_allParticleFlags&exports.b2ParticleFlag.b2_tensileParticle){this.SolveTensile(subStep);}if(this.m_allGroupFlags&exports.b2ParticleGroupFlag.b2_solidParticleGroup){this.SolveSolid(subStep);}if(this.m_allParticleFlags&exports.b2ParticleFlag.b2_colorMixingParticle){this.SolveColorMixing();}this.SolveGravity(subStep);if(this.m_allParticleFlags&exports.b2ParticleFlag.b2_staticPressureParticle){this.SolveStaticPressure(subStep);}this.SolvePressure(subStep);this.SolveDamping(subStep);if(this.m_allParticleFlags&b2ParticleSystem.k_extraDampingFlags){this.SolveExtraDamping();}if(this.m_allParticleFlags&exports.b2ParticleFlag.b2_elasticParticle){this.SolveElastic(subStep);}if(this.m_allParticleFlags&exports.b2ParticleFlag.b2_springParticle){this.SolveSpring(subStep);}this.LimitVelocity(subStep);if(this.m_allGroupFlags&exports.b2ParticleGroupFlag.b2_rigidParticleGroup){this.SolveRigidDamping();}if(this.m_allParticleFlags&exports.b2ParticleFlag.b2_barrierParticle){this.SolveBarrier(subStep);}this.SolveCollision(subStep);if(this.m_allGroupFlags&exports.b2ParticleGroupFlag.b2_rigidParticleGroup){this.SolveRigid(subStep);}if(this.m_allParticleFlags&exports.b2ParticleFlag.b2_wallParticle){this.SolveWall();}for(let i=0;i<this.m_count;i++){this.m_positionBuffer.data[i].SelfMulAdd(subStep.dt,this.m_velocityBuffer.data[i]);}}}SolveCollision(step){const s_aabb=b2ParticleSystem.SolveCollision_s_aabb;const pos_data=this.m_positionBuffer.data;const vel_data=this.m_velocityBuffer.data;const aabb=s_aabb;aabb.lowerBound.x=+b2_maxFloat;aabb.lowerBound.y=+b2_maxFloat;aabb.upperBound.x=-b2_maxFloat;aabb.upperBound.y=-b2_maxFloat;for(let i=0;i<this.m_count;i++){const v=vel_data[i];const p1=pos_data[i];const p2_x=p1.x+step.dt*v.x;const p2_y=p1.y+step.dt*v.y;aabb.lowerBound.x=b2Min(aabb.lowerBound.x,b2Min(p1.x,p2_x));aabb.lowerBound.y=b2Min(aabb.lowerBound.y,b2Min(p1.y,p2_y));aabb.upperBound.x=b2Max(aabb.upperBound.x,b2Max(p1.x,p2_x));aabb.upperBound.y=b2Max(aabb.upperBound.y,b2Max(p1.y,p2_y));}if(this.SolveCollision_callback===null){this.SolveCollision_callback=new b2ParticleSystem_SolveCollisionCallback(this,step);}const callback=this.SolveCollision_callback;callback.m_step=step;this.m_world.QueryAABB(callback,aabb);}LimitVelocity(step){const vel_data=this.m_velocityBuffer.data;const criticalVelocitySquared=this.GetCriticalVelocitySquared(step);for(let i=0;i<this.m_count;i++){const v=vel_data[i];const v2=b2Vec2.DotVV(v,v);if(v2>criticalVelocitySquared){v.SelfMul(b2Sqrt(criticalVelocitySquared/v2));}}}SolveGravity(step){const s_gravity=b2ParticleSystem.SolveGravity_s_gravity;const vel_data=this.m_velocityBuffer.data;const gravity=b2Vec2.MulSV(step.dt*this.m_def.gravityScale,this.m_world.GetGravity(),s_gravity);for(let i=0;i<this.m_count;i++){vel_data[i].SelfAdd(gravity);}}SolveBarrier(step){const s_aabb=b2ParticleSystem.SolveBarrier_s_aabb;const s_va=b2ParticleSystem.SolveBarrier_s_va;const s_vb=b2ParticleSystem.SolveBarrier_s_vb;const s_pba=b2ParticleSystem.SolveBarrier_s_pba;const s_vba=b2ParticleSystem.SolveBarrier_s_vba;const s_vc=b2ParticleSystem.SolveBarrier_s_vc;const s_pca=b2ParticleSystem.SolveBarrier_s_pca;const s_vca=b2ParticleSystem.SolveBarrier_s_vca;const s_qba=b2ParticleSystem.SolveBarrier_s_qba;const s_qca=b2ParticleSystem.SolveBarrier_s_qca;const s_dv=b2ParticleSystem.SolveBarrier_s_dv;const s_f=b2ParticleSystem.SolveBarrier_s_f;const pos_data=this.m_positionBuffer.data;const vel_data=this.m_velocityBuffer.data;for(let i=0;i<this.m_count;i++){const flags=this.m_flagsBuffer.data[i];if((flags&b2ParticleSystem.k_barrierWallFlags)!==0){vel_data[i].SetZero();}}const tmax=b2_barrierCollisionTime*step.dt;const mass=this.GetParticleMass();for(let k=0;k<this.m_pairBuffer.count;k++){const pair=this.m_pairBuffer.data[k];if(pair.flags&exports.b2ParticleFlag.b2_barrierParticle){const a=pair.indexA;const b=pair.indexB;const pa=pos_data[a];const pb=pos_data[b];const aabb=s_aabb;b2Vec2.MinV(pa,pb,aabb.lowerBound);b2Vec2.MaxV(pa,pb,aabb.upperBound);const aGroup=this.m_groupBuffer[a];const bGroup=this.m_groupBuffer[b];const va=this.GetLinearVelocity(aGroup,a,pa,s_va);const vb=this.GetLinearVelocity(bGroup,b,pb,s_vb);const pba=b2Vec2.SubVV(pb,pa,s_pba);const vba=b2Vec2.SubVV(vb,va,s_vba);const enumerator=this.GetInsideBoundsEnumerator(aabb);let c;while((c=enumerator.GetNext())>=0){const pc=pos_data[c];const cGroup=this.m_groupBuffer[c];if(aGroup!==cGroup&&bGroup!==cGroup){const vc=this.GetLinearVelocity(cGroup,c,pc,s_vc);const pca=b2Vec2.SubVV(pc,pa,s_pca);const vca=b2Vec2.SubVV(vc,va,s_vca);const e2=b2Vec2.CrossVV(vba,vca);const e1=b2Vec2.CrossVV(pba,vca)-b2Vec2.CrossVV(pca,vba);const e0=b2Vec2.CrossVV(pba,pca);let s,t;const qba=s_qba,qca=s_qca;if(e2===0){if(e1===0){continue;}t=-e0/e1;if(!(t>=0&&t<tmax)){continue;}b2Vec2.AddVMulSV(pba,t,vba,qba);b2Vec2.AddVMulSV(pca,t,vca,qca);s=b2Vec2.DotVV(qba,qca)/b2Vec2.DotVV(qba,qba);if(!(s>=0&&s<=1)){continue;}}else {const det=e1*e1-4*e0*e2;if(det<0){continue;}const sqrtDet=b2Sqrt(det);let t1=(-e1-sqrtDet)/(2*e2);let t2=(-e1+sqrtDet)/(2*e2);if(t1>t2){const tmp=t1;t1=t2;t2=tmp;}t=t1;b2Vec2.AddVMulSV(pba,t,vba,qba);b2Vec2.AddVMulSV(pca,t,vca,qca);s=b2Vec2.DotVV(qba,qca)/b2Vec2.DotVV(qba,qba);if(!(t>=0&&t<tmax&&s>=0&&s<=1)){t=t2;if(!(t>=0&&t<tmax)){continue;}b2Vec2.AddVMulSV(pba,t,vba,qba);b2Vec2.AddVMulSV(pca,t,vca,qca);s=b2Vec2.DotVV(qba,qca)/b2Vec2.DotVV(qba,qba);if(!(s>=0&&s<=1)){continue;}}}const dv=s_dv;dv.x=va.x+s*vba.x-vc.x;dv.y=va.y+s*vba.y-vc.y;const f=b2Vec2.MulSV(mass,dv,s_f);if(cGroup&&this.IsRigidGroup(cGroup)){const mass=cGroup.GetMass();const inertia=cGroup.GetInertia();if(mass>0){cGroup.m_linearVelocity.SelfMulAdd(1/mass,f);}if(inertia>0){cGroup.m_angularVelocity+=b2Vec2.CrossVV(b2Vec2.SubVV(pc,cGroup.GetCenter(),b2Vec2.s_t0),f)/inertia;}}else {vel_data[c].SelfAdd(dv);}this.ParticleApplyForce(c,f.SelfMul(-step.inv_dt));}}}}}SolveStaticPressure(step){this.m_staticPressureBuffer=this.RequestBuffer(this.m_staticPressureBuffer);const criticalPressure=this.GetCriticalPressure(step);const pressurePerWeight=this.m_def.staticPressureStrength*criticalPressure;const maxPressure=b2_maxParticlePressure*criticalPressure;const relaxation=this.m_def.staticPressureRelaxation;for(let t=0;t<this.m_def.staticPressureIterations;t++){for(let i=0;i<this.m_count;i++){this.m_accumulationBuffer[i]=0;}for(let k=0;k<this.m_contactBuffer.count;k++){const contact=this.m_contactBuffer.data[k];if(contact.flags&exports.b2ParticleFlag.b2_staticPressureParticle){const a=contact.indexA;const b=contact.indexB;const w=contact.weight;this.m_accumulationBuffer[a]+=w*this.m_staticPressureBuffer[b];this.m_accumulationBuffer[b]+=w*this.m_staticPressureBuffer[a];}}for(let i=0;i<this.m_count;i++){const w=this.m_weightBuffer[i];if(this.m_flagsBuffer.data[i]&exports.b2ParticleFlag.b2_staticPressureParticle){const wh=this.m_accumulationBuffer[i];const h=(wh+pressurePerWeight*(w-b2_minParticleWeight))/(w+relaxation);this.m_staticPressureBuffer[i]=b2Clamp(h,0.0,maxPressure);}else {this.m_staticPressureBuffer[i]=0;}}}}ComputeWeight(){for(let k=0;k<this.m_count;k++){this.m_weightBuffer[k]=0;}for(let k=0;k<this.m_bodyContactBuffer.count;k++){const contact=this.m_bodyContactBuffer.data[k];const a=contact.index;const w=contact.weight;this.m_weightBuffer[a]+=w;}for(let k=0;k<this.m_contactBuffer.count;k++){const contact=this.m_contactBuffer.data[k];const a=contact.indexA;const b=contact.indexB;const w=contact.weight;this.m_weightBuffer[a]+=w;this.m_weightBuffer[b]+=w;}}SolvePressure(step){const s_f=b2ParticleSystem.SolvePressure_s_f;const pos_data=this.m_positionBuffer.data;const vel_data=this.m_velocityBuffer.data;const criticalPressure=this.GetCriticalPressure(step);const pressurePerWeight=this.m_def.pressureStrength*criticalPressure;const maxPressure=b2_maxParticlePressure*criticalPressure;for(let i=0;i<this.m_count;i++){const w=this.m_weightBuffer[i];const h=pressurePerWeight*b2Max(0.0,w-b2_minParticleWeight);this.m_accumulationBuffer[i]=b2Min(h,maxPressure);}if(this.m_allParticleFlags&b2ParticleSystem.k_noPressureFlags){for(let i=0;i<this.m_count;i++){if(this.m_flagsBuffer.data[i]&b2ParticleSystem.k_noPressureFlags){this.m_accumulationBuffer[i]=0;}}}if(this.m_allParticleFlags&exports.b2ParticleFlag.b2_staticPressureParticle){for(let i=0;i<this.m_count;i++){if(this.m_flagsBuffer.data[i]&exports.b2ParticleFlag.b2_staticPressureParticle){this.m_accumulationBuffer[i]+=this.m_staticPressureBuffer[i];}}}const velocityPerPressure=step.dt/(this.m_def.density*this.m_particleDiameter);const inv_mass=this.GetParticleInvMass();for(let k=0;k<this.m_bodyContactBuffer.count;k++){const contact=this.m_bodyContactBuffer.data[k];const a=contact.index;const b=contact.body;const w=contact.weight;const m=contact.mass;const n=contact.normal;const p=pos_data[a];const h=this.m_accumulationBuffer[a]+pressurePerWeight*w;const f=b2Vec2.MulSV(velocityPerPressure*w*m*h,n,s_f);vel_data[a].SelfMulSub(inv_mass,f);b.ApplyLinearImpulse(f,p,true);}for(let k=0;k<this.m_contactBuffer.count;k++){const contact=this.m_contactBuffer.data[k];const a=contact.indexA;const b=contact.indexB;const w=contact.weight;const n=contact.normal;const h=this.m_accumulationBuffer[a]+this.m_accumulationBuffer[b];const f=b2Vec2.MulSV(velocityPerPressure*w*h,n,s_f);vel_data[a].SelfSub(f);vel_data[b].SelfAdd(f);}}SolveDamping(step){const s_v=b2ParticleSystem.SolveDamping_s_v;const s_f=b2ParticleSystem.SolveDamping_s_f;const pos_data=this.m_positionBuffer.data;const vel_data=this.m_velocityBuffer.data;const linearDamping=this.m_def.dampingStrength;const quadraticDamping=1/this.GetCriticalVelocity(step);const inv_mass=this.GetParticleInvMass();for(let k=0;k<this.m_bodyContactBuffer.count;k++){const contact=this.m_bodyContactBuffer.data[k];const a=contact.index;const b=contact.body;const w=contact.weight;const m=contact.mass;const n=contact.normal;const p=pos_data[a];const v=b2Vec2.SubVV(b.GetLinearVelocityFromWorldPoint(p,b2Vec2.s_t0),vel_data[a],s_v);const vn=b2Vec2.DotVV(v,n);if(vn<0){const damping=b2Max(linearDamping*w,b2Min(-quadraticDamping*vn,0.5));const f=b2Vec2.MulSV(damping*m*vn,n,s_f);vel_data[a].SelfMulAdd(inv_mass,f);b.ApplyLinearImpulse(f.SelfNeg(),p,true);}}for(let k=0;k<this.m_contactBuffer.count;k++){const contact=this.m_contactBuffer.data[k];const a=contact.indexA;const b=contact.indexB;const w=contact.weight;const n=contact.normal;const v=b2Vec2.SubVV(vel_data[b],vel_data[a],s_v);const vn=b2Vec2.DotVV(v,n);if(vn<0){const damping=b2Max(linearDamping*w,b2Min(-quadraticDamping*vn,0.5));const f=b2Vec2.MulSV(damping*vn,n,s_f);vel_data[a].SelfAdd(f);vel_data[b].SelfSub(f);}}}SolveRigidDamping(){const s_t0=b2ParticleSystem.SolveRigidDamping_s_t0;const s_t1=b2ParticleSystem.SolveRigidDamping_s_t1;const s_p=b2ParticleSystem.SolveRigidDamping_s_p;const s_v=b2ParticleSystem.SolveRigidDamping_s_v;const invMassA=[0.0],invInertiaA=[0.0],tangentDistanceA=[0.0];const invMassB=[0.0],invInertiaB=[0.0],tangentDistanceB=[0.0];const pos_data=this.m_positionBuffer.data;const damping=this.m_def.dampingStrength;for(let k=0;k<this.m_bodyContactBuffer.count;k++){const contact=this.m_bodyContactBuffer.data[k];const a=contact.index;const aGroup=this.m_groupBuffer[a];if(aGroup&&this.IsRigidGroup(aGroup)){const b=contact.body;const n=contact.normal;const w=contact.weight;const p=pos_data[a];const v=b2Vec2.SubVV(b.GetLinearVelocityFromWorldPoint(p,s_t0),aGroup.GetLinearVelocityFromWorldPoint(p,s_t1),s_v);const vn=b2Vec2.DotVV(v,n);if(vn<0){this.InitDampingParameterWithRigidGroupOrParticle(invMassA,invInertiaA,tangentDistanceA,true,aGroup,a,p,n);this.InitDampingParameter(invMassB,invInertiaB,tangentDistanceB,b.GetMass(),b.GetInertia()-b.GetMass()*b.GetLocalCenter().LengthSquared(),b.GetWorldCenter(),p,n);const f=damping*b2Min(w,1.0)*this.ComputeDampingImpulse(invMassA[0],invInertiaA[0],tangentDistanceA[0],invMassB[0],invInertiaB[0],tangentDistanceB[0],vn);this.ApplyDamping(invMassA[0],invInertiaA[0],tangentDistanceA[0],true,aGroup,a,f,n);b.ApplyLinearImpulse(b2Vec2.MulSV(-f,n,b2Vec2.s_t0),p,true);}}}for(let k=0;k<this.m_contactBuffer.count;k++){const contact=this.m_contactBuffer.data[k];const a=contact.indexA;const b=contact.indexB;const n=contact.normal;const w=contact.weight;const aGroup=this.m_groupBuffer[a];const bGroup=this.m_groupBuffer[b];const aRigid=this.IsRigidGroup(aGroup);const bRigid=this.IsRigidGroup(bGroup);if(aGroup!==bGroup&&(aRigid||bRigid)){const p=b2Vec2.MidVV(pos_data[a],pos_data[b],s_p);const v=b2Vec2.SubVV(this.GetLinearVelocity(bGroup,b,p,s_t0),this.GetLinearVelocity(aGroup,a,p,s_t1),s_v);const vn=b2Vec2.DotVV(v,n);if(vn<0){this.InitDampingParameterWithRigidGroupOrParticle(invMassA,invInertiaA,tangentDistanceA,aRigid,aGroup,a,p,n);this.InitDampingParameterWithRigidGroupOrParticle(invMassB,invInertiaB,tangentDistanceB,bRigid,bGroup,b,p,n);const f=damping*w*this.ComputeDampingImpulse(invMassA[0],invInertiaA[0],tangentDistanceA[0],invMassB[0],invInertiaB[0],tangentDistanceB[0],vn);this.ApplyDamping(invMassA[0],invInertiaA[0],tangentDistanceA[0],aRigid,aGroup,a,f,n);this.ApplyDamping(invMassB[0],invInertiaB[0],tangentDistanceB[0],bRigid,bGroup,b,-f,n);}}}}SolveExtraDamping(){const s_v=b2ParticleSystem.SolveExtraDamping_s_v;const s_f=b2ParticleSystem.SolveExtraDamping_s_f;const vel_data=this.m_velocityBuffer.data;const pos_data=this.m_positionBuffer.data;const inv_mass=this.GetParticleInvMass();for(let k=0;k<this.m_bodyContactBuffer.count;k++){const contact=this.m_bodyContactBuffer.data[k];const a=contact.index;if(this.m_flagsBuffer.data[a]&b2ParticleSystem.k_extraDampingFlags){const b=contact.body;const m=contact.mass;const n=contact.normal;const p=pos_data[a];const v=b2Vec2.SubVV(b.GetLinearVelocityFromWorldPoint(p,b2Vec2.s_t0),vel_data[a],s_v);const vn=b2Vec2.DotVV(v,n);if(vn<0){const f=b2Vec2.MulSV(0.5*m*vn,n,s_f);vel_data[a].SelfMulAdd(inv_mass,f);b.ApplyLinearImpulse(f.SelfNeg(),p,true);}}}}SolveWall(){const vel_data=this.m_velocityBuffer.data;for(let i=0;i<this.m_count;i++){if(this.m_flagsBuffer.data[i]&exports.b2ParticleFlag.b2_wallParticle){vel_data[i].SetZero();}}}SolveRigid(step){const s_position=b2ParticleSystem.SolveRigid_s_position;const s_rotation=b2ParticleSystem.SolveRigid_s_rotation;const s_transform=b2ParticleSystem.SolveRigid_s_transform;const s_velocityTransform=b2ParticleSystem.SolveRigid_s_velocityTransform;const pos_data=this.m_positionBuffer.data;const vel_data=this.m_velocityBuffer.data;for(let group=this.m_groupList;group;group=group.GetNext()){if(group.m_groupFlags&exports.b2ParticleGroupFlag.b2_rigidParticleGroup){group.UpdateStatistics();const rotation=s_rotation;rotation.SetAngle(step.dt*group.m_angularVelocity);const position=b2Vec2.AddVV(group.m_center,b2Vec2.SubVV(b2Vec2.MulSV(step.dt,group.m_linearVelocity,b2Vec2.s_t0),b2Rot.MulRV(rotation,group.m_center,b2Vec2.s_t1),b2Vec2.s_t0),s_position);const transform=s_transform;transform.SetPositionRotation(position,rotation);b2Transform.MulXX(transform,group.m_transform,group.m_transform);const velocityTransform=s_velocityTransform;velocityTransform.p.x=step.inv_dt*transform.p.x;velocityTransform.p.y=step.inv_dt*transform.p.y;velocityTransform.q.s=step.inv_dt*transform.q.s;velocityTransform.q.c=step.inv_dt*(transform.q.c-1);for(let i=group.m_firstIndex;i<group.m_lastIndex;i++){b2Transform.MulXV(velocityTransform,pos_data[i],vel_data[i]);}}}}SolveElastic(step){const s_pa=b2ParticleSystem.SolveElastic_s_pa;const s_pb=b2ParticleSystem.SolveElastic_s_pb;const s_pc=b2ParticleSystem.SolveElastic_s_pc;const s_r=b2ParticleSystem.SolveElastic_s_r;const s_t0=b2ParticleSystem.SolveElastic_s_t0;const pos_data=this.m_positionBuffer.data;const vel_data=this.m_velocityBuffer.data;const elasticStrength=step.inv_dt*this.m_def.elasticStrength;for(let k=0;k<this.m_triadBuffer.count;k++){const triad=this.m_triadBuffer.data[k];if(triad.flags&exports.b2ParticleFlag.b2_elasticParticle){const a=triad.indexA;const b=triad.indexB;const c=triad.indexC;const oa=triad.pa;const ob=triad.pb;const oc=triad.pc;const pa=s_pa.Copy(pos_data[a]);const pb=s_pb.Copy(pos_data[b]);const pc=s_pc.Copy(pos_data[c]);const va=vel_data[a];const vb=vel_data[b];const vc=vel_data[c];pa.SelfMulAdd(step.dt,va);pb.SelfMulAdd(step.dt,vb);pc.SelfMulAdd(step.dt,vc);const midPoint_x=(pa.x+pb.x+pc.x)/3.0;const midPoint_y=(pa.y+pb.y+pc.y)/3.0;pa.x-=midPoint_x;pa.y-=midPoint_y;pb.x-=midPoint_x;pb.y-=midPoint_y;pc.x-=midPoint_x;pc.y-=midPoint_y;const r=s_r;r.s=b2Vec2.CrossVV(oa,pa)+b2Vec2.CrossVV(ob,pb)+b2Vec2.CrossVV(oc,pc);r.c=b2Vec2.DotVV(oa,pa)+b2Vec2.DotVV(ob,pb)+b2Vec2.DotVV(oc,pc);const r2=r.s*r.s+r.c*r.c;let invR=b2InvSqrt(r2);if(!isFinite(invR)){invR=1.98177537e+019;}r.s*=invR;r.c*=invR;const strength=elasticStrength*triad.strength;b2Rot.MulRV(r,oa,s_t0);b2Vec2.SubVV(s_t0,pa,s_t0);b2Vec2.MulSV(strength,s_t0,s_t0);va.SelfAdd(s_t0);b2Rot.MulRV(r,ob,s_t0);b2Vec2.SubVV(s_t0,pb,s_t0);b2Vec2.MulSV(strength,s_t0,s_t0);vb.SelfAdd(s_t0);b2Rot.MulRV(r,oc,s_t0);b2Vec2.SubVV(s_t0,pc,s_t0);b2Vec2.MulSV(strength,s_t0,s_t0);vc.SelfAdd(s_t0);}}}SolveSpring(step){const s_pa=b2ParticleSystem.SolveSpring_s_pa;const s_pb=b2ParticleSystem.SolveSpring_s_pb;const s_d=b2ParticleSystem.SolveSpring_s_d;const s_f=b2ParticleSystem.SolveSpring_s_f;const pos_data=this.m_positionBuffer.data;const vel_data=this.m_velocityBuffer.data;const springStrength=step.inv_dt*this.m_def.springStrength;for(let k=0;k<this.m_pairBuffer.count;k++){const pair=this.m_pairBuffer.data[k];if(pair.flags&exports.b2ParticleFlag.b2_springParticle){const a=pair.indexA;const b=pair.indexB;const pa=s_pa.Copy(pos_data[a]);const pb=s_pb.Copy(pos_data[b]);const va=vel_data[a];const vb=vel_data[b];pa.SelfMulAdd(step.dt,va);pb.SelfMulAdd(step.dt,vb);const d=b2Vec2.SubVV(pb,pa,s_d);const r0=pair.distance;const r1=d.Length();const strength=springStrength*pair.strength;const f=b2Vec2.MulSV(strength*(r0-r1)/r1,d,s_f);va.SelfSub(f);vb.SelfAdd(f);}}}SolveTensile(step){const s_weightedNormal=b2ParticleSystem.SolveTensile_s_weightedNormal;const s_s=b2ParticleSystem.SolveTensile_s_s;const s_f=b2ParticleSystem.SolveTensile_s_f;const vel_data=this.m_velocityBuffer.data;for(let i=0;i<this.m_count;i++){this.m_accumulation2Buffer[i]=new b2Vec2();this.m_accumulation2Buffer[i].SetZero();}for(let k=0;k<this.m_contactBuffer.count;k++){const contact=this.m_contactBuffer.data[k];if(contact.flags&exports.b2ParticleFlag.b2_tensileParticle){const a=contact.indexA;const b=contact.indexB;const w=contact.weight;const n=contact.normal;const weightedNormal=b2Vec2.MulSV((1-w)*w,n,s_weightedNormal);this.m_accumulation2Buffer[a].SelfSub(weightedNormal);this.m_accumulation2Buffer[b].SelfAdd(weightedNormal);}}const criticalVelocity=this.GetCriticalVelocity(step);const pressureStrength=this.m_def.surfaceTensionPressureStrength*criticalVelocity;const normalStrength=this.m_def.surfaceTensionNormalStrength*criticalVelocity;const maxVelocityVariation=b2_maxParticleForce*criticalVelocity;for(let k=0;k<this.m_contactBuffer.count;k++){const contact=this.m_contactBuffer.data[k];if(contact.flags&exports.b2ParticleFlag.b2_tensileParticle){const a=contact.indexA;const b=contact.indexB;const w=contact.weight;const n=contact.normal;const h=this.m_weightBuffer[a]+this.m_weightBuffer[b];const s=b2Vec2.SubVV(this.m_accumulation2Buffer[b],this.m_accumulation2Buffer[a],s_s);const fn=b2Min(pressureStrength*(h-2)+normalStrength*b2Vec2.DotVV(s,n),maxVelocityVariation)*w;const f=b2Vec2.MulSV(fn,n,s_f);vel_data[a].SelfSub(f);vel_data[b].SelfAdd(f);}}}SolveViscous(){const s_v=b2ParticleSystem.SolveViscous_s_v;const s_f=b2ParticleSystem.SolveViscous_s_f;const pos_data=this.m_positionBuffer.data;const vel_data=this.m_velocityBuffer.data;const viscousStrength=this.m_def.viscousStrength;const inv_mass=this.GetParticleInvMass();for(let k=0;k<this.m_bodyContactBuffer.count;k++){const contact=this.m_bodyContactBuffer.data[k];const a=contact.index;if(this.m_flagsBuffer.data[a]&exports.b2ParticleFlag.b2_viscousParticle){const b=contact.body;const w=contact.weight;const m=contact.mass;const p=pos_data[a];const v=b2Vec2.SubVV(b.GetLinearVelocityFromWorldPoint(p,b2Vec2.s_t0),vel_data[a],s_v);const f=b2Vec2.MulSV(viscousStrength*m*w,v,s_f);vel_data[a].SelfMulAdd(inv_mass,f);b.ApplyLinearImpulse(f.SelfNeg(),p,true);}}for(let k=0;k<this.m_contactBuffer.count;k++){const contact=this.m_contactBuffer.data[k];if(contact.flags&exports.b2ParticleFlag.b2_viscousParticle){const a=contact.indexA;const b=contact.indexB;const w=contact.weight;const v=b2Vec2.SubVV(vel_data[b],vel_data[a],s_v);const f=b2Vec2.MulSV(viscousStrength*w,v,s_f);vel_data[a].SelfAdd(f);vel_data[b].SelfSub(f);}}}SolveRepulsive(step){const s_f=b2ParticleSystem.SolveRepulsive_s_f;const vel_data=this.m_velocityBuffer.data;const repulsiveStrength=this.m_def.repulsiveStrength*this.GetCriticalVelocity(step);for(let k=0;k<this.m_contactBuffer.count;k++){const contact=this.m_contactBuffer.data[k];if(contact.flags&exports.b2ParticleFlag.b2_repulsiveParticle){const a=contact.indexA;const b=contact.indexB;if(this.m_groupBuffer[a]!==this.m_groupBuffer[b]){const w=contact.weight;const n=contact.normal;const f=b2Vec2.MulSV(repulsiveStrength*w,n,s_f);vel_data[a].SelfSub(f);vel_data[b].SelfAdd(f);}}}}SolvePowder(step){const s_f=b2ParticleSystem.SolvePowder_s_f;const pos_data=this.m_positionBuffer.data;const vel_data=this.m_velocityBuffer.data;const powderStrength=this.m_def.powderStrength*this.GetCriticalVelocity(step);const minWeight=1.0-b2_particleStride;const inv_mass=this.GetParticleInvMass();for(let k=0;k<this.m_bodyContactBuffer.count;k++){const contact=this.m_bodyContactBuffer.data[k];const a=contact.index;if(this.m_flagsBuffer.data[a]&exports.b2ParticleFlag.b2_powderParticle){const w=contact.weight;if(w>minWeight){const b=contact.body;const m=contact.mass;const p=pos_data[a];const n=contact.normal;const f=b2Vec2.MulSV(powderStrength*m*(w-minWeight),n,s_f);vel_data[a].SelfMulSub(inv_mass,f);b.ApplyLinearImpulse(f,p,true);}}}for(let k=0;k<this.m_contactBuffer.count;k++){const contact=this.m_contactBuffer.data[k];if(contact.flags&exports.b2ParticleFlag.b2_powderParticle){const w=contact.weight;if(w>minWeight){const a=contact.indexA;const b=contact.indexB;const n=contact.normal;const f=b2Vec2.MulSV(powderStrength*(w-minWeight),n,s_f);vel_data[a].SelfSub(f);vel_data[b].SelfAdd(f);}}}}SolveSolid(step){const s_f=b2ParticleSystem.SolveSolid_s_f;const vel_data=this.m_velocityBuffer.data;this.m_depthBuffer=this.RequestBuffer(this.m_depthBuffer);const ejectionStrength=step.inv_dt*this.m_def.ejectionStrength;for(let k=0;k<this.m_contactBuffer.count;k++){const contact=this.m_contactBuffer.data[k];const a=contact.indexA;const b=contact.indexB;if(this.m_groupBuffer[a]!==this.m_groupBuffer[b]){const w=contact.weight;const n=contact.normal;const h=this.m_depthBuffer[a]+this.m_depthBuffer[b];const f=b2Vec2.MulSV(ejectionStrength*h*w,n,s_f);vel_data[a].SelfSub(f);vel_data[b].SelfAdd(f);}}}SolveForce(step){const vel_data=this.m_velocityBuffer.data;const velocityPerForce=step.dt*this.GetParticleInvMass();for(let i=0;i<this.m_count;i++){vel_data[i].SelfMulAdd(velocityPerForce,this.m_forceBuffer[i]);}this.m_hasForce=false;}SolveColorMixing(){const colorMixing=0.5*this.m_def.colorMixingStrength;if(colorMixing){for(let k=0;k<this.m_contactBuffer.count;k++){const contact=this.m_contactBuffer.data[k];const a=contact.indexA;const b=contact.indexB;if(this.m_flagsBuffer.data[a]&this.m_flagsBuffer.data[b]&exports.b2ParticleFlag.b2_colorMixingParticle){const colorA=this.m_colorBuffer.data[a];const colorB=this.m_colorBuffer.data[b];b2Color.MixColors(colorA,colorB,colorMixing);}}}}SolveZombie(){let newCount=0;const newIndices=[];for(let i=0;i<this.m_count;i++){newIndices[i]=b2_invalidParticleIndex;}let allParticleFlags=0;for(let i=0;i<this.m_count;i++){const flags=this.m_flagsBuffer.data[i];if(flags&exports.b2ParticleFlag.b2_zombieParticle){const destructionListener=this.m_world.m_destructionListener;if(flags&exports.b2ParticleFlag.b2_destructionListenerParticle&&destructionListener){destructionListener.SayGoodbyeParticle(this,i);}if(this.m_handleIndexBuffer.data){const handle=this.m_handleIndexBuffer.data[i];if(handle){handle.SetIndex(b2_invalidParticleIndex);this.m_handleIndexBuffer.data[i]=null;}}newIndices[i]=b2_invalidParticleIndex;}else {newIndices[i]=newCount;if(i!==newCount){if(this.m_handleIndexBuffer.data){const handle=this.m_handleIndexBuffer.data[i];if(handle){handle.SetIndex(newCount);}this.m_handleIndexBuffer.data[newCount]=handle;}this.m_flagsBuffer.data[newCount]=this.m_flagsBuffer.data[i];if(this.m_lastBodyContactStepBuffer.data){this.m_lastBodyContactStepBuffer.data[newCount]=this.m_lastBodyContactStepBuffer.data[i];}if(this.m_bodyContactCountBuffer.data){this.m_bodyContactCountBuffer.data[newCount]=this.m_bodyContactCountBuffer.data[i];}if(this.m_consecutiveContactStepsBuffer.data){this.m_consecutiveContactStepsBuffer.data[newCount]=this.m_consecutiveContactStepsBuffer.data[i];}this.m_positionBuffer.data[newCount].Copy(this.m_positionBuffer.data[i]);this.m_velocityBuffer.data[newCount].Copy(this.m_velocityBuffer.data[i]);this.m_groupBuffer[newCount]=this.m_groupBuffer[i];if(this.m_hasForce){this.m_forceBuffer[newCount].Copy(this.m_forceBuffer[i]);}if(this.m_staticPressureBuffer){this.m_staticPressureBuffer[newCount]=this.m_staticPressureBuffer[i];}if(this.m_depthBuffer){this.m_depthBuffer[newCount]=this.m_depthBuffer[i];}if(this.m_colorBuffer.data){this.m_colorBuffer.data[newCount].Copy(this.m_colorBuffer.data[i]);}if(this.m_userDataBuffer.data){this.m_userDataBuffer.data[newCount]=this.m_userDataBuffer.data[i];}if(this.m_expirationTimeBuffer.data){this.m_expirationTimeBuffer.data[newCount]=this.m_expirationTimeBuffer.data[i];}}newCount++;allParticleFlags|=flags;}}const Test={IsProxyInvalid:proxy=>{return proxy.index<0;},IsContactInvalid:contact=>{return contact.indexA<0||contact.indexB<0;},IsBodyContactInvalid:contact=>{return contact.index<0;},IsPairInvalid:pair=>{return pair.indexA<0||pair.indexB<0;},IsTriadInvalid:triad=>{return triad.indexA<0||triad.indexB<0||triad.indexC<0;}};for(let k=0;k<this.m_proxyBuffer.count;k++){const proxy=this.m_proxyBuffer.data[k];proxy.index=newIndices[proxy.index];}this.m_proxyBuffer.RemoveIf(Test.IsProxyInvalid);for(let k=0;k<this.m_contactBuffer.count;k++){const contact=this.m_contactBuffer.data[k];contact.indexA=newIndices[contact.indexA];contact.indexB=newIndices[contact.indexB];}this.m_contactBuffer.RemoveIf(Test.IsContactInvalid);for(let k=0;k<this.m_bodyContactBuffer.count;k++){const contact=this.m_bodyContactBuffer.data[k];contact.index=newIndices[contact.index];}this.m_bodyContactBuffer.RemoveIf(Test.IsBodyContactInvalid);for(let k=0;k<this.m_pairBuffer.count;k++){const pair=this.m_pairBuffer.data[k];pair.indexA=newIndices[pair.indexA];pair.indexB=newIndices[pair.indexB];}this.m_pairBuffer.RemoveIf(Test.IsPairInvalid);for(let k=0;k<this.m_triadBuffer.count;k++){const triad=this.m_triadBuffer.data[k];triad.indexA=newIndices[triad.indexA];triad.indexB=newIndices[triad.indexB];triad.indexC=newIndices[triad.indexC];}this.m_triadBuffer.RemoveIf(Test.IsTriadInvalid);if(this.m_indexByExpirationTimeBuffer.data){let writeOffset=0;for(let readOffset=0;readOffset<this.m_count;readOffset++){const newIndex=newIndices[this.m_indexByExpirationTimeBuffer.data[readOffset]];if(newIndex!==b2_invalidParticleIndex){this.m_indexByExpirationTimeBuffer.data[writeOffset++]=newIndex;}}}for(let group=this.m_groupList;group;group=group.GetNext()){let firstIndex=newCount;let lastIndex=0;let modified=false;for(let i=group.m_firstIndex;i<group.m_lastIndex;i++){const j=newIndices[i];if(j>=0){firstIndex=b2Min(firstIndex,j);lastIndex=b2Max(lastIndex,j+1);}else {modified=true;}}if(firstIndex<lastIndex){group.m_firstIndex=firstIndex;group.m_lastIndex=lastIndex;if(modified){if(group.m_groupFlags&exports.b2ParticleGroupFlag.b2_solidParticleGroup){this.SetGroupFlags(group,group.m_groupFlags|exports.b2ParticleGroupFlag.b2_particleGroupNeedsUpdateDepth);}}}else {group.m_firstIndex=0;group.m_lastIndex=0;if(!(group.m_groupFlags&exports.b2ParticleGroupFlag.b2_particleGroupCanBeEmpty)){this.SetGroupFlags(group,group.m_groupFlags|exports.b2ParticleGroupFlag.b2_particleGroupWillBeDestroyed);}}}this.m_count=newCount;this.m_allParticleFlags=allParticleFlags;this.m_needsUpdateAllParticleFlags=false;for(let group=this.m_groupList;group;){const next=group.GetNext();if(group.m_groupFlags&exports.b2ParticleGroupFlag.b2_particleGroupWillBeDestroyed){this.DestroyParticleGroup(group);}group=next;}}SolveLifetimes(step){this.m_timeElapsed=this.LifetimeToExpirationTime(step.dt);const quantizedTimeElapsed=this.GetQuantizedTimeElapsed();const expirationTimes=this.m_expirationTimeBuffer.data;const expirationTimeIndices=this.m_indexByExpirationTimeBuffer.data;const particleCount=this.GetParticleCount();if(this.m_expirationTimeBufferRequiresSorting){const ExpirationTimeComparator=(particleIndexA,particleIndexB)=>{const expirationTimeA=expirationTimes[particleIndexA];const expirationTimeB=expirationTimes[particleIndexB];const infiniteExpirationTimeA=expirationTimeA<=0.0;const infiniteExpirationTimeB=expirationTimeB<=0.0;return infiniteExpirationTimeA===infiniteExpirationTimeB?expirationTimeA>expirationTimeB:infiniteExpirationTimeA;};std_sort$1(expirationTimeIndices,0,particleCount,ExpirationTimeComparator);this.m_expirationTimeBufferRequiresSorting=false;}for(let i=particleCount-1;i>=0;--i){const particleIndex=expirationTimeIndices[i];const expirationTime=expirationTimes[particleIndex];if(quantizedTimeElapsed<expirationTime||expirationTime<=0){break;}this.DestroyParticle(particleIndex);}}RotateBuffer(start,mid,end){if(start===mid||mid===end){return;}function newIndices(i){if(i<start){return i;}else if(i<mid){return i+end-mid;}else if(i<end){return i+start-mid;}else {return i;}}std_rotate(this.m_flagsBuffer.data,start,mid,end);if(this.m_lastBodyContactStepBuffer.data){std_rotate(this.m_lastBodyContactStepBuffer.data,start,mid,end);}if(this.m_bodyContactCountBuffer.data){std_rotate(this.m_bodyContactCountBuffer.data,start,mid,end);}if(this.m_consecutiveContactStepsBuffer.data){std_rotate(this.m_consecutiveContactStepsBuffer.data,start,mid,end);}std_rotate(this.m_positionBuffer.data,start,mid,end);std_rotate(this.m_velocityBuffer.data,start,mid,end);std_rotate(this.m_groupBuffer,start,mid,end);if(this.m_hasForce){std_rotate(this.m_forceBuffer,start,mid,end);}if(this.m_staticPressureBuffer){std_rotate(this.m_staticPressureBuffer,start,mid,end);}if(this.m_depthBuffer){std_rotate(this.m_depthBuffer,start,mid,end);}if(this.m_colorBuffer.data){std_rotate(this.m_colorBuffer.data,start,mid,end);}if(this.m_userDataBuffer.data){std_rotate(this.m_userDataBuffer.data,start,mid,end);}if(this.m_handleIndexBuffer.data){std_rotate(this.m_handleIndexBuffer.data,start,mid,end);for(let i=start;i<end;++i){const handle=this.m_handleIndexBuffer.data[i];if(handle){handle.SetIndex(newIndices(handle.GetIndex()));}}}if(this.m_expirationTimeBuffer.data){std_rotate(this.m_expirationTimeBuffer.data,start,mid,end);const particleCount=this.GetParticleCount();const indexByExpirationTime=this.m_indexByExpirationTimeBuffer.data;for(let i=0;i<particleCount;++i){indexByExpirationTime[i]=newIndices(indexByExpirationTime[i]);}}for(let k=0;k<this.m_proxyBuffer.count;k++){const proxy=this.m_proxyBuffer.data[k];proxy.index=newIndices(proxy.index);}for(let k=0;k<this.m_contactBuffer.count;k++){const contact=this.m_contactBuffer.data[k];contact.indexA=newIndices(contact.indexA);contact.indexB=newIndices(contact.indexB);}for(let k=0;k<this.m_bodyContactBuffer.count;k++){const contact=this.m_bodyContactBuffer.data[k];contact.index=newIndices(contact.index);}for(let k=0;k<this.m_pairBuffer.count;k++){const pair=this.m_pairBuffer.data[k];pair.indexA=newIndices(pair.indexA);pair.indexB=newIndices(pair.indexB);}for(let k=0;k<this.m_triadBuffer.count;k++){const triad=this.m_triadBuffer.data[k];triad.indexA=newIndices(triad.indexA);triad.indexB=newIndices(triad.indexB);triad.indexC=newIndices(triad.indexC);}for(let group=this.m_groupList;group;group=group.GetNext()){group.m_firstIndex=newIndices(group.m_firstIndex);group.m_lastIndex=newIndices(group.m_lastIndex-1)+1;}}GetCriticalVelocity(step){return this.m_particleDiameter*step.inv_dt;}GetCriticalVelocitySquared(step){const velocity=this.GetCriticalVelocity(step);return velocity*velocity;}GetCriticalPressure(step){return this.m_def.density*this.GetCriticalVelocitySquared(step);}GetParticleStride(){return b2_particleStride*this.m_particleDiameter;}GetParticleMass(){const stride=this.GetParticleStride();return this.m_def.density*stride*stride;}GetParticleInvMass(){const inverseStride=this.m_inverseDiameter*(1.0/b2_particleStride);return this.m_inverseDensity*inverseStride*inverseStride;}GetFixtureContactFilter(){return this.m_allParticleFlags&exports.b2ParticleFlag.b2_fixtureContactFilterParticle?this.m_world.m_contactManager.m_contactFilter:null;}GetParticleContactFilter(){return this.m_allParticleFlags&exports.b2ParticleFlag.b2_particleContactFilterParticle?this.m_world.m_contactManager.m_contactFilter:null;}GetFixtureContactListener(){return this.m_allParticleFlags&exports.b2ParticleFlag.b2_fixtureContactListenerParticle?this.m_world.m_contactManager.m_contactListener:null;}GetParticleContactListener(){return this.m_allParticleFlags&exports.b2ParticleFlag.b2_particleContactListenerParticle?this.m_world.m_contactManager.m_contactListener:null;}SetUserOverridableBuffer(buffer,data){buffer.data=data;buffer.userSuppliedCapacity=data.length;}SetGroupFlags(group,newFlags){const oldFlags=group.m_groupFlags;if((oldFlags^newFlags)&exports.b2ParticleGroupFlag.b2_solidParticleGroup){newFlags|=exports.b2ParticleGroupFlag.b2_particleGroupNeedsUpdateDepth;}if(oldFlags&~newFlags){this.m_needsUpdateAllGroupFlags=true;}if(~this.m_allGroupFlags&newFlags){if(newFlags&exports.b2ParticleGroupFlag.b2_solidParticleGroup){this.m_depthBuffer=this.RequestBuffer(this.m_depthBuffer);}this.m_allGroupFlags|=newFlags;}group.m_groupFlags=newFlags;}static BodyContactCompare(lhs,rhs){if(lhs.index===rhs.index){return lhs.weight>rhs.weight;}return lhs.index<rhs.index;}RemoveSpuriousBodyContacts(){std_sort$1(this.m_bodyContactBuffer.data,0,this.m_bodyContactBuffer.count,b2ParticleSystem.BodyContactCompare);const s_n=b2ParticleSystem.RemoveSpuriousBodyContacts_s_n;const s_pos=b2ParticleSystem.RemoveSpuriousBodyContacts_s_pos;const s_normal=b2ParticleSystem.RemoveSpuriousBodyContacts_s_normal;const k_maxContactsPerPoint=3;const system=this;let lastIndex=-1;let currentContacts=0;const b2ParticleBodyContactRemovePredicate=contact=>{if(contact.index!==lastIndex){currentContacts=0;lastIndex=contact.index;}if(currentContacts++>k_maxContactsPerPoint){return true;}const n=s_n.Copy(contact.normal);n.SelfMul(system.m_particleDiameter*(1-contact.weight));const pos=b2Vec2.AddVV(system.m_positionBuffer.data[contact.index],n,s_pos);if(!contact.fixture.TestPoint(pos)){const childCount=contact.fixture.GetShape().GetChildCount();for(let childIndex=0;childIndex<childCount;childIndex++){const normal=s_normal;const distance=contact.fixture.ComputeDistance(pos,normal,childIndex);if(distance<b2_linearSlop){return false;}}return true;}return false;};this.m_bodyContactBuffer.count=std_remove_if(this.m_bodyContactBuffer.data,b2ParticleBodyContactRemovePredicate,this.m_bodyContactBuffer.count);}DetectStuckParticle(particle){if(this.m_stuckThreshold<=0){return;}++this.m_bodyContactCountBuffer.data[particle];if(this.m_bodyContactCountBuffer.data[particle]===2){++this.m_consecutiveContactStepsBuffer.data[particle];if(this.m_consecutiveContactStepsBuffer.data[particle]>this.m_stuckThreshold){this.m_stuckParticleBuffer.data[this.m_stuckParticleBuffer.Append()]=particle;}}this.m_lastBodyContactStepBuffer.data[particle]=this.m_timestamp;}ValidateParticleIndex(index){return index>=0&&index<this.GetParticleCount()&&index!==b2_invalidParticleIndex;}GetQuantizedTimeElapsed(){return Math.floor(this.m_timeElapsed/0x100000000);}LifetimeToExpirationTime(lifetime){return this.m_timeElapsed+Math.floor(lifetime/this.m_def.lifetimeGranularity*0x100000000);}ForceCanBeApplied(flags){return !(flags&exports.b2ParticleFlag.b2_wallParticle);}PrepareForceBuffer(){if(!this.m_hasForce){for(let i=0;i<this.m_count;i++){this.m_forceBuffer[i].SetZero();}this.m_hasForce=true;}}IsRigidGroup(group){return group!==null&&(group.m_groupFlags&exports.b2ParticleGroupFlag.b2_rigidParticleGroup)!==0;}GetLinearVelocity(group,particleIndex,point,out){if(group&&this.IsRigidGroup(group)){return group.GetLinearVelocityFromWorldPoint(point,out);}else {return out.Copy(this.m_velocityBuffer.data[particleIndex]);}}InitDampingParameter(invMass,invInertia,tangentDistance,mass,inertia,center,point,normal){invMass[0]=mass>0?1/mass:0;invInertia[0]=inertia>0?1/inertia:0;tangentDistance[0]=b2Vec2.CrossVV(b2Vec2.SubVV(point,center,b2Vec2.s_t0),normal);}InitDampingParameterWithRigidGroupOrParticle(invMass,invInertia,tangentDistance,isRigidGroup,group,particleIndex,point,normal){if(group&&isRigidGroup){this.InitDampingParameter(invMass,invInertia,tangentDistance,group.GetMass(),group.GetInertia(),group.GetCenter(),point,normal);}else {const flags=this.m_flagsBuffer.data[particleIndex];this.InitDampingParameter(invMass,invInertia,tangentDistance,flags&exports.b2ParticleFlag.b2_wallParticle?0:this.GetParticleMass(),0,point,point,normal);}}ComputeDampingImpulse(invMassA,invInertiaA,tangentDistanceA,invMassB,invInertiaB,tangentDistanceB,normalVelocity){const invMass=invMassA+invInertiaA*tangentDistanceA*tangentDistanceA+invMassB+invInertiaB*tangentDistanceB*tangentDistanceB;return invMass>0?normalVelocity/invMass:0;}ApplyDamping(invMass,invInertia,tangentDistance,isRigidGroup,group,particleIndex,impulse,normal){if(group&&isRigidGroup){group.m_linearVelocity.SelfMulAdd(impulse*invMass,normal);group.m_angularVelocity+=impulse*tangentDistance*invInertia;}else {this.m_velocityBuffer.data[particleIndex].SelfMulAdd(impulse*invMass,normal);}}}b2ParticleSystem.xTruncBits=12;b2ParticleSystem.yTruncBits=12;b2ParticleSystem.tagBits=8*4;b2ParticleSystem.yOffset=1<<b2ParticleSystem.yTruncBits-1;b2ParticleSystem.yShift=b2ParticleSystem.tagBits-b2ParticleSystem.yTruncBits;b2ParticleSystem.xShift=b2ParticleSystem.tagBits-b2ParticleSystem.yTruncBits-b2ParticleSystem.xTruncBits;b2ParticleSystem.xScale=1<<b2ParticleSystem.xShift;b2ParticleSystem.xOffset=b2ParticleSystem.xScale*(1<<b2ParticleSystem.xTruncBits-1);b2ParticleSystem.yMask=(1<<b2ParticleSystem.yTruncBits)-1<<b2ParticleSystem.yShift;b2ParticleSystem.xMask=~b2ParticleSystem.yMask;b2ParticleSystem.DestroyParticlesInShape_s_aabb=new b2AABB();b2ParticleSystem.CreateParticleGroup_s_transform=new b2Transform();b2ParticleSystem.ComputeCollisionEnergy_s_v=new b2Vec2();b2ParticleSystem.QueryShapeAABB_s_aabb=new b2AABB();b2ParticleSystem.QueryPointAABB_s_aabb=new b2AABB();b2ParticleSystem.RayCast_s_aabb=new b2AABB();b2ParticleSystem.RayCast_s_p=new b2Vec2();b2ParticleSystem.RayCast_s_v=new b2Vec2();b2ParticleSystem.RayCast_s_n=new b2Vec2();b2ParticleSystem.RayCast_s_point=new b2Vec2();b2ParticleSystem.k_pairFlags=exports.b2ParticleFlag.b2_springParticle;b2ParticleSystem.k_triadFlags=exports.b2ParticleFlag.b2_elasticParticle;b2ParticleSystem.k_noPressureFlags=exports.b2ParticleFlag.b2_powderParticle|exports.b2ParticleFlag.b2_tensileParticle;b2ParticleSystem.k_extraDampingFlags=exports.b2ParticleFlag.b2_staticPressureParticle;b2ParticleSystem.k_barrierWallFlags=exports.b2ParticleFlag.b2_barrierParticle|exports.b2ParticleFlag.b2_wallParticle;b2ParticleSystem.CreateParticlesStrokeShapeForGroup_s_edge=new b2EdgeShape();b2ParticleSystem.CreateParticlesStrokeShapeForGroup_s_d=new b2Vec2();b2ParticleSystem.CreateParticlesStrokeShapeForGroup_s_p=new b2Vec2();b2ParticleSystem.CreateParticlesFillShapeForGroup_s_aabb=new b2AABB();b2ParticleSystem.CreateParticlesFillShapeForGroup_s_p=new b2Vec2();b2ParticleSystem.UpdatePairsAndTriads_s_dab=new b2Vec2();b2ParticleSystem.UpdatePairsAndTriads_s_dbc=new b2Vec2();b2ParticleSystem.UpdatePairsAndTriads_s_dca=new b2Vec2();b2ParticleSystem.AddContact_s_d=new b2Vec2();b2ParticleSystem.UpdateBodyContacts_s_aabb=new b2AABB();b2ParticleSystem.Solve_s_subStep=new b2TimeStep();b2ParticleSystem.SolveCollision_s_aabb=new b2AABB();b2ParticleSystem.SolveGravity_s_gravity=new b2Vec2();b2ParticleSystem.SolveBarrier_s_aabb=new b2AABB();b2ParticleSystem.SolveBarrier_s_va=new b2Vec2();b2ParticleSystem.SolveBarrier_s_vb=new b2Vec2();b2ParticleSystem.SolveBarrier_s_pba=new b2Vec2();b2ParticleSystem.SolveBarrier_s_vba=new b2Vec2();b2ParticleSystem.SolveBarrier_s_vc=new b2Vec2();b2ParticleSystem.SolveBarrier_s_pca=new b2Vec2();b2ParticleSystem.SolveBarrier_s_vca=new b2Vec2();b2ParticleSystem.SolveBarrier_s_qba=new b2Vec2();b2ParticleSystem.SolveBarrier_s_qca=new b2Vec2();b2ParticleSystem.SolveBarrier_s_dv=new b2Vec2();b2ParticleSystem.SolveBarrier_s_f=new b2Vec2();b2ParticleSystem.SolvePressure_s_f=new b2Vec2();b2ParticleSystem.SolveDamping_s_v=new b2Vec2();b2ParticleSystem.SolveDamping_s_f=new b2Vec2();b2ParticleSystem.SolveRigidDamping_s_t0=new b2Vec2();b2ParticleSystem.SolveRigidDamping_s_t1=new b2Vec2();b2ParticleSystem.SolveRigidDamping_s_p=new b2Vec2();b2ParticleSystem.SolveRigidDamping_s_v=new b2Vec2();b2ParticleSystem.SolveExtraDamping_s_v=new b2Vec2();b2ParticleSystem.SolveExtraDamping_s_f=new b2Vec2();b2ParticleSystem.SolveRigid_s_position=new b2Vec2();b2ParticleSystem.SolveRigid_s_rotation=new b2Rot();b2ParticleSystem.SolveRigid_s_transform=new b2Transform();b2ParticleSystem.SolveRigid_s_velocityTransform=new b2Transform();b2ParticleSystem.SolveElastic_s_pa=new b2Vec2();b2ParticleSystem.SolveElastic_s_pb=new b2Vec2();b2ParticleSystem.SolveElastic_s_pc=new b2Vec2();b2ParticleSystem.SolveElastic_s_r=new b2Rot();b2ParticleSystem.SolveElastic_s_t0=new b2Vec2();b2ParticleSystem.SolveSpring_s_pa=new b2Vec2();b2ParticleSystem.SolveSpring_s_pb=new b2Vec2();b2ParticleSystem.SolveSpring_s_d=new b2Vec2();b2ParticleSystem.SolveSpring_s_f=new b2Vec2();b2ParticleSystem.SolveTensile_s_weightedNormal=new b2Vec2();b2ParticleSystem.SolveTensile_s_s=new b2Vec2();b2ParticleSystem.SolveTensile_s_f=new b2Vec2();b2ParticleSystem.SolveViscous_s_v=new b2Vec2();b2ParticleSystem.SolveViscous_s_f=new b2Vec2();b2ParticleSystem.SolveRepulsive_s_f=new b2Vec2();b2ParticleSystem.SolvePowder_s_f=new b2Vec2();b2ParticleSystem.SolveSolid_s_f=new b2Vec2();b2ParticleSystem.RemoveSpuriousBodyContacts_s_n=new b2Vec2();b2ParticleSystem.RemoveSpuriousBodyContacts_s_pos=new b2Vec2();b2ParticleSystem.RemoveSpuriousBodyContacts_s_normal=new b2Vec2();class b2ParticleSystem_UserOverridableBuffer{constructor(){this._data=null;this.userSuppliedCapacity=0;}get data(){return this._data;}set data(value){this._data=value;}}class b2ParticleSystem_Proxy{constructor(){this.index=b2_invalidParticleIndex;this.tag=0;}static CompareProxyProxy(a,b){return a.tag<b.tag;}static CompareTagProxy(a,b){return a<b.tag;}static CompareProxyTag(a,b){return a.tag<b;}}class b2ParticleSystem_InsideBoundsEnumerator{constructor(system,lower,upper,first,last){this.m_system=system;this.m_xLower=(lower&b2ParticleSystem.xMask)>>>0;this.m_xUpper=(upper&b2ParticleSystem.xMask)>>>0;this.m_yLower=(lower&b2ParticleSystem.yMask)>>>0;this.m_yUpper=(upper&b2ParticleSystem.yMask)>>>0;this.m_first=first;this.m_last=last;}GetNext(){while(this.m_first<this.m_last){const xTag=(this.m_system.m_proxyBuffer.data[this.m_first].tag&b2ParticleSystem.xMask)>>>0;if(xTag>=this.m_xLower&&xTag<=this.m_xUpper){return this.m_system.m_proxyBuffer.data[this.m_first++].index;}this.m_first++;}return b2_invalidParticleIndex;}}class b2ParticleSystem_ParticleListNode{constructor(){this.next=null;this.count=0;this.index=0;}}class b2ParticleSystem_FixedSetAllocator{Allocate(itemSize,count){return count;}Clear(){}GetCount(){return 0;}Invalidate(itemIndex){}GetValidBuffer(){return [];}GetBuffer(){return [];}SetCount(count){}}class b2ParticleSystem_FixtureParticle{constructor(fixture,particle){this.second=b2_invalidParticleIndex;this.first=fixture;this.second=particle;}}class b2ParticleSystem_FixtureParticleSet extends b2ParticleSystem_FixedSetAllocator{Initialize(bodyContactBuffer,flagsBuffer){}Find(pair){return b2_invalidParticleIndex;}}class b2ParticleSystem_ParticlePair{constructor(particleA,particleB){this.first=b2_invalidParticleIndex;this.second=b2_invalidParticleIndex;this.first=particleA;this.second=particleB;}}class b2ParticlePairSet extends b2ParticleSystem_FixedSetAllocator{Initialize(contactBuffer,flagsBuffer){}Find(pair){return b2_invalidParticleIndex;}}class b2ParticleSystem_ConnectionFilter{IsNecessary(index){return true;}ShouldCreatePair(a,b){return true;}ShouldCreateTriad(a,b,c){return true;}}class b2ParticleSystem_DestroyParticlesInShapeCallback extends b2QueryCallback{constructor(system,shape,xf,callDestructionListener){super();this.m_callDestructionListener=false;this.m_destroyed=0;this.m_system=system;this.m_shape=shape;this.m_xf=xf;this.m_callDestructionListener=callDestructionListener;this.m_destroyed=0;}ReportFixture(fixture){return false;}ReportParticle(particleSystem,index){if(particleSystem!==this.m_system){return false;}if(this.m_shape.TestPoint(this.m_xf,this.m_system.m_positionBuffer.data[index])){this.m_system.DestroyParticle(index,this.m_callDestructionListener);this.m_destroyed++;}return true;}Destroyed(){return this.m_destroyed;}}class b2ParticleSystem_JoinParticleGroupsFilter extends b2ParticleSystem_ConnectionFilter{constructor(threshold){super();this.m_threshold=0;this.m_threshold=threshold;}ShouldCreatePair(a,b){return a<this.m_threshold&&this.m_threshold<=b||b<this.m_threshold&&this.m_threshold<=a;}ShouldCreateTriad(a,b,c){return (a<this.m_threshold||b<this.m_threshold||c<this.m_threshold)&&(this.m_threshold<=a||this.m_threshold<=b||this.m_threshold<=c);}}class b2ParticleSystem_CompositeShape extends b2Shape{constructor(shapes,shapeCount=shapes.length){super(exports.b2ShapeType.e_unknown,0);this.m_shapeCount=0;this.m_shapes=shapes;this.m_shapeCount=shapeCount;}Clone(){throw new Error();}GetChildCount(){return 1;}TestPoint(xf,p){for(let i=0;i<this.m_shapeCount;i++){if(this.m_shapes[i].TestPoint(xf,p)){return true;}}return false;}ComputeDistance(xf,p,normal,childIndex){return 0;}RayCast(output,input,xf,childIndex){return false;}ComputeAABB(aabb,xf,childIndex){const s_subaabb=new b2AABB();aabb.lowerBound.x=+b2_maxFloat;aabb.lowerBound.y=+b2_maxFloat;aabb.upperBound.x=-b2_maxFloat;aabb.upperBound.y=-b2_maxFloat;for(let i=0;i<this.m_shapeCount;i++){const childCount=this.m_shapes[i].GetChildCount();for(let j=0;j<childCount;j++){const subaabb=s_subaabb;this.m_shapes[i].ComputeAABB(subaabb,xf,j);aabb.Combine1(subaabb);}}}ComputeMass(massData,density){}SetupDistanceProxy(proxy,index){}ComputeSubmergedArea(normal,offset,xf,c){return 0;}Dump(log){}}class b2ParticleSystem_ReactiveFilter extends b2ParticleSystem_ConnectionFilter{constructor(flagsBuffer){super();this.m_flagsBuffer=flagsBuffer;}IsNecessary(index){return (this.m_flagsBuffer.data[index]&exports.b2ParticleFlag.b2_reactiveParticle)!==0;}}class b2ParticleSystem_UpdateBodyContactsCallback extends b2FixtureParticleQueryCallback{constructor(system,contactFilter=null){super(system);this.m_contactFilter=null;this.m_contactFilter=contactFilter;}ShouldCollideFixtureParticle(fixture,particleSystem,particleIndex){if(this.m_contactFilter){const flags=this.m_system.GetFlagsBuffer();if(flags[particleIndex]&exports.b2ParticleFlag.b2_fixtureContactFilterParticle){return this.m_contactFilter.ShouldCollideFixtureParticle(fixture,this.m_system,particleIndex);}}return true;}ReportFixtureAndParticle(fixture,childIndex,a){const s_n=b2ParticleSystem_UpdateBodyContactsCallback.ReportFixtureAndParticle_s_n;const s_rp=b2ParticleSystem_UpdateBodyContactsCallback.ReportFixtureAndParticle_s_rp;const ap=this.m_system.m_positionBuffer.data[a];const n=s_n;const d=fixture.ComputeDistance(ap,n,childIndex);if(d<this.m_system.m_particleDiameter&&this.ShouldCollideFixtureParticle(fixture,this.m_system,a)){const b=fixture.GetBody();const bp=b.GetWorldCenter();const bm=b.GetMass();const bI=b.GetInertia()-bm*b.GetLocalCenter().LengthSquared();const invBm=bm>0?1/bm:0;const invBI=bI>0?1/bI:0;const invAm=this.m_system.m_flagsBuffer.data[a]&exports.b2ParticleFlag.b2_wallParticle?0:this.m_system.GetParticleInvMass();const rp=b2Vec2.SubVV(ap,bp,s_rp);const rpn=b2Vec2.CrossVV(rp,n);const invM=invAm+invBm+invBI*rpn*rpn;const contact=this.m_system.m_bodyContactBuffer.data[this.m_system.m_bodyContactBuffer.Append()];contact.index=a;contact.body=b;contact.fixture=fixture;contact.weight=1-d*this.m_system.m_inverseDiameter;contact.normal.Copy(n.SelfNeg());contact.mass=invM>0?1/invM:0;this.m_system.DetectStuckParticle(a);}}}b2ParticleSystem_UpdateBodyContactsCallback.ReportFixtureAndParticle_s_n=new b2Vec2();b2ParticleSystem_UpdateBodyContactsCallback.ReportFixtureAndParticle_s_rp=new b2Vec2();class b2ParticleSystem_SolveCollisionCallback extends b2FixtureParticleQueryCallback{constructor(system,step){super(system);this.m_step=step;}ReportFixtureAndParticle(fixture,childIndex,a){const s_p1=b2ParticleSystem_SolveCollisionCallback.ReportFixtureAndParticle_s_p1;const s_output=b2ParticleSystem_SolveCollisionCallback.ReportFixtureAndParticle_s_output;const s_input=b2ParticleSystem_SolveCollisionCallback.ReportFixtureAndParticle_s_input;const s_p=b2ParticleSystem_SolveCollisionCallback.ReportFixtureAndParticle_s_p;const s_v=b2ParticleSystem_SolveCollisionCallback.ReportFixtureAndParticle_s_v;const s_f=b2ParticleSystem_SolveCollisionCallback.ReportFixtureAndParticle_s_f;const body=fixture.GetBody();const ap=this.m_system.m_positionBuffer.data[a];const av=this.m_system.m_velocityBuffer.data[a];const output=s_output;const input=s_input;if(this.m_system.m_iterationIndex===0){const p1=b2Transform.MulTXV(body.m_xf0,ap,s_p1);if(fixture.GetShape().GetType()===exports.b2ShapeType.e_circleShape){p1.SelfSub(body.GetLocalCenter());b2Rot.MulRV(body.m_xf0.q,p1,p1);b2Rot.MulTRV(body.m_xf.q,p1,p1);p1.SelfAdd(body.GetLocalCenter());}b2Transform.MulXV(body.m_xf,p1,input.p1);}else {input.p1.Copy(ap);}b2Vec2.AddVMulSV(ap,this.m_step.dt,av,input.p2);input.maxFraction=1;if(fixture.RayCast(output,input,childIndex)){const n=output.normal;const p=s_p;p.x=(1-output.fraction)*input.p1.x+output.fraction*input.p2.x+b2_linearSlop*n.x;p.y=(1-output.fraction)*input.p1.y+output.fraction*input.p2.y+b2_linearSlop*n.y;const v=s_v;v.x=this.m_step.inv_dt*(p.x-ap.x);v.y=this.m_step.inv_dt*(p.y-ap.y);this.m_system.m_velocityBuffer.data[a].Copy(v);const f=s_f;f.x=this.m_step.inv_dt*this.m_system.GetParticleMass()*(av.x-v.x);f.y=this.m_step.inv_dt*this.m_system.GetParticleMass()*(av.y-v.y);this.m_system.ParticleApplyForce(a,f);}}ReportParticle(system,index){return false;}}b2ParticleSystem_SolveCollisionCallback.ReportFixtureAndParticle_s_p1=new b2Vec2();b2ParticleSystem_SolveCollisionCallback.ReportFixtureAndParticle_s_output=new b2RayCastOutput();b2ParticleSystem_SolveCollisionCallback.ReportFixtureAndParticle_s_input=new b2RayCastInput();b2ParticleSystem_SolveCollisionCallback.ReportFixtureAndParticle_s_p=new b2Vec2();b2ParticleSystem_SolveCollisionCallback.ReportFixtureAndParticle_s_v=new b2Vec2();b2ParticleSystem_SolveCollisionCallback.ReportFixtureAndParticle_s_f=new b2Vec2();class b2World{constructor(gravity){this.m_newFixture=false;this.m_locked=false;this.m_clearForces=true;this.m_contactManager=new b2ContactManager();this.m_bodyList=null;this.m_jointList=null;this.m_particleSystemList=null;this.m_bodyCount=0;this.m_jointCount=0;this.m_gravity=new b2Vec2();this.m_allowSleep=true;this.m_destructionListener=null;this.m_debugDraw=null;this.m_inv_dt0=0;this.m_warmStarting=true;this.m_continuousPhysics=true;this.m_subStepping=false;this.m_stepComplete=true;this.m_profile=new b2Profile();this.m_island=new b2Island();this.s_stack=[];this.m_controllerList=null;this.m_controllerCount=0;this.m_gravity.Copy(gravity);}SetDestructionListener(listener){this.m_destructionListener=listener;}SetContactFilter(filter){this.m_contactManager.m_contactFilter=filter;}SetContactListener(listener){this.m_contactManager.m_contactListener=listener;}SetDebugDraw(debugDraw){this.m_debugDraw=debugDraw;}CreateBody(def={}){if(this.IsLocked()){throw new Error();}const b=new b2Body(def,this);b.m_prev=null;b.m_next=this.m_bodyList;if(this.m_bodyList){this.m_bodyList.m_prev=b;}this.m_bodyList=b;++this.m_bodyCount;return b;}DestroyBody(b){if(this.IsLocked()){throw new Error();}let je=b.m_jointList;while(je){const je0=je;je=je.next;if(this.m_destructionListener){this.m_destructionListener.SayGoodbyeJoint(je0.joint);}this.DestroyJoint(je0.joint);b.m_jointList=je;}b.m_jointList=null;let coe=b.m_controllerList;while(coe){const coe0=coe;coe=coe.nextController;coe0.controller.RemoveBody(b);}let ce=b.m_contactList;while(ce){const ce0=ce;ce=ce.next;this.m_contactManager.Destroy(ce0.contact);}b.m_contactList=null;let f=b.m_fixtureList;while(f){const f0=f;f=f.m_next;if(this.m_destructionListener){this.m_destructionListener.SayGoodbyeFixture(f0);}f0.DestroyProxies();f0.Reset();b.m_fixtureList=f;b.m_fixtureCount-=1;}b.m_fixtureList=null;b.m_fixtureCount=0;if(b.m_prev){b.m_prev.m_next=b.m_next;}if(b.m_next){b.m_next.m_prev=b.m_prev;}if(b===this.m_bodyList){this.m_bodyList=b.m_next;}--this.m_bodyCount;}static _Joint_Create(def){switch(def.type){case exports.b2JointType.e_distanceJoint:return new b2DistanceJoint(def);case exports.b2JointType.e_mouseJoint:return new b2MouseJoint(def);case exports.b2JointType.e_prismaticJoint:return new b2PrismaticJoint(def);case exports.b2JointType.e_revoluteJoint:return new b2RevoluteJoint(def);case exports.b2JointType.e_pulleyJoint:return new b2PulleyJoint(def);case exports.b2JointType.e_gearJoint:return new b2GearJoint(def);case exports.b2JointType.e_wheelJoint:return new b2WheelJoint(def);case exports.b2JointType.e_weldJoint:return new b2WeldJoint(def);case exports.b2JointType.e_frictionJoint:return new b2FrictionJoint(def);case exports.b2JointType.e_ropeJoint:return new b2RopeJoint(def);case exports.b2JointType.e_motorJoint:return new b2MotorJoint(def);case exports.b2JointType.e_areaJoint:return new b2AreaJoint(def);}throw new Error();}static _Joint_Destroy(joint){}CreateJoint(def){if(this.IsLocked()){throw new Error();}const j=b2World._Joint_Create(def);j.m_prev=null;j.m_next=this.m_jointList;if(this.m_jointList){this.m_jointList.m_prev=j;}this.m_jointList=j;++this.m_jointCount;j.m_edgeA.prev=null;j.m_edgeA.next=j.m_bodyA.m_jointList;if(j.m_bodyA.m_jointList){j.m_bodyA.m_jointList.prev=j.m_edgeA;}j.m_bodyA.m_jointList=j.m_edgeA;j.m_edgeB.prev=null;j.m_edgeB.next=j.m_bodyB.m_jointList;if(j.m_bodyB.m_jointList){j.m_bodyB.m_jointList.prev=j.m_edgeB;}j.m_bodyB.m_jointList=j.m_edgeB;const bodyA=j.m_bodyA;const bodyB=j.m_bodyB;const collideConnected=j.m_collideConnected;if(!collideConnected){let edge=bodyB.GetContactList();while(edge){if(edge.other===bodyA){edge.contact.FlagForFiltering();}edge=edge.next;}}return j;}DestroyJoint(j){if(this.IsLocked()){throw new Error();}if(j.m_prev){j.m_prev.m_next=j.m_next;}if(j.m_next){j.m_next.m_prev=j.m_prev;}if(j===this.m_jointList){this.m_jointList=j.m_next;}const bodyA=j.m_bodyA;const bodyB=j.m_bodyB;const collideConnected=j.m_collideConnected;bodyA.SetAwake(true);bodyB.SetAwake(true);if(j.m_edgeA.prev){j.m_edgeA.prev.next=j.m_edgeA.next;}if(j.m_edgeA.next){j.m_edgeA.next.prev=j.m_edgeA.prev;}if(j.m_edgeA===bodyA.m_jointList){bodyA.m_jointList=j.m_edgeA.next;}j.m_edgeA.Reset();if(j.m_edgeB.prev){j.m_edgeB.prev.next=j.m_edgeB.next;}if(j.m_edgeB.next){j.m_edgeB.next.prev=j.m_edgeB.prev;}if(j.m_edgeB===bodyB.m_jointList){bodyB.m_jointList=j.m_edgeB.next;}j.m_edgeB.Reset();b2World._Joint_Destroy(j);--this.m_jointCount;if(!collideConnected){let edge=bodyB.GetContactList();while(edge){if(edge.other===bodyA){edge.contact.FlagForFiltering();}edge=edge.next;}}}CreateParticleSystem(def){if(this.IsLocked()){throw new Error();}const p=new b2ParticleSystem(def,this);p.m_prev=null;p.m_next=this.m_particleSystemList;if(this.m_particleSystemList){this.m_particleSystemList.m_prev=p;}this.m_particleSystemList=p;return p;}DestroyParticleSystem(p){if(this.IsLocked()){throw new Error();}if(p.m_prev){p.m_prev.m_next=p.m_next;}if(p.m_next){p.m_next.m_prev=p.m_prev;}if(p===this.m_particleSystemList){this.m_particleSystemList=p.m_next;}}CalculateReasonableParticleIterations(timeStep){if(this.m_particleSystemList===null){return 1;}function GetSmallestRadius(world){let smallestRadius=b2_maxFloat;for(let system=world.GetParticleSystemList();system!==null;system=system.m_next){smallestRadius=b2Min(smallestRadius,system.GetRadius());}return smallestRadius;}return b2CalculateParticleIterations(this.m_gravity.Length(),GetSmallestRadius(this),timeStep);}Step(dt,velocityIterations,positionIterations,particleIterations=this.CalculateReasonableParticleIterations(dt)){const stepTimer=b2World.Step_s_stepTimer.Reset();if(this.m_newFixture){this.m_contactManager.FindNewContacts();this.m_newFixture=false;}this.m_locked=true;const step=b2World.Step_s_step;step.dt=dt;step.velocityIterations=velocityIterations;step.positionIterations=positionIterations;step.particleIterations=particleIterations;if(dt>0){step.inv_dt=1/dt;}else {step.inv_dt=0;}step.dtRatio=this.m_inv_dt0*dt;step.warmStarting=this.m_warmStarting;const timer=b2World.Step_s_timer.Reset();this.m_contactManager.Collide();this.m_profile.collide=timer.GetMilliseconds();if(this.m_stepComplete&&step.dt>0){const timer=b2World.Step_s_timer.Reset();for(let p=this.m_particleSystemList;p;p=p.m_next){p.Solve(step);}this.Solve(step);this.m_profile.solve=timer.GetMilliseconds();}if(this.m_continuousPhysics&&step.dt>0){const timer=b2World.Step_s_timer.Reset();this.SolveTOI(step);this.m_profile.solveTOI=timer.GetMilliseconds();}if(step.dt>0){this.m_inv_dt0=step.inv_dt;}if(this.m_clearForces){this.ClearForces();}this.m_locked=false;this.m_profile.step=stepTimer.GetMilliseconds();}ClearForces(){for(let body=this.m_bodyList;body;body=body.m_next){body.m_force.SetZero();body.m_torque=0;}}DrawParticleSystem(system){if(this.m_debugDraw===null){return;}const particleCount=system.GetParticleCount();if(particleCount){const radius=system.GetRadius();const positionBuffer=system.GetPositionBuffer();if(system.m_colorBuffer.data){const colorBuffer=system.GetColorBuffer();this.m_debugDraw.DrawParticles(positionBuffer,radius,colorBuffer,particleCount);}else {this.m_debugDraw.DrawParticles(positionBuffer,radius,null,particleCount);}}}DrawDebugData(){if(this.m_debugDraw===null){return;}const flags=this.m_debugDraw.GetFlags();const color=b2World.DrawDebugData_s_color.SetRGB(0,0,0);if(flags&exports.b2DrawFlags.e_shapeBit){for(let b=this.m_bodyList;b;b=b.m_next){const xf=b.m_xf;this.m_debugDraw.PushTransform(xf);for(let f=b.GetFixtureList();f;f=f.m_next){if(!b.IsActive()){color.SetRGB(0.5,0.5,0.3);this.DrawShape(f,color);}else if(b.GetType()===exports.b2BodyType.b2_staticBody){color.SetRGB(0.5,0.9,0.5);this.DrawShape(f,color);}else if(b.GetType()===exports.b2BodyType.b2_kinematicBody){color.SetRGB(0.5,0.5,0.9);this.DrawShape(f,color);}else if(!b.IsAwake()){color.SetRGB(0.6,0.6,0.6);this.DrawShape(f,color);}else {color.SetRGB(0.9,0.7,0.7);this.DrawShape(f,color);}}this.m_debugDraw.PopTransform(xf);}}if(flags&exports.b2DrawFlags.e_particleBit){for(let p=this.m_particleSystemList;p;p=p.m_next){this.DrawParticleSystem(p);}}if(flags&exports.b2DrawFlags.e_jointBit){for(let j=this.m_jointList;j;j=j.m_next){this.DrawJoint(j);}}if(flags&exports.b2DrawFlags.e_aabbBit){color.SetRGB(0.9,0.3,0.9);const vs=b2World.DrawDebugData_s_vs;for(let b=this.m_bodyList;b;b=b.m_next){if(!b.IsActive()){continue;}for(let f=b.GetFixtureList();f;f=f.m_next){for(let i=0;i<f.m_proxyCount;++i){const proxy=f.m_proxies[i];const aabb=proxy.treeNode.aabb;vs[0].Set(aabb.lowerBound.x,aabb.lowerBound.y);vs[1].Set(aabb.upperBound.x,aabb.lowerBound.y);vs[2].Set(aabb.upperBound.x,aabb.upperBound.y);vs[3].Set(aabb.lowerBound.x,aabb.upperBound.y);this.m_debugDraw.DrawPolygon(vs,4,color);}}}}if(flags&exports.b2DrawFlags.e_centerOfMassBit){for(let b=this.m_bodyList;b;b=b.m_next){const xf=b2World.DrawDebugData_s_xf;xf.q.Copy(b.m_xf.q);xf.p.Copy(b.GetWorldCenter());this.m_debugDraw.DrawTransform(xf);}}if(flags&exports.b2DrawFlags.e_controllerBit){for(let c=this.m_controllerList;c;c=c.m_next){c.Draw(this.m_debugDraw);}}}QueryAABB(...args){if(args[0]instanceof b2QueryCallback){this._QueryAABB(args[0],args[1]);}else {this._QueryAABB(null,args[0],args[1]);}}_QueryAABB(callback,aabb,fn){this.m_contactManager.m_broadPhase.Query(aabb,proxy=>{const fixture_proxy=proxy.userData;const fixture=fixture_proxy.fixture;if(callback){return callback.ReportFixture(fixture);}else if(fn){return fn(fixture);}return true;});if(callback instanceof b2QueryCallback){for(let p=this.m_particleSystemList;p;p=p.m_next){if(callback.ShouldQueryParticleSystem(p)){p.QueryAABB(callback,aabb);}}}}QueryAllAABB(aabb,out=[]){this.QueryAABB(aabb,fixture=>{out.push(fixture);return true;});return out;}QueryPointAABB(...args){if(args[0]instanceof b2QueryCallback){this._QueryPointAABB(args[0],args[1]);}else {this._QueryPointAABB(null,args[0],args[1]);}}_QueryPointAABB(callback,point,fn){this.m_contactManager.m_broadPhase.QueryPoint(point,proxy=>{const fixture_proxy=proxy.userData;const fixture=fixture_proxy.fixture;if(callback){return callback.ReportFixture(fixture);}else if(fn){return fn(fixture);}return true;});if(callback instanceof b2QueryCallback){for(let p=this.m_particleSystemList;p;p=p.m_next){if(callback.ShouldQueryParticleSystem(p)){p.QueryPointAABB(callback,point);}}}}QueryAllPointAABB(point,out=[]){this.QueryPointAABB(point,fixture=>{out.push(fixture);return true;});return out;}QueryFixtureShape(...args){if(args[0]instanceof b2QueryCallback){this._QueryFixtureShape(args[0],args[1],args[2],args[3]);}else {this._QueryFixtureShape(null,args[0],args[1],args[2],args[3]);}}_QueryFixtureShape(callback,shape,index,transform,fn){const aabb=b2World.QueryFixtureShape_s_aabb;shape.ComputeAABB(aabb,transform,index);this.m_contactManager.m_broadPhase.Query(aabb,proxy=>{const fixture_proxy=proxy.userData;const fixture=fixture_proxy.fixture;if(b2TestOverlapShape(shape,index,fixture.GetShape(),fixture_proxy.childIndex,transform,fixture.GetBody().GetTransform())){if(callback){return callback.ReportFixture(fixture);}else if(fn){return fn(fixture);}}return true;});if(callback instanceof b2QueryCallback){for(let p=this.m_particleSystemList;p;p=p.m_next){if(callback.ShouldQueryParticleSystem(p)){p.QueryAABB(callback,aabb);}}}}QueryAllFixtureShape(shape,index,transform,out=[]){this.QueryFixtureShape(shape,index,transform,fixture=>{out.push(fixture);return true;});return out;}QueryFixturePoint(...args){if(args[0]instanceof b2QueryCallback){this._QueryFixturePoint(args[0],args[1]);}else {this._QueryFixturePoint(null,args[0],args[1]);}}_QueryFixturePoint(callback,point,fn){this.m_contactManager.m_broadPhase.QueryPoint(point,proxy=>{const fixture_proxy=proxy.userData;const fixture=fixture_proxy.fixture;if(fixture.TestPoint(point)){if(callback){return callback.ReportFixture(fixture);}else if(fn){return fn(fixture);}}return true;});if(callback){for(let p=this.m_particleSystemList;p;p=p.m_next){if(callback.ShouldQueryParticleSystem(p)){p.QueryPointAABB(callback,point);}}}}QueryAllFixturePoint(point,out=[]){this.QueryFixturePoint(point,fixture=>{out.push(fixture);return true;});return out;}RayCast(...args){if(args[0]instanceof b2RayCastCallback){this._RayCast(args[0],args[1],args[2]);}else {this._RayCast(null,args[0],args[1],args[2]);}}_RayCast(callback,point1,point2,fn){const input=b2World.RayCast_s_input;input.maxFraction=1;input.p1.Copy(point1);input.p2.Copy(point2);this.m_contactManager.m_broadPhase.RayCast(input,(input,proxy)=>{const fixture_proxy=proxy.userData;const fixture=fixture_proxy.fixture;const index=fixture_proxy.childIndex;const output=b2World.RayCast_s_output;const hit=fixture.RayCast(output,input,index);if(hit){const fraction=output.fraction;const point=b2World.RayCast_s_point;point.Set((1-fraction)*point1.x+fraction*point2.x,(1-fraction)*point1.y+fraction*point2.y);if(callback){return callback.ReportFixture(fixture,point,output.normal,fraction);}else if(fn){return fn(fixture,point,output.normal,fraction);}}return input.maxFraction;});if(callback){for(let p=this.m_particleSystemList;p;p=p.m_next){if(callback.ShouldQueryParticleSystem(p)){p.RayCast(callback,point1,point2);}}}}RayCastOne(point1,point2){let result=null;let min_fraction=1;this.RayCast(point1,point2,(fixture,point,normal,fraction)=>{if(fraction<min_fraction){min_fraction=fraction;result=fixture;}return min_fraction;});return result;}RayCastAll(point1,point2,out=[]){this.RayCast(point1,point2,(fixture,point,normal,fraction)=>{out.push(fixture);return 1;});return out;}GetBodyList(){return this.m_bodyList;}GetJointList(){return this.m_jointList;}GetParticleSystemList(){return this.m_particleSystemList;}GetContactList(){return this.m_contactManager.m_contactList;}SetAllowSleeping(flag){if(flag===this.m_allowSleep){return;}this.m_allowSleep=flag;if(!this.m_allowSleep){for(let b=this.m_bodyList;b;b=b.m_next){b.SetAwake(true);}}}GetAllowSleeping(){return this.m_allowSleep;}SetWarmStarting(flag){this.m_warmStarting=flag;}GetWarmStarting(){return this.m_warmStarting;}SetContinuousPhysics(flag){this.m_continuousPhysics=flag;}GetContinuousPhysics(){return this.m_continuousPhysics;}SetSubStepping(flag){this.m_subStepping=flag;}GetSubStepping(){return this.m_subStepping;}GetProxyCount(){return this.m_contactManager.m_broadPhase.GetProxyCount();}GetBodyCount(){return this.m_bodyCount;}GetJointCount(){return this.m_jointCount;}GetContactCount(){return this.m_contactManager.m_contactCount;}GetTreeHeight(){return this.m_contactManager.m_broadPhase.GetTreeHeight();}GetTreeBalance(){return this.m_contactManager.m_broadPhase.GetTreeBalance();}GetTreeQuality(){return this.m_contactManager.m_broadPhase.GetTreeQuality();}SetGravity(gravity,wake=true){if(!b2Vec2.IsEqualToV(this.m_gravity,gravity)){this.m_gravity.Copy(gravity);if(wake){for(let b=this.m_bodyList;b;b=b.m_next){b.SetAwake(true);}}}}GetGravity(){return this.m_gravity;}IsLocked(){return this.m_locked;}SetAutoClearForces(flag){this.m_clearForces=flag;}GetAutoClearForces(){return this.m_clearForces;}ShiftOrigin(newOrigin){if(this.IsLocked()){throw new Error();}for(let b=this.m_bodyList;b;b=b.m_next){b.m_xf.p.SelfSub(newOrigin);b.m_sweep.c0.SelfSub(newOrigin);b.m_sweep.c.SelfSub(newOrigin);}for(let j=this.m_jointList;j;j=j.m_next){j.ShiftOrigin(newOrigin);}this.m_contactManager.m_broadPhase.ShiftOrigin(newOrigin);}GetContactManager(){return this.m_contactManager;}GetProfile(){return this.m_profile;}Dump(log){if(this.m_locked){return;}log("const g: b2Vec2 = new b2Vec2(%.15f, %.15f);\n",this.m_gravity.x,this.m_gravity.y);log("this.m_world.SetGravity(g);\n");log("const bodies: b2Body[] = [];\n");log("const joints: b2Joint[] = [];\n");let i=0;for(let b=this.m_bodyList;b;b=b.m_next){b.m_islandIndex=i;b.Dump(log);++i;}i=0;for(let j=this.m_jointList;j;j=j.m_next){j.m_index=i;++i;}for(let j=this.m_jointList;j;j=j.m_next){if(j.m_type===exports.b2JointType.e_gearJoint){continue;}log("{\n");j.Dump(log);log("}\n");}for(let j=this.m_jointList;j;j=j.m_next){if(j.m_type!==exports.b2JointType.e_gearJoint){continue;}log("{\n");j.Dump(log);log("}\n");}}DrawJoint(joint){if(this.m_debugDraw===null){return;}const bodyA=joint.GetBodyA();const bodyB=joint.GetBodyB();const xf1=bodyA.m_xf;const xf2=bodyB.m_xf;const x1=xf1.p;const x2=xf2.p;const p1=joint.GetAnchorA(b2World.DrawJoint_s_p1);const p2=joint.GetAnchorB(b2World.DrawJoint_s_p2);const color=b2World.DrawJoint_s_color.SetRGB(0.5,0.8,0.8);switch(joint.m_type){case exports.b2JointType.e_distanceJoint:this.m_debugDraw.DrawSegment(p1,p2,color);break;case exports.b2JointType.e_pulleyJoint:{const pulley=joint;const s1=pulley.GetGroundAnchorA();const s2=pulley.GetGroundAnchorB();this.m_debugDraw.DrawSegment(s1,p1,color);this.m_debugDraw.DrawSegment(s2,p2,color);this.m_debugDraw.DrawSegment(s1,s2,color);break;}case exports.b2JointType.e_mouseJoint:{const c=b2World.DrawJoint_s_c;c.Set(0.0,1.0,0.0);this.m_debugDraw.DrawPoint(p1,4.0,c);this.m_debugDraw.DrawPoint(p2,4.0,c);c.Set(0.8,0.8,0.8);this.m_debugDraw.DrawSegment(p1,p2,c);break;}default:this.m_debugDraw.DrawSegment(x1,p1,color);this.m_debugDraw.DrawSegment(p1,p2,color);this.m_debugDraw.DrawSegment(x2,p2,color);}}DrawShape(fixture,color){if(this.m_debugDraw===null){return;}const shape=fixture.GetShape();switch(shape.m_type){case exports.b2ShapeType.e_circleShape:{const circle=shape;const center=circle.m_p;const radius=circle.m_radius;const axis=b2Vec2.UNITX;this.m_debugDraw.DrawSolidCircle(center,radius,axis,color);break;}case exports.b2ShapeType.e_edgeShape:{const edge=shape;const v1=edge.m_vertex1;const v2=edge.m_vertex2;this.m_debugDraw.DrawSegment(v1,v2,color);break;}case exports.b2ShapeType.e_chainShape:{const chain=shape;const count=chain.m_count;const vertices=chain.m_vertices;const ghostColor=b2World.DrawShape_s_ghostColor.SetRGBA(0.75*color.r,0.75*color.g,0.75*color.b,color.a);let v1=vertices[0];this.m_debugDraw.DrawPoint(v1,4.0,color);if(chain.m_hasPrevVertex){const vp=chain.m_prevVertex;this.m_debugDraw.DrawSegment(vp,v1,ghostColor);this.m_debugDraw.DrawCircle(vp,0.1,ghostColor);}for(let i=1;i<count;++i){const v2=vertices[i];this.m_debugDraw.DrawSegment(v1,v2,color);this.m_debugDraw.DrawPoint(v2,4.0,color);v1=v2;}if(chain.m_hasNextVertex){const vn=chain.m_nextVertex;this.m_debugDraw.DrawSegment(vn,v1,ghostColor);this.m_debugDraw.DrawCircle(vn,0.1,ghostColor);}break;}case exports.b2ShapeType.e_polygonShape:{const poly=shape;const vertexCount=poly.m_count;const vertices=poly.m_vertices;this.m_debugDraw.DrawSolidPolygon(vertices,vertexCount,color);break;}}}Solve(step){for(let b=this.m_bodyList;b;b=b.m_next){b.m_xf0.Copy(b.m_xf);}for(let controller=this.m_controllerList;controller;controller=controller.m_next){controller.Step(step);}this.m_profile.solveInit=0;this.m_profile.solveVelocity=0;this.m_profile.solvePosition=0;const island=this.m_island;island.Initialize(this.m_bodyCount,this.m_contactManager.m_contactCount,this.m_jointCount,this.m_contactManager.m_contactListener);for(let b=this.m_bodyList;b;b=b.m_next){b.m_islandFlag=false;}for(let c=this.m_contactManager.m_contactList;c;c=c.m_next){c.m_islandFlag=false;}for(let j=this.m_jointList;j;j=j.m_next){j.m_islandFlag=false;}const stack=this.s_stack;for(let seed=this.m_bodyList;seed;seed=seed.m_next){if(seed.m_islandFlag){continue;}if(!seed.IsAwake()||!seed.IsActive()){continue;}if(seed.GetType()===exports.b2BodyType.b2_staticBody){continue;}island.Clear();let stackCount=0;stack[stackCount++]=seed;seed.m_islandFlag=true;while(stackCount>0){const b=stack[--stackCount];if(!b){throw new Error();}island.AddBody(b);b.m_awakeFlag=true;if(b.GetType()===exports.b2BodyType.b2_staticBody){continue;}for(let ce=b.m_contactList;ce;ce=ce.next){const contact=ce.contact;if(contact.m_islandFlag){continue;}if(!contact.IsEnabled()||!contact.IsTouching()){continue;}const sensorA=contact.m_fixtureA.m_isSensor;const sensorB=contact.m_fixtureB.m_isSensor;if(sensorA||sensorB){continue;}island.AddContact(contact);contact.m_islandFlag=true;const other=ce.other;if(other.m_islandFlag){continue;}stack[stackCount++]=other;other.m_islandFlag=true;}for(let je=b.m_jointList;je;je=je.next){if(je.joint.m_islandFlag){continue;}const other=je.other;if(!other.IsActive()){continue;}island.AddJoint(je.joint);je.joint.m_islandFlag=true;if(other.m_islandFlag){continue;}stack[stackCount++]=other;other.m_islandFlag=true;}}const profile=new b2Profile();island.Solve(profile,step,this.m_gravity,this.m_allowSleep);this.m_profile.solveInit+=profile.solveInit;this.m_profile.solveVelocity+=profile.solveVelocity;this.m_profile.solvePosition+=profile.solvePosition;for(let i=0;i<island.m_bodyCount;++i){const b=island.m_bodies[i];if(b.GetType()===exports.b2BodyType.b2_staticBody){b.m_islandFlag=false;}}}for(let i=0;i<stack.length;++i){if(!stack[i]){break;}stack[i]=null;}const timer=new b2Timer();for(let b=this.m_bodyList;b;b=b.m_next){if(!b.m_islandFlag){continue;}if(b.GetType()===exports.b2BodyType.b2_staticBody){continue;}b.SynchronizeFixtures();}this.m_contactManager.FindNewContacts();this.m_profile.broadphase=timer.GetMilliseconds();}SolveTOI(step){const island=this.m_island;island.Initialize(2*b2_maxTOIContacts,b2_maxTOIContacts,0,this.m_contactManager.m_contactListener);if(this.m_stepComplete){for(let b=this.m_bodyList;b;b=b.m_next){b.m_islandFlag=false;b.m_sweep.alpha0=0;}for(let c=this.m_contactManager.m_contactList;c;c=c.m_next){c.m_toiFlag=false;c.m_islandFlag=false;c.m_toiCount=0;c.m_toi=1;}}for(;;){let minContact=null;let minAlpha=1;for(let c=this.m_contactManager.m_contactList;c;c=c.m_next){if(!c.IsEnabled()){continue;}if(c.m_toiCount>b2_maxSubSteps){continue;}let alpha=1;if(c.m_toiFlag){alpha=c.m_toi;}else {const fA=c.GetFixtureA();const fB=c.GetFixtureB();if(fA.IsSensor()||fB.IsSensor()){continue;}const bA=fA.GetBody();const bB=fB.GetBody();const typeA=bA.m_type;const typeB=bB.m_type;const activeA=bA.IsAwake()&&typeA!==exports.b2BodyType.b2_staticBody;const activeB=bB.IsAwake()&&typeB!==exports.b2BodyType.b2_staticBody;if(!activeA&&!activeB){continue;}const collideA=bA.IsBullet()||typeA!==exports.b2BodyType.b2_dynamicBody;const collideB=bB.IsBullet()||typeB!==exports.b2BodyType.b2_dynamicBody;if(!collideA&&!collideB){continue;}let alpha0=bA.m_sweep.alpha0;if(bA.m_sweep.alpha0<bB.m_sweep.alpha0){alpha0=bB.m_sweep.alpha0;bA.m_sweep.Advance(alpha0);}else if(bB.m_sweep.alpha0<bA.m_sweep.alpha0){alpha0=bA.m_sweep.alpha0;bB.m_sweep.Advance(alpha0);}const indexA=c.GetChildIndexA();const indexB=c.GetChildIndexB();const input=b2World.SolveTOI_s_toi_input;input.proxyA.SetShape(fA.GetShape(),indexA);input.proxyB.SetShape(fB.GetShape(),indexB);input.sweepA.Copy(bA.m_sweep);input.sweepB.Copy(bB.m_sweep);input.tMax=1;const output=b2World.SolveTOI_s_toi_output;b2TimeOfImpact(output,input);const beta=output.t;if(output.state===exports.b2TOIOutputState.e_touching){alpha=b2Min(alpha0+(1-alpha0)*beta,1);}else {alpha=1;}c.m_toi=alpha;c.m_toiFlag=true;}if(alpha<minAlpha){minContact=c;minAlpha=alpha;}}if(minContact===null||1-10*b2_epsilon<minAlpha){this.m_stepComplete=true;break;}const fA=minContact.GetFixtureA();const fB=minContact.GetFixtureB();const bA=fA.GetBody();const bB=fB.GetBody();const backup1=b2World.SolveTOI_s_backup1.Copy(bA.m_sweep);const backup2=b2World.SolveTOI_s_backup2.Copy(bB.m_sweep);bA.Advance(minAlpha);bB.Advance(minAlpha);minContact.Update(this.m_contactManager.m_contactListener);minContact.m_toiFlag=false;++minContact.m_toiCount;if(!minContact.IsEnabled()||!minContact.IsTouching()){minContact.SetEnabled(false);bA.m_sweep.Copy(backup1);bB.m_sweep.Copy(backup2);bA.SynchronizeTransform();bB.SynchronizeTransform();continue;}bA.SetAwake(true);bB.SetAwake(true);island.Clear();island.AddBody(bA);island.AddBody(bB);island.AddContact(minContact);bA.m_islandFlag=true;bB.m_islandFlag=true;minContact.m_islandFlag=true;for(let i=0;i<2;++i){const body=i===0?bA:bB;if(body.m_type===exports.b2BodyType.b2_dynamicBody){for(let ce=body.m_contactList;ce;ce=ce.next){if(island.m_bodyCount===island.m_bodyCapacity){break;}if(island.m_contactCount===island.m_contactCapacity){break;}const contact=ce.contact;if(contact.m_islandFlag){continue;}const other=ce.other;if(other.m_type===exports.b2BodyType.b2_dynamicBody&&!body.IsBullet()&&!other.IsBullet()){continue;}const sensorA=contact.m_fixtureA.m_isSensor;const sensorB=contact.m_fixtureB.m_isSensor;if(sensorA||sensorB){continue;}const backup=b2World.SolveTOI_s_backup.Copy(other.m_sweep);if(!other.m_islandFlag){other.Advance(minAlpha);}contact.Update(this.m_contactManager.m_contactListener);if(!contact.IsEnabled()){other.m_sweep.Copy(backup);other.SynchronizeTransform();continue;}if(!contact.IsTouching()){other.m_sweep.Copy(backup);other.SynchronizeTransform();continue;}contact.m_islandFlag=true;island.AddContact(contact);if(other.m_islandFlag){continue;}other.m_islandFlag=true;if(other.m_type!==exports.b2BodyType.b2_staticBody){other.SetAwake(true);}island.AddBody(other);}}}const subStep=b2World.SolveTOI_s_subStep;subStep.dt=(1-minAlpha)*step.dt;subStep.inv_dt=1/subStep.dt;subStep.dtRatio=1;subStep.positionIterations=20;subStep.velocityIterations=step.velocityIterations;subStep.particleIterations=step.particleIterations;subStep.warmStarting=false;island.SolveTOI(subStep,bA.m_islandIndex,bB.m_islandIndex);for(let i=0;i<island.m_bodyCount;++i){const body=island.m_bodies[i];body.m_islandFlag=false;if(body.m_type!==exports.b2BodyType.b2_dynamicBody){continue;}body.SynchronizeFixtures();for(let ce=body.m_contactList;ce;ce=ce.next){ce.contact.m_toiFlag=false;ce.contact.m_islandFlag=false;}}this.m_contactManager.FindNewContacts();if(this.m_subStepping){this.m_stepComplete=false;break;}}}AddController(controller){controller.m_next=this.m_controllerList;controller.m_prev=null;if(this.m_controllerList){this.m_controllerList.m_prev=controller;}this.m_controllerList=controller;++this.m_controllerCount;return controller;}RemoveController(controller){if(controller.m_prev){controller.m_prev.m_next=controller.m_next;}if(controller.m_next){controller.m_next.m_prev=controller.m_prev;}if(this.m_controllerList===controller){this.m_controllerList=controller.m_next;}--this.m_controllerCount;controller.m_prev=null;controller.m_next=null;return controller;}}b2World.Step_s_step=new b2TimeStep();b2World.Step_s_stepTimer=new b2Timer();b2World.Step_s_timer=new b2Timer();b2World.DrawDebugData_s_color=new b2Color(0,0,0);b2World.DrawDebugData_s_vs=b2Vec2.MakeArray(4);b2World.DrawDebugData_s_xf=new b2Transform();b2World.QueryFixtureShape_s_aabb=new b2AABB();b2World.RayCast_s_input=new b2RayCastInput();b2World.RayCast_s_output=new b2RayCastOutput();b2World.RayCast_s_point=new b2Vec2();b2World.DrawJoint_s_p1=new b2Vec2();b2World.DrawJoint_s_p2=new b2Vec2();b2World.DrawJoint_s_color=new b2Color(0.5,0.8,0.8);b2World.DrawJoint_s_c=new b2Color();b2World.DrawShape_s_ghostColor=new b2Color();b2World.SolveTOI_s_subStep=new b2TimeStep();b2World.SolveTOI_s_backup=new b2Sweep();b2World.SolveTOI_s_backup1=new b2Sweep();b2World.SolveTOI_s_backup2=new b2Sweep();b2World.SolveTOI_s_toi_input=new b2TOIInput();b2World.SolveTOI_s_toi_output=new b2TOIOutput();class b2ControllerEdge{constructor(controller,body){this.prevBody=null;this.nextBody=null;this.prevController=null;this.nextController=null;this.controller=controller;this.body=body;}}class b2Controller{constructor(){this.m_bodyList=null;this.m_bodyCount=0;this.m_prev=null;this.m_next=null;}GetNext(){return this.m_next;}GetPrev(){return this.m_prev;}GetBodyList(){return this.m_bodyList;}AddBody(body){const edge=new b2ControllerEdge(this,body);edge.nextBody=this.m_bodyList;edge.prevBody=null;if(this.m_bodyList){this.m_bodyList.prevBody=edge;}this.m_bodyList=edge;++this.m_bodyCount;edge.nextController=body.m_controllerList;edge.prevController=null;if(body.m_controllerList){body.m_controllerList.prevController=edge;}body.m_controllerList=edge;++body.m_controllerCount;}RemoveBody(body){if(this.m_bodyCount<=0){throw new Error();}let edge=this.m_bodyList;while(edge&&edge.body!==body){edge=edge.nextBody;}if(edge===null){throw new Error();}if(edge.prevBody){edge.prevBody.nextBody=edge.nextBody;}if(edge.nextBody){edge.nextBody.prevBody=edge.prevBody;}if(this.m_bodyList===edge){this.m_bodyList=edge.nextBody;}--this.m_bodyCount;if(edge.nextController){edge.nextController.prevController=edge.prevController;}if(edge.prevController){edge.prevController.nextController=edge.nextController;}if(body.m_controllerList===edge){body.m_controllerList=edge.nextController;}--body.m_controllerCount;}Clear(){while(this.m_bodyList){this.RemoveBody(this.m_bodyList.body);}this.m_bodyCount=0;}}class b2BuoyancyController extends b2Controller{constructor(){super(...arguments);this.normal=new b2Vec2(0,1);this.offset=0;this.density=0;this.velocity=new b2Vec2(0,0);this.linearDrag=0;this.angularDrag=0;this.useDensity=false;this.useWorldGravity=true;this.gravity=new b2Vec2(0,0);}Step(step){if(!this.m_bodyList){return;}if(this.useWorldGravity){this.gravity.Copy(this.m_bodyList.body.GetWorld().GetGravity());}for(let i=this.m_bodyList;i;i=i.nextBody){const body=i.body;if(!body.IsAwake()){continue;}const areac=new b2Vec2();const massc=new b2Vec2();let area=0;let mass=0;for(let fixture=body.GetFixtureList();fixture;fixture=fixture.m_next){const sc=new b2Vec2();const sarea=fixture.GetShape().ComputeSubmergedArea(this.normal,this.offset,body.GetTransform(),sc);area+=sarea;areac.x+=sarea*sc.x;areac.y+=sarea*sc.y;let shapeDensity=0;if(this.useDensity){shapeDensity=fixture.GetDensity();}else {shapeDensity=1;}mass+=sarea*shapeDensity;massc.x+=sarea*sc.x*shapeDensity;massc.y+=sarea*sc.y*shapeDensity;}areac.x/=area;areac.y/=area;massc.x/=mass;massc.y/=mass;if(area<b2_epsilon){continue;}const buoyancyForce=this.gravity.Clone().SelfNeg();buoyancyForce.SelfMul(this.density*area);body.ApplyForce(buoyancyForce,massc);const dragForce=body.GetLinearVelocityFromWorldPoint(areac,new b2Vec2());dragForce.SelfSub(this.velocity);dragForce.SelfMul(-this.linearDrag*area);body.ApplyForce(dragForce,areac);body.ApplyTorque(-body.GetInertia()/body.GetMass()*area*body.GetAngularVelocity()*this.angularDrag);}}Draw(debugDraw){const r=100;const p1=new b2Vec2();const p2=new b2Vec2();p1.x=this.normal.x*this.offset+this.normal.y*r;p1.y=this.normal.y*this.offset-this.normal.x*r;p2.x=this.normal.x*this.offset-this.normal.y*r;p2.y=this.normal.y*this.offset+this.normal.x*r;const color=new b2Color(0,0,0.8);debugDraw.DrawSegment(p1,p2,color);}}class b2ConstantAccelController extends b2Controller{constructor(){super(...arguments);this.A=new b2Vec2(0,0);}Step(step){const dtA=b2Vec2.MulSV(step.dt,this.A,b2ConstantAccelController.Step_s_dtA);for(let i=this.m_bodyList;i;i=i.nextBody){const body=i.body;if(!body.IsAwake()){continue;}body.SetLinearVelocity(b2Vec2.AddVV(body.GetLinearVelocity(),dtA,b2Vec2.s_t0));}}Draw(draw){}}b2ConstantAccelController.Step_s_dtA=new b2Vec2();class b2ConstantForceController extends b2Controller{constructor(){super(...arguments);this.F=new b2Vec2(0,0);}Step(step){for(let i=this.m_bodyList;i;i=i.nextBody){const body=i.body;if(!body.IsAwake()){continue;}body.ApplyForce(this.F,body.GetWorldCenter());}}Draw(draw){}}class b2GravityController extends b2Controller{constructor(){super(...arguments);this.G=1;this.invSqr=true;}Step(step){if(this.invSqr){for(let i=this.m_bodyList;i;i=i.nextBody){const body1=i.body;const p1=body1.GetWorldCenter();const mass1=body1.GetMass();for(let j=this.m_bodyList;j&&j!==i;j=j.nextBody){const body2=j.body;const p2=body2.GetWorldCenter();const mass2=body2.GetMass();const dx=p2.x-p1.x;const dy=p2.y-p1.y;const r2=dx*dx+dy*dy;if(r2<b2_epsilon){continue;}const f=b2GravityController.Step_s_f.Set(dx,dy);f.SelfMul(this.G/r2/b2Sqrt(r2)*mass1*mass2);if(body1.IsAwake()){body1.ApplyForce(f,p1);}if(body2.IsAwake()){body2.ApplyForce(f.SelfMul(-1),p2);}}}}else {for(let i=this.m_bodyList;i;i=i.nextBody){const body1=i.body;const p1=body1.GetWorldCenter();const mass1=body1.GetMass();for(let j=this.m_bodyList;j&&j!==i;j=j.nextBody){const body2=j.body;const p2=body2.GetWorldCenter();const mass2=body2.GetMass();const dx=p2.x-p1.x;const dy=p2.y-p1.y;const r2=dx*dx+dy*dy;if(r2<b2_epsilon){continue;}const f=b2GravityController.Step_s_f.Set(dx,dy);f.SelfMul(this.G/r2*mass1*mass2);if(body1.IsAwake()){body1.ApplyForce(f,p1);}if(body2.IsAwake()){body2.ApplyForce(f.SelfMul(-1),p2);}}}}}Draw(draw){}}b2GravityController.Step_s_f=new b2Vec2();class b2TensorDampingController extends b2Controller{constructor(){super(...arguments);this.T=new b2Mat22();this.maxTimestep=0;}Step(step){let timestep=step.dt;if(timestep<=b2_epsilon){return;}if(timestep>this.maxTimestep&&this.maxTimestep>0){timestep=this.maxTimestep;}for(let i=this.m_bodyList;i;i=i.nextBody){const body=i.body;if(!body.IsAwake()){continue;}const damping=body.GetWorldVector(b2Mat22.MulMV(this.T,body.GetLocalVector(body.GetLinearVelocity(),b2Vec2.s_t0),b2Vec2.s_t1),b2TensorDampingController.Step_s_damping);body.SetLinearVelocity(b2Vec2.AddVV(body.GetLinearVelocity(),b2Vec2.MulSV(timestep,damping,b2Vec2.s_t0),b2Vec2.s_t1));}}Draw(draw){}SetAxisAligned(xDamping,yDamping){this.T.ex.x=-xDamping;this.T.ex.y=0;this.T.ey.x=0;this.T.ey.y=-yDamping;if(xDamping>0||yDamping>0){this.maxTimestep=1/b2Max(xDamping,yDamping);}else {this.maxTimestep=0;}}}b2TensorDampingController.Step_s_damping=new b2Vec2();class b2RopeDef{constructor(){this.vertices=[];this.count=0;this.masses=[];this.gravity=new b2Vec2(0,0);this.damping=0.1;this.k2=0.9;this.k3=0.1;}}class b2Rope{constructor(){this.m_count=0;this.m_ps=[];this.m_p0s=[];this.m_vs=[];this.m_ims=[];this.m_Ls=[];this.m_as=[];this.m_gravity=new b2Vec2();this.m_damping=0;this.m_k2=1;this.m_k3=0.1;}GetVertexCount(){return this.m_count;}GetVertices(){return this.m_ps;}Initialize(def){this.m_count=def.count;this.m_ps=b2Vec2.MakeArray(this.m_count);this.m_p0s=b2Vec2.MakeArray(this.m_count);this.m_vs=b2Vec2.MakeArray(this.m_count);this.m_ims=b2MakeNumberArray(this.m_count);for(let i=0;i<this.m_count;++i){this.m_ps[i].Copy(def.vertices[i]);this.m_p0s[i].Copy(def.vertices[i]);this.m_vs[i].SetZero();const m=def.masses[i];if(m>0){this.m_ims[i]=1/m;}else {this.m_ims[i]=0;}}const count2=this.m_count-1;const count3=this.m_count-2;this.m_Ls=b2MakeNumberArray(count2);this.m_as=b2MakeNumberArray(count3);for(let i=0;i<count2;++i){const p1=this.m_ps[i];const p2=this.m_ps[i+1];this.m_Ls[i]=b2Vec2.DistanceVV(p1,p2);}for(let i=0;i<count3;++i){const p1=this.m_ps[i];const p2=this.m_ps[i+1];const p3=this.m_ps[i+2];const d1=b2Vec2.SubVV(p2,p1,b2Vec2.s_t0);const d2=b2Vec2.SubVV(p3,p2,b2Vec2.s_t1);const a=b2Vec2.CrossVV(d1,d2);const b=b2Vec2.DotVV(d1,d2);this.m_as[i]=b2Atan2(a,b);}this.m_gravity.Copy(def.gravity);this.m_damping=def.damping;this.m_k2=def.k2;this.m_k3=def.k3;}Step(h,iterations){if(h===0){return;}const d=Math.exp(-h*this.m_damping);for(let i=0;i<this.m_count;++i){this.m_p0s[i].Copy(this.m_ps[i]);if(this.m_ims[i]>0){this.m_vs[i].SelfMulAdd(h,this.m_gravity);}this.m_vs[i].SelfMul(d);this.m_ps[i].SelfMulAdd(h,this.m_vs[i]);}for(let i=0;i<iterations;++i){this.SolveC2();this.SolveC3();this.SolveC2();}const inv_h=1/h;for(let i=0;i<this.m_count;++i){b2Vec2.MulSV(inv_h,b2Vec2.SubVV(this.m_ps[i],this.m_p0s[i],b2Vec2.s_t0),this.m_vs[i]);}}SolveC2(){const count2=this.m_count-1;for(let i=0;i<count2;++i){const p1=this.m_ps[i];const p2=this.m_ps[i+1];const d=b2Vec2.SubVV(p2,p1,b2Rope.s_d);const L=d.Normalize();const im1=this.m_ims[i];const im2=this.m_ims[i+1];if(im1+im2===0){continue;}const s1=im1/(im1+im2);const s2=im2/(im1+im2);p1.SelfMulSub(this.m_k2*s1*(this.m_Ls[i]-L),d);p2.SelfMulAdd(this.m_k2*s2*(this.m_Ls[i]-L),d);}}SetAngle(angle){const count3=this.m_count-2;for(let i=0;i<count3;++i){this.m_as[i]=angle;}}SolveC3(){const count3=this.m_count-2;for(let i=0;i<count3;++i){const p1=this.m_ps[i];const p2=this.m_ps[i+1];const p3=this.m_ps[i+2];const m1=this.m_ims[i];const m2=this.m_ims[i+1];const m3=this.m_ims[i+2];const d1=b2Vec2.SubVV(p2,p1,b2Rope.s_d1);const d2=b2Vec2.SubVV(p3,p2,b2Rope.s_d2);const L1sqr=d1.LengthSquared();const L2sqr=d2.LengthSquared();if(L1sqr*L2sqr===0){continue;}const a=b2Vec2.CrossVV(d1,d2);const b=b2Vec2.DotVV(d1,d2);let angle=b2Atan2(a,b);const Jd1=b2Vec2.MulSV(-1/L1sqr,d1.SelfSkew(),b2Rope.s_Jd1);const Jd2=b2Vec2.MulSV(1/L2sqr,d2.SelfSkew(),b2Rope.s_Jd2);const J1=b2Vec2.NegV(Jd1,b2Rope.s_J1);const J2=b2Vec2.SubVV(Jd1,Jd2,b2Rope.s_J2);const J3=Jd2;let mass=m1*b2Vec2.DotVV(J1,J1)+m2*b2Vec2.DotVV(J2,J2)+m3*b2Vec2.DotVV(J3,J3);if(mass===0){continue;}mass=1/mass;let C=angle-this.m_as[i];while(C>b2_pi){angle-=2*b2_pi;C=angle-this.m_as[i];}while(C<-b2_pi){angle+=2*b2_pi;C=angle-this.m_as[i];}const impulse=-this.m_k3*mass*C;p1.SelfMulAdd(m1*impulse,J1);p2.SelfMulAdd(m2*impulse,J2);p3.SelfMulAdd(m3*impulse,J3);}}Draw(draw){const c=new b2Color(0.4,0.5,0.7);for(let i=0;i<this.m_count-1;++i){draw.DrawSegment(this.m_ps[i],this.m_ps[i+1],c);}}}b2Rope.s_d=new b2Vec2();b2Rope.s_d1=new b2Vec2();b2Rope.s_d2=new b2Vec2();b2Rope.s_Jd1=new b2Vec2();b2Rope.s_Jd2=new b2Vec2();b2Rope.s_J1=new b2Vec2();b2Rope.s_J2=new b2Vec2();exports.b2AABB=b2AABB;exports.b2Abs=b2Abs;exports.b2Acos=b2Acos;exports.b2Alloc=b2Alloc;exports.b2AreaJoint=b2AreaJoint;exports.b2AreaJointDef=b2AreaJointDef;exports.b2Asin=b2Asin;exports.b2Assert=b2Assert;exports.b2Atan2=b2Atan2;exports.b2BlockAllocator=b2BlockAllocator;exports.b2Body=b2Body;exports.b2BodyDef=b2BodyDef;exports.b2BroadPhase=b2BroadPhase;exports.b2BuoyancyController=b2BuoyancyController;exports.b2CalculateParticleIterations=b2CalculateParticleIterations;exports.b2ChainAndCircleContact=b2ChainAndCircleContact;exports.b2ChainAndPolygonContact=b2ChainAndPolygonContact;exports.b2ChainShape=b2ChainShape;exports.b2CircleContact=b2CircleContact;exports.b2CircleShape=b2CircleShape;exports.b2Clamp=b2Clamp;exports.b2ClipSegmentToLine=b2ClipSegmentToLine;exports.b2ClipVertex=b2ClipVertex;exports.b2CollideCircles=b2CollideCircles;exports.b2CollideEdgeAndCircle=b2CollideEdgeAndCircle;exports.b2CollideEdgeAndPolygon=b2CollideEdgeAndPolygon;exports.b2CollidePolygonAndCircle=b2CollidePolygonAndCircle;exports.b2CollidePolygons=b2CollidePolygons;exports.b2Color=b2Color;exports.b2ConstantAccelController=b2ConstantAccelController;exports.b2ConstantForceController=b2ConstantForceController;exports.b2Contact=b2Contact;exports.b2ContactEdge=b2ContactEdge;exports.b2ContactFactory=b2ContactFactory;exports.b2ContactFeature=b2ContactFeature;exports.b2ContactFilter=b2ContactFilter;exports.b2ContactID=b2ContactID;exports.b2ContactImpulse=b2ContactImpulse;exports.b2ContactListener=b2ContactListener;exports.b2ContactManager=b2ContactManager;exports.b2ContactPositionConstraint=b2ContactPositionConstraint;exports.b2ContactRegister=b2ContactRegister;exports.b2ContactSolver=b2ContactSolver;exports.b2ContactSolverDef=b2ContactSolverDef;exports.b2ContactVelocityConstraint=b2ContactVelocityConstraint;exports.b2Controller=b2Controller;exports.b2ControllerEdge=b2ControllerEdge;exports.b2Cos=b2Cos;exports.b2Counter=b2Counter;exports.b2DegToRad=b2DegToRad;exports.b2DestructionListener=b2DestructionListener;exports.b2Distance=b2Distance;exports.b2DistanceInput=b2DistanceInput;exports.b2DistanceJoint=b2DistanceJoint;exports.b2DistanceJointDef=b2DistanceJointDef;exports.b2DistanceOutput=b2DistanceOutput;exports.b2DistanceProxy=b2DistanceProxy;exports.b2Draw=b2Draw;exports.b2DynamicTree=b2DynamicTree;exports.b2EdgeAndCircleContact=b2EdgeAndCircleContact;exports.b2EdgeAndPolygonContact=b2EdgeAndPolygonContact;exports.b2EdgeShape=b2EdgeShape;exports.b2Filter=b2Filter;exports.b2Fixture=b2Fixture;exports.b2FixtureDef=b2FixtureDef;exports.b2FixtureParticleQueryCallback=b2FixtureParticleQueryCallback;exports.b2FixtureProxy=b2FixtureProxy;exports.b2Free=b2Free;exports.b2FrictionJoint=b2FrictionJoint;exports.b2FrictionJointDef=b2FrictionJointDef;exports.b2GearJoint=b2GearJoint;exports.b2GearJointDef=b2GearJointDef;exports.b2GetPointStates=b2GetPointStates;exports.b2GravityController=b2GravityController;exports.b2GrowableBuffer=b2GrowableBuffer;exports.b2GrowableStack=b2GrowableStack;exports.b2InvSqrt=b2InvSqrt;exports.b2IsPowerOfTwo=b2IsPowerOfTwo;exports.b2IsValid=b2IsValid;exports.b2Island=b2Island;exports.b2Jacobian=b2Jacobian;exports.b2Joint=b2Joint;exports.b2JointDef=b2JointDef;exports.b2JointEdge=b2JointEdge;exports.b2Log=b2Log;exports.b2MakeArray=b2MakeArray;exports.b2MakeNullArray=b2MakeNullArray;exports.b2MakeNumberArray=b2MakeNumberArray;exports.b2Manifold=b2Manifold;exports.b2ManifoldPoint=b2ManifoldPoint;exports.b2MassData=b2MassData;exports.b2Mat22=b2Mat22;exports.b2Mat33=b2Mat33;exports.b2Max=b2Max;exports.b2Maybe=b2Maybe;exports.b2Min=b2Min;exports.b2MixFriction=b2MixFriction;exports.b2MixRestitution=b2MixRestitution;exports.b2MotorJoint=b2MotorJoint;exports.b2MotorJointDef=b2MotorJointDef;exports.b2MouseJoint=b2MouseJoint;exports.b2MouseJointDef=b2MouseJointDef;exports.b2NextPowerOfTwo=b2NextPowerOfTwo;exports.b2Pair=b2Pair;exports.b2PairLessThan=b2PairLessThan;exports.b2ParseInt=b2ParseInt;exports.b2ParseUInt=b2ParseUInt;exports.b2ParticleBodyContact=b2ParticleBodyContact;exports.b2ParticleContact=b2ParticleContact;exports.b2ParticleDef=b2ParticleDef;exports.b2ParticleGroup=b2ParticleGroup;exports.b2ParticleGroupDef=b2ParticleGroupDef;exports.b2ParticleHandle=b2ParticleHandle;exports.b2ParticlePair=b2ParticlePair;exports.b2ParticlePairSet=b2ParticlePairSet;exports.b2ParticleSystem=b2ParticleSystem;exports.b2ParticleSystemDef=b2ParticleSystemDef;exports.b2ParticleSystem_CompositeShape=b2ParticleSystem_CompositeShape;exports.b2ParticleSystem_ConnectionFilter=b2ParticleSystem_ConnectionFilter;exports.b2ParticleSystem_DestroyParticlesInShapeCallback=b2ParticleSystem_DestroyParticlesInShapeCallback;exports.b2ParticleSystem_FixedSetAllocator=b2ParticleSystem_FixedSetAllocator;exports.b2ParticleSystem_FixtureParticle=b2ParticleSystem_FixtureParticle;exports.b2ParticleSystem_FixtureParticleSet=b2ParticleSystem_FixtureParticleSet;exports.b2ParticleSystem_InsideBoundsEnumerator=b2ParticleSystem_InsideBoundsEnumerator;exports.b2ParticleSystem_JoinParticleGroupsFilter=b2ParticleSystem_JoinParticleGroupsFilter;exports.b2ParticleSystem_ParticleListNode=b2ParticleSystem_ParticleListNode;exports.b2ParticleSystem_ParticlePair=b2ParticleSystem_ParticlePair;exports.b2ParticleSystem_Proxy=b2ParticleSystem_Proxy;exports.b2ParticleSystem_ReactiveFilter=b2ParticleSystem_ReactiveFilter;exports.b2ParticleSystem_SolveCollisionCallback=b2ParticleSystem_SolveCollisionCallback;exports.b2ParticleSystem_UpdateBodyContactsCallback=b2ParticleSystem_UpdateBodyContactsCallback;exports.b2ParticleSystem_UserOverridableBuffer=b2ParticleSystem_UserOverridableBuffer;exports.b2ParticleTriad=b2ParticleTriad;exports.b2PolygonAndCircleContact=b2PolygonAndCircleContact;exports.b2PolygonContact=b2PolygonContact;exports.b2PolygonShape=b2PolygonShape;exports.b2Position=b2Position;exports.b2PositionSolverManifold=b2PositionSolverManifold;exports.b2Pow=b2Pow;exports.b2PrismaticJoint=b2PrismaticJoint;exports.b2PrismaticJointDef=b2PrismaticJointDef;exports.b2Profile=b2Profile;exports.b2PulleyJoint=b2PulleyJoint;exports.b2PulleyJointDef=b2PulleyJointDef;exports.b2QueryCallback=b2QueryCallback;exports.b2RadToDeg=b2RadToDeg;exports.b2Random=b2Random;exports.b2RandomRange=b2RandomRange;exports.b2RayCastCallback=b2RayCastCallback;exports.b2RayCastInput=b2RayCastInput;exports.b2RayCastOutput=b2RayCastOutput;exports.b2RevoluteJoint=b2RevoluteJoint;exports.b2RevoluteJointDef=b2RevoluteJointDef;exports.b2Rope=b2Rope;exports.b2RopeDef=b2RopeDef;exports.b2RopeJoint=b2RopeJoint;exports.b2RopeJointDef=b2RopeJointDef;exports.b2Rot=b2Rot;exports.b2SeparationFunction=b2SeparationFunction;exports.b2Shape=b2Shape;exports.b2ShapeCast=b2ShapeCast;exports.b2ShapeCastInput=b2ShapeCastInput;exports.b2ShapeCastOutput=b2ShapeCastOutput;exports.b2Simplex=b2Simplex;exports.b2SimplexCache=b2SimplexCache;exports.b2SimplexVertex=b2SimplexVertex;exports.b2Sin=b2Sin;exports.b2SolverData=b2SolverData;exports.b2Sq=b2Sq;exports.b2Sqrt=b2Sqrt;exports.b2StackAllocator=b2StackAllocator;exports.b2Swap=b2Swap;exports.b2Sweep=b2Sweep;exports.b2TOIInput=b2TOIInput;exports.b2TOIOutput=b2TOIOutput;exports.b2TensorDampingController=b2TensorDampingController;exports.b2TestOverlapAABB=b2TestOverlapAABB;exports.b2TestOverlapShape=b2TestOverlapShape;exports.b2TimeOfImpact=b2TimeOfImpact;exports.b2TimeStep=b2TimeStep;exports.b2Timer=b2Timer;exports.b2Transform=b2Transform;exports.b2TreeNode=b2TreeNode;exports.b2Vec2=b2Vec2;exports.b2Vec2_zero=b2Vec2_zero;exports.b2Vec3=b2Vec3;exports.b2Velocity=b2Velocity;exports.b2VelocityConstraintPoint=b2VelocityConstraintPoint;exports.b2Version=b2Version;exports.b2WeldJoint=b2WeldJoint;exports.b2WeldJointDef=b2WeldJointDef;exports.b2WheelJoint=b2WheelJoint;exports.b2WheelJointDef=b2WheelJointDef;exports.b2World=b2World;exports.b2WorldManifold=b2WorldManifold;exports.b2_180_over_pi=b2_180_over_pi;exports.b2_aabbExtension=b2_aabbExtension;exports.b2_aabbMultiplier=b2_aabbMultiplier;exports.b2_angularSleepTolerance=b2_angularSleepTolerance;exports.b2_angularSlop=b2_angularSlop;exports.b2_barrierCollisionTime=b2_barrierCollisionTime;exports.b2_baumgarte=b2_baumgarte;exports.b2_branch=b2_branch;exports.b2_commit=b2_commit;exports.b2_epsilon=b2_epsilon;exports.b2_epsilon_sq=b2_epsilon_sq;exports.b2_gjk_reset=b2_gjk_reset;exports.b2_invalidParticleIndex=b2_invalidParticleIndex;exports.b2_linearSleepTolerance=b2_linearSleepTolerance;exports.b2_linearSlop=b2_linearSlop;exports.b2_maxAngularCorrection=b2_maxAngularCorrection;exports.b2_maxFloat=b2_maxFloat;exports.b2_maxLinearCorrection=b2_maxLinearCorrection;exports.b2_maxManifoldPoints=b2_maxManifoldPoints;exports.b2_maxParticleForce=b2_maxParticleForce;exports.b2_maxParticleIndex=b2_maxParticleIndex;exports.b2_maxParticlePressure=b2_maxParticlePressure;exports.b2_maxPolygonVertices=b2_maxPolygonVertices;exports.b2_maxRotation=b2_maxRotation;exports.b2_maxRotationSquared=b2_maxRotationSquared;exports.b2_maxSubSteps=b2_maxSubSteps;exports.b2_maxTOIContacts=b2_maxTOIContacts;exports.b2_maxTranslation=b2_maxTranslation;exports.b2_maxTranslationSquared=b2_maxTranslationSquared;exports.b2_maxTriadDistance=b2_maxTriadDistance;exports.b2_maxTriadDistanceSquared=b2_maxTriadDistanceSquared;exports.b2_minParticleSystemBufferCapacity=b2_minParticleSystemBufferCapacity;exports.b2_minParticleWeight=b2_minParticleWeight;exports.b2_minPulleyLength=b2_minPulleyLength;exports.b2_particleStride=b2_particleStride;exports.b2_pi=b2_pi;exports.b2_pi_over_180=b2_pi_over_180;exports.b2_polygonRadius=b2_polygonRadius;exports.b2_timeToSleep=b2_timeToSleep;exports.b2_toiBaumgarte=b2_toiBaumgarte;exports.b2_toi_reset=b2_toi_reset;exports.b2_two_pi=b2_two_pi;exports.b2_velocityThreshold=b2_velocityThreshold;exports.b2_version=b2_version;exports.g_blockSolve=g_blockSolve;Object.defineProperty(exports,'__esModule',{value:true});});});unwrapExports(box2d_umd);

            let b2={};for(var key in box2d_umd){if(key.indexOf('b2_')!==-1){continue;}let newKey=key.replace('b2','');b2[newKey]=box2d_umd[key];}var box2d_1=b2;

            let ERigidBody2DType;

            (function (ERigidBody2DType) {
              ERigidBody2DType[ERigidBody2DType["Static"] = 0] = "Static";
              ERigidBody2DType[ERigidBody2DType["Kinematic"] = 1] = "Kinematic";
              ERigidBody2DType[ERigidBody2DType["Dynamic"] = 2] = "Dynamic";
              ERigidBody2DType[ERigidBody2DType["Animated"] = 3] = "Animated";
            })(ERigidBody2DType || (ERigidBody2DType = exports('ERigidBody2DType', {})));

            Enum(ERigidBody2DType);
            let ECollider2DType;

            (function (ECollider2DType) {
              ECollider2DType[ECollider2DType["None"] = 0] = "None";
              ECollider2DType[ECollider2DType["BOX"] = 1] = "BOX";
              ECollider2DType[ECollider2DType["CIRCLE"] = 2] = "CIRCLE";
              ECollider2DType[ECollider2DType["POLYGON"] = 3] = "POLYGON";
            })(ECollider2DType || (ECollider2DType = exports('ECollider2DType', {})));

            Enum(ECollider2DType);
            let EJoint2DType;

            (function (EJoint2DType) {
              EJoint2DType[EJoint2DType["None"] = 0] = "None";
              EJoint2DType[EJoint2DType["DISTANCE"] = 1] = "DISTANCE";
              EJoint2DType[EJoint2DType["SPRING"] = 2] = "SPRING";
              EJoint2DType[EJoint2DType["WHEEL"] = 3] = "WHEEL";
              EJoint2DType[EJoint2DType["MOUSE"] = 4] = "MOUSE";
              EJoint2DType[EJoint2DType["FIXED"] = 5] = "FIXED";
              EJoint2DType[EJoint2DType["SLIDER"] = 6] = "SLIDER";
              EJoint2DType[EJoint2DType["RELATIVE"] = 7] = "RELATIVE";
              EJoint2DType[EJoint2DType["HINGE"] = 8] = "HINGE";
            })(EJoint2DType || (EJoint2DType = exports('EJoint2DType', {})));

            Enum(EJoint2DType);
            let PhysicsGroup;

            (function (PhysicsGroup) {
              PhysicsGroup[PhysicsGroup["DEFAULT"] = 1] = "DEFAULT";
            })(PhysicsGroup || (PhysicsGroup = exports('PhysicsGroup', {})));

            Enum(PhysicsGroup);
            let ERaycast2DType;

            (function (ERaycast2DType) {
              ERaycast2DType[ERaycast2DType["Closest"] = 0] = "Closest";
              ERaycast2DType[ERaycast2DType["Any"] = 1] = "Any";
              ERaycast2DType[ERaycast2DType["AllClosest"] = 2] = "AllClosest";
              ERaycast2DType[ERaycast2DType["All"] = 3] = "All";
            })(ERaycast2DType || (ERaycast2DType = exports('ERaycast2DType', {})));

            const Contact2DType = exports('Contact2DType', {
              None: 'none-contact',
              BEGIN_CONTACT: 'begin-contact',
              END_CONTACT: 'end-contact',
              PRE_SOLVE: 'pre-solve',
              POST_SOLVE: 'post-solve'
            });
            let EPhysics2DDrawFlags;

            (function (EPhysics2DDrawFlags) {
              EPhysics2DDrawFlags[EPhysics2DDrawFlags["None"] = 0] = "None";
              EPhysics2DDrawFlags[EPhysics2DDrawFlags["Shape"] = 1] = "Shape";
              EPhysics2DDrawFlags[EPhysics2DDrawFlags["Joint"] = 2] = "Joint";
              EPhysics2DDrawFlags[EPhysics2DDrawFlags["Aabb"] = 4] = "Aabb";
              EPhysics2DDrawFlags[EPhysics2DDrawFlags["Pair"] = 8] = "Pair";
              EPhysics2DDrawFlags[EPhysics2DDrawFlags["CenterOfMass"] = 16] = "CenterOfMass";
              EPhysics2DDrawFlags[EPhysics2DDrawFlags["Particle"] = 32] = "Particle";
              EPhysics2DDrawFlags[EPhysics2DDrawFlags["Controller"] = 64] = "Controller";
              EPhysics2DDrawFlags[EPhysics2DDrawFlags["All"] = 63] = "All";
            })(EPhysics2DDrawFlags || (EPhysics2DDrawFlags = exports('EPhysics2DDrawFlags', {})));

            const PHYSICS_2D_PTM_RATIO = exports('PHYSICS_2D_PTM_RATIO', 32);

            class PhysicsContactListener extends box2d_1.ContactListener {
              constructor(...args) {
                super(...args);
                this._contactFixtures = [];
                this._BeginContact = null;
                this._EndContact = null;
                this._PreSolve = null;
                this._PostSolve = null;
              }

              setBeginContact(cb) {
                this._BeginContact = cb;
              }

              setEndContact(cb) {
                this._EndContact = cb;
              }

              setPreSolve(cb) {
                this._PreSolve = cb;
              }

              setPostSolve(cb) {
                this._PostSolve = cb;
              }

              BeginContact(contact) {
                if (!this._BeginContact) return;
                const fixtureA = contact.GetFixtureA();
                const fixtureB = contact.GetFixtureB();
                const fixtures = this._contactFixtures;
                contact._shouldReport = false;

                if (fixtures.indexOf(fixtureA) !== -1 || fixtures.indexOf(fixtureB) !== -1) {
                  contact._shouldReport = true;

                  this._BeginContact(contact);
                }
              }

              EndContact(contact) {
                if (this._EndContact && contact._shouldReport) {
                  contact._shouldReport = false;

                  this._EndContact(contact);
                }
              }

              PreSolve(contact, oldManifold) {
                if (this._PreSolve && contact._shouldReport) {
                  this._PreSolve(contact, oldManifold);
                }
              }

              PostSolve(contact, impulse) {
                if (this._PostSolve && contact._shouldReport) {
                  this._PostSolve(contact, impulse);
                }
              }

              registerContactFixture(fixture) {
                this._contactFixtures.push(fixture);
              }

              unregisterContactFixture(fixture) {
                remove(this._contactFixtures, fixture);
              }

            }

            class PhysicsAABBQueryCallback extends box2d_1.QueryCallback {
              constructor(...args) {
                super(...args);
                this._point = new box2d_1.Vec2();
                this._isPoint = false;
                this._fixtures = [];
              }

              init(point) {
                if (point) {
                  this._isPoint = true;
                  this._point.x = point.x;
                  this._point.y = point.y;
                } else {
                  this._isPoint = false;
                }

                this._fixtures.length = 0;
              }

              ReportFixture(fixture) {
                if (this._isPoint) {
                  if (fixture.TestPoint(this._point)) {
                    this._fixtures.push(fixture);
                  }
                } else {
                  this._fixtures.push(fixture);
                }

                return true;
              }

              getFixture() {
                return this._fixtures[0];
              }

              getFixtures() {
                return this._fixtures;
              }

            }

            function At(i, vertices) {
              const s = vertices.length;
              return vertices[i < 0 ? s - -i % s : i % s];
            }

            function Copy(i, j, vertices) {
              const p = [];

              while (j < i) j += vertices.length;

              for (; i <= j; ++i) {
                p.push(At(i, vertices));
              }

              return p;
            }

            function ConvexPartition(vertices) {
              ForceCounterClockWise(vertices);
              let list = [];
              let d;
              let lowerDist;
              let upperDist;
              let p;
              let lowerInt = new Vec2();
              let upperInt = new Vec2();
              let lowerIndex = 0;
              let upperIndex = 0;
              let lowerPoly;
              let upperPoly;

              for (let i = 0; i < vertices.length; ++i) {
                if (Reflex(i, vertices)) {
                  lowerDist = upperDist = 10e7;

                  for (let j = 0; j < vertices.length; ++j) {
                    if (Left(At(i - 1, vertices), At(i, vertices), At(j, vertices)) && RightOn(At(i - 1, vertices), At(i, vertices), At(j - 1, vertices))) {
                      p = LineIntersect(At(i - 1, vertices), At(i, vertices), At(j, vertices), At(j - 1, vertices));

                      if (Right(At(i + 1, vertices), At(i, vertices), p)) {
                        d = SquareDist(At(i, vertices), p);

                        if (d < lowerDist) {
                          lowerDist = d;
                          lowerInt = p;
                          lowerIndex = j;
                        }
                      }
                    }

                    if (Left(At(i + 1, vertices), At(i, vertices), At(j + 1, vertices)) && RightOn(At(i + 1, vertices), At(i, vertices), At(j, vertices))) {
                      p = LineIntersect(At(i + 1, vertices), At(i, vertices), At(j, vertices), At(j + 1, vertices));

                      if (Left(At(i - 1, vertices), At(i, vertices), p)) {
                        d = SquareDist(At(i, vertices), p);

                        if (d < upperDist) {
                          upperDist = d;
                          upperIndex = j;
                          upperInt = p;
                        }
                      }
                    }
                  }

                  if (lowerIndex == (upperIndex + 1) % vertices.length) {
                    const sp = lowerInt.add(upperInt).multiplyScalar(1 / 2);
                    lowerPoly = Copy(i, upperIndex, vertices);
                    lowerPoly.push(sp);
                    upperPoly = Copy(lowerIndex, i, vertices);
                    upperPoly.push(sp);
                  } else {
                    let highestScore = 0;
                    let bestIndex = lowerIndex;

                    while (upperIndex < lowerIndex) {
                      upperIndex += vertices.length;
                    }

                    for (let j = lowerIndex; j <= upperIndex; ++j) {
                      if (CanSee(i, j, vertices)) {
                        let score = 1 / (SquareDist(At(i, vertices), At(j, vertices)) + 1);

                        if (Reflex(j, vertices)) {
                          if (RightOn(At(j - 1, vertices), At(j, vertices), At(i, vertices)) && LeftOn(At(j + 1, vertices), At(j, vertices), At(i, vertices))) {
                            score += 3;
                          } else {
                            score += 2;
                          }
                        } else {
                          score += 1;
                        }

                        if (score > highestScore) {
                          bestIndex = j;
                          highestScore = score;
                        }
                      }
                    }

                    lowerPoly = Copy(i, bestIndex, vertices);
                    upperPoly = Copy(bestIndex, i, vertices);
                  }

                  list = list.concat(ConvexPartition(lowerPoly));
                  list = list.concat(ConvexPartition(upperPoly));
                  return list;
                }
              }

              list.push(vertices);

              for (let i = list.length - 1; i >= 0; i--) {
                if (list[i].length == 0) list.splice(i, 0);
              }

              return list;
            }

            function CanSee(i, j, vertices) {
              if (Reflex(i, vertices)) {
                if (LeftOn(At(i, vertices), At(i - 1, vertices), At(j, vertices)) && RightOn(At(i, vertices), At(i + 1, vertices), At(j, vertices))) return false;
              } else if (RightOn(At(i, vertices), At(i + 1, vertices), At(j, vertices)) || LeftOn(At(i, vertices), At(i - 1, vertices), At(j, vertices))) return false;

              if (Reflex(j, vertices)) {
                if (LeftOn(At(j, vertices), At(j - 1, vertices), At(i, vertices)) && RightOn(At(j, vertices), At(j + 1, vertices), At(i, vertices))) return false;
              } else if (RightOn(At(j, vertices), At(j + 1, vertices), At(i, vertices)) || LeftOn(At(j, vertices), At(j - 1, vertices), At(i, vertices))) return false;

              for (let k = 0; k < vertices.length; ++k) {
                if ((k + 1) % vertices.length == i || k == i || (k + 1) % vertices.length == j || k == j) {
                  continue;
                }

                const intersectionPoint = new Vec2();

                if (LineIntersect2(At(i, vertices), At(j, vertices), At(k, vertices), At(k + 1, vertices), intersectionPoint)) {
                  return false;
                }
              }

              return true;
            }

            function Reflex(i, vertices) {
              return Right(i, vertices);
            }

            function Right(a, b, c) {
              if (typeof c === 'undefined') {
                const i = a;
                const vertices = b;
                a = At(i - 1, vertices);
                b = At(i, vertices);
                c = At(i + 1, vertices);
              }

              return Area(a, b, c) < 0;
            }

            function Left(a, b, c) {
              return Area(a, b, c) > 0;
            }

            function LeftOn(a, b, c) {
              return Area(a, b, c) >= 0;
            }

            function RightOn(a, b, c) {
              return Area(a, b, c) <= 0;
            }

            function SquareDist(a, b) {
              const dx = b.x - a.x;
              const dy = b.y - a.y;
              return dx * dx + dy * dy;
            }

            function ForceCounterClockWise(vertices) {
              if (!IsCounterClockWise(vertices)) {
                vertices.reverse();
              }
            }
            function IsCounterClockWise(vertices) {
              if (vertices.length < 3) return true;
              return GetSignedArea(vertices) > 0;
            }

            function GetSignedArea(vertices) {
              let i;
              let area = 0;

              for (i = 0; i < vertices.length; i++) {
                const j = (i + 1) % vertices.length;
                area += vertices[i].x * vertices[j].y;
                area -= vertices[i].y * vertices[j].x;
              }

              area /= 2;
              return area;
            }

            function LineIntersect(p1, p2, q1, q2) {
              const i = new Vec2();
              const a1 = p2.y - p1.y;
              const b1 = p1.x - p2.x;
              const c1 = a1 * p1.x + b1 * p1.y;
              const a2 = q2.y - q1.y;
              const b2 = q1.x - q2.x;
              const c2 = a2 * q1.x + b2 * q1.y;
              const det = a1 * b2 - a2 * b1;

              if (!FloatEquals(det, 0)) {
                i.x = (b2 * c1 - b1 * c2) / det;
                i.y = (a1 * c2 - a2 * c1) / det;
              }

              return i;
            }

            function LineIntersect2(a0, a1, b0, b1, intersectionPoint) {
              if (a0 == b0 || a0 == b1 || a1 == b0 || a1 == b1) return false;
              const x1 = a0.x;
              const y1 = a0.y;
              const x2 = a1.x;
              const y2 = a1.y;
              const x3 = b0.x;
              const y3 = b0.y;
              const x4 = b1.x;
              const y4 = b1.y;
              if (Math.max(x1, x2) < Math.min(x3, x4) || Math.max(x3, x4) < Math.min(x1, x2)) return false;
              if (Math.max(y1, y2) < Math.min(y3, y4) || Math.max(y3, y4) < Math.min(y1, y2)) return false;
              let ua = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
              let ub = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
              const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);

              if (Math.abs(denom) < 10e-7) {
                return false;
              }

              ua /= denom;
              ub /= denom;

              if (ua > 0 && ua < 1 && ub > 0 && ub < 1) {
                intersectionPoint.x = x1 + ua * (x2 - x1);
                intersectionPoint.y = y1 + ua * (y2 - y1);
                return true;
              }

              return false;
            }

            function FloatEquals(value1, value2) {
              return Math.abs(value1 - value2) <= 10e-7;
            }

            function Area(a, b, c) {
              return a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y);
            }

            var PolygonSeparator = /*#__PURE__*/Object.freeze({
                __proto__: null,
                ConvexPartition: ConvexPartition,
                ForceCounterClockWise: ForceCounterClockWise,
                IsCounterClockWise: IsCounterClockWise
            });

            const FUNC = (...v) => 0;

            function checkPhysicsModule(obj) {
              if ( obj == null) {
                errorID(9600);
                return true;
              }

              return false;
            }
            function createPhysicsWorld() {
              if ( checkPhysicsModule(WRAPPER.PhysicsWorld)) {
                return null;
              }

              return new WRAPPER.PhysicsWorld();
            }
            const EntireBody = {
              impl: null,
              rigidBody: null,
              isAwake: false,
              isSleeping: false,
              initialize: FUNC,
              setType: FUNC,
              setLinearDamping: FUNC,
              setAngularDamping: FUNC,
              setGravityScale: FUNC,
              setFixedRotation: FUNC,
              setAllowSleep: FUNC,
              isActive: FUNC,
              setActive: FUNC,
              wakeUp: FUNC,
              sleep: FUNC,
              getMass: FUNC,
              getInertia: FUNC,
              getLinearVelocity: FUNC,
              setLinearVelocity: FUNC,
              getLinearVelocityFromWorldPoint: FUNC,
              getAngularVelocity: FUNC,
              setAngularVelocity: FUNC,
              getLocalVector: FUNC,
              getWorldVector: FUNC,
              getLocalPoint: FUNC,
              getWorldPoint: FUNC,
              getLocalCenter: FUNC,
              getWorldCenter: FUNC,
              applyForce: FUNC,
              applyForceToCenter: FUNC,
              applyTorque: FUNC,
              applyLinearImpulse: FUNC,
              applyLinearImpulseToCenter: FUNC,
              applyAngularImpulse: FUNC,
              onEnable: FUNC,
              onDisable: FUNC,
              onDestroy: FUNC
            };
            function createRigidBody() {
              const PHYSICS_2D_BUILTIN = legacyCC._global.CC_PHYSICS_2D_BUILTIN;

              if (PHYSICS_2D_BUILTIN) {
                return EntireBody;
              } else {
                if ( checkPhysicsModule(WRAPPER.RigidBody)) {
                  return null;
                }

                return new WRAPPER.RigidBody();
              }
            }
            const CREATE_COLLIDER_PROXY = {
              INITED: false
            };
            const ENTIRE_SHAPE = {
              impl: null,
              collider: null,
              worldAABB: null,
              worldPoints: null,
              worldPosition: null,
              worldRadius: null,
              initialize: FUNC,
              apply: FUNC,
              onLoad: FUNC,
              onEnable: FUNC,
              onDisable: FUNC,
              onDestroy: FUNC,
              onGroupChanged: FUNC
            };
            function createShape(type) {
              initColliderProxy();
              return CREATE_COLLIDER_PROXY[type]();
            }

            function initColliderProxy() {
              if (CREATE_COLLIDER_PROXY.INITED) return;
              CREATE_COLLIDER_PROXY.INITED = true;

              CREATE_COLLIDER_PROXY[ECollider2DType.BOX] = function createBoxShape() {
                if ( checkPhysicsModule(WRAPPER.BoxShape)) {
                  return ENTIRE_SHAPE;
                }

                return new WRAPPER.BoxShape();
              };

              CREATE_COLLIDER_PROXY[ECollider2DType.CIRCLE] = function createCircleShape() {
                if ( checkPhysicsModule(WRAPPER.CircleShape)) {
                  return ENTIRE_SHAPE;
                }

                return new WRAPPER.CircleShape();
              };

              CREATE_COLLIDER_PROXY[ECollider2DType.POLYGON] = function createPolygonShape() {
                if ( checkPhysicsModule(WRAPPER.PolygonShape)) {
                  return ENTIRE_SHAPE;
                }

                return new WRAPPER.PolygonShape();
              };
            }

            const CREATE_JOINT_PROXY = {
              INITED: false
            };
            const ENTIRE_JOINT = {
              impl: null,
              initialize: FUNC,
              setDampingRatio: FUNC,
              setFrequency: FUNC,
              setMaxForce: FUNC,
              setTarget: FUNC,
              setDistance: FUNC,
              setAngularOffset: FUNC,
              setCorrectionFactor: FUNC,
              setLinearOffset: FUNC,
              setMaxLength: FUNC,
              setMaxTorque: FUNC,
              setLowerLimit: FUNC,
              setUpperLimit: FUNC,
              setMaxMotorForce: FUNC,
              setMaxMotorTorque: FUNC,
              setMotorSpeed: FUNC,
              enableLimit: FUNC,
              enableMotor: FUNC,
              setLowerAngle: FUNC,
              setUpperAngle: FUNC
            };
            function createJoint(type) {
              initJointProxy();
              return CREATE_JOINT_PROXY[type]();
            }

            function initJointProxy() {
              if (CREATE_JOINT_PROXY.INITED) return;
              CREATE_JOINT_PROXY.INITED = true;
              const PHYSICS_2D_BUILTIN = legacyCC._global.CC_PHYSICS_2D_BUILTIN;

              CREATE_JOINT_PROXY[EJoint2DType.SPRING] = function createSpringJoint() {
                if (PHYSICS_2D_BUILTIN) {
                  return ENTIRE_JOINT;
                } else {
                  if ( checkPhysicsModule(WRAPPER.SpringJoint)) {
                    return ENTIRE_JOINT;
                  }

                  return new WRAPPER.SpringJoint();
                }
              };

              CREATE_JOINT_PROXY[EJoint2DType.DISTANCE] = function createDistanceJoint() {
                if (PHYSICS_2D_BUILTIN) {
                  return ENTIRE_JOINT;
                } else {
                  if ( checkPhysicsModule(WRAPPER.DistanceJoint)) {
                    return ENTIRE_JOINT;
                  }

                  return new WRAPPER.DistanceJoint();
                }
              };

              CREATE_JOINT_PROXY[EJoint2DType.FIXED] = function createFixedJoint() {
                if (PHYSICS_2D_BUILTIN) {
                  return ENTIRE_JOINT;
                } else {
                  if ( checkPhysicsModule(WRAPPER.FixedJoint)) {
                    return ENTIRE_JOINT;
                  }

                  return new WRAPPER.FixedJoint();
                }
              };

              CREATE_JOINT_PROXY[EJoint2DType.MOUSE] = function createMouseJoint() {
                if (PHYSICS_2D_BUILTIN) {
                  return ENTIRE_JOINT;
                } else {
                  if ( checkPhysicsModule(WRAPPER.MouseJoint)) {
                    return ENTIRE_JOINT;
                  }

                  return new WRAPPER.MouseJoint();
                }
              };

              CREATE_JOINT_PROXY[EJoint2DType.RELATIVE] = function createRelativeJoint() {
                if (PHYSICS_2D_BUILTIN) {
                  return ENTIRE_JOINT;
                } else {
                  if ( checkPhysicsModule(WRAPPER.RelativeJoint)) {
                    return ENTIRE_JOINT;
                  }

                  return new WRAPPER.RelativeJoint();
                }
              };

              CREATE_JOINT_PROXY[EJoint2DType.SLIDER] = function createSliderJoint() {
                if (PHYSICS_2D_BUILTIN) {
                  return ENTIRE_JOINT;
                } else {
                  if ( checkPhysicsModule(WRAPPER.SliderJoint)) {
                    return ENTIRE_JOINT;
                  }

                  return new WRAPPER.SliderJoint();
                }
              };

              CREATE_JOINT_PROXY[EJoint2DType.WHEEL] = function createWheelJoint() {
                if (PHYSICS_2D_BUILTIN) {
                  return ENTIRE_JOINT;
                } else {
                  if ( checkPhysicsModule(WRAPPER.WheelJoint)) {
                    return ENTIRE_JOINT;
                  }

                  return new WRAPPER.WheelJoint();
                }
              };

              CREATE_JOINT_PROXY[EJoint2DType.HINGE] = function createHingeJoint() {
                if (PHYSICS_2D_BUILTIN) {
                  return ENTIRE_JOINT;
                } else {
                  if ( checkPhysicsModule(WRAPPER.HingeJoint)) {
                    return ENTIRE_JOINT;
                  }

                  return new WRAPPER.HingeJoint();
                }
              };
            }

            let instance = null;
            class PhysicsSystem2D extends Eventify(System) {
              get enable() {
                return this._enable;
              }

              set enable(value) {
                this._enable = value;
              }

              get allowSleep() {
                return this._allowSleep;
              }

              set allowSleep(v) {
                this._allowSleep = v;

                {
                  this.physicsWorld.setAllowSleep(v);
                }
              }

              get gravity() {
                return this._gravity;
              }

              set gravity(gravity) {
                this._gravity.set(gravity);

                {
                  this.physicsWorld.setGravity(new Vec2(gravity.x / PHYSICS_2D_PTM_RATIO, gravity.y / PHYSICS_2D_PTM_RATIO));
                }
              }

              get maxSubSteps() {
                return this._maxSubSteps;
              }

              set maxSubSteps(value) {
                this._maxSubSteps = value;
              }

              get fixedTimeStep() {
                return this._fixedTimeStep;
              }

              set fixedTimeStep(value) {
                this._fixedTimeStep = value;
              }

              get autoSimulation() {
                return this._autoSimulation;
              }

              set autoSimulation(value) {
                this._autoSimulation = value;
              }

              get debugDrawFlags() {
                return this.physicsWorld.debugDrawFlags;
              }

              set debugDrawFlags(v) {
                this.physicsWorld.debugDrawFlags = v;
              }

              static get PHYSICS_NONE() {
                return !physicsEngineId;
              }

              static get PHYSICS_BUILTIN() {
                return physicsEngineId === 'builtin';
              }

              static get PHYSICS_BOX2D() {
                return physicsEngineId === 'box2d';
              }

              static get PhysicsGroup() {
                return PhysicsGroup;
              }

              static get instance() {
                if (!instance) {
                  instance = new PhysicsSystem2D();
                }

                return instance;
              }

              get stepping() {
                return this._steping;
              }

              constructor() {
                super();
                this.velocityIterations = 10;
                this.positionIterations = 10;
                this.physicsWorld = void 0;
                this.collisionMatrix = new CollisionMatrix();
                this._enable = true;
                this._allowSleep = true;
                this._maxSubSteps = 1;
                this._fixedTimeStep = 1.0 / 60.0;
                this._autoSimulation = true;
                this._accumulator = 0;
                this._steping = false;
                this._gravity = new Vec2(0, -10 * PHYSICS_2D_PTM_RATIO);
                this._delayEvents = [];
                const config = game.config ? game.config.physics : null;

                if (config) {
                  Vec2.copy(this._gravity, config.gravity);

                  this._gravity.multiplyScalar(PHYSICS_2D_PTM_RATIO);

                  this._allowSleep = config.allowSleep;
                  this._fixedTimeStep = config.fixedTimeStep;
                  this._maxSubSteps = config.maxSubSteps;
                  this._autoSimulation = config.autoSimulation;

                  if (config.collisionMatrix) {
                    for (const i in config.collisionMatrix) {
                      const bit = parseInt(i);
                      const value = 1 << parseInt(i);
                      this.collisionMatrix[`${value}`] = config.collisionMatrix[bit];
                    }
                  }

                  if (config.collisionGroups) {
                    const cg = config.collisionGroups;

                    if (cg instanceof Array) {
                      cg.forEach(v => {
                        PhysicsGroup[v.name] = 1 << v.index;
                      });
                      Enum.update(PhysicsGroup);
                    }
                  }
                }

                this.physicsWorld = createPhysicsWorld();
                this.gravity = this._gravity;
                this.allowSleep = this._allowSleep;
              }

              postUpdate(deltaTime) {
                if (!this._enable) {
                  return;
                }

                if (!this._autoSimulation) {
                  return;
                }

                director.emit(Director.EVENT_BEFORE_PHYSICS);
                this._steping = true;
                const fixedTimeStep = this._fixedTimeStep;
                const velocityIterations = this.velocityIterations;
                const positionIterations = this.positionIterations;
                this._accumulator += deltaTime;
                let substepIndex = 0;

                while (substepIndex++ < this._maxSubSteps && this._accumulator > fixedTimeStep) {
                  this.physicsWorld.step(fixedTimeStep, velocityIterations, positionIterations);
                  this._accumulator -= fixedTimeStep;
                }

                const events = this._delayEvents;

                for (let i = 0, l = events.length; i < l; i++) {
                  const event = events[i];
                  event.func.call(event.target);
                }

                events.length = 0;
                this.physicsWorld.syncPhysicsToScene();

                if (this.debugDrawFlags) {
                  this.physicsWorld.drawDebug();
                }

                this._steping = false;
                director.emit(Director.EVENT_AFTER_PHYSICS);
              }

              _callAfterStep(target, func) {
                if (this._steping) {
                  this._delayEvents.push({
                    target,
                    func
                  });
                } else {
                  func.call(target);
                }
              }

              resetAccumulator(time = 0) {
                this._accumulator = time;
              }

              step(fixedTimeStep) {
                this.physicsWorld.step(fixedTimeStep, this.velocityIterations, this.positionIterations);
              }

              raycast(p1, p2, type = ERaycast2DType.Closest, mask = 0xffffffff) {
                return this.physicsWorld.raycast(p1, p2, type, mask);
              }

              testPoint(p) {
                return this.physicsWorld.testPoint(p);
              }

              testAABB(rect) {
                return this.physicsWorld.testAABB(rect);
              }

            } exports('PhysicsSystem2D', PhysicsSystem2D);
            PhysicsSystem2D.ID = 'PHYSICS_2D';
            director.once(Director.EVENT_INIT, () => {
              console.log('pptest initPhysicsSystem 1');
              initPhysicsSystem();
              console.log('pptest initPhysicsSystem 5');
            });

            function initPhysicsSystem() {
              console.log('pptest initPhysicsSystem 2');
              if (!PhysicsSystem2D.PHYSICS_NONE && !EDITOR) {
                console.log('pptest initPhysicsSystem 3');
                director.registerSystem(PhysicsSystem2D.ID, PhysicsSystem2D.instance, System.Priority.LOW);
                console.log('pptest initPhysicsSystem 4');
              }
            }

            let Physics2DManifoldType;

            (function (Physics2DManifoldType) {
              Physics2DManifoldType[Physics2DManifoldType["Circles"] = 0] = "Circles";
              Physics2DManifoldType[Physics2DManifoldType["FaceA"] = 1] = "FaceA";
              Physics2DManifoldType[Physics2DManifoldType["FaceB"] = 2] = "FaceB";
            })(Physics2DManifoldType || (Physics2DManifoldType = exports('Physics2DManifoldType', {})));

            var _dec$10, _dec2$W, _dec3$U, _dec4$Q, _class$10, _class2$S, _descriptor$R, _descriptor2$O, _descriptor3$G, _descriptor4$E, _descriptor5$y, _descriptor6$q, _descriptor7$m, _descriptor8$i, _descriptor9$f, _descriptor10$e, _descriptor11$d, _descriptor12$b, _temp$V;
            const {
              property,
              type,
              menu
            } = _decorator;
            let RigidBody2D = exports('RigidBody2D', (_dec$10 = ccclass('cc.RigidBody2D'), _dec2$W = menu('Physics2D/RigidBody2D'), _dec3$U = type(PhysicsGroup$1), _dec4$Q = type(ERigidBody2DType), _dec$10(_class$10 = _dec2$W(_class$10 = (_class2$S = (_temp$V = class RigidBody2D extends Component {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "enabledContactListener", _descriptor$R, this);

                _initializerDefineProperty(this, "bullet", _descriptor2$O, this);

                _initializerDefineProperty(this, "awakeOnLoad", _descriptor3$G, this);

                this._body = null;

                _initializerDefineProperty(this, "_group", _descriptor4$E, this);

                _initializerDefineProperty(this, "_type", _descriptor5$y, this);

                _initializerDefineProperty(this, "_allowSleep", _descriptor6$q, this);

                _initializerDefineProperty(this, "_gravityScale", _descriptor7$m, this);

                _initializerDefineProperty(this, "_linearDamping", _descriptor8$i, this);

                _initializerDefineProperty(this, "_angularDamping", _descriptor9$f, this);

                _initializerDefineProperty(this, "_linearVelocity", _descriptor10$e, this);

                _initializerDefineProperty(this, "_angularVelocity", _descriptor11$d, this);

                _initializerDefineProperty(this, "_fixedRotation", _descriptor12$b, this);
              }

              get group() {
                return this._group;
              }

              set group(v) {
                this._group = v;
              }

              get type() {
                return this._type;
              }

              set type(v) {
                this._type = v;

                if (this._body) {
                  if (v === ERigidBody2DType.Animated) {
                    this._body.setType(ERigidBody2DType.Kinematic);
                  } else {
                    this._body.setType(v);
                  }
                }
              }

              get allowSleep() {
                return this._allowSleep;
              }

              set allowSleep(v) {
                this._allowSleep = v;

                if (this._body) {
                  this._body.setAllowSleep(v);
                }
              }

              get gravityScale() {
                return this._gravityScale;
              }

              set gravityScale(v) {
                this._gravityScale = v;

                if (this._body) {
                  this._body.setGravityScale(v);
                }
              }

              get linearDamping() {
                return this._linearDamping;
              }

              set linearDamping(v) {
                this._linearDamping = v;

                if (this._body) {
                  this._body.setLinearDamping(v);
                }
              }

              get angularDamping() {
                return this._angularDamping;
              }

              set angularDamping(v) {
                this._angularDamping = v;

                if (this._body) {
                  this._body.setAngularDamping(v);
                }
              }

              get linearVelocity() {
                if (this._body) {
                  this._body.getLinearVelocity(this._linearVelocity);
                }

                return this._linearVelocity;
              }

              set linearVelocity(v) {
                this._linearVelocity = v;

                if (this._body) {
                  this._body.setLinearVelocity(v);
                }
              }

              get angularVelocity() {
                if (this._body) {
                  this._angularVelocity = this._body.getAngularVelocity();
                }

                return this._angularVelocity;
              }

              set angularVelocity(v) {
                this._angularVelocity = v;

                if (this._body) {
                  this._body.setAngularVelocity(v);
                }
              }

              get fixedRotation() {
                return this._fixedRotation;
              }

              set fixedRotation(v) {
                this._fixedRotation = v;

                if (this._body) {
                  this._body.setFixedRotation(v);
                }
              }

              isAwake() {
                if (this._body) {
                  return this._body.isAwake;
                }

                return false;
              }

              wakeUp() {
                if (this._body) {
                  this._body.wakeUp();
                }
              }

              sleep() {
                if (this._body) {
                  this._body.sleep();
                }
              }

              getMass() {
                if (this._body) {
                  return this._body.getMass();
                }

                return 0;
              }

              applyForce(force, point, wake) {
                if (this._body) {
                  this._body.applyForce(force, point, wake);
                }
              }

              applyForceToCenter(force, wake) {
                if (this._body) {
                  this._body.applyForceToCenter(force, wake);
                }
              }

              applyTorque(torque, wake) {
                if (this._body) {
                  this._body.applyTorque(torque, wake);
                }
              }

              applyLinearImpulse(impulse, point, wake) {
                if (this._body) {
                  this._body.applyLinearImpulse(impulse, point, wake);
                }
              }

              applyLinearImpulseToCenter(impulse, wake) {
                if (this._body) {
                  this._body.applyLinearImpulseToCenter(impulse, wake);
                }
              }

              applyAngularImpulse(impulse, wake) {
                if (this._body) {
                  this._body.applyAngularImpulse(impulse, wake);
                }
              }

              getLinearVelocityFromWorldPoint(worldPoint, out) {
                if (this._body) {
                  return this._body.getLinearVelocityFromWorldPoint(worldPoint, out);
                }

                return out;
              }

              getLocalVector(worldVector, out) {
                if (this._body) {
                  return this._body.getLocalVector(worldVector, out);
                }

                return out;
              }

              getWorldVector(localVector, out) {
                if (this._body) {
                  return this._body.getWorldVector(localVector, out);
                }

                return out;
              }

              getLocalPoint(worldPoint, out) {
                if (this._body) {
                  return this._body.getLocalPoint(worldPoint, out);
                }

                return out;
              }

              getWorldPoint(localPoint, out) {
                if (this._body) {
                  return this._body.getWorldPoint(localPoint, out);
                }

                return out;
              }

              getLocalCenter(out) {
                if (this._body) {
                  return this._body.getLocalCenter(out);
                }

                return out;
              }

              getWorldCenter(out) {
                if (this._body) {
                  return this._body.getWorldCenter(out);
                }

                return out;
              }

              getInertia() {
                if (this._body) {
                  this._body.getInertia();
                }

                return 0;
              }

              onLoad() {
                {
                  this._body = createRigidBody();

                  this._body.initialize(this);
                }
              }

              onEnable() {
                if (this._body) {
                  this._body.onEnable();
                }
              }

              onDisable() {
                if (this._body) {
                  this._body.onDisable();
                }
              }

              onDestroy() {
                if (this._body) {
                  this._body.onDestroy();
                }
              }

              get impl() {
                return this._body;
              }

            }, _temp$V), (_applyDecoratedDescriptor(_class2$S.prototype, "group", [_dec3$U], Object.getOwnPropertyDescriptor(_class2$S.prototype, "group"), _class2$S.prototype), _descriptor$R = _applyDecoratedDescriptor(_class2$S.prototype, "enabledContactListener", [property], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor2$O = _applyDecoratedDescriptor(_class2$S.prototype, "bullet", [property], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _applyDecoratedDescriptor(_class2$S.prototype, "type", [_dec4$Q], Object.getOwnPropertyDescriptor(_class2$S.prototype, "type"), _class2$S.prototype), _applyDecoratedDescriptor(_class2$S.prototype, "allowSleep", [property], Object.getOwnPropertyDescriptor(_class2$S.prototype, "allowSleep"), _class2$S.prototype), _applyDecoratedDescriptor(_class2$S.prototype, "gravityScale", [property], Object.getOwnPropertyDescriptor(_class2$S.prototype, "gravityScale"), _class2$S.prototype), _applyDecoratedDescriptor(_class2$S.prototype, "linearDamping", [property], Object.getOwnPropertyDescriptor(_class2$S.prototype, "linearDamping"), _class2$S.prototype), _applyDecoratedDescriptor(_class2$S.prototype, "angularDamping", [property], Object.getOwnPropertyDescriptor(_class2$S.prototype, "angularDamping"), _class2$S.prototype), _applyDecoratedDescriptor(_class2$S.prototype, "linearVelocity", [property], Object.getOwnPropertyDescriptor(_class2$S.prototype, "linearVelocity"), _class2$S.prototype), _applyDecoratedDescriptor(_class2$S.prototype, "angularVelocity", [property], Object.getOwnPropertyDescriptor(_class2$S.prototype, "angularVelocity"), _class2$S.prototype), _applyDecoratedDescriptor(_class2$S.prototype, "fixedRotation", [property], Object.getOwnPropertyDescriptor(_class2$S.prototype, "fixedRotation"), _class2$S.prototype), _descriptor3$G = _applyDecoratedDescriptor(_class2$S.prototype, "awakeOnLoad", [property], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _descriptor4$E = _applyDecoratedDescriptor(_class2$S.prototype, "_group", [property], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return PhysicsGroup$1.DEFAULT;
              }
            }), _descriptor5$y = _applyDecoratedDescriptor(_class2$S.prototype, "_type", [property], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return ERigidBody2DType.Dynamic;
              }
            }), _descriptor6$q = _applyDecoratedDescriptor(_class2$S.prototype, "_allowSleep", [property], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _descriptor7$m = _applyDecoratedDescriptor(_class2$S.prototype, "_gravityScale", [property], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            }), _descriptor8$i = _applyDecoratedDescriptor(_class2$S.prototype, "_linearDamping", [property], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor9$f = _applyDecoratedDescriptor(_class2$S.prototype, "_angularDamping", [property], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor10$e = _applyDecoratedDescriptor(_class2$S.prototype, "_linearVelocity", [property], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec2();
              }
            }), _descriptor11$d = _applyDecoratedDescriptor(_class2$S.prototype, "_angularVelocity", [property], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor12$b = _applyDecoratedDescriptor(_class2$S.prototype, "_fixedRotation", [property], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            })), _class2$S)) || _class$10) || _class$10));

            var _dec$11, _dec2$X, _class$11, _class2$T, _descriptor$S, _descriptor2$P, _descriptor3$H, _descriptor4$F, _descriptor5$z, _descriptor6$r, _descriptor7$n, _descriptor8$j, _temp$W;
            let Collider2D = exports('Collider2D', (_dec$11 = ccclass('cc.Collider2D'), _dec2$X = type$1(PhysicsGroup$1), _dec$11(_class$11 = (_class2$T = (_temp$W = class Collider2D extends Eventify(Component) {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "editing", _descriptor$S, this);

                _initializerDefineProperty(this, "tag", _descriptor2$P, this);

                this.TYPE = ECollider2DType.None;
                this._shape = null;
                this._body = null;

                _initializerDefineProperty(this, "_group", _descriptor3$H, this);

                _initializerDefineProperty(this, "_density", _descriptor4$F, this);

                _initializerDefineProperty(this, "_sensor", _descriptor5$z, this);

                _initializerDefineProperty(this, "_friction", _descriptor6$r, this);

                _initializerDefineProperty(this, "_restitution", _descriptor7$n, this);

                _initializerDefineProperty(this, "_offset", _descriptor8$j, this);
              }

              get group() {
                return this._group;
              }

              set group(v) {
                this._group = v;

                if (this._shape && this._shape.onGroupChanged) {
                  this._shape.onGroupChanged();
                }
              }

              get density() {
                return this._density;
              }

              set density(v) {
                this._density = v;
              }

              get sensor() {
                return this._sensor;
              }

              set sensor(v) {
                this._sensor = v;
              }

              get friction() {
                return this._friction;
              }

              set friction(v) {
                this._friction = v;
              }

              get restitution() {
                return this._restitution;
              }

              set restitution(v) {
                this._restitution = v;
              }

              get offset() {
                return this._offset;
              }

              set offset(v) {
                this._offset = v;
              }

              get body() {
                return this._body;
              }

              get impl() {
                return this._shape;
              }

              onLoad() {
                {
                  this._shape = createShape(this.TYPE);

                  this._shape.initialize(this);

                  if (this._shape.onLoad) {
                    this._shape.onLoad();
                  }

                  this._body = this.getComponent(RigidBody2D);
                }
              }

              onEnable() {
                if (this._shape) {
                  this._shape.onEnable();
                }
              }

              onDisable() {
                if (this._shape && this._shape.onDisable) {
                  this._shape.onDisable();
                }
              }

              onDestroy() {
                if (this._shape && this._shape.onDestroy) {
                  this._shape.onDestroy();
                }
              }

              apply() {
                if (this._shape && this._shape.apply) {
                  this._shape.apply();
                }
              }

              get worldAABB() {
                if (this._shape) {
                  return this._shape.worldAABB;
                }

                return new Rect$1();
              }

            }, _temp$W), (_descriptor$S = _applyDecoratedDescriptor(_class2$T.prototype, "editing", [editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor2$P = _applyDecoratedDescriptor(_class2$T.prototype, "tag", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _applyDecoratedDescriptor(_class2$T.prototype, "group", [_dec2$X], Object.getOwnPropertyDescriptor(_class2$T.prototype, "group"), _class2$T.prototype), _applyDecoratedDescriptor(_class2$T.prototype, "density", [property$1], Object.getOwnPropertyDescriptor(_class2$T.prototype, "density"), _class2$T.prototype), _applyDecoratedDescriptor(_class2$T.prototype, "sensor", [property$1], Object.getOwnPropertyDescriptor(_class2$T.prototype, "sensor"), _class2$T.prototype), _applyDecoratedDescriptor(_class2$T.prototype, "friction", [property$1], Object.getOwnPropertyDescriptor(_class2$T.prototype, "friction"), _class2$T.prototype), _applyDecoratedDescriptor(_class2$T.prototype, "restitution", [property$1], Object.getOwnPropertyDescriptor(_class2$T.prototype, "restitution"), _class2$T.prototype), _applyDecoratedDescriptor(_class2$T.prototype, "offset", [property$1], Object.getOwnPropertyDescriptor(_class2$T.prototype, "offset"), _class2$T.prototype), _descriptor3$H = _applyDecoratedDescriptor(_class2$T.prototype, "_group", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return PhysicsGroup$1.DEFAULT;
              }
            }), _descriptor4$F = _applyDecoratedDescriptor(_class2$T.prototype, "_density", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1.0;
              }
            }), _descriptor5$z = _applyDecoratedDescriptor(_class2$T.prototype, "_sensor", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor6$r = _applyDecoratedDescriptor(_class2$T.prototype, "_friction", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.2;
              }
            }), _descriptor7$n = _applyDecoratedDescriptor(_class2$T.prototype, "_restitution", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor8$j = _applyDecoratedDescriptor(_class2$T.prototype, "_offset", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec2();
              }
            })), _class2$T)) || _class$11));

            var _dec$12, _dec2$Y, _class$12, _class2$U, _descriptor$T, _temp$X;
            let BoxCollider2D = exports('BoxCollider2D', (_dec$12 = ccclass('cc.BoxCollider2D'), _dec2$Y = menu$1(), _dec$12(_class$12 = _dec2$Y(_class$12 = (_class2$U = (_temp$X = class BoxCollider2D extends Collider2D {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "_size", _descriptor$T, this);

                this.TYPE = ECollider2DType.BOX;
              }

              get size() {
                return this._size;
              }

              set size(v) {
                this._size = v;
              }

              get worldPoints() {
                if (this._shape) {
                  return this._shape.worldPoints;
                }

                return [];
              }

            }, _temp$X), (_descriptor$T = _applyDecoratedDescriptor(_class2$U.prototype, "_size", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Size$1(1, 1);
              }
            }), _applyDecoratedDescriptor(_class2$U.prototype, "size", [property$1], Object.getOwnPropertyDescriptor(_class2$U.prototype, "size"), _class2$U.prototype)), _class2$U)) || _class$12) || _class$12));

            var _dec$13, _dec2$Z, _class$13, _class2$V, _descriptor$U, _temp$Y;
            let CircleCollider2D = exports('CircleCollider2D', (_dec$13 = ccclass('cc.CircleCollider2D'), _dec2$Z = menu$1(), _dec$13(_class$13 = _dec2$Z(_class$13 = (_class2$V = (_temp$Y = class CircleCollider2D extends Collider2D {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "_radius", _descriptor$U, this);

                this.TYPE = ECollider2DType.CIRCLE;
              }

              get radius() {
                return this._radius;
              }

              set radius(v) {
                this._radius = v < 0 ? 0 : v;
              }

              get worldPosition() {
                if (this._shape) {
                  return this._shape.worldPosition;
                }

                return new Vec2();
              }

              get worldRadius() {
                if (this._shape) {
                  return this._shape.worldRadius;
                }

                return 0;
              }

            }, _temp$Y), (_descriptor$U = _applyDecoratedDescriptor(_class2$V.prototype, "_radius", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            }), _applyDecoratedDescriptor(_class2$V.prototype, "radius", [property$1], Object.getOwnPropertyDescriptor(_class2$V.prototype, "radius"), _class2$V.prototype)), _class2$V)) || _class$13) || _class$13));

            var _dec$14, _dec2$_, _dec3$V, _dec4$R, _class$14, _class2$W, _descriptor$V, _descriptor2$Q, _temp$Z;
            let PolygonCollider2D = exports('PolygonCollider2D', (_dec$14 = ccclass('cc.PolygonCollider2D'), _dec2$_ = menu$1(), _dec3$V = property$1({
              serializable: false
            }), _dec4$R = property$1({
              type: Vec2
            }), _dec$14(_class$14 = _dec2$_(_class$14 = (_class2$W = (_temp$Z = class PolygonCollider2D extends Collider2D {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "threshold", _descriptor$V, this);

                _initializerDefineProperty(this, "_points", _descriptor2$Q, this);

                this.TYPE = ECollider2DType.POLYGON;
              }

              get points() {
                return this._points;
              }

              set points(v) {
                this._points = v;
              }

              get worldPoints() {
                if (this._shape) {
                  return this._shape.worldPoints;
                }

                return [];
              }

            }, _temp$Z), (_descriptor$V = _applyDecoratedDescriptor(_class2$W.prototype, "threshold", [_dec3$V], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            }), _descriptor2$Q = _applyDecoratedDescriptor(_class2$W.prototype, "_points", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [new Vec2(-1, -1), new Vec2(1, -1), new Vec2(1, 1), new Vec2(-1, 1)];
              }
            }), _applyDecoratedDescriptor(_class2$W.prototype, "points", [_dec4$R], Object.getOwnPropertyDescriptor(_class2$W.prototype, "points"), _class2$W.prototype)), _class2$W)) || _class$14) || _class$14));

            var _dec$15, _dec2$$, _class$15, _class2$X, _descriptor$W, _descriptor2$R, _descriptor3$I, _descriptor4$G, _temp$_;
            let Joint2D = exports('Joint2D', (_dec$15 = ccclass('cc.Joint2D'), _dec2$$ = type$1(RigidBody2D), _dec$15(_class$15 = (_class2$X = (_temp$_ = class Joint2D extends Component {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "anchor", _descriptor$W, this);

                _initializerDefineProperty(this, "connectedAnchor", _descriptor2$R, this);

                _initializerDefineProperty(this, "collideConnected", _descriptor3$I, this);

                _initializerDefineProperty(this, "connectedBody", _descriptor4$G, this);

                this._body = null;
                this._joint = null;
                this.TYPE = EJoint2DType.None;
              }

              get body() {
                return this._body;
              }

              get impl() {
                return this._joint;
              }

              onLoad() {
                {
                  this._joint = createJoint(this.TYPE);

                  this._joint.initialize(this);

                  this._body = this.getComponent(RigidBody2D);
                }
              }

              onEnable() {
                if (this._joint && this._joint.onEnable) {
                  this._joint.onEnable();
                }
              }

              onDisable() {
                if (this._joint && this._joint.onDisable) {
                  this._joint.onDisable();
                }
              }

              start() {
                if (this._joint && this._joint.start) {
                  this._joint.start();
                }
              }

              onDestroy() {
                if (this._joint && this._joint.onDestroy) {
                  this._joint.onDestroy();
                }
              }

            }, _temp$_), (_descriptor$W = _applyDecoratedDescriptor(_class2$X.prototype, "anchor", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec2();
              }
            }), _descriptor2$R = _applyDecoratedDescriptor(_class2$X.prototype, "connectedAnchor", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec2();
              }
            }), _descriptor3$I = _applyDecoratedDescriptor(_class2$X.prototype, "collideConnected", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor4$G = _applyDecoratedDescriptor(_class2$X.prototype, "connectedBody", [_dec2$$], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            })), _class2$X)) || _class$15));

            var _dec$16, _dec2$10, _class$16, _class2$Y, _descriptor$X, _descriptor2$S, _temp$$;
            let DistanceJoint2D = exports('DistanceJoint2D', (_dec$16 = ccclass('cc.DistanceJoint2D'), _dec2$10 = menu$1(), _dec$16(_class$16 = _dec2$10(_class$16 = (_class2$Y = (_temp$$ = class DistanceJoint2D extends Joint2D {
              constructor(...args) {
                super(...args);
                this.TYPE = EJoint2DType.DISTANCE;

                _initializerDefineProperty(this, "_maxLength", _descriptor$X, this);

                _initializerDefineProperty(this, "_autoCalcDistance", _descriptor2$S, this);
              }

              get maxLength() {
                if (this._autoCalcDistance && this.connectedBody) {
                  return Vec3.distance(this.node.worldPosition, this.connectedBody.node.worldPosition);
                }

                return this._maxLength;
              }

              set maxLength(v) {
                this._maxLength = v;

                if (this._joint) {
                  this._joint.setMaxLength(v);
                }
              }

              get autoCalcDistance() {
                return this._autoCalcDistance;
              }

              set autoCalcDistance(v) {
                this._autoCalcDistance = v;
              }

            }, _temp$$), (_applyDecoratedDescriptor(_class2$Y.prototype, "maxLength", [property$1], Object.getOwnPropertyDescriptor(_class2$Y.prototype, "maxLength"), _class2$Y.prototype), _applyDecoratedDescriptor(_class2$Y.prototype, "autoCalcDistance", [property$1], Object.getOwnPropertyDescriptor(_class2$Y.prototype, "autoCalcDistance"), _class2$Y.prototype), _descriptor$X = _applyDecoratedDescriptor(_class2$Y.prototype, "_maxLength", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 5;
              }
            }), _descriptor2$S = _applyDecoratedDescriptor(_class2$Y.prototype, "_autoCalcDistance", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            })), _class2$Y)) || _class$16) || _class$16));

            var _dec$17, _dec2$11, _class$17, _class2$Z, _descriptor$Y, _descriptor2$T, _descriptor3$J, _descriptor4$H, _temp$10;
            let SpringJoint2D = exports('SpringJoint2D', (_dec$17 = ccclass('cc.SpringJoint2D'), _dec2$11 = menu$1(), _dec$17(_class$17 = _dec2$11(_class$17 = (_class2$Z = (_temp$10 = class SpringJoint2D extends Joint2D {
              constructor(...args) {
                super(...args);
                this.TYPE = EJoint2DType.SPRING;

                _initializerDefineProperty(this, "_frequency", _descriptor$Y, this);

                _initializerDefineProperty(this, "_dampingRatio", _descriptor2$T, this);

                _initializerDefineProperty(this, "_distance", _descriptor3$J, this);

                _initializerDefineProperty(this, "_autoCalcDistance", _descriptor4$H, this);
              }

              get frequency() {
                return this._frequency;
              }

              set frequency(v) {
                this._frequency = v;

                if (this._joint) {
                  this._joint.setFrequency(v);
                }
              }

              get dampingRatio() {
                return this._dampingRatio;
              }

              set dampingRatio(v) {
                this._dampingRatio = v;

                if (this._joint) {
                  this._joint.setDampingRatio(v);
                }
              }

              get distance() {
                if (this._autoCalcDistance && this.connectedBody) {
                  return Vec3.distance(this.node.worldPosition, this.connectedBody.node.worldPosition);
                }

                return this._distance;
              }

              set distance(v) {
                this._distance = v;

                if (this._joint) {
                  this._joint.setDistance(v);
                }
              }

              get autoCalcDistance() {
                return this._autoCalcDistance;
              }

              set autoCalcDistance(v) {
                this._autoCalcDistance = v;
              }

            }, _temp$10), (_applyDecoratedDescriptor(_class2$Z.prototype, "frequency", [property$1], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "frequency"), _class2$Z.prototype), _applyDecoratedDescriptor(_class2$Z.prototype, "dampingRatio", [property$1], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "dampingRatio"), _class2$Z.prototype), _applyDecoratedDescriptor(_class2$Z.prototype, "distance", [property$1], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "distance"), _class2$Z.prototype), _applyDecoratedDescriptor(_class2$Z.prototype, "autoCalcDistance", [property$1], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "autoCalcDistance"), _class2$Z.prototype), _descriptor$Y = _applyDecoratedDescriptor(_class2$Z.prototype, "_frequency", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 5;
              }
            }), _descriptor2$T = _applyDecoratedDescriptor(_class2$Z.prototype, "_dampingRatio", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.7;
              }
            }), _descriptor3$J = _applyDecoratedDescriptor(_class2$Z.prototype, "_distance", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 10;
              }
            }), _descriptor4$H = _applyDecoratedDescriptor(_class2$Z.prototype, "_autoCalcDistance", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            })), _class2$Z)) || _class$17) || _class$17));

            var _dec$18, _dec2$12, _class$18, _class2$_, _descriptor$Z, _descriptor2$U, _descriptor3$K, _temp$11;
            let MouseJoint2D = exports('MouseJoint2D', (_dec$18 = ccclass('cc.MouseJoint2D'), _dec2$12 = menu$1(), _dec$18(_class$18 = _dec2$12(_class$18 = (_class2$_ = (_temp$11 = class MouseJoint2D extends Joint2D {
              constructor(...args) {
                super(...args);
                this.TYPE = EJoint2DType.MOUSE;

                _initializerDefineProperty(this, "_maxForce", _descriptor$Z, this);

                _initializerDefineProperty(this, "_dampingRatio", _descriptor2$U, this);

                _initializerDefineProperty(this, "_frequency", _descriptor3$K, this);

                this._target = new Vec2();
              }

              get target() {
                return this._target;
              }

              set target(v) {
                this._target = v;

                if (this._joint) {
                  this._joint.setTarget(v);
                }
              }

              get frequency() {
                return this._frequency;
              }

              set frequency(v) {
                this._frequency = v;

                if (this._joint) {
                  this._joint.setFrequency(v);
                }
              }

              get dampingRatio() {
                return this._dampingRatio;
              }

              set dampingRatio(v) {
                this._dampingRatio = v;

                if (this._joint) {
                  this._joint.setDampingRatio(v);
                }
              }

              get maxForce() {
                return this._maxForce;
              }

              set maxForce(v) {
                this._maxForce = v;

                if (this._joint) {
                  this._joint.setMaxForce(v);
                }
              }

              update(dt) {
                this._joint.update(dt);
              }

            }, _temp$11), (_applyDecoratedDescriptor(_class2$_.prototype, "frequency", [property$1], Object.getOwnPropertyDescriptor(_class2$_.prototype, "frequency"), _class2$_.prototype), _applyDecoratedDescriptor(_class2$_.prototype, "dampingRatio", [property$1], Object.getOwnPropertyDescriptor(_class2$_.prototype, "dampingRatio"), _class2$_.prototype), _applyDecoratedDescriptor(_class2$_.prototype, "maxForce", [property$1], Object.getOwnPropertyDescriptor(_class2$_.prototype, "maxForce"), _class2$_.prototype), _descriptor$Z = _applyDecoratedDescriptor(_class2$_.prototype, "_maxForce", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1000;
              }
            }), _descriptor2$U = _applyDecoratedDescriptor(_class2$_.prototype, "_dampingRatio", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.7;
              }
            }), _descriptor3$K = _applyDecoratedDescriptor(_class2$_.prototype, "_frequency", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 5;
              }
            })), _class2$_)) || _class$18) || _class$18));

            var _dec$19, _dec2$13, _class$19, _class2$$, _descriptor$_, _descriptor2$V, _descriptor3$L, _descriptor4$I, _descriptor5$A, _descriptor6$s, _temp$12;
            const tempVec3_1 = new Vec3();
            const tempVec3_2 = new Vec3();
            let RelativeJoint2D = exports('RelativeJoint2D', (_dec$19 = ccclass('cc.RelativeJoint2D'), _dec2$13 = menu$1(), _dec$19(_class$19 = _dec2$13(_class$19 = (_class2$$ = (_temp$12 = class RelativeJoint2D extends Joint2D {
              constructor(...args) {
                super(...args);
                this.TYPE = EJoint2DType.RELATIVE;

                _initializerDefineProperty(this, "_maxForce", _descriptor$_, this);

                _initializerDefineProperty(this, "_maxTorque", _descriptor2$V, this);

                _initializerDefineProperty(this, "_correctionFactor", _descriptor3$L, this);

                _initializerDefineProperty(this, "_angularOffset", _descriptor4$I, this);

                _initializerDefineProperty(this, "_linearOffset", _descriptor5$A, this);

                _initializerDefineProperty(this, "_autoCalcOffset", _descriptor6$s, this);
              }

              get maxForce() {
                return this._maxForce;
              }

              set maxForce(v) {
                this._maxForce = v;

                if (this._joint) {
                  this._joint.setMaxForce(v);
                }
              }

              get maxTorque() {
                return this._maxTorque;
              }

              set maxTorque(v) {
                this._maxTorque = v;

                if (this._joint) {
                  this._joint.setMaxTorque(v);
                }
              }

              get correctionFactor() {
                return this._correctionFactor;
              }

              set correctionFactor(v) {
                this._correctionFactor = v;

                if (this._joint) {
                  this._joint.setCorrectionFactor(v);
                }
              }

              get linearOffset() {
                if (this._autoCalcOffset && this.connectedBody) {
                  return Vec2.subtract(this._linearOffset, this.connectedBody.node.worldPosition, this.node.worldPosition);
                }

                return this._linearOffset;
              }

              set linearOffset(v) {
                this._linearOffset.set(v);

                if (this._joint) {
                  this._joint.setLinearOffset(v);
                }
              }

              get angularOffset() {
                if (this._autoCalcOffset && this.connectedBody) {
                  Quat.toEuler(tempVec3_1, this.node.worldRotation);
                  Quat.toEuler(tempVec3_2, this.connectedBody.node.worldRotation);
                  this._angularOffset = tempVec3_2.z - tempVec3_1.z;
                }

                return this._angularOffset;
              }

              set angularOffset(v) {
                this._angularOffset = v;

                if (this._joint) {
                  this._joint.setAngularOffset(v);
                }
              }

              get autoCalcOffset() {
                return this._autoCalcOffset;
              }

              set autoCalcOffset(v) {
                this._autoCalcOffset = v;
              }

            }, _temp$12), (_applyDecoratedDescriptor(_class2$$.prototype, "maxForce", [property$1], Object.getOwnPropertyDescriptor(_class2$$.prototype, "maxForce"), _class2$$.prototype), _applyDecoratedDescriptor(_class2$$.prototype, "maxTorque", [property$1], Object.getOwnPropertyDescriptor(_class2$$.prototype, "maxTorque"), _class2$$.prototype), _applyDecoratedDescriptor(_class2$$.prototype, "correctionFactor", [property$1], Object.getOwnPropertyDescriptor(_class2$$.prototype, "correctionFactor"), _class2$$.prototype), _applyDecoratedDescriptor(_class2$$.prototype, "linearOffset", [property$1], Object.getOwnPropertyDescriptor(_class2$$.prototype, "linearOffset"), _class2$$.prototype), _applyDecoratedDescriptor(_class2$$.prototype, "angularOffset", [property$1], Object.getOwnPropertyDescriptor(_class2$$.prototype, "angularOffset"), _class2$$.prototype), _applyDecoratedDescriptor(_class2$$.prototype, "autoCalcOffset", [property$1], Object.getOwnPropertyDescriptor(_class2$$.prototype, "autoCalcOffset"), _class2$$.prototype), _descriptor$_ = _applyDecoratedDescriptor(_class2$$.prototype, "_maxForce", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 5;
              }
            }), _descriptor2$V = _applyDecoratedDescriptor(_class2$$.prototype, "_maxTorque", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.7;
              }
            }), _descriptor3$L = _applyDecoratedDescriptor(_class2$$.prototype, "_correctionFactor", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.3;
              }
            }), _descriptor4$I = _applyDecoratedDescriptor(_class2$$.prototype, "_angularOffset", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor5$A = _applyDecoratedDescriptor(_class2$$.prototype, "_linearOffset", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Vec2();
              }
            }), _descriptor6$s = _applyDecoratedDescriptor(_class2$$.prototype, "_autoCalcOffset", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            })), _class2$$)) || _class$19) || _class$19));

            
            console.log('pptest importing cc 3.2');
            var _dec$1a, _dec2$14, _class$1a, _class2$10, _descriptor$$, _descriptor2$W, _descriptor3$M, _descriptor4$J, _descriptor5$B, _descriptor6$t, _descriptor7$o, _descriptor8$k, _temp$13;
            const tempVec2 = new Vec2();
            let SliderJoint2D = exports('SliderJoint2D', (_dec$1a = ccclass('cc.SliderJoint2D'), _dec2$14 = menu$1(), _dec$1a(_class$1a = _dec2$14(_class$1a = (_class2$10 = (_temp$13 = class SliderJoint2D extends Joint2D {
              constructor(...args) {
                super(...args);
                this.TYPE = EJoint2DType.SLIDER;

                _initializerDefineProperty(this, "_angle", _descriptor$$, this);

                _initializerDefineProperty(this, "_autoCalcAngle", _descriptor2$W, this);

                _initializerDefineProperty(this, "_enableMotor", _descriptor3$M, this);

                _initializerDefineProperty(this, "_maxMotorForce", _descriptor4$J, this);

                _initializerDefineProperty(this, "_motorSpeed", _descriptor5$B, this);

                _initializerDefineProperty(this, "_enableLimit", _descriptor6$t, this);

                _initializerDefineProperty(this, "_lowerLimit", _descriptor7$o, this);

                _initializerDefineProperty(this, "_upperLimit", _descriptor8$k, this);
              }

              get angle() {
                if (this._autoCalcAngle && this.connectedBody) {
                  Vec2.subtract(tempVec2, this.connectedBody.node.worldPosition, this.node.worldPosition);
                  this._angle = toDegree(Math.atan2(tempVec2.y, tempVec2.x));
                }

                return this._angle;
              }

              set angle(v) {
                this._angle = v;
              }

              get autoCalcAngle() {
                return this._autoCalcAngle;
              }

              set autoCalcAngle(v) {
                this._autoCalcAngle = v;
              }

              get enableMotor() {
                return this._enableMotor;
              }

              set enableMotor(v) {
                this._enableMotor = v;
              }

              get maxMotorForce() {
                return this._maxMotorForce;
              }

              set maxMotorForce(v) {
                this._maxMotorForce = v;

                if (this._joint) {
                  this._joint.setMaxMotorForce(v);
                }
              }

              get motorSpeed() {
                return this._motorSpeed;
              }

              set motorSpeed(v) {
                this._motorSpeed = v;

                if (this._joint) {
                  this._joint.setMotorSpeed(v);
                }
              }

              get enableLimit() {
                return this._enableLimit;
              }

              set enableLimit(v) {
                this._enableLimit = v;
              }

              get lowerLimit() {
                return this._lowerLimit;
              }

              set lowerLimit(v) {
                this._lowerLimit = v;

                if (this._joint) {
                  this._joint.setLowerLimit(v);
                }
              }

              get upperLimit() {
                return this._upperLimit;
              }

              set upperLimit(v) {
                this._upperLimit = v;

                if (this._joint) {
                  this._joint.setUpperLimit(v);
                }
              }

            }, _temp$13), (_applyDecoratedDescriptor(_class2$10.prototype, "angle", [property$1], Object.getOwnPropertyDescriptor(_class2$10.prototype, "angle"), _class2$10.prototype), _applyDecoratedDescriptor(_class2$10.prototype, "autoCalcAngle", [property$1], Object.getOwnPropertyDescriptor(_class2$10.prototype, "autoCalcAngle"), _class2$10.prototype), _applyDecoratedDescriptor(_class2$10.prototype, "enableMotor", [property$1], Object.getOwnPropertyDescriptor(_class2$10.prototype, "enableMotor"), _class2$10.prototype), _applyDecoratedDescriptor(_class2$10.prototype, "maxMotorForce", [property$1], Object.getOwnPropertyDescriptor(_class2$10.prototype, "maxMotorForce"), _class2$10.prototype), _applyDecoratedDescriptor(_class2$10.prototype, "motorSpeed", [property$1], Object.getOwnPropertyDescriptor(_class2$10.prototype, "motorSpeed"), _class2$10.prototype), _applyDecoratedDescriptor(_class2$10.prototype, "enableLimit", [property$1], Object.getOwnPropertyDescriptor(_class2$10.prototype, "enableLimit"), _class2$10.prototype), _applyDecoratedDescriptor(_class2$10.prototype, "lowerLimit", [property$1], Object.getOwnPropertyDescriptor(_class2$10.prototype, "lowerLimit"), _class2$10.prototype), _applyDecoratedDescriptor(_class2$10.prototype, "upperLimit", [property$1], Object.getOwnPropertyDescriptor(_class2$10.prototype, "upperLimit"), _class2$10.prototype), _descriptor$$ = _applyDecoratedDescriptor(_class2$10.prototype, "_angle", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor2$W = _applyDecoratedDescriptor(_class2$10.prototype, "_autoCalcAngle", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _descriptor3$M = _applyDecoratedDescriptor(_class2$10.prototype, "_enableMotor", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor4$J = _applyDecoratedDescriptor(_class2$10.prototype, "_maxMotorForce", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1000;
              }
            }), _descriptor5$B = _applyDecoratedDescriptor(_class2$10.prototype, "_motorSpeed", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1000;
              }
            }), _descriptor6$t = _applyDecoratedDescriptor(_class2$10.prototype, "_enableLimit", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor7$o = _applyDecoratedDescriptor(_class2$10.prototype, "_lowerLimit", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor8$k = _applyDecoratedDescriptor(_class2$10.prototype, "_upperLimit", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            })), _class2$10)) || _class$1a) || _class$1a));

            var _dec$1b, _dec2$15, _class$1b, _class2$11, _descriptor$10, _descriptor2$X, _temp$14;
            let FixedJoint2D = exports('FixedJoint2D', (_dec$1b = ccclass('cc.FixedJoint2D'), _dec2$15 = menu$1(), _dec$1b(_class$1b = _dec2$15(_class$1b = (_class2$11 = (_temp$14 = class FixedJoint2D extends Joint2D {
              constructor(...args) {
                super(...args);
                this.TYPE = EJoint2DType.FIXED;

                _initializerDefineProperty(this, "_frequency", _descriptor$10, this);

                _initializerDefineProperty(this, "_dampingRatio", _descriptor2$X, this);
              }

              get frequency() {
                return this._frequency;
              }

              set frequency(v) {
                this._frequency = v;

                if (this._joint) {
                  this._joint.setFrequency(v);
                }
              }

              get dampingRatio() {
                return this._dampingRatio;
              }

              set dampingRatio(v) {
                this._dampingRatio = v;

                if (this._joint) {
                  this._joint.setDampingRatio(v);
                }
              }

            }, _temp$14), (_applyDecoratedDescriptor(_class2$11.prototype, "frequency", [property$1], Object.getOwnPropertyDescriptor(_class2$11.prototype, "frequency"), _class2$11.prototype), _applyDecoratedDescriptor(_class2$11.prototype, "dampingRatio", [property$1], Object.getOwnPropertyDescriptor(_class2$11.prototype, "dampingRatio"), _class2$11.prototype), _descriptor$10 = _applyDecoratedDescriptor(_class2$11.prototype, "_frequency", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.7;
              }
            }), _descriptor2$X = _applyDecoratedDescriptor(_class2$11.prototype, "_dampingRatio", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.5;
              }
            })), _class2$11)) || _class$1b) || _class$1b));

            var _dec$1c, _dec2$16, _class$1c, _class2$12, _descriptor$11, _descriptor2$Y, _descriptor3$N, _descriptor4$K, _descriptor5$C, _descriptor6$u, _temp$15;
            let WheelJoint2D = exports('WheelJoint2D', (_dec$1c = ccclass('cc.WheelJoint2D'), _dec2$16 = menu$1(), _dec$1c(_class$1c = _dec2$16(_class$1c = (_class2$12 = (_temp$15 = class WheelJoint2D extends Joint2D {
              constructor(...args) {
                super(...args);
                this.TYPE = EJoint2DType.WHEEL;

                _initializerDefineProperty(this, "_angle", _descriptor$11, this);

                _initializerDefineProperty(this, "_enableMotor", _descriptor2$Y, this);

                _initializerDefineProperty(this, "_maxMotorTorque", _descriptor3$N, this);

                _initializerDefineProperty(this, "_motorSpeed", _descriptor4$K, this);

                _initializerDefineProperty(this, "_frequency", _descriptor5$C, this);

                _initializerDefineProperty(this, "_dampingRatio", _descriptor6$u, this);
              }

              get angle() {
                return this._angle;
              }

              set angle(v) {
                this._angle = v;
              }

              get enableMotor() {
                return this._enableMotor;
              }

              set enableMotor(v) {
                this._enableMotor = v;

                if (this._joint) {
                  this._joint.enableMotor(v);
                }
              }

              get maxMotorTorque() {
                return this._maxMotorTorque;
              }

              set maxMotorTorque(v) {
                this._maxMotorTorque = v;

                if (this._joint) {
                  this._joint.setMaxMotorTorque(v);
                }
              }

              get motorSpeed() {
                return this._motorSpeed;
              }

              set motorSpeed(v) {
                this._motorSpeed = v;

                if (this._joint) {
                  this._joint.setMotorSpeed(v);
                }
              }

              get frequency() {
                return this._frequency;
              }

              set frequency(v) {
                this._frequency = v;

                if (this._joint) {
                  this._joint.setFrequency(v);
                }
              }

              get dampingRatio() {
                return this._dampingRatio;
              }

              set dampingRatio(v) {
                this._dampingRatio = v;

                if (this._joint) {
                  this._joint.setDampingRatio(v);
                }
              }

            }, _temp$15), (_applyDecoratedDescriptor(_class2$12.prototype, "angle", [property$1], Object.getOwnPropertyDescriptor(_class2$12.prototype, "angle"), _class2$12.prototype), _applyDecoratedDescriptor(_class2$12.prototype, "enableMotor", [property$1], Object.getOwnPropertyDescriptor(_class2$12.prototype, "enableMotor"), _class2$12.prototype), _applyDecoratedDescriptor(_class2$12.prototype, "maxMotorTorque", [property$1], Object.getOwnPropertyDescriptor(_class2$12.prototype, "maxMotorTorque"), _class2$12.prototype), _applyDecoratedDescriptor(_class2$12.prototype, "motorSpeed", [property$1], Object.getOwnPropertyDescriptor(_class2$12.prototype, "motorSpeed"), _class2$12.prototype), _applyDecoratedDescriptor(_class2$12.prototype, "frequency", [property$1], Object.getOwnPropertyDescriptor(_class2$12.prototype, "frequency"), _class2$12.prototype), _applyDecoratedDescriptor(_class2$12.prototype, "dampingRatio", [property$1], Object.getOwnPropertyDescriptor(_class2$12.prototype, "dampingRatio"), _class2$12.prototype), _descriptor$11 = _applyDecoratedDescriptor(_class2$12.prototype, "_angle", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 90;
              }
            }), _descriptor2$Y = _applyDecoratedDescriptor(_class2$12.prototype, "_enableMotor", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor3$N = _applyDecoratedDescriptor(_class2$12.prototype, "_maxMotorTorque", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1000;
              }
            }), _descriptor4$K = _applyDecoratedDescriptor(_class2$12.prototype, "_motorSpeed", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor5$C = _applyDecoratedDescriptor(_class2$12.prototype, "_frequency", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 5;
              }
            }), _descriptor6$u = _applyDecoratedDescriptor(_class2$12.prototype, "_dampingRatio", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0.7;
              }
            })), _class2$12)) || _class$1c) || _class$1c));

            var _dec$1d, _dec2$17, _class$1d, _class2$13, _descriptor$12, _descriptor2$Z, _descriptor3$O, _descriptor4$L, _descriptor5$D, _descriptor6$v, _temp$16;
            let HingeJoint2D = exports('HingeJoint2D', (_dec$1d = ccclass('cc.HingeJoint2D'), _dec2$17 = menu$1(), _dec$1d(_class$1d = _dec2$17(_class$1d = (_class2$13 = (_temp$16 = class HingeJoint2D extends Joint2D {
              constructor(...args) {
                super(...args);
                this.TYPE = EJoint2DType.HINGE;

                _initializerDefineProperty(this, "_enableLimit", _descriptor$12, this);

                _initializerDefineProperty(this, "_lowerAngle", _descriptor2$Z, this);

                _initializerDefineProperty(this, "_upperAngle", _descriptor3$O, this);

                _initializerDefineProperty(this, "_enableMotor", _descriptor4$L, this);

                _initializerDefineProperty(this, "_maxMotorTorque", _descriptor5$D, this);

                _initializerDefineProperty(this, "_motorSpeed", _descriptor6$v, this);
              }

              get enableLimit() {
                return this._enableLimit;
              }

              set enableLimit(v) {
                this._enableLimit = v;
              }

              get lowerAngle() {
                return this._lowerAngle;
              }

              set lowerAngle(v) {
                this._lowerAngle = v;

                if (this._joint) {
                  this._joint.setLowerAngle(v);
                }
              }

              get upperAngle() {
                return this._upperAngle;
              }

              set upperAngle(v) {
                this._upperAngle = v;

                if (this._joint) {
                  this._joint.setUpperAngle(v);
                }
              }

              get enableMotor() {
                return this._enableMotor;
              }

              set enableMotor(v) {
                this._enableMotor = v;

                if (this._joint) {
                  this._joint.enableMotor(v);
                }
              }

              get maxMotorTorque() {
                return this._maxMotorTorque;
              }

              set maxMotorTorque(v) {
                this._maxMotorTorque = v;

                if (this._joint) {
                  this._joint.setMaxMotorTorque(v);
                }
              }

              get motorSpeed() {
                return this._motorSpeed;
              }

              set motorSpeed(v) {
                this._motorSpeed = v;

                if (this._joint) {
                  this._joint.setMotorSpeed(v);
                }
              }

            }, _temp$16), (_applyDecoratedDescriptor(_class2$13.prototype, "enableLimit", [property$1], Object.getOwnPropertyDescriptor(_class2$13.prototype, "enableLimit"), _class2$13.prototype), _applyDecoratedDescriptor(_class2$13.prototype, "lowerAngle", [property$1], Object.getOwnPropertyDescriptor(_class2$13.prototype, "lowerAngle"), _class2$13.prototype), _applyDecoratedDescriptor(_class2$13.prototype, "upperAngle", [property$1], Object.getOwnPropertyDescriptor(_class2$13.prototype, "upperAngle"), _class2$13.prototype), _applyDecoratedDescriptor(_class2$13.prototype, "enableMotor", [property$1], Object.getOwnPropertyDescriptor(_class2$13.prototype, "enableMotor"), _class2$13.prototype), _applyDecoratedDescriptor(_class2$13.prototype, "maxMotorTorque", [property$1], Object.getOwnPropertyDescriptor(_class2$13.prototype, "maxMotorTorque"), _class2$13.prototype), _applyDecoratedDescriptor(_class2$13.prototype, "motorSpeed", [property$1], Object.getOwnPropertyDescriptor(_class2$13.prototype, "motorSpeed"), _class2$13.prototype), _descriptor$12 = _applyDecoratedDescriptor(_class2$13.prototype, "_enableLimit", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor2$Z = _applyDecoratedDescriptor(_class2$13.prototype, "_lowerAngle", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor3$O = _applyDecoratedDescriptor(_class2$13.prototype, "_upperAngle", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor4$L = _applyDecoratedDescriptor(_class2$13.prototype, "_enableMotor", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor5$D = _applyDecoratedDescriptor(_class2$13.prototype, "_maxMotorTorque", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1000;
              }
            }), _descriptor6$v = _applyDecoratedDescriptor(_class2$13.prototype, "_motorSpeed", [property$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            })), _class2$13)) || _class$1d) || _class$1d));

            const Physics2DUtils = exports('Physics2DUtils', {
              PolygonSeparator
            });

            class PhysicsRayCastCallback extends box2d_1.RayCastCallback {
              constructor(...args) {
                super(...args);
                this._type = ERaycast2DType.Closest;
                this._fixtures = [];
                this._points = [];
                this._normals = [];
                this._fractions = [];
                this._mask = 0xffffffff;
              }

              init(type, mask) {
                this._type = type;
                this._mask = mask;
                this._fixtures.length = 0;
                this._points.length = 0;
                this._normals.length = 0;
                this._fractions.length = 0;
              }

              ReportFixture(fixture, point, normal, fraction) {
                if ((fixture.GetFilterData().categoryBits & this._mask) === 0) {
                  return 0;
                }

                if (this._type === ERaycast2DType.Closest) {
                  this._fixtures[0] = fixture;
                  this._points[0] = point;
                  this._normals[0] = normal;
                  this._fractions[0] = fraction;
                  return fraction;
                }

                this._fixtures.push(fixture);

                this._points.push(new Vec2(point.x, point.y));

                this._normals.push(new Vec2(normal.x, normal.y));

                this._fractions.push(fraction);

                if (this._type === ERaycast2DType.Any) {
                  return 0;
                } else if (this._type >= ERaycast2DType.All) {
                  return 1;
                }

                return fraction;
              }

              getFixtures() {
                return this._fixtures;
              }

              getPoints() {
                return this._points;
              }

              getNormals() {
                return this._normals;
              }

              getFractions() {
                return this._fractions;
              }

            }

            const pools = [];
            const pointCache = [new Vec2(), new Vec2()];
            const b2worldmanifold = new box2d_1.WorldManifold();
            const worldmanifold = {
              points: [],
              separations: [],
              normal: new Vec2()
            };

            class ManifoldPoint {
              constructor() {
                this.localPoint = new Vec2();
                this.normalImpulse = 0;
                this.tangentImpulse = 0;
              }

            }

            const manifoldPointCache = [new ManifoldPoint(), new ManifoldPoint()];
            const manifold = {
              type: 0,
              localPoint: new Vec2(),
              localNormal: new Vec2(),
              points: []
            };
            const impulse = {
              normalImpulses: [],
              tangentImpulses: []
            };
            class PhysicsContact {
              constructor() {
                this.colliderA = null;
                this.colliderB = null;
                this.disabled = false;
                this.disabledOnce = false;
                this._impulse = null;
                this._inverted = false;
                this._b2contact = null;
              }

              static get(b2contact) {
                let c = pools.pop();

                if (!c) {
                  c = new PhysicsContact();
                }

                c.init(b2contact);
                return c;
              }

              static put(b2contact) {
                const c = b2contact.m_userData;
                if (!c) return;
                pools.push(c);
                c.reset();
              }

              _setImpulse(impulse) {
                this._impulse = impulse;
              }

              init(b2contact) {
                this.colliderA = b2contact.m_fixtureA.m_userData.collider;
                this.colliderB = b2contact.m_fixtureB.m_userData.collider;
                this.disabled = false;
                this.disabledOnce = false;
                this._impulse = null;
                this._inverted = false;
                this._b2contact = b2contact;
                b2contact.m_userData = this;
              }

              reset() {
                this.setTangentSpeed(0);
                this.resetFriction();
                this.resetRestitution();
                this.colliderA = null;
                this.colliderB = null;
                this.disabled = false;
                this._impulse = null;
                this._b2contact.m_userData = null;
                this._b2contact = null;
              }

              getWorldManifold() {
                const points = worldmanifold.points;
                const separations = worldmanifold.separations;
                const normal = worldmanifold.normal;

                this._b2contact.GetWorldManifold(b2worldmanifold);

                const b2points = b2worldmanifold.points;
                const b2separations = b2worldmanifold.separations;

                const count = this._b2contact.GetManifold().pointCount;

                points.length = separations.length = count;

                for (let i = 0; i < count; i++) {
                  const p = pointCache[i];
                  p.x = b2points[i].x * PHYSICS_2D_PTM_RATIO;
                  p.y = b2points[i].y * PHYSICS_2D_PTM_RATIO;
                  points[i] = p;
                  separations[i] = b2separations[i] * PHYSICS_2D_PTM_RATIO;
                }

                normal.x = b2worldmanifold.normal.x;
                normal.y = b2worldmanifold.normal.y;

                if (this._inverted) {
                  normal.x *= -1;
                  normal.y *= -1;
                }

                return worldmanifold;
              }

              getManifold() {
                const points = manifold.points;
                const localNormal = manifold.localNormal;
                const localPoint = manifold.localPoint;

                const b2manifold = this._b2contact.GetManifold();

                const b2points = b2manifold.points;
                const count = points.length = b2manifold.pointCount;

                for (let i = 0; i < count; i++) {
                  const p = manifoldPointCache[i];
                  const b2p = b2points[i];
                  p.localPoint.x = b2p.localPoint.x * PHYSICS_2D_PTM_RATIO;
                  p.localPoint.y = b2p.localPoint.y * PHYSICS_2D_PTM_RATIO;
                  p.normalImpulse = b2p.normalImpulse * PHYSICS_2D_PTM_RATIO;
                  p.tangentImpulse = b2p.tangentImpulse;
                  points[i] = p;
                }

                localPoint.x = b2manifold.localPoint.x * PHYSICS_2D_PTM_RATIO;
                localPoint.y = b2manifold.localPoint.y * PHYSICS_2D_PTM_RATIO;
                localNormal.x = b2manifold.localNormal.x;
                localNormal.y = b2manifold.localNormal.y;
                manifold.type = b2manifold.type;

                if (this._inverted) {
                  localNormal.x *= -1;
                  localNormal.y *= -1;
                }

                return manifold;
              }

              getImpulse() {
                const b2impulse = this._impulse;
                if (!b2impulse) return null;
                const normalImpulses = impulse.normalImpulses;
                const tangentImpulses = impulse.tangentImpulses;
                const count = b2impulse.count;

                for (let i = 0; i < count; i++) {
                  normalImpulses[i] = b2impulse.normalImpulses[i] * PHYSICS_2D_PTM_RATIO;
                  tangentImpulses[i] = b2impulse.tangentImpulses[i];
                }

                tangentImpulses.length = normalImpulses.length = count;
                return impulse;
              }

              emit(contactType) {

                const colliderA = this.colliderA;
                const colliderB = this.colliderB;
                const bodyA = colliderA.body;
                const bodyB = colliderB.body;

                if (bodyA.enabledContactListener) {
                  colliderA === null || colliderA === void 0 ? void 0 : colliderA.emit(contactType, colliderA, colliderB, this);
                }

                if (bodyB.enabledContactListener) {
                  colliderB === null || colliderB === void 0 ? void 0 : colliderB.emit(contactType, colliderB, colliderA, this);
                }

                if (bodyA.enabledContactListener || bodyB.enabledContactListener) {
                  PhysicsSystem2D.instance.emit(contactType, colliderA, colliderB);
                }

                if (this.disabled || this.disabledOnce) {
                  this.setEnabled(false);
                  this.disabledOnce = false;
                }
              }

              setEnabled(value) {
                this._b2contact.SetEnabled(value);
              }

              isTouching() {
                return this._b2contact.IsTouching();
              }

              setTangentSpeed(value) {
                this._b2contact.SetTangentSpeed(value);
              }

              getTangentSpeed() {
                return this._b2contact.GetTangentSpeed();
              }

              setFriction(value) {
                this._b2contact.SetFriction(value);
              }

              getFriction() {
                return this._b2contact.GetFriction();
              }

              resetFriction() {
                return this._b2contact.ResetFriction();
              }

              setRestitution(value) {
                this._b2contact.SetRestitution(value);
              }

              getRestitution() {
                return this._b2contact.GetRestitution();
              }

              resetRestitution() {
                return this._b2contact.ResetRestitution();
              }

            }

            const _tmp_vec2 = new box2d_1.Vec2();

            const _tmp_color = new Color$1();

            const GREEN_COLOR = Color$1.GREEN;
            const RED_COLOR = Color$1.RED;
            class PhysicsDebugDraw extends box2d_1.Draw {
              constructor(drawer) {
                super();
                this._drawer = null;
                this._xf = new box2d_1.Transform();
                this._dxf = new box2d_1.Transform();
                this._drawer = drawer;
              }

              _DrawPolygon(vertices, vertexCount) {
                const drawer = this._drawer;

                for (let i = 0; i < vertexCount; i++) {
                  box2d_1.Transform.MulXV(this._xf, vertices[i], _tmp_vec2);
                  const x = _tmp_vec2.x * PHYSICS_2D_PTM_RATIO;
                  const y = _tmp_vec2.y * PHYSICS_2D_PTM_RATIO;
                  if (i === 0) drawer.moveTo(x, y);else {
                    drawer.lineTo(x, y);
                  }
                }

                drawer.close();
              }

              DrawPolygon(vertices, vertexCount, color) {
                this._applyStrokeColor(color);

                this._DrawPolygon(vertices, vertexCount);

                this._drawer.stroke();
              }

              DrawSolidPolygon(vertices, vertexCount, color) {
                this._applyFillColor(color);

                this._DrawPolygon(vertices, vertexCount);

                this._drawer.fill();

                this._drawer.stroke();
              }

              _DrawCircle(center, radius) {
                const p = this._xf.p;

                this._drawer.circle((center.x + p.x) * PHYSICS_2D_PTM_RATIO, (center.y + p.y) * PHYSICS_2D_PTM_RATIO, radius * PHYSICS_2D_PTM_RATIO);
              }

              DrawCircle(center, radius, color) {
                this._applyStrokeColor(color);

                this._DrawCircle(center, radius);

                this._drawer.stroke();
              }

              DrawSolidCircle(center, radius, axis, color) {
                this._applyFillColor(color);

                this._DrawCircle(center, radius);

                this._drawer.fill();
              }

              DrawSegment(p1, p2, color) {
                const drawer = this._drawer;

                if (p1.x === p2.x && p1.y === p2.y) {
                  this._applyFillColor(color);

                  this._DrawCircle(p1, 2 / PHYSICS_2D_PTM_RATIO);

                  drawer.fill();
                  return;
                }

                this._applyStrokeColor(color);

                box2d_1.Transform.MulXV(this._xf, p1, _tmp_vec2);
                drawer.moveTo(_tmp_vec2.x * PHYSICS_2D_PTM_RATIO, _tmp_vec2.y * PHYSICS_2D_PTM_RATIO);
                box2d_1.Transform.MulXV(this._xf, p2, _tmp_vec2);
                drawer.lineTo(_tmp_vec2.x * PHYSICS_2D_PTM_RATIO, _tmp_vec2.y * PHYSICS_2D_PTM_RATIO);
                drawer.stroke();
              }

              DrawTransform(xf) {
                const drawer = this._drawer;
                drawer.strokeColor = RED_COLOR;
                _tmp_vec2.x = _tmp_vec2.y = 0;
                box2d_1.Transform.MulXV(xf, _tmp_vec2, _tmp_vec2);
                drawer.moveTo(_tmp_vec2.x * PHYSICS_2D_PTM_RATIO, _tmp_vec2.y * PHYSICS_2D_PTM_RATIO);
                _tmp_vec2.x = 1;
                _tmp_vec2.y = 0;
                box2d_1.Transform.MulXV(xf, _tmp_vec2, _tmp_vec2);
                drawer.lineTo(_tmp_vec2.x * PHYSICS_2D_PTM_RATIO, _tmp_vec2.y * PHYSICS_2D_PTM_RATIO);
                drawer.stroke();
                drawer.strokeColor = GREEN_COLOR;
                _tmp_vec2.x = _tmp_vec2.y = 0;
                box2d_1.Transform.MulXV(xf, _tmp_vec2, _tmp_vec2);
                drawer.moveTo(_tmp_vec2.x * PHYSICS_2D_PTM_RATIO, _tmp_vec2.y * PHYSICS_2D_PTM_RATIO);
                _tmp_vec2.x = 0;
                _tmp_vec2.y = 1;
                box2d_1.Transform.MulXV(xf, _tmp_vec2, _tmp_vec2);
                drawer.lineTo(_tmp_vec2.x * PHYSICS_2D_PTM_RATIO, _tmp_vec2.y * PHYSICS_2D_PTM_RATIO);
                drawer.stroke();
              }

              DrawPoint(center, radius, color) {}

              DrawParticles() {}

              _applyStrokeColor(color) {
                this._drawer.strokeColor = _tmp_color.set(color.r * 255, color.g * 255, color.b * 255, 150);
              }

              _applyFillColor(color) {
                this._drawer.fillColor = _tmp_color.set(color.r * 255, color.g * 255, color.b * 255, 150);
              }

              PushTransform(xf) {
                this._xf = xf;
              }

              PopTransform() {
                this._xf = this._dxf;
              }

            }

            const tempVec3 = new Vec3();
            const tempVec2_1 = new Vec2();
            const tempVec2_2 = new Vec2();
            const temoBodyDef = new box2d_1.BodyDef();
            const tempB2AABB = new box2d_1.AABB();
            const testResults = [];
            class b2PhysicsWorld {
              get impl() {
                return this._world;
              }

              constructor() {
                this._world = void 0;
                this._bodies = [];
                this._animatedBodies = [];
                this._rotationAxis = new Vec3();
                this._contactListener = void 0;
                this._aabbQueryCallback = void 0;
                this._raycastQueryCallback = void 0;
                this._debugGraphics = null;
                this._b2DebugDrawer = null;
                this._debugDrawFlags = 0;
                this._world = new box2d_1.World(new box2d_1.Vec2(0, -10));
                const listener = new PhysicsContactListener();
                listener.setBeginContact(this._onBeginContact);
                listener.setEndContact(this._onEndContact);
                listener.setPreSolve(this._onPreSolve);
                listener.setPostSolve(this._onPostSolve);

                this._world.SetContactListener(listener);

                this._contactListener = listener;
                this._aabbQueryCallback = new PhysicsAABBQueryCallback();
                this._raycastQueryCallback = new PhysicsRayCastCallback();
              }

              get debugDrawFlags() {
                return this._debugDrawFlags;
              }

              set debugDrawFlags(v) {

                if (!v) {
                  if (this._debugGraphics) {
                    this._debugGraphics.node.parent = null;
                  }
                }

                this._debugDrawFlags = v;
              }

              _checkDebugDrawValid() {

                if (!this._debugGraphics || !this._debugGraphics.isValid) {
                  let canvas = find('Canvas');

                  if (!canvas) {
                    const scene = director.getScene();

                    if (!scene) {
                      return;
                    }

                    canvas = new Node('Canvas');
                    canvas.addComponent(Canvas);
                    canvas.parent = scene;
                  }

                  const node = new Node('PHYSICS_2D_DEBUG_DRAW');
                  node.hideFlags |= CCObject.Flags.DontSave;
                  node.parent = canvas;
                  node.worldPosition = Vec3.ZERO;
                  node.layer = Layers.Enum.UI_2D;
                  this._debugGraphics = node.addComponent(Graphics);
                  this._debugGraphics.lineWidth = 2;
                  const debugDraw = new PhysicsDebugDraw(this._debugGraphics);
                  this._b2DebugDrawer = debugDraw;

                  this._world.SetDebugDraw(debugDraw);
                }

                const parent = this._debugGraphics.node.parent;

                this._debugGraphics.node.setSiblingIndex(parent.children.length - 1);

                if (this._b2DebugDrawer) {
                  this._b2DebugDrawer.SetFlags(this.debugDrawFlags);
                }
              }

              setGravity(v) {
                this._world.SetGravity(v);
              }

              setAllowSleep(v) {
                this._world.SetAllowSleeping(true);
              }

              step(deltaTime, velocityIterations = 10, positionIterations = 10) {
                const animatedBodies = this._animatedBodies;

                for (let i = 0, l = animatedBodies.length; i < l; i++) {
                  animatedBodies[i].animate(deltaTime);
                }

                this._world.Step(deltaTime, velocityIterations, positionIterations);
              }

              raycast(p1, p2, type, mask) {
                if (p1.equals(p2)) {
                  return [];
                }

                type = type || ERaycast2DType.Closest;
                tempVec2_1.x = p1.x / PHYSICS_2D_PTM_RATIO;
                tempVec2_1.y = p1.y / PHYSICS_2D_PTM_RATIO;
                tempVec2_2.x = p2.x / PHYSICS_2D_PTM_RATIO;
                tempVec2_2.y = p2.y / PHYSICS_2D_PTM_RATIO;
                const callback = this._raycastQueryCallback;
                callback.init(type, mask);

                this._world.RayCast(callback, tempVec2_1, tempVec2_2);

                const fixtures = callback.getFixtures();

                if (fixtures.length > 0) {
                  const points = callback.getPoints();
                  const normals = callback.getNormals();
                  const fractions = callback.getFractions();
                  const results = [];

                  for (let i = 0, l = fixtures.length; i < l; i++) {
                    const fixture = fixtures[i];
                    const shape = fixture.m_userData;
                    const collider = shape.collider;

                    if (type === ERaycast2DType.AllClosest) {
                      let result;

                      for (let j = 0; j < results.length; j++) {
                        if (results[j].collider === collider) {
                          result = results[j];
                        }
                      }

                      if (result) {
                        if (fractions[i] < result.fraction) {
                          result.fixtureIndex = shape.getFixtureIndex(fixture);
                          result.point.x = points[i].x * PHYSICS_2D_PTM_RATIO;
                          result.point.y = points[i].y * PHYSICS_2D_PTM_RATIO;
                          result.normal.x = normals[i].x;
                          result.normal.y = normals[i].y;
                          result.fraction = fractions[i];
                        }

                        continue;
                      }
                    }

                    results.push({
                      collider,
                      fixtureIndex: shape.getFixtureIndex(fixture),
                      point: new Vec2(points[i].x * PHYSICS_2D_PTM_RATIO, points[i].y * PHYSICS_2D_PTM_RATIO),
                      normal: new Vec2(normals[i].x, normals[i].y),
                      fraction: fractions[i]
                    });
                  }

                  return results;
                }

                return [];
              }

              syncPhysicsToScene() {
                const bodies = this._bodies;

                for (let i = 0, l = bodies.length; i < l; i++) {
                  const body = bodies[i];
                  const bodyComp = body.rigidBody;

                  if (bodyComp.type === ERigidBody2DType.Animated) {
                    body.resetVelocity();
                    continue;
                  }

                  const node = bodyComp.node;
                  const b2body = body.impl;
                  const pos = b2body.GetPosition();
                  tempVec3.x = pos.x * PHYSICS_2D_PTM_RATIO;
                  tempVec3.y = pos.y * PHYSICS_2D_PTM_RATIO;
                  tempVec3.z = 0;
                  node.worldPosition = tempVec3;
                  const angle = toDegree(b2body.GetAngle());
                  node.setWorldRotationFromEuler(0, 0, angle);
                }
              }

              syncSceneToPhysics() {
                const bodies = this._bodies;

                for (let i = 0; i < bodies.length; i++) {
                  bodies[i].syncRotationToPhysics();
                  bodies[i].syncPositionToPhysics();
                }
              }

              addBody(body) {
                const bodies = this._bodies;

                if (bodies.includes(body)) {
                  return;
                }

                const bodyDef = temoBodyDef;
                const comp = body.rigidBody;
                bodyDef.allowSleep = comp.allowSleep;
                bodyDef.gravityScale = comp.gravityScale;
                bodyDef.linearDamping = comp.linearDamping;
                bodyDef.angularDamping = comp.angularDamping;
                bodyDef.fixedRotation = comp.fixedRotation;
                bodyDef.bullet = comp.bullet;
                const node = comp.node;
                const pos = node.worldPosition;
                bodyDef.position.Set(pos.x / PHYSICS_2D_PTM_RATIO, pos.y / PHYSICS_2D_PTM_RATIO);
                tempVec3.z = Quat.getAxisAngle(this._rotationAxis, node.worldRotation);
                bodyDef.angle = tempVec3.z;
                bodyDef.awake = comp.awakeOnLoad;

                if (comp.type === ERigidBody2DType.Animated) {
                  bodyDef.type = ERigidBody2DType.Kinematic;

                  this._animatedBodies.push(body);

                  body._animatedPos.set(bodyDef.position.x, bodyDef.position.y);

                  body._animatedAngle = bodyDef.angle;
                } else {
                  bodyDef.type = comp.type;
                }

                const compPrivate = comp;
                const linearVelocity = compPrivate._linearVelocity;
                bodyDef.linearVelocity.Set(linearVelocity.x, linearVelocity.y);
                bodyDef.angularVelocity = toRadian(compPrivate._angularVelocity);

                const b2Body = this._world.CreateBody(bodyDef);

                b2Body.m_userData = body;
                body._imp = b2Body;

                this._bodies.push(body);
              }

              removeBody(body) {
                if (!this._bodies.includes(body)) {
                  return;
                }

                if (body.impl) {
                  body.impl.m_userData = null;

                  this._world.DestroyBody(body.impl);

                  body._imp = null;
                }

                array.remove(this._bodies, body);
                const comp = body.rigidBody;

                if (comp.type === ERigidBody2DType.Animated) {
                  array.remove(this._animatedBodies, body);
                }
              }

              registerContactFixture(fixture) {
                this._contactListener.registerContactFixture(fixture);
              }

              unregisterContactFixture(fixture) {
                this._contactListener.unregisterContactFixture(fixture);
              }

              testPoint(point) {
                const x = tempVec2_1.x = point.x / PHYSICS_2D_PTM_RATIO;
                const y = tempVec2_1.y = point.y / PHYSICS_2D_PTM_RATIO;
                const d = 0.2 / PHYSICS_2D_PTM_RATIO;
                tempB2AABB.lowerBound.x = x - d;
                tempB2AABB.lowerBound.y = y - d;
                tempB2AABB.upperBound.x = x + d;
                tempB2AABB.upperBound.y = y + d;
                const callback = this._aabbQueryCallback;
                callback.init(tempVec2_1);

                this._world.QueryAABB(callback, tempB2AABB);

                const fixtures = callback.getFixtures();
                testResults.length = 0;

                for (let i = 0; i < fixtures.length; i++) {
                  const collider = fixtures[i].m_userData.collider;

                  if (!testResults.includes(collider)) {
                    testResults.push(collider);
                  }
                }

                return testResults;
              }

              testAABB(rect) {
                tempB2AABB.lowerBound.x = rect.xMin / PHYSICS_2D_PTM_RATIO;
                tempB2AABB.lowerBound.y = rect.yMin / PHYSICS_2D_PTM_RATIO;
                tempB2AABB.upperBound.x = rect.xMax / PHYSICS_2D_PTM_RATIO;
                tempB2AABB.upperBound.y = rect.yMax / PHYSICS_2D_PTM_RATIO;
                const callback = this._aabbQueryCallback;
                callback.init();

                this._world.QueryAABB(callback, tempB2AABB);

                const fixtures = callback.getFixtures();
                testResults.length = 0;

                for (let i = 0; i < fixtures.length; i++) {
                  const collider = fixtures[i].m_userData.collider;

                  if (!testResults.includes(collider)) {
                    testResults.push(collider);
                  }
                }

                return testResults;
              }

              drawDebug() {
                this._checkDebugDrawValid();

                if (!this._debugGraphics) {
                  return;
                }

                this._debugGraphics.clear();

                this._world.DrawDebugData();
              }

              _onBeginContact(b2contact) {
                const c = PhysicsContact.get(b2contact);
                c.emit(Contact2DType.BEGIN_CONTACT);
              }

              _onEndContact(b2contact) {
                const c = b2contact.m_userData;

                if (!c) {
                  return;
                }

                c.emit(Contact2DType.END_CONTACT);
                PhysicsContact.put(b2contact);
              }

              _onPreSolve(b2contact) {
                const c = b2contact.m_userData;

                if (!c) {
                  return;
                }

                c.emit(Contact2DType.PRE_SOLVE);
              }

              _onPostSolve(b2contact, impulse) {
                const c = b2contact.m_userData;

                if (!c) {
                  return;
                }

                c._setImpulse(impulse);

                c.emit(Contact2DType.POST_SOLVE);

                c._setImpulse(null);
              }

            }

            const tempVec3$1 = new Vec3();
            const tempVec2_1$1 = new box2d_1.Vec2();
            class b2RigidBody2D {
              constructor() {
                this._animatedPos = new Vec2();
                this._animatedAngle = 0;
                this._body = null;
                this._rigidBody = void 0;
                this._inited = false;
              }

              get impl() {
                return this._body;
              }

              set _imp(v) {
                this._body = v;
              }

              get rigidBody() {
                return this._rigidBody;
              }

              get isAwake() {
                return this._body.IsAwake();
              }

              get isSleeping() {
                return !this._body.IsAwake();
              }

              initialize(com) {
                this._rigidBody = com;

                PhysicsSystem2D.instance._callAfterStep(this, this._init);
              }

              onDestroy() {
                PhysicsSystem2D.instance._callAfterStep(this, this._destroy);
              }

              onEnable() {
                this.setActive(true);
              }

              onDisable() {
                this.setActive(false);
              }

              _registerNodeEvents() {
                const node = this.rigidBody.node;
                node.on(NodeEventType.TRANSFORM_CHANGED, this._onNodeTransformChanged, this);
              }

              _unregisterNodeEvents() {
                const node = this.rigidBody.node;
                node.off(NodeEventType.TRANSFORM_CHANGED, this._onNodeTransformChanged, this);
              }

              _onNodeTransformChanged(type) {
                if (PhysicsSystem2D.instance.stepping) {
                  return;
                }

                if (type & Node.TransformBit.SCALE) {
                  const colliders = this.rigidBody.getComponents(Collider2D);

                  for (let i = 0; i < colliders.length; i++) {
                    colliders[i].apply();
                  }
                }

                if (type & Node.TransformBit.POSITION) {
                  this.syncPositionToPhysics(true);
                }

                if (type & Node.TransformBit.ROTATION) {
                  this.syncRotationToPhysics(true);
                }
              }

              _init() {
                if (this._inited) {
                  return;
                }

                this._registerNodeEvents();

                PhysicsSystem2D.instance.physicsWorld.addBody(this);
                this._inited = true;
              }

              _destroy() {
                if (!this._inited) return;
                PhysicsSystem2D.instance.physicsWorld.removeBody(this);

                this._unregisterNodeEvents();

                this._inited = false;
              }

              animate(dt) {
                const b2body = this._body;
                if (!b2body) return;
                const b2Pos = b2body.GetPosition();
                b2body.SetAwake(true);
                const timeStep = 1 / dt;
                tempVec2_1$1.x = (this._animatedPos.x - b2Pos.x) * timeStep;
                tempVec2_1$1.y = (this._animatedPos.y - b2Pos.y) * timeStep;
                b2body.SetLinearVelocity(tempVec2_1$1);
                const b2Rotation = b2body.GetAngle();
                b2body.SetAngularVelocity((this._animatedAngle - b2Rotation) * timeStep);
              }

              syncPositionToPhysics(enableAnimated = false) {
                const b2body = this._body;
                if (!b2body) return;
                const pos = this._rigidBody.node.worldPosition;
                let temp;
                const bodyType = this._rigidBody.type;

                if (bodyType === ERigidBody2DType.Animated) {
                  temp = b2body.GetLinearVelocity();
                } else {
                  temp = b2body.GetPosition();
                }

                temp.x = pos.x / PHYSICS_2D_PTM_RATIO;
                temp.y = pos.y / PHYSICS_2D_PTM_RATIO;

                if (bodyType === ERigidBody2DType.Animated && enableAnimated) {
                  this._animatedPos.set(temp.x, temp.y);
                } else {
                  b2body.SetTransformVec(temp, b2body.GetAngle());
                }
              }

              syncRotationToPhysics(enableAnimated = false) {
                const b2body = this._body;
                if (!b2body) return;
                const rotation = toRadian(this._rigidBody.node.eulerAngles.z);
                const bodyType = this._rigidBody.type;

                if (bodyType === ERigidBody2DType.Animated && enableAnimated) {
                  this._animatedAngle = rotation;
                } else {
                  b2body.SetTransformVec(b2body.GetPosition(), rotation);
                }
              }

              resetVelocity() {
                const b2body = this._body;
                if (!b2body) return;
                const temp = b2body.m_linearVelocity;
                temp.Set(0, 0);
                b2body.SetLinearVelocity(temp);
                b2body.SetAngularVelocity(0);
              }

              setType(v) {
                this._body.SetType(v);
              }

              setLinearDamping(v) {
                this._body.SetLinearDamping(v);
              }

              setAngularDamping(v) {
                this._body.SetAngularDamping(v);
              }

              setGravityScale(v) {
                this._body.SetGravityScale(v);
              }

              setFixedRotation(v) {
                this._body.SetFixedRotation(v);
              }

              setAllowSleep(v) {
                this._body.SetSleepingAllowed(v);
              }

              isActive() {
                return this._body.IsActive();
              }

              setActive(v) {
                this._body.SetActive(v);
              }

              wakeUp() {
                this._body.SetAwake(true);
              }

              sleep() {
                this._body.SetAwake(false);
              }

              getMass() {
                return this._body.GetMass();
              }

              setLinearVelocity(v) {
                this._body.SetLinearVelocity(v);
              }

              getLinearVelocity(out) {
                const velocity = this._body.GetLinearVelocity();

                out.x = velocity.x;
                out.y = velocity.y;
                return out;
              }

              getLinearVelocityFromWorldPoint(worldPoint, out) {
                tempVec2_1$1.Set(worldPoint.x / PHYSICS_2D_PTM_RATIO, worldPoint.y / PHYSICS_2D_PTM_RATIO);

                this._body.GetLinearVelocityFromWorldPoint(tempVec2_1$1, out);

                out.x *= PHYSICS_2D_PTM_RATIO;
                out.y *= PHYSICS_2D_PTM_RATIO;
                return out;
              }

              setAngularVelocity(v) {
                this._body.SetAngularVelocity(v);
              }

              getAngularVelocity() {
                return toDegree(this._body.GetAngularVelocity());
              }

              getLocalVector(worldVector, out) {
                out = out || new Vec2();
                tempVec2_1$1.Set(worldVector.x / PHYSICS_2D_PTM_RATIO, worldVector.y / PHYSICS_2D_PTM_RATIO);

                this._body.GetLocalVector(tempVec2_1$1, out);

                out.x *= PHYSICS_2D_PTM_RATIO;
                out.y *= PHYSICS_2D_PTM_RATIO;
                return out;
              }

              getWorldVector(localVector, out) {
                tempVec2_1$1.Set(localVector.x / PHYSICS_2D_PTM_RATIO, localVector.y / PHYSICS_2D_PTM_RATIO);

                this._body.GetWorldVector(tempVec2_1$1, out);

                out.x *= PHYSICS_2D_PTM_RATIO;
                out.y *= PHYSICS_2D_PTM_RATIO;
                return out;
              }

              getLocalPoint(worldPoint, out) {
                out = out || new Vec2();
                tempVec2_1$1.Set(worldPoint.x / PHYSICS_2D_PTM_RATIO, worldPoint.y / PHYSICS_2D_PTM_RATIO);

                this._body.GetLocalPoint(tempVec2_1$1, out);

                out.x *= PHYSICS_2D_PTM_RATIO;
                out.y *= PHYSICS_2D_PTM_RATIO;
                return out;
              }

              getWorldPoint(localPoint, out) {
                out = out || new Vec2();
                tempVec2_1$1.Set(localPoint.x / PHYSICS_2D_PTM_RATIO, localPoint.y / PHYSICS_2D_PTM_RATIO);

                this._body.GetWorldPoint(tempVec2_1$1, out);

                out.x *= PHYSICS_2D_PTM_RATIO;
                out.y *= PHYSICS_2D_PTM_RATIO;
                return out;
              }

              getLocalCenter(out) {
                out = out || new Vec2();

                const pos = this._body.GetLocalCenter();

                out.x = pos.x * PHYSICS_2D_PTM_RATIO;
                out.y = pos.y * PHYSICS_2D_PTM_RATIO;
                return out;
              }

              getWorldCenter(out) {
                out = out || new Vec2();

                const pos = this._body.GetWorldCenter();

                out.x = pos.x * PHYSICS_2D_PTM_RATIO;
                out.y = pos.y * PHYSICS_2D_PTM_RATIO;
                return out;
              }

              getInertia() {
                return this._body.GetInertia();
              }

              applyForce(force, point, wake) {
                if (this._body) {
                  tempVec2_1$1.Set(point.x / PHYSICS_2D_PTM_RATIO, point.y / PHYSICS_2D_PTM_RATIO);

                  this._body.ApplyForce(force, tempVec2_1$1, wake);
                }
              }

              applyForceToCenter(force, wake) {
                if (this._body) {
                  this._body.ApplyForceToCenter(force, wake);
                }
              }

              applyTorque(torque, wake) {
                if (this._body) {
                  this._body.ApplyTorque(torque, wake);
                }
              }

              applyLinearImpulse(impulse, point, wake) {
                if (this._body) {
                  tempVec2_1$1.Set(point.x / PHYSICS_2D_PTM_RATIO, point.y / PHYSICS_2D_PTM_RATIO);

                  this._body.ApplyLinearImpulse(impulse, tempVec2_1$1, wake);
                }
              }

              applyLinearImpulseToCenter(impulse, wake) {
                if (this._body) {
                  this._body.ApplyLinearImpulse(impulse, this._body.GetPosition(), wake);
                }
              }

              applyAngularImpulse(impulse, wake) {
                if (this._body) {
                  this._body.ApplyAngularImpulse(impulse, wake);
                }
              }

            }

            const tempFilter = new box2d_1.Filter();

            function getFilter(shape) {
              const comp = shape.collider;
              tempFilter.categoryBits = comp.group === PhysicsGroup$1.DEFAULT ? comp.body.group : comp.group;
              tempFilter.maskBits = PhysicsSystem2D.instance.collisionMatrix[tempFilter.categoryBits];
              return tempFilter;
            }

            class b2Shape2D {
              constructor() {
                this._shapes = [];
                this._fixtures = [];
                this._collider = null;
                this._body = null;
                this._inited = false;
                this._rect = new Rect$1();
              }

              get impl() {
                return this._shapes;
              }

              get collider() {
                return this._collider;
              }

              initialize(comp) {
                this._collider = comp;
              }

              onLoad() {}

              onEnable() {
                PhysicsSystem2D.instance._callAfterStep(this, this._init);
              }

              onDisable() {
                PhysicsSystem2D.instance._callAfterStep(this, this._destroy);
              }

              start() {}

              onGroupChanged() {
                const filter = getFilter(this);

                this._fixtures.forEach(f => {
                  f.SetFilterData(filter);
                });
              }

              apply() {
                this._destroy();

                this._init();
              }

              get worldAABB() {
                const MAX = 10e6;
                let minX = MAX;
                let minY = MAX;
                let maxX = -MAX;
                let maxY = -MAX;
                const fixtures = this._fixtures;

                for (let i = 0; i < fixtures.length; i++) {
                  const fixture = fixtures[i];
                  const count = fixture.GetShape().GetChildCount();

                  for (let j = 0; j < count; j++) {
                    const aabb = fixture.GetAABB(j);
                    if (aabb.lowerBound.x < minX) minX = aabb.lowerBound.x;
                    if (aabb.lowerBound.y < minY) minY = aabb.lowerBound.y;
                    if (aabb.upperBound.x > maxX) maxX = aabb.upperBound.x;
                    if (aabb.upperBound.y > maxY) maxY = aabb.upperBound.y;
                  }
                }

                minX *= PHYSICS_2D_PTM_RATIO;
                minY *= PHYSICS_2D_PTM_RATIO;
                maxX *= PHYSICS_2D_PTM_RATIO;
                maxY *= PHYSICS_2D_PTM_RATIO;
                const r = this._rect;
                r.x = minX;
                r.y = minY;
                r.width = maxX - minX;
                r.height = maxY - minY;
                return r;
              }

              getFixtureIndex(fixture) {
                return this._fixtures.indexOf(fixture);
              }

              _createShapes(scaleX, scaleY) {
                return [];
              }

              _init() {
                var _body$impl;

                if (this._inited) return;
                const comp = this.collider;
                const body = comp.getComponent(RigidBody2D);
                if (!body) return;
                const innerBody = (_body$impl = body.impl) === null || _body$impl === void 0 ? void 0 : _body$impl.impl;
                if (!innerBody) return;
                const node = body.node;
                const scale = node.worldScale;
                const shapes = scale.x === 0 && scale.y === 0 ? [] : this._createShapes(scale.x, scale.y);
                const filter = getFilter(this);

                for (let i = 0; i < shapes.length; i++) {
                  const shape = shapes[i];
                  const fixDef = {
                    density: comp.density,
                    isSensor: comp.sensor,
                    friction: comp.friction,
                    restitution: comp.restitution,
                    shape,
                    filter
                  };
                  const fixture = innerBody.CreateFixture(fixDef);
                  fixture.m_userData = this;

                  if (body.enabledContactListener) {
                    PhysicsSystem2D.instance.physicsWorld.registerContactFixture(fixture);
                  }

                  this._shapes.push(shape);

                  this._fixtures.push(fixture);
                }

                this._body = innerBody;
                this._inited = true;
              }

              _destroy() {
                if (!this._inited) return;
                const fixtures = this._fixtures;
                const body = this._body;

                for (let i = fixtures.length - 1; i >= 0; i--) {
                  const fixture = fixtures[i];
                  fixture.m_userData = null;
                  PhysicsSystem2D.instance.physicsWorld.unregisterContactFixture(fixture);

                  if (body) {
                    body.DestroyFixture(fixture);
                  }
                }

                this._body = null;
                this._fixtures.length = 0;
                this._shapes.length = 0;
                this._inited = false;
              }

            }

            const tempAabb = new Rect$1();
            class b2BoxShape extends b2Shape2D {
              constructor(...args) {
                super(...args);
                this._worldPoints = [new Vec2(), new Vec2(), new Vec2(), new Vec2()];
              }

              get worldPoints() {
                const aabb = tempAabb;
                const collider = this.collider;
                const size = collider.size;
                const offset = collider.offset;
                aabb.x = offset.x - size.width / 2;
                aabb.y = offset.y - size.height / 2;
                aabb.width = size.width;
                aabb.height = size.height;
                const wps = this._worldPoints;
                const wp0 = wps[0];
                const wp1 = wps[1];
                const wp2 = wps[2];
                const wp3 = wps[3];
                aabb.transformMat4ToPoints(collider.node.worldMatrix, wp0, wp1, wp2, wp3);
                return wps;
              }

              _createShapes(scaleX, scaleY) {
                scaleX = Math.abs(scaleX);
                scaleY = Math.abs(scaleY);
                const comp = this.collider;
                const width = comp.size.width / 2 / PHYSICS_2D_PTM_RATIO * scaleX;
                const height = comp.size.height / 2 / PHYSICS_2D_PTM_RATIO * scaleY;
                const offsetX = comp.offset.x / PHYSICS_2D_PTM_RATIO * scaleX;
                const offsetY = comp.offset.y / PHYSICS_2D_PTM_RATIO * scaleY;
                const shape = new box2d_1.PolygonShape();
                shape.SetAsBox(width, height, new box2d_1.Vec2(offsetX, offsetY), 0);
                return [shape];
              }

            }

            class b2CircleShape extends b2Shape2D {
              constructor(...args) {
                super(...args);
                this._worldPosition = new Vec2();
              }

              get worldRadius() {
                return this._shapes[0].m_radius * PHYSICS_2D_PTM_RATIO;
              }

              get worldPosition() {
                const p = this._shapes[0].m_p;
                return this._worldPosition.set(p.x * PHYSICS_2D_PTM_RATIO, p.y * PHYSICS_2D_PTM_RATIO);
              }

              _createShapes(scaleX, scaleY) {
                scaleX = Math.abs(scaleX);
                scaleY = Math.abs(scaleY);
                const comp = this.collider;
                const offsetX = comp.offset.x / PHYSICS_2D_PTM_RATIO * scaleX;
                const offsetY = comp.offset.y / PHYSICS_2D_PTM_RATIO * scaleY;
                const shape = new box2d_1.CircleShape();
                shape.m_radius = comp.radius / PHYSICS_2D_PTM_RATIO * scaleX;
                shape.m_p.Set(offsetX, offsetY);
                return [shape];
              }

            }

            class b2PolygonShape extends b2Shape2D {
              constructor(...args) {
                super(...args);
                this._worldPoints = [];
              }

              get worldPoints() {
                const comp = this.collider;
                const points = comp.points;
                const worldPoints = this._worldPoints;
                const m = comp.node.worldMatrix;

                for (let i = 0; i < points.length; i++) {
                  if (!worldPoints[i]) {
                    worldPoints[i] = new Vec2();
                  }

                  Vec2.transformMat4(worldPoints[i], points[i], m);
                }

                worldPoints.length = points.length;
                return this._worldPoints;
              }

              _createShapes(scaleX, scaleY) {
                const shapes = [];
                const comp = this.collider;
                const points = comp.points;

                if (points.length > 0 && points[0].equals(points[points.length - 1])) {
                  points.length -= 1;
                }

                const polys = ConvexPartition(points);
                const offset = comp.offset;

                for (let i = 0; i < polys.length; i++) {
                  const poly = polys[i];
                  let shape = null;
                  let vertices = [];
                  let firstVertice = null;

                  for (let j = 0, l = poly.length; j < l; j++) {
                    if (!shape) {
                      shape = new box2d_1.PolygonShape();
                    }

                    const p = poly[j];
                    const x = (p.x + offset.x) / PHYSICS_2D_PTM_RATIO * scaleX;
                    const y = (p.y + offset.y) / PHYSICS_2D_PTM_RATIO * scaleY;
                    const v = new box2d_1.Vec2(x, y);
                    vertices.push(v);

                    if (!firstVertice) {
                      firstVertice = v;
                    }

                    if (vertices.length === box2d_1.maxPolygonVertices) {
                      shape.Set(vertices, vertices.length);
                      shapes.push(shape);
                      shape = null;

                      if (j < l - 1) {
                        vertices = [firstVertice, vertices[vertices.length - 1]];
                      }
                    }
                  }

                  if (shape) {
                    shape.Set(vertices, vertices.length);
                    shapes.push(shape);
                  }
                }

                return shapes;
              }

            }

            class b2Joint {
              constructor() {
                this._b2joint = null;
                this._jointComp = null;
                this._body = null;
                this._inited = false;
              }

              get impl() {
                return this._b2joint;
              }

              get comp() {
                return this._jointComp;
              }

              get body() {
                return this._body;
              }

              initialize(comp) {
                this._jointComp = comp;
              }

              onEnable() {
                PhysicsSystem2D.instance._callAfterStep(this, this._init);
              }

              onDisable() {
                PhysicsSystem2D.instance._callAfterStep(this, this._destroy);
              }

              start() {
                PhysicsSystem2D.instance._callAfterStep(this, this._init);
              }

              _init() {
                if (this._inited) return;
                const comp = this._jointComp;

                if (!comp.isValid) {
                  return;
                }

                this._body = comp.getComponent(RigidBody2D);

                const def = this._createJointDef();

                if (!def) {
                  return;
                }

                const connectedBody = comp.connectedBody;

                if (!connectedBody || !connectedBody.enabledInHierarchy) {
                  return;
                }

                def.bodyA = this._body.impl.impl;
                def.bodyB = connectedBody.impl.impl;
                def.collideConnected = comp.collideConnected;
                this._b2joint = PhysicsSystem2D.instance.physicsWorld.impl.CreateJoint(def);
                this._inited = true;
              }

              _destroy() {
                if (!this._inited) return;
                PhysicsSystem2D.instance.physicsWorld.impl.DestroyJoint(this._b2joint);
                this._b2joint = null;
                this._inited = false;
              }

              _createJointDef() {
                return null;
              }

              isValid() {
                return this._b2joint && this._body && this._body.impl && this._jointComp && this._jointComp.connectedBody && this._jointComp.connectedBody.impl;
              }

            }

            const tempB2Vec2 = new box2d_1.Vec2();
            class b2MouseJoint extends b2Joint {
              constructor(...args) {
                super(...args);
                this._touchPoint = new Vec2();
                this._isTouched = false;
              }

              setTarget(v) {
                if (this._b2joint) {
                  tempB2Vec2.x = v.x / PHYSICS_2D_PTM_RATIO;
                  tempB2Vec2.y = v.y / PHYSICS_2D_PTM_RATIO;

                  this._b2joint.SetTarget(tempB2Vec2);
                }
              }

              setDampingRatio(v) {
                if (this._b2joint) {
                  this._b2joint.SetDampingRatio(v);
                }
              }

              setFrequency(v) {
                if (this._b2joint) {
                  this._b2joint.SetFrequency(v);
                }
              }

              setMaxForce(v) {
                if (this._b2joint) {
                  this._b2joint.SetMaxForce(v);
                }
              }

              _createJointDef() {
                const def = new box2d_1.MouseJointDef();
                const comp = this._jointComp;
                def.target.Set(this._touchPoint.x / PHYSICS_2D_PTM_RATIO, this._touchPoint.y / PHYSICS_2D_PTM_RATIO);
                def.maxForce = comp.maxForce;
                def.dampingRatio = comp.dampingRatio;
                def.frequencyHz = comp.frequency;
                return def;
              }

              initialize(comp) {
                super.initialize(comp);
                const canvas = find('Canvas');

                if (canvas) {
                  canvas.on(NodeEventType.TOUCH_START, this.onTouchBegan, this);
                  canvas.on(NodeEventType.TOUCH_MOVE, this.onTouchMove, this);
                  canvas.on(NodeEventType.TOUCH_END, this.onTouchEnd, this);
                  canvas.on(NodeEventType.TOUCH_CANCEL, this.onTouchEnd, this);
                }
              }

              onEnable() {}

              start() {}

              onTouchBegan(event) {
                this._isTouched = true;

                const target = this._touchPoint.set(event.getUILocation());

                const world = PhysicsSystem2D.instance.physicsWorld;
                const colliders = world.testPoint(target);
                if (colliders.length <= 0) return;
                const body = colliders[0].body;
                body.wakeUp();
                const comp = this._jointComp;
                comp.connectedBody = body;

                this._init();

                this.setMaxForce(comp.maxForce * body.getMass());
                this.setTarget(target);
              }

              onTouchMove(event) {
                this._touchPoint = event.getUILocation();
              }

              onTouchEnd(event) {
                this._destroy();

                this._isTouched = false;
              }

              update() {
                if (!this._isTouched || !this.isValid()) {
                  return;
                }

                this.setTarget(this._touchPoint);
              }

            }

            class b2DistanceJoint extends b2Joint {
              setMaxLength(v) {
                if (this._b2joint) {
                  this._b2joint.SetMaxLength(v);
                }
              }

              _createJointDef() {
                const comp = this._jointComp;
                const def = new box2d_1.RopeJointDef();
                def.localAnchorA.Set(comp.anchor.x / PHYSICS_2D_PTM_RATIO, comp.anchor.y / PHYSICS_2D_PTM_RATIO);
                def.localAnchorB.Set(comp.connectedAnchor.x / PHYSICS_2D_PTM_RATIO, comp.connectedAnchor.y / PHYSICS_2D_PTM_RATIO);
                def.maxLength = comp.maxLength / PHYSICS_2D_PTM_RATIO;
                return def;
              }

            }

            class b2SpringJoint extends b2Joint {
              setDampingRatio(v) {
                if (this._b2joint) {
                  this._b2joint.SetDampingRatio(v);
                }
              }

              setFrequency(v) {
                if (this._b2joint) {
                  this._b2joint.SetFrequency(v);
                }
              }

              setDistance(v) {
                if (this._b2joint) {
                  this._b2joint.SetLength(v);
                }
              }

              _createJointDef() {
                const comp = this._jointComp;
                const def = new box2d_1.DistanceJointDef();
                def.localAnchorA.Set(comp.anchor.x / PHYSICS_2D_PTM_RATIO, comp.anchor.y / PHYSICS_2D_PTM_RATIO);
                def.localAnchorB.Set(comp.connectedAnchor.x / PHYSICS_2D_PTM_RATIO, comp.connectedAnchor.y / PHYSICS_2D_PTM_RATIO);
                def.length = comp.distance / PHYSICS_2D_PTM_RATIO;
                def.dampingRatio = comp.dampingRatio;
                def.frequencyHz = comp.frequency;
                return def;
              }

            }

            class b2RelativeJoint extends b2Joint {
              setMaxForce(v) {
                if (this._b2joint) {
                  this._b2joint.SetMaxForce(v);
                }
              }

              setAngularOffset(v) {
                if (this._b2joint) {
                  this._b2joint.SetAngularOffset(toRadian(v));
                }
              }

              setLinearOffset(v) {
                if (this._b2joint) {
                  this._b2joint.SetLinearOffset(new box2d_1.Vec2(v.x / PHYSICS_2D_PTM_RATIO, v.y / PHYSICS_2D_PTM_RATIO));
                }
              }

              setCorrectionFactor(v) {
                if (this._b2joint) {
                  this._b2joint.m_correctionFactor = v;
                }
              }

              setMaxTorque(v) {
                if (this._b2joint) {
                  this._b2joint.SetMaxTorque(v);
                }
              }

              _createJointDef() {
                const comp = this._jointComp;
                const def = new box2d_1.MotorJointDef();
                def.linearOffset.Set(comp.linearOffset.x / PHYSICS_2D_PTM_RATIO, comp.linearOffset.y / PHYSICS_2D_PTM_RATIO);
                def.angularOffset = toRadian(comp.angularOffset);
                def.maxForce = comp.maxForce;
                def.maxTorque = comp.maxTorque;
                def.correctionFactor = comp.correctionFactor;
                return def;
              }

            }

            class b2SliderJoint extends b2Joint {
              enableLimit(v) {
                if (this._b2joint) {
                  this._b2joint.EnableLimit(v);
                }
              }

              setLowerLimit(v) {
                this.updateLimits();
              }

              setUpperLimit(v) {
                this.updateLimits();
              }

              updateLimits() {
                if (this._b2joint) {
                  const comp = this._jointComp;

                  this._b2joint.SetLimits(comp.lowerLimit / PHYSICS_2D_PTM_RATIO, comp.upperLimit / PHYSICS_2D_PTM_RATIO);
                }
              }

              enableMotor(v) {
                if (this._b2joint) {
                  this._b2joint.EnableMotor(v);
                }
              }

              setMaxMotorForce(v) {
                if (this._b2joint) {
                  this._b2joint.SetMaxMotorForce(v);
                }
              }

              setMotorSpeed(v) {
                if (this._b2joint) {
                  this._b2joint.SetMotorSpeed(v);
                }
              }

              _createJointDef() {
                const comp = this._jointComp;
                const def = new box2d_1.PrismaticJointDef();
                def.localAnchorA.Set(comp.anchor.x / PHYSICS_2D_PTM_RATIO, comp.anchor.y / PHYSICS_2D_PTM_RATIO);
                def.localAnchorB.Set(comp.connectedAnchor.x / PHYSICS_2D_PTM_RATIO, comp.connectedAnchor.y / PHYSICS_2D_PTM_RATIO);
                const angle = toRadian(comp.angle);
                def.localAxisA.Set(Math.cos(angle), Math.sin(angle));
                def.referenceAngle = 0;
                def.enableLimit = comp.enableLimit;
                def.lowerTranslation = comp.lowerLimit / PHYSICS_2D_PTM_RATIO;
                def.upperTranslation = comp.upperLimit / PHYSICS_2D_PTM_RATIO;
                def.enableMotor = comp.enableMotor;
                def.maxMotorForce = comp.maxMotorForce;
                def.motorSpeed = comp.motorSpeed;
                return def;
              }

            }

            class b2FixedJoint extends b2Joint {
              setFrequency(v) {
                if (this._b2joint) {
                  this._b2joint.SetFrequency(v);
                }
              }

              setDampingRatio(v) {
                if (this._b2joint) {
                  this._b2joint.SetDampingRatio(v);
                }
              }

              _createJointDef() {
                const comp = this._jointComp;
                const def = new box2d_1.WeldJointDef();
                def.localAnchorA.Set(comp.anchor.x / PHYSICS_2D_PTM_RATIO, comp.anchor.y / PHYSICS_2D_PTM_RATIO);
                def.localAnchorB.Set(comp.connectedAnchor.x / PHYSICS_2D_PTM_RATIO, comp.connectedAnchor.y / PHYSICS_2D_PTM_RATIO);
                def.referenceAngle = 0;
                def.frequencyHz = comp.frequency;
                def.dampingRatio = comp.dampingRatio;
                return def;
              }

            }

            class b2WheelJoint extends b2Joint {
              setDampingRatio(v) {
                if (this._b2joint) {
                  this._b2joint.SetSpringDampingRatio(v);
                }
              }

              setFrequency(v) {
                if (this._b2joint) {
                  this._b2joint.SetSpringFrequencyHz(v);
                }
              }

              enableMotor(v) {
                if (this._b2joint) {
                  this._b2joint.EnableMotor(v);
                }
              }

              setMaxMotorTorque(v) {
                if (this._b2joint) {
                  this._b2joint.SetMaxMotorTorque(v);
                }
              }

              setMotorSpeed(v) {
                if (this._b2joint) {
                  this._b2joint.SetMotorSpeed(v);
                }
              }

              _createJointDef() {
                const comp = this._jointComp;
                const def = new box2d_1.WheelJointDef();
                def.localAnchorA.Set(comp.anchor.x / PHYSICS_2D_PTM_RATIO, comp.anchor.y / PHYSICS_2D_PTM_RATIO);
                def.localAnchorB.Set(comp.connectedAnchor.x / PHYSICS_2D_PTM_RATIO, comp.connectedAnchor.y / PHYSICS_2D_PTM_RATIO);
                const angle = toRadian(comp.angle);
                def.localAxisA.Set(Math.cos(angle), Math.sin(angle));
                def.maxMotorTorque = comp.maxMotorTorque;
                def.motorSpeed = toRadian(comp.motorSpeed);
                def.enableMotor = comp.enableMotor;
                def.dampingRatio = comp.dampingRatio;
                def.frequencyHz = comp.frequency;
                return def;
              }

            }

            class b2HingeJoint extends b2Joint {
              enableLimit(v) {
                if (this._b2joint) {
                  this._b2joint.EnableLimit(v);
                }
              }

              setLowerAngle(v) {
                this.updateLimits();
              }

              setUpperAngle(v) {
                this.updateLimits();
              }

              updateLimits() {
                if (this._b2joint) {
                  const comp = this._jointComp;

                  this._b2joint.SetLimits(toRadian(comp.lowerAngle), toRadian(comp.upperAngle));
                }
              }

              enableMotor(v) {
                if (this._b2joint) {
                  this._b2joint.EnableMotor(v);
                }
              }

              setMaxMotorTorque(v) {
                if (this._b2joint) {
                  this._b2joint.SetMaxMotorTorque(v);
                }
              }

              setMotorSpeed(v) {
                if (this._b2joint) {
                  this._b2joint.SetMotorSpeed(v);
                }
              }

              _createJointDef() {
                const comp = this._jointComp;
                const def = new box2d_1.RevoluteJointDef();
                def.localAnchorA.Set(comp.anchor.x / PHYSICS_2D_PTM_RATIO, comp.anchor.y / PHYSICS_2D_PTM_RATIO);
                def.localAnchorB.Set(comp.connectedAnchor.x / PHYSICS_2D_PTM_RATIO, comp.connectedAnchor.y / PHYSICS_2D_PTM_RATIO);
                def.enableMotor = comp.enableMotor;
                def.maxMotorTorque = comp.maxMotorTorque;
                def.motorSpeed = toRadian(comp.motorSpeed);
                def.enableLimit = comp.enableLimit;
                def.lowerAngle = comp.lowerAngle;
                def.upperAngle = comp.upperAngle;
                return def;
              }

            }

            select('box2d', {
              PhysicsWorld: b2PhysicsWorld,
              RigidBody: b2RigidBody2D,
              BoxShape: b2BoxShape,
              CircleShape: b2CircleShape,
              PolygonShape: b2PolygonShape,
              MouseJoint: b2MouseJoint,
              DistanceJoint: b2DistanceJoint,
              SpringJoint: b2SpringJoint,
              RelativeJoint: b2RelativeJoint,
              SliderJoint: b2SliderJoint,
              FixedJoint: b2FixedJoint,
              WheelJoint: b2WheelJoint,
              HingeJoint: b2HingeJoint
            });

            function lineLine(a1, a2, b1, b2) {
              const ua_t = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);
              const ub_t = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x);
              const u_b = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);

              if (u_b !== 0) {
                const ua = ua_t / u_b;
                const ub = ub_t / u_b;

                if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
                  return true;
                }
              }

              return false;
            }

            const tempR1 = new Vec2();
            const tempR2 = new Vec2();
            const tempR3 = new Vec2();
            const tempR4 = new Vec2();

            function lineRect(a1, a2, b) {
              const r0 = tempR1.set(b.x, b.y);
              const r1 = tempR2.set(b.x, b.yMax);
              const r2 = tempR3.set(b.xMax, b.yMax);
              const r3 = tempR4.set(b.xMax, b.y);
              if (lineLine(a1, a2, r0, r1)) return true;
              if (lineLine(a1, a2, r1, r2)) return true;
              if (lineLine(a1, a2, r2, r3)) return true;
              if (lineLine(a1, a2, r3, r0)) return true;
              return false;
            }

            function linePolygon(a1, a2, b) {
              const length = b.length;

              for (let i = 0; i < length; ++i) {
                const b1 = b[i];
                const b2 = b[(i + 1) % length];
                if (lineLine(a1, a2, b1, b2)) return true;
              }

              return false;
            }

            function rectRect(a, b) {
              const a_min_x = a.x;
              const a_min_y = a.y;
              const a_max_x = a.x + a.width;
              const a_max_y = a.y + a.height;
              const b_min_x = b.x;
              const b_min_y = b.y;
              const b_max_x = b.x + b.width;
              const b_max_y = b.y + b.height;
              return a_min_x <= b_max_x && a_max_x >= b_min_x && a_min_y <= b_max_y && a_max_y >= b_min_y;
            }

            function rectPolygon(a, b) {
              const r0 = tempR1.set(a.x, a.y);
              const r1 = tempR2.set(a.x, a.yMax);
              const r2 = tempR3.set(a.xMax, a.yMax);
              const r3 = tempR4.set(a.xMax, a.y);
              if (linePolygon(r0, r1, b)) return true;
              if (linePolygon(r1, r2, b)) return true;
              if (linePolygon(r2, r3, b)) return true;
              if (linePolygon(r3, r0, b)) return true;

              for (let i = 0, l = b.length; i < l; ++i) {
                if (a.contains(b[i])) return true;
              }

              if (pointInPolygon(r0, b)) return true;
              if (pointInPolygon(r1, b)) return true;
              if (pointInPolygon(r2, b)) return true;
              if (pointInPolygon(r3, b)) return true;
              return false;
            }

            function polygonPolygon(a, b) {
              let i;
              let l;

              for (i = 0, l = a.length; i < l; ++i) {
                const a1 = a[i];
                const a2 = a[(i + 1) % l];
                if (linePolygon(a1, a2, b)) return true;
              }

              for (i = 0, l = b.length; i < l; ++i) {
                if (pointInPolygon(b[i], a)) return true;
              }

              for (i = 0, l = a.length; i < l; ++i) {
                if (pointInPolygon(a[i], b)) return true;
              }

              return false;
            }

            function circleCircle(c1p, c1r, c2p, c2r) {
              const distance = Vec2.distance(c1p, c2p);
              return distance < c1r + c2r;
            }

            function polygonCircle(polygon, cp, cr) {
              const position = cp;

              if (pointInPolygon(position, polygon)) {
                return true;
              }

              for (let i = 0, l = polygon.length; i < l; i++) {
                const start = i === 0 ? polygon[polygon.length - 1] : polygon[i - 1];
                const end = polygon[i];

                if (pointLineDistance(position, start, end, true) < cr) {
                  return true;
                }
              }

              return false;
            }

            function rectCircle(rect, cp, cr) {
              const cx = cp.x;
              const cy = cp.y;
              const rx = rect.x;
              const ry = rect.y;
              const rw = rect.width;
              const rh = rect.height;
              let testX = cx;
              let testY = cy;
              if (cx < rx) testX = rx;else if (cx > rx + rw) testX = rx + rw;
              if (cy < ry) testY = ry;else if (cy > ry + rh) testY = ry + rh;
              const distX = cx - testX;
              const distY = cy - testY;
              const distance = Math.sqrt(distX * distX + distY * distY);

              if (distance <= cr) {
                return true;
              }

              return false;
            }

            function pointInPolygon(point, polygon) {
              let inside = false;
              const x = point.x;
              const y = point.y;
              const length = polygon.length;

              for (let i = 0, j = length - 1; i < length; j = i++) {
                const xi = polygon[i].x;
                const yi = polygon[i].y;
                const xj = polygon[j].x;
                const yj = polygon[j].y;
                const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
                if (intersect) inside = !inside;
              }

              return inside;
            }

            function pointLineDistance(point, start, end, isSegment) {
              let dx = end.x - start.x;
              let dy = end.y - start.y;
              const d = dx * dx + dy * dy;
              const t = ((point.x - start.x) * dx + (point.y - start.y) * dy) / d;
              let p;

              if (!isSegment) {
                p = tempR1.set(start.x + t * dx, start.y + t * dy);
              } else if (d) {
                if (t < 0) p = start;else if (t > 1) p = end;else p = tempR1.set(start.x + t * dx, start.y + t * dy);
              } else {
                p = start;
              }

              dx = point.x - p.x;
              dy = point.y - p.y;
              return Math.sqrt(dx * dx + dy * dy);
            }

            class Intersection2D {} exports('Intersection2D', Intersection2D);
            Intersection2D.lineLine = lineLine;
            Intersection2D.lineRect = lineRect;
            Intersection2D.linePolygon = linePolygon;
            Intersection2D.rectRect = rectRect;
            Intersection2D.rectPolygon = rectPolygon;
            Intersection2D.rectCircle = rectCircle;
            Intersection2D.polygonPolygon = polygonPolygon;
            Intersection2D.circleCircle = circleCircle;
            Intersection2D.polygonCircle = polygonCircle;
            Intersection2D.pointInPolygon = pointInPolygon;
            Intersection2D.pointLineDistance = pointLineDistance;

            var _dec$1e, _dec2$18, _class$1e, _class2$14, _descriptor$13, _descriptor2$_, _class3$m, _temp$17;
            var PrimitiveType;

            (function (PrimitiveType) {
              PrimitiveType[PrimitiveType["BOX"] = 0] = "BOX";
              PrimitiveType[PrimitiveType["SPHERE"] = 1] = "SPHERE";
              PrimitiveType[PrimitiveType["CYLINDER"] = 2] = "CYLINDER";
              PrimitiveType[PrimitiveType["CONE"] = 3] = "CONE";
              PrimitiveType[PrimitiveType["CAPSULE"] = 4] = "CAPSULE";
              PrimitiveType[PrimitiveType["TORUS"] = 5] = "TORUS";
              PrimitiveType[PrimitiveType["PLANE"] = 6] = "PLANE";
              PrimitiveType[PrimitiveType["QUAD"] = 7] = "QUAD";
            })(PrimitiveType || (PrimitiveType = {}));

            ccenum(PrimitiveType);
            let Primitive = exports('Primitive', (_dec$1e = ccclass('cc.Primitive'), _dec2$18 = type$1(PrimitiveType), _dec$1e(_class$1e = (_class2$14 = (_temp$17 = _class3$m = class Primitive extends Mesh {
              constructor(type = PrimitiveType.BOX) {
                super();

                _initializerDefineProperty(this, "type", _descriptor$13, this);

                _initializerDefineProperty(this, "info", _descriptor2$_, this);

                this.type = type;
              }

              onLoaded() {
                createMesh(primitives[PrimitiveType[this.type].toLowerCase()](this.info), this);
              }

            }, _class3$m.PrimitiveType = PrimitiveType, _temp$17), (_descriptor$13 = _applyDecoratedDescriptor(_class2$14.prototype, "type", [_dec2$18], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return PrimitiveType.BOX;
              }
            }), _descriptor2$_ = _applyDecoratedDescriptor(_class2$14.prototype, "info", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return {};
              }
            })), _class2$14)) || _class$1e));
            legacyCC.Primitive = Primitive;

            legacyCC.primitives = primitives;

            class Counter {
              get value() {
                return this._value;
              }

              set value(val) {
                this._value = val;
              }

              constructor(id, opts, now) {
                this._id = void 0;
                this._opts = void 0;
                this._accumStart = void 0;
                this._total = 0;
                this._value = 0;
                this._averageValue = 0;
                this._accumValue = 0;
                this._accumSamples = 0;
                this._id = id;
                this._opts = opts;
                this._accumStart = now;
              }

              sample(now) {
                this._average(this._value, now);
              }

              human() {
                const {
                  average,
                  isInteger
                } = this._opts;
                const v = average ? this._averageValue : this._value;
                return isInteger ? Math.round(v) : Math.round(v * 100) / 100;
              }

              alarm() {
                return this._opts.below && this._value < this._opts.below || this._opts.over && this._value > this._opts.over;
              }

              _average(v, now = 0) {
                if (this._opts.average) {
                  this._accumValue += v;
                  ++this._accumSamples;
                  const t = now;

                  if (t - this._accumStart >= this._opts.average) {
                    this._averageValue = this._accumValue / this._accumSamples;
                    this._accumValue = 0;
                    this._accumStart = t;
                    this._accumSamples = 0;
                  }
                }
              }

            }

            var _dec$1f, _class$1f, _temp$18;
            let PerfCounter = (_dec$1f = ccclass('cc.PerfCounter'), _dec$1f(_class$1f = (_temp$18 = class PerfCounter extends Counter {
              constructor(id, opts, now) {
                super(id, opts, now);
                this._time = void 0;
                this._time = now;
              }

              start(now = 0) {
                this._time = now;
              }

              end(now = 0) {
                this._value = now - this._time;

                this._average(this._value);
              }

              tick() {
                this.end();
                this.start();
              }

              frame(now) {
                const t = now;
                const e = t - this._time;
                this._total++;
                const avg = this._opts.average || 1000;

                if (e > avg) {
                  this._value = this._total * 1000 / e;
                  this._total = 0;
                  this._time = t;

                  this._average(this._value);
                }
              }

            }, _temp$18)) || _class$1f);

            const _characters = '0123456789. ';
            const _average = 500;
            const _string2offset = {
              0: 0,
              1: 1,
              2: 2,
              3: 3,
              4: 4,
              5: 5,
              6: 6,
              7: 7,
              8: 8,
              9: 9,
              '.': 10
            };
            const _profileInfo = {
              fps: {
                desc: 'Framerate (FPS)',
                below: 30,
                average: _average,
                isInteger: true
              },
              draws: {
                desc: 'Draw call',
                isInteger: true
              },
              frame: {
                desc: 'Frame time (ms)',
                min: 0,
                max: 50,
                average: _average
              },
              instances: {
                desc: 'Instance Count',
                isInteger: true
              },
              tricount: {
                desc: 'Triangle',
                isInteger: true
              },
              logic: {
                desc: 'Game Logic (ms)',
                min: 0,
                max: 50,
                average: _average,
                color: '#080'
              },
              physics: {
                desc: 'Physics (ms)',
                min: 0,
                max: 50,
                average: _average
              },
              render: {
                desc: 'Renderer (ms)',
                min: 0,
                max: 50,
                average: _average,
                color: '#f90'
              },
              textureMemory: {
                desc: 'GFX Texture Mem(M)'
              },
              bufferMemory: {
                desc: 'GFX Buffer Mem(M)'
              }
            };
            const _constants = {
              fontSize: 23,
              quadHeight: 0.4,
              segmentsPerLine: 8,
              textureWidth: 256,
              textureHeight: 256
            };
            class Profiler {
              constructor() {
                this._stats = null;
                this.id = '__Profiler__';
                this._showFPS = false;
                this._rootNode = null;
                this._device = null;
                this._swapchain = null;
                this._pipeline = null;
                this._meshRenderer = null;
                this._canvas = null;
                this._ctx = null;
                this._texture = null;
                this._region = new BufferTextureCopy();
                this._canvasArr = [];
                this._regionArr = [this._region];
                this.digitsData = null;
                this.offsetData = null;
                this.pass = null;
                this._canvasDone = false;
                this._statsDone = false;
                this._inited = false;
                this._lineHeight = _constants.textureHeight / (Object.keys(_profileInfo).length + 1);
                this._wordHeight = 0;
                this._eachNumWidth = 0;
                this._totalLines = 0;
                this.lastTime = 0;

                {
                  this._canvas = document.createElement('canvas');
                  this._ctx = this._canvas.getContext('2d');

                  this._canvasArr.push(this._canvas);
                }
              }

              reset() {
                this._stats = null;
                this._showFPS = false;
                this._rootNode = null;
                this._device = null;
                this._swapchain = null;
                this._pipeline = null;

                if (this._meshRenderer) {
                  this._meshRenderer.destroy();
                }

                this._meshRenderer = null;
                this.digitsData = null;
                this.offsetData = null;
                this.pass = null;
                this._canvasDone = false;
                this._statsDone = false;
                this._inited = false;
                this._lineHeight = _constants.textureHeight / (Object.keys(_profileInfo).length + 1);
                this._wordHeight = 0;
                this._eachNumWidth = 0;
                this._totalLines = 0;
                this.lastTime = 0;
              }

              isShowingStats() {
                return this._showFPS;
              }

              hideStats() {
                if (this._showFPS) {
                  if (this._rootNode) {
                    this._rootNode.active = false;
                  }

                  legacyCC.director.off(legacyCC.Director.EVENT_BEFORE_UPDATE, this.beforeUpdate, this);
                  legacyCC.director.off(legacyCC.Director.EVENT_AFTER_UPDATE, this.afterUpdate, this);
                  legacyCC.director.off(legacyCC.Director.EVENT_BEFORE_PHYSICS, this.beforePhysics, this);
                  legacyCC.director.off(legacyCC.Director.EVENT_AFTER_PHYSICS, this.afterPhysics, this);
                  legacyCC.director.off(legacyCC.Director.EVENT_BEFORE_DRAW, this.beforeDraw, this);
                  legacyCC.director.off(legacyCC.Director.EVENT_AFTER_DRAW, this.afterDraw, this);
                  this._showFPS = false;
                  this._pipeline.profiler = null;
                  legacyCC.game.config.showFPS = false;
                }
              }

              showStats() {
                if (!this._showFPS) {
                  if (!this._device) {
                    const root = legacyCC.director.root;
                    this._device = root.device;
                    this._swapchain = root.mainWindow.swapchain;
                    this._pipeline = root.pipeline;
                  }

                  {
                    this.generateCanvas();
                  }

                  this.generateStats();

                  {
                    legacyCC.game.once(legacyCC.Game.EVENT_ENGINE_INITED, this.generateNode, this);
                  }

                  if (this._rootNode) {
                    this._rootNode.active = true;
                  }

                  legacyCC.director.on(legacyCC.Director.EVENT_BEFORE_UPDATE, this.beforeUpdate, this);
                  legacyCC.director.on(legacyCC.Director.EVENT_AFTER_UPDATE, this.afterUpdate, this);
                  legacyCC.director.on(legacyCC.Director.EVENT_BEFORE_PHYSICS, this.beforePhysics, this);
                  legacyCC.director.on(legacyCC.Director.EVENT_AFTER_PHYSICS, this.afterPhysics, this);
                  legacyCC.director.on(legacyCC.Director.EVENT_BEFORE_DRAW, this.beforeDraw, this);
                  legacyCC.director.on(legacyCC.Director.EVENT_AFTER_DRAW, this.afterDraw, this);
                  this._showFPS = true;
                  this._canvasDone = true;
                  this._statsDone = true;
                  legacyCC.game.config.showFPS = true;
                }
              }

              generateCanvas() {
                if (this._canvasDone) {
                  return;
                }

                const {
                  textureWidth,
                  textureHeight
                } = _constants;

                if (!this._ctx || !this._canvas) {
                  return;
                }

                this._canvas.width = textureWidth;
                this._canvas.height = textureHeight;
                this._canvas.style.width = `${this._canvas.width}`;
                this._canvas.style.height = `${this._canvas.height}`;
                this._ctx.font = `${_constants.fontSize}px Arial`;
                this._ctx.textBaseline = 'top';
                this._ctx.fillStyle = '#fff';
                this._texture = this._device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.SAMPLED | TextureUsageBit.TRANSFER_DST, Format.RGBA8, textureWidth, textureHeight));
                this._region.texExtent.width = textureWidth;
                this._region.texExtent.height = textureHeight;
              }

              generateStats() {
                if (this._statsDone || !this._ctx || !this._canvas) {
                  return;
                }

                this._stats = null;
                const now = performance.now();
                this._ctx.textAlign = 'left';
                let i = 0;

                for (const id in _profileInfo) {
                  const element = _profileInfo[id];
                  this._ctx.fillText(element.desc, 0, i * this._lineHeight);
                  element.counter = new PerfCounter(id, element, now);
                  i++;
                }

                this._totalLines = i;
                this._wordHeight = this._totalLines * this._lineHeight / this._canvas.height;

                {
                  for (let j = 0; j < _characters.length; ++j) {
                    const offset = this._ctx.measureText(_characters[j]).width;

                    this._eachNumWidth = Math.max(this._eachNumWidth, offset);
                  }

                  for (let j = 0; j < _characters.length; ++j) {
                    this._ctx.fillText(_characters[j], j * this._eachNumWidth, this._totalLines * this._lineHeight);
                  }
                }

                this._eachNumWidth /= this._canvas.width;
                this._stats = _profileInfo;
                this._canvasArr[0] = this._canvas;
                this._device.copyTexImagesToTexture(this._canvasArr, this._texture, this._regionArr);
              }

              generateNode() {
                if (this._rootNode && this._rootNode.isValid) {
                  return;
                }

                this._rootNode = new Node('PROFILER_NODE');
                legacyCC.game.addPersistRootNode(this._rootNode);
                const managerNode = new Node('Profiler_Root');
                managerNode.parent = this._rootNode;
                const height = _constants.quadHeight;
                const rowHeight = height / this._totalLines;
                const lWidth = height / this._wordHeight;
                const scale = rowHeight / _constants.fontSize;
                const columnWidth = this._eachNumWidth * this._canvas.width * scale;
                const vertexPos = [0, height, 0, lWidth, height, 0, lWidth, 0, 0, 0, 0, 0];
                const vertexindices = [0, 2, 1, 0, 3, 2];
                const vertexUV = [0, 0, -1, 0, 1, 0, -1, 0, 1, this._wordHeight, -1, 0, 0, this._wordHeight, -1, 0];
                let offset = 0;

                for (let i = 0; i < this._totalLines; i++) {
                  for (let j = 0; j < _constants.segmentsPerLine; j++) {
                    vertexPos.push(lWidth + j * columnWidth, height - i * rowHeight, 0);
                    vertexPos.push(lWidth + (j + 1) * columnWidth, height - i * rowHeight, 0);
                    vertexPos.push(lWidth + (j + 1) * columnWidth, height - (i + 1) * rowHeight, 0);
                    vertexPos.push(lWidth + j * columnWidth, height - (i + 1) * rowHeight, 0);
                    offset = (i * _constants.segmentsPerLine + j + 1) * 4;
                    vertexindices.push(0 + offset, 2 + offset, 1 + offset, 0 + offset, 3 + offset, 2 + offset);
                    const idx = i * _constants.segmentsPerLine + j;
                    const z = Math.floor(idx / 4);
                    const w = idx - z * 4;
                    vertexUV.push(0, this._wordHeight, z, w);
                    vertexUV.push(this._eachNumWidth, this._wordHeight, z, w);
                    vertexUV.push(this._eachNumWidth, 1, z, w);
                    vertexUV.push(0, 1, z, w);
                  }
                }

                this._meshRenderer = managerNode.addComponent(MeshRenderer);
                this._meshRenderer.mesh = createMesh({
                  positions: vertexPos,
                  indices: vertexindices,
                  colors: vertexUV
                });

                const _material = new Material();

                _material.initialize({
                  effectName: 'profiler'
                });

                const pass = this.pass = _material.passes[0];
                const hTexture = pass.getBinding('mainTexture');
                const bDigits = pass.getBinding('digits');
                const bOffset = pass.getBinding('offset');
                pass.bindTexture(hTexture, this._texture);
                this.digitsData = pass.blocks[bDigits];
                this.offsetData = pass.blocks[bOffset];
                this.offsetData[3] = -1;
                this._meshRenderer.material = _material;
                this._meshRenderer.node.layer = Layers.Enum.PROFILER;
                this._inited = true;
              }

              beforeUpdate() {
                if (!this._stats) {
                  return;
                }

                const now = performance.now();

                this._stats.frame.counter.start(now);

                this._stats.logic.counter.start(now);
              }

              afterUpdate() {
                if (!this._stats) {
                  return;
                }

                const now = performance.now();

                if (legacyCC.director.isPaused()) {
                  this._stats.frame.counter.start(now);
                } else {
                  this._stats.logic.counter.end(now);
                }
              }

              beforePhysics() {
                if (!this._stats) {
                  return;
                }

                const now = performance.now();

                this._stats.physics.counter.start(now);
              }

              afterPhysics() {
                if (!this._stats) {
                  return;
                }

                const now = performance.now();

                this._stats.physics.counter.end(now);
              }

              beforeDraw() {
                if (!this._stats || !this._inited) {
                  return;
                }

                {
                  const surfaceTransform = this._swapchain.surfaceTransform;
                  const clipSpaceSignY = this._device.capabilities.clipSpaceSignY;

                  if (surfaceTransform !== this.offsetData[3]) {
                    const preTransform = preTransforms[surfaceTransform];
                    const x = -0.9;
                    const y = -0.9 * clipSpaceSignY;
                    this.offsetData[0] = x * preTransform[0] + y * preTransform[2];
                    this.offsetData[1] = x * preTransform[1] + y * preTransform[3];
                    this.offsetData[2] = this._eachNumWidth;
                    this.offsetData[3] = surfaceTransform;
                  }

                  this.pass._setRootBufferDirty(true);
                }

                if (this._meshRenderer.model) this._pipeline.profiler = this._meshRenderer.model;
                const now = performance.now();

                this._stats.render.counter.start(now);
              }

              afterDraw() {
                if (!this._stats || !this._inited) {
                  return;
                }

                const now = performance.now();

                this._stats.frame.counter.end(now);

                this._stats.fps.counter.frame(now);

                this._stats.render.counter.end(now);

                if (now - this.lastTime < _average) {
                  return;
                }

                this.lastTime = now;
                const device = this._device;
                this._stats.draws.counter.value = device.numDrawCalls;
                this._stats.instances.counter.value = device.numInstances;
                this._stats.bufferMemory.counter.value = device.memoryStatus.bufferSize / (1024 * 1024);
                this._stats.textureMemory.counter.value = device.memoryStatus.textureSize / (1024 * 1024);
                this._stats.tricount.counter.value = device.numTris;
                let i = 0;

                {
                  const view = this.digitsData;

                  for (const id in this._stats) {
                    const stat = this._stats[id];
                    stat.counter.sample(now);
                    const result = stat.counter.human().toString();

                    for (let j = _constants.segmentsPerLine - 1; j >= 0; j--) {
                      const index = i * _constants.segmentsPerLine + j;
                      const character = result[result.length - (_constants.segmentsPerLine - j)];
                      let offset = _string2offset[character];

                      if (offset === undefined) {
                        offset = 11;
                      }

                      view[index] = offset;
                    }

                    i++;
                  }
                }
              }

            } exports('Profiler', Profiler);
            const profiler = exports('profiler', new Profiler());
            legacyCC.profiler = profiler;

            const DURATION_INFINITY = -1;
            const START_SIZE_EQUAL_TO_END_SIZE = -1;
            const START_RADIUS_EQUAL_TO_END_RADIUS = -1;
            const EmitterMode = Enum({
              GRAVITY: 0,
              RADIUS: 1
            });
            const PositionType = Enum({
              FREE: 0,
              RELATIVE: 1,
              GROUPED: 2
            });

            const ZERO_VEC2 = new Vec2(0, 0);

            const _pos = new Vec2();

            const _tpa = new Vec2();

            const _tpb = new Vec2();

            const _tpc = new Vec2();

            const formatBytes = getComponentPerVertex(vfmtPosUvColor);

            function getWorldRotation(node) {
              let rotation = 0;
              let tempNode = node;

              while (tempNode) {
                rotation += tempNode.eulerAngles.z;
                tempNode = tempNode.parent;
              }

              return rotation;
            }

            class Particle$1 {
              constructor() {
                this.pos = new Vec2(0, 0);
                this.startPos = new Vec2(0, 0);
                this.color = new Color$1(0, 0, 0, 255);
                this.deltaColor = {
                  r: 0,
                  g: 0,
                  b: 0,
                  a: 255
                };
                this.size = 0;
                this.deltaSize = 0;
                this.rotation = 0;
                this.deltaRotation = 0;
                this.timeToLive = 0;
                this.drawPos = new Vec2(0, 0);
                this.aspectRatio = 1;
                this.dir = new Vec2(0, 0);
                this.radialAccel = 0;
                this.tangentialAccel = 0;
                this.angle = 0;
                this.degreesPerSecond = 0;
                this.radius = 0;
                this.deltaRadius = 0;
              }

            }

            class ParticlePool extends Pool$1 {
              get() {
                return this._get() || new Particle$1();
              }

            }

            const pool$1 = new ParticlePool(par => {
              par.pos.set(ZERO_VEC2);
              par.startPos.set(ZERO_VEC2);
              par.color._val = 0xFF000000;
              par.deltaColor.r = par.deltaColor.g = par.deltaColor.b = 0;
              par.deltaColor.a = 255;
              par.size = 0;
              par.deltaSize = 0;
              par.rotation = 0;
              par.deltaRotation = 0;
              par.timeToLive = 0;
              par.drawPos.set(ZERO_VEC2);
              par.aspectRatio = 1;
              par.dir.set(ZERO_VEC2);
              par.radialAccel = 0;
              par.tangentialAccel = 0;
              par.angle = 0;
              par.degreesPerSecond = 0;
              par.radius = 0;
              par.deltaRadius = 0;
            }, 1024);
            
            console.log('pptest importing cc 3.3');
            class Simulator {
              constructor(system) {
                this.particles = [];
                this.active = false;
                this.uvFilled = 0;
                this.finished = false;
                this.readyToPlay = true;
                this.elapsed = 0;
                this.emitCounter = 0;
                this._worldRotation = 0;
                this.sys = system;
                this.particles = [];
                this.active = false;
                this.readyToPlay = true;
                this.finished = false;
                this.elapsed = 0;
                this.emitCounter = 0;
                this.uvFilled = 0;
                this._worldRotation = 0;
              }

              stop() {
                this.active = false;
                this.readyToPlay = false;
                this.elapsed = this.sys.duration;
                this.emitCounter = 0;
              }

              reset() {
                this.active = true;
                this.readyToPlay = true;
                this.elapsed = 0;
                this.emitCounter = 0;
                this.finished = false;
                const particles = this.particles;

                for (let id = 0; id < particles.length; ++id) pool$1.put(particles[id]);

                particles.length = 0;
              }

              emitParticle(pos) {
                const psys = this.sys;
                const particle = pool$1.get();
                this.particles.push(particle);
                particle.timeToLive = psys.life + psys.lifeVar * (Math.random() - 0.5) * 2;
                const timeToLive = particle.timeToLive = Math.max(0, particle.timeToLive);
                particle.pos.x = psys.sourcePos.x + psys.posVar.x * (Math.random() - 0.5) * 2;
                particle.pos.y = psys.sourcePos.y + psys.posVar.y * (Math.random() - 0.5) * 2;
                let sr = 0;
                let sg = 0;
                let sb = 0;
                let sa = 0;
                const startColor = psys.startColor;
                const startColorVar = psys.startColorVar;
                const endColor = psys.endColor;
                const endColorVar = psys.endColorVar;
                particle.color.r = sr = clampf(startColor.r + startColorVar.r * (Math.random() - 0.5) * 2, 0, 255);
                particle.color.g = sg = clampf(startColor.g + startColorVar.g * (Math.random() - 0.5) * 2, 0, 255);
                particle.color.b = sb = clampf(startColor.b + startColorVar.b * (Math.random() - 0.5) * 2, 0, 255);
                particle.color.a = sa = clampf(startColor.a + startColorVar.a * (Math.random() - 0.5) * 2, 0, 255);
                particle.deltaColor.r = (clampf(endColor.r + endColorVar.r * (Math.random() - 0.5) * 2, 0, 255) - sr) / timeToLive;
                particle.deltaColor.g = (clampf(endColor.g + endColorVar.g * (Math.random() - 0.5) * 2, 0, 255) - sg) / timeToLive;
                particle.deltaColor.b = (clampf(endColor.b + endColorVar.b * (Math.random() - 0.5) * 2, 0, 255) - sb) / timeToLive;
                particle.deltaColor.a = (clampf(endColor.a + endColorVar.a * (Math.random() - 0.5) * 2, 0, 255) - sa) / timeToLive;
                let startS = psys.startSize + psys.startSizeVar * (Math.random() - 0.5) * 2;
                startS = Math.max(0, startS);
                particle.size = startS;

                if (psys.endSize === START_SIZE_EQUAL_TO_END_SIZE) {
                  particle.deltaSize = 0;
                } else {
                  let endS = psys.endSize + psys.endSizeVar * (Math.random() - 0.5) * 2;
                  endS = Math.max(0, endS);
                  particle.deltaSize = (endS - startS) / timeToLive;
                }

                const startA = psys.startSpin + psys.startSpinVar * (Math.random() - 0.5) * 2;
                const endA = psys.endSpin + psys.endSpinVar * (Math.random() - 0.5) * 2;
                particle.rotation = startA;
                particle.deltaRotation = (endA - startA) / timeToLive;
                particle.startPos.x = pos.x;
                particle.startPos.y = pos.y;
                particle.aspectRatio = psys.aspectRatio || 1;
                const a = degreesToRadians(psys.angle + this._worldRotation + psys.angleVar * (Math.random() - 0.5) * 2);

                if (psys.emitterMode === EmitterMode.GRAVITY) {
                  const s = psys.speed + psys.speedVar * (Math.random() - 0.5) * 2;
                  particle.dir.x = Math.cos(a);
                  particle.dir.y = Math.sin(a);
                  particle.dir.multiplyScalar(s);
                  particle.radialAccel = psys.radialAccel + psys.radialAccelVar * (Math.random() - 0.5) * 2;
                  particle.tangentialAccel = psys.tangentialAccel + psys.tangentialAccelVar * (Math.random() - 0.5) * 2;

                  if (psys.rotationIsDir) {
                    particle.rotation = -radiansToDegrees(Math.atan2(particle.dir.y, particle.dir.x));
                  }
                } else {
                  const startRadius = psys.startRadius + psys.startRadiusVar * (Math.random() - 0.5) * 2;
                  const endRadius = psys.endRadius + psys.endRadiusVar * (Math.random() - 0.5) * 2;
                  particle.radius = startRadius;
                  particle.deltaRadius = psys.endRadius === START_RADIUS_EQUAL_TO_END_RADIUS ? 0 : (endRadius - startRadius) / timeToLive;
                  particle.angle = a;
                  particle.degreesPerSecond = degreesToRadians(psys.rotatePerS + psys.rotatePerSVar * (Math.random() - 0.5) * 2);
                }
              }

              updateUVs(force) {
                const renderData = this.renderData;

                if (renderData && this.sys._renderSpriteFrame) {
                  const vbuf = renderData.vData;
                  const uv = this.sys._renderSpriteFrame.uv;
                  const start = force ? 0 : this.uvFilled;
                  const particleCount = this.particles.length;

                  for (let i = start; i < particleCount; i++) {
                    const offset = i * formatBytes * 4;
                    vbuf[offset + 3] = uv[0];
                    vbuf[offset + 4] = uv[1];
                    vbuf[offset + 12] = uv[2];
                    vbuf[offset + 13] = uv[3];
                    vbuf[offset + 21] = uv[4];
                    vbuf[offset + 22] = uv[5];
                    vbuf[offset + 30] = uv[6];
                    vbuf[offset + 31] = uv[7];
                  }

                  this.uvFilled = particleCount;
                }
              }

              updateParticleBuffer(particle, pos, buffer, offset) {
                const vbuf = buffer.vData;
                const x = pos.x;
                const y = pos.y;
                let width = particle.size;
                let height = width;
                const aspectRatio = particle.aspectRatio;

                if (aspectRatio > 1) {
                  height = width / aspectRatio;
                } else {
                  width = height * aspectRatio;
                }

                const halfWidth = width / 2;
                const halfHeight = height / 2;

                if (particle.rotation) {
                  const x1 = -halfWidth;
                  const y1 = -halfHeight;
                  const x2 = halfWidth;
                  const y2 = halfHeight;
                  const rad = -degreesToRadians(particle.rotation);
                  const cr = Math.cos(rad);
                  const sr = Math.sin(rad);
                  vbuf[offset] = x1 * cr - y1 * sr + x;
                  vbuf[offset + 1] = x1 * sr + y1 * cr + y;
                  vbuf[offset + 2] = 0;
                  vbuf[offset + 9] = x2 * cr - y1 * sr + x;
                  vbuf[offset + 10] = x2 * sr + y1 * cr + y;
                  vbuf[offset + 11] = 0;
                  vbuf[offset + 18] = x1 * cr - y2 * sr + x;
                  vbuf[offset + 19] = x1 * sr + y2 * cr + y;
                  vbuf[offset + 20] = 0;
                  vbuf[offset + 27] = x2 * cr - y2 * sr + x;
                  vbuf[offset + 28] = x2 * sr + y2 * cr + y;
                  vbuf[offset + 29] = 0;
                } else {
                  vbuf[offset] = x - halfWidth;
                  vbuf[offset + 1] = y - halfHeight;
                  vbuf[offset + 2] = 0;
                  vbuf[offset + 9] = x + halfWidth;
                  vbuf[offset + 10] = y - halfHeight;
                  vbuf[offset + 11] = 0;
                  vbuf[offset + 18] = x - halfWidth;
                  vbuf[offset + 19] = y + halfHeight;
                  vbuf[offset + 20] = 0;
                  vbuf[offset + 27] = x + halfWidth;
                  vbuf[offset + 28] = y + halfHeight;
                  vbuf[offset + 29] = 0;
                }

                Color$1.toArray(vbuf, particle.color, offset + 5);
                Color$1.toArray(vbuf, particle.color, offset + 14);
                Color$1.toArray(vbuf, particle.color, offset + 23);
                Color$1.toArray(vbuf, particle.color, offset + 32);
              }

              step(dt) {
                const assembler = this.sys.assembler;
                const psys = this.sys;
                const node = psys.node;
                const particles = this.particles;
                dt = dt > assembler.maxParticleDeltaTime ? assembler.maxParticleDeltaTime : dt;
                node.updateWorldTransform();

                if (psys.positionType === PositionType.FREE) {
                  this._worldRotation = getWorldRotation(node);
                  const m = node.worldMatrix;
                  _pos.x = m.m12;
                  _pos.y = m.m13;
                } else if (psys.positionType === PositionType.RELATIVE) {
                  this._worldRotation = node.eulerAngles.z;
                  _pos.x = node.position.x;
                  _pos.y = node.position.y;
                } else {
                  this._worldRotation = 0;
                }

                if (this.active && psys.emissionRate) {
                  const rate = 1.0 / psys.emissionRate;
                  if (particles.length < psys.totalParticles) this.emitCounter += dt;

                  while (particles.length < psys.totalParticles && this.emitCounter > rate) {
                    this.emitParticle(_pos);
                    this.emitCounter -= rate;
                  }

                  this.elapsed += dt;

                  if (psys.duration !== -1 && psys.duration < this.elapsed) {
                    psys.stopSystem();
                  }
                }

                const renderData = this.renderData;
                const particleCount = particles.length;
                renderData.reset();
                this.requestData(particleCount * 4, particleCount * 6);

                if (particleCount > this.uvFilled) {
                  this.updateUVs();
                }

                let particleIdx = 0;

                while (particleIdx < particles.length) {
                  _tpa.x = _tpa.y = _tpb.x = _tpb.y = _tpc.x = _tpc.y = 0;
                  const particle = particles[particleIdx];
                  particle.timeToLive -= dt;

                  if (particle.timeToLive > 0) {
                    if (psys.emitterMode === EmitterMode.GRAVITY) {
                      const tmp = _tpc;
                      const radial = _tpa;
                      const tangential = _tpb;

                      if (particle.pos.x || particle.pos.y) {
                        radial.set(particle.pos);
                        radial.normalize();
                      }

                      tangential.set(radial);
                      radial.multiplyScalar(particle.radialAccel);
                      const newy = tangential.x;
                      tangential.x = -tangential.y;
                      tangential.y = newy;
                      tangential.multiplyScalar(particle.tangentialAccel);
                      tmp.set(radial);
                      tmp.add(tangential);
                      tmp.add(psys.gravity);
                      tmp.multiplyScalar(dt);
                      particle.dir.add(tmp);
                      tmp.set(particle.dir);
                      tmp.multiplyScalar(dt);
                      particle.pos.add(tmp);
                    } else {
                      particle.angle += particle.degreesPerSecond * dt;
                      particle.radius += particle.deltaRadius * dt;
                      particle.pos.x = -Math.cos(particle.angle) * particle.radius;
                      particle.pos.y = -Math.sin(particle.angle) * particle.radius;
                    }

                    particle.color.r += particle.deltaColor.r * dt;
                    particle.color.g += particle.deltaColor.g * dt;
                    particle.color.b += particle.deltaColor.b * dt;
                    particle.color.a += particle.deltaColor.a * dt;
                    particle.size += particle.deltaSize * dt;

                    if (particle.size < 0) {
                      particle.size = 0;
                    }

                    particle.rotation += particle.deltaRotation * dt;
                    const newPos = _tpa;
                    newPos.set(particle.pos);

                    if (psys.positionType !== PositionType.GROUPED) {
                      newPos.add(particle.startPos);
                    }

                    const offset = formatBytes * particleIdx * 4;
                    this.updateParticleBuffer(particle, newPos, renderData, offset);
                    ++particleIdx;
                  } else {
                    const deadParticle = particles[particleIdx];

                    if (particleIdx !== particles.length - 1) {
                      particles[particleIdx] = particles[particles.length - 1];
                    }

                    pool$1.put(deadParticle);
                    particles.length--;
                    renderData.indicesCount -= 6;
                    renderData.vertexCount -= 4;
                  }
                }

                if (particles.length === 0 && !this.active && !this.readyToPlay) {
                  this.finished = true;

                  psys._finishedSimulation();
                }
              }

              requestData(vertexCount, indicesCount) {
                let offset = this.renderData.indicesCount;
                this.renderData.request(vertexCount, indicesCount);
                const count = this.renderData.indicesCount / 6;
                const buffer = this.renderData.iData;

                for (let i = offset; i < count; i++) {
                  const vId = i * 4;
                  buffer[offset++] = vId;
                  buffer[offset++] = vId + 1;
                  buffer[offset++] = vId + 2;
                  buffer[offset++] = vId + 1;
                  buffer[offset++] = vId + 3;
                  buffer[offset++] = vId + 2;
                }
              }

            }

            var _dec$1g, _class$1g, _class2$15, _descriptor$14, _temp$19;
            let ParticleAsset = exports('ParticleAsset', (_dec$1g = ccclass('cc.ParticleAsset'), _dec$1g(_class$1g = (_class2$15 = (_temp$19 = class ParticleAsset extends Asset {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "spriteFrame", _descriptor$14, this);
              }

            }, _temp$19), (_descriptor$14 = _applyDecoratedDescriptor(_class2$15.prototype, "spriteFrame", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            })), _class2$15)) || _class$1g));
            legacyCC.ParticleAsset = ParticleAsset;

            /** @license zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */
            var window$1 = {};
            (function () {

              function i(a) {
                throw a;
              }

              var r = void 0,
                  v = !0,
                  aa = this;

              function y(a, c) {
                var b = a.split("."),
                    e = aa;
                !(b[0] in e) && e.execScript && e.execScript("var " + b[0]);

                for (var f; b.length && (f = b.shift());) !b.length && c !== r ? e[f] = c : e = e[f] ? e[f] : e[f] = {};
              }
              var H = "undefined" !== typeof Uint8Array && "undefined" !== typeof Uint16Array && "undefined" !== typeof Uint32Array;

              function ba(a) {
                if ("string" === typeof a) {
                  var c = a.split(""),
                      b,
                      e;
                  b = 0;

                  for (e = c.length; b < e; b++) c[b] = (c[b].charCodeAt(0) & 255) >>> 0;

                  a = c;
                }

                for (var f = 1, d = 0, g = a.length, h, m = 0; 0 < g;) {
                  h = 1024 < g ? 1024 : g;
                  g -= h;

                  do f += a[m++], d += f; while (--h);

                  f %= 65521;
                  d %= 65521;
                }

                return (d << 16 | f) >>> 0;
              }

              function J(a, c) {
                this.index = "number" === typeof c ? c : 0;
                this.i = 0;
                this.buffer = a instanceof (H ? Uint8Array : Array) ? a : new (H ? Uint8Array : Array)(32768);
                2 * this.buffer.length <= this.index && i(Error("invalid index"));
                this.buffer.length <= this.index && this.f();
              }

              J.prototype.f = function () {
                var a = this.buffer,
                    c,
                    b = a.length,
                    e = new (H ? Uint8Array : Array)(b << 1);
                if (H) e.set(a);else for (c = 0; c < b; ++c) e[c] = a[c];
                return this.buffer = e;
              };

              J.prototype.d = function (a, c, b) {
                var e = this.buffer,
                    f = this.index,
                    d = this.i,
                    g = e[f],
                    h;
                b && 1 < c && (a = 8 < c ? (N[a & 255] << 24 | N[a >>> 8 & 255] << 16 | N[a >>> 16 & 255] << 8 | N[a >>> 24 & 255]) >> 32 - c : N[a] >> 8 - c);
                if (8 > c + d) g = g << c | a, d += c;else for (h = 0; h < c; ++h) g = g << 1 | a >> c - h - 1 & 1, 8 === ++d && (d = 0, e[f++] = N[g], g = 0, f === e.length && (e = this.f()));
                e[f] = g;
                this.buffer = e;
                this.i = d;
                this.index = f;
              };

              J.prototype.finish = function () {
                var a = this.buffer,
                    c = this.index,
                    b;
                0 < this.i && (a[c] <<= 8 - this.i, a[c] = N[a[c]], c++);
                H ? b = a.subarray(0, c) : (a.length = c, b = a);
                return b;
              };

              var ca = new (H ? Uint8Array : Array)(256),
                  ha;

              for (ha = 0; 256 > ha; ++ha) {
                for (var R = ha, ia = R, ja = 7, R = R >>> 1; R; R >>>= 1) ia <<= 1, ia |= R & 1, --ja;

                ca[ha] = (ia << ja & 255) >>> 0;
              }

              var N = ca;

              function la(a) {
                this.buffer = new (H ? Uint16Array : Array)(2 * a);
                this.length = 0;
              }

              la.prototype.getParent = function (a) {
                return 2 * ((a - 2) / 4 | 0);
              };

              la.prototype.push = function (a, c) {
                var b,
                    e,
                    f = this.buffer,
                    d;
                b = this.length;
                f[this.length++] = c;

                for (f[this.length++] = a; 0 < b;) if (e = this.getParent(b), f[b] > f[e]) d = f[b], f[b] = f[e], f[e] = d, d = f[b + 1], f[b + 1] = f[e + 1], f[e + 1] = d, b = e;else break;

                return this.length;
              };

              la.prototype.pop = function () {
                var a,
                    c,
                    b = this.buffer,
                    e,
                    f,
                    d;
                c = b[0];
                a = b[1];
                this.length -= 2;
                b[0] = b[this.length];
                b[1] = b[this.length + 1];

                for (d = 0;;) {
                  f = 2 * d + 2;
                  if (f >= this.length) break;
                  f + 2 < this.length && b[f + 2] > b[f] && (f += 2);
                  if (b[f] > b[d]) e = b[d], b[d] = b[f], b[f] = e, e = b[d + 1], b[d + 1] = b[f + 1], b[f + 1] = e;else break;
                  d = f;
                }

                return {
                  index: a,
                  value: c,
                  length: this.length
                };
              };

              function S(a) {
                var c = a.length,
                    b = 0,
                    e = Number.POSITIVE_INFINITY,
                    f,
                    d,
                    g,
                    h,
                    m,
                    j,
                    s,
                    n,
                    l;

                for (n = 0; n < c; ++n) a[n] > b && (b = a[n]), a[n] < e && (e = a[n]);

                f = 1 << b;
                d = new (H ? Uint32Array : Array)(f);
                g = 1;
                h = 0;

                for (m = 2; g <= b;) {
                  for (n = 0; n < c; ++n) if (a[n] === g) {
                    j = 0;
                    s = h;

                    for (l = 0; l < g; ++l) j = j << 1 | s & 1, s >>= 1;

                    for (l = j; l < f; l += m) d[l] = g << 16 | n;

                    ++h;
                  }

                  ++g;
                  h <<= 1;
                  m <<= 1;
                }

                return [d, b, e];
              }

              function ma(a, c) {
                this.h = pa;
                this.w = 0;
                this.input = a;
                this.b = 0;
                c && (c.lazy && (this.w = c.lazy), "number" === typeof c.compressionType && (this.h = c.compressionType), c.outputBuffer && (this.a = H && c.outputBuffer instanceof Array ? new Uint8Array(c.outputBuffer) : c.outputBuffer), "number" === typeof c.outputIndex && (this.b = c.outputIndex));
                this.a || (this.a = new (H ? Uint8Array : Array)(32768));
              }

              var pa = 2,
                  qa = {
                NONE: 0,
                r: 1,
                j: pa,
                N: 3
              },
                  ra = [],
                  T;

              for (T = 0; 288 > T; T++) switch (v) {
                case 143 >= T:
                  ra.push([T + 48, 8]);
                  break;

                case 255 >= T:
                  ra.push([T - 144 + 400, 9]);
                  break;

                case 279 >= T:
                  ra.push([T - 256 + 0, 7]);
                  break;

                case 287 >= T:
                  ra.push([T - 280 + 192, 8]);
                  break;

                default:
                  i("invalid literal: " + T);
              }

              ma.prototype.n = function () {
                var a,
                    c,
                    b,
                    e,
                    f = this.input;

                switch (this.h) {
                  case 0:
                    b = 0;

                    for (e = f.length; b < e;) {
                      c = H ? f.subarray(b, b + 65535) : f.slice(b, b + 65535);
                      b += c.length;
                      var d = c,
                          g = b === e,
                          h = r,
                          m = r,
                          j = r,
                          s = r,
                          n = r,
                          l = this.a,
                          q = this.b;

                      if (H) {
                        for (l = new Uint8Array(this.a.buffer); l.length <= q + d.length + 5;) l = new Uint8Array(l.length << 1);

                        l.set(this.a);
                      }

                      h = g ? 1 : 0;
                      l[q++] = h | 0;
                      m = d.length;
                      j = ~m + 65536 & 65535;
                      l[q++] = m & 255;
                      l[q++] = m >>> 8 & 255;
                      l[q++] = j & 255;
                      l[q++] = j >>> 8 & 255;
                      if (H) l.set(d, q), q += d.length, l = l.subarray(0, q);else {
                        s = 0;

                        for (n = d.length; s < n; ++s) l[q++] = d[s];

                        l.length = q;
                      }
                      this.b = q;
                      this.a = l;
                    }

                    break;

                  case 1:
                    var E = new J(new Uint8Array(this.a.buffer), this.b);
                    E.d(1, 1, v);
                    E.d(1, 2, v);
                    var t = sa(this, f),
                        z,
                        K,
                        A;
                    z = 0;

                    for (K = t.length; z < K; z++) if (A = t[z], J.prototype.d.apply(E, ra[A]), 256 < A) E.d(t[++z], t[++z], v), E.d(t[++z], 5), E.d(t[++z], t[++z], v);else if (256 === A) break;

                    this.a = E.finish();
                    this.b = this.a.length;
                    break;

                  case pa:
                    var x = new J(new Uint8Array(this.a), this.b),
                        B,
                        k,
                        p,
                        D,
                        C,
                        da = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
                        W,
                        Ma,
                        ea,
                        Na,
                        na,
                        va = Array(19),
                        Oa,
                        $,
                        oa,
                        F,
                        Pa;
                    B = pa;
                    x.d(1, 1, v);
                    x.d(B, 2, v);
                    k = sa(this, f);
                    W = ta(this.L, 15);
                    Ma = ua(W);
                    ea = ta(this.K, 7);
                    Na = ua(ea);

                    for (p = 286; 257 < p && 0 === W[p - 1]; p--);

                    for (D = 30; 1 < D && 0 === ea[D - 1]; D--);

                    var Qa = p,
                        Ra = D,
                        M = new (H ? Uint32Array : Array)(Qa + Ra),
                        u,
                        O,
                        w,
                        fa,
                        L = new (H ? Uint32Array : Array)(316),
                        I,
                        G,
                        P = new (H ? Uint8Array : Array)(19);

                    for (u = O = 0; u < Qa; u++) M[O++] = W[u];

                    for (u = 0; u < Ra; u++) M[O++] = ea[u];

                    if (!H) {
                      u = 0;

                      for (fa = P.length; u < fa; ++u) P[u] = 0;
                    }

                    u = I = 0;

                    for (fa = M.length; u < fa; u += O) {
                      for (O = 1; u + O < fa && M[u + O] === M[u]; ++O);

                      w = O;
                      if (0 === M[u]) {
                        if (3 > w) for (; 0 < w--;) L[I++] = 0, P[0]++;else for (; 0 < w;) G = 138 > w ? w : 138, G > w - 3 && G < w && (G = w - 3), 10 >= G ? (L[I++] = 17, L[I++] = G - 3, P[17]++) : (L[I++] = 18, L[I++] = G - 11, P[18]++), w -= G;
                      } else if (L[I++] = M[u], P[M[u]]++, w--, 3 > w) for (; 0 < w--;) L[I++] = M[u], P[M[u]]++;else for (; 0 < w;) G = 6 > w ? w : 6, G > w - 3 && G < w && (G = w - 3), L[I++] = 16, L[I++] = G - 3, P[16]++, w -= G;
                    }

                    a = H ? L.subarray(0, I) : L.slice(0, I);
                    na = ta(P, 7);

                    for (F = 0; 19 > F; F++) va[F] = na[da[F]];

                    for (C = 19; 4 < C && 0 === va[C - 1]; C--);

                    Oa = ua(na);
                    x.d(p - 257, 5, v);
                    x.d(D - 1, 5, v);
                    x.d(C - 4, 4, v);

                    for (F = 0; F < C; F++) x.d(va[F], 3, v);

                    F = 0;

                    for (Pa = a.length; F < Pa; F++) if ($ = a[F], x.d(Oa[$], na[$], v), 16 <= $) {
                      F++;

                      switch ($) {
                        case 16:
                          oa = 2;
                          break;

                        case 17:
                          oa = 3;
                          break;

                        case 18:
                          oa = 7;
                          break;

                        default:
                          i("invalid code: " + $);
                      }

                      x.d(a[F], oa, v);
                    }

                    var Sa = [Ma, W],
                        Ta = [Na, ea],
                        Q,
                        Ua,
                        ga,
                        ya,
                        Va,
                        Wa,
                        Xa,
                        Ya;
                    Va = Sa[0];
                    Wa = Sa[1];
                    Xa = Ta[0];
                    Ya = Ta[1];
                    Q = 0;

                    for (Ua = k.length; Q < Ua; ++Q) if (ga = k[Q], x.d(Va[ga], Wa[ga], v), 256 < ga) x.d(k[++Q], k[++Q], v), ya = k[++Q], x.d(Xa[ya], Ya[ya], v), x.d(k[++Q], k[++Q], v);else if (256 === ga) break;

                    this.a = x.finish();
                    this.b = this.a.length;
                    break;

                  default:
                    i("invalid compression type");
                }

                return this.a;
              };

              function wa(a, c) {
                this.length = a;
                this.G = c;
              }

              function xa() {
                var a = za;

                switch (v) {
                  case 3 === a:
                    return [257, a - 3, 0];

                  case 4 === a:
                    return [258, a - 4, 0];

                  case 5 === a:
                    return [259, a - 5, 0];

                  case 6 === a:
                    return [260, a - 6, 0];

                  case 7 === a:
                    return [261, a - 7, 0];

                  case 8 === a:
                    return [262, a - 8, 0];

                  case 9 === a:
                    return [263, a - 9, 0];

                  case 10 === a:
                    return [264, a - 10, 0];

                  case 12 >= a:
                    return [265, a - 11, 1];

                  case 14 >= a:
                    return [266, a - 13, 1];

                  case 16 >= a:
                    return [267, a - 15, 1];

                  case 18 >= a:
                    return [268, a - 17, 1];

                  case 22 >= a:
                    return [269, a - 19, 2];

                  case 26 >= a:
                    return [270, a - 23, 2];

                  case 30 >= a:
                    return [271, a - 27, 2];

                  case 34 >= a:
                    return [272, a - 31, 2];

                  case 42 >= a:
                    return [273, a - 35, 3];

                  case 50 >= a:
                    return [274, a - 43, 3];

                  case 58 >= a:
                    return [275, a - 51, 3];

                  case 66 >= a:
                    return [276, a - 59, 3];

                  case 82 >= a:
                    return [277, a - 67, 4];

                  case 98 >= a:
                    return [278, a - 83, 4];

                  case 114 >= a:
                    return [279, a - 99, 4];

                  case 130 >= a:
                    return [280, a - 115, 4];

                  case 162 >= a:
                    return [281, a - 131, 5];

                  case 194 >= a:
                    return [282, a - 163, 5];

                  case 226 >= a:
                    return [283, a - 195, 5];

                  case 257 >= a:
                    return [284, a - 227, 5];

                  case 258 === a:
                    return [285, a - 258, 0];

                  default:
                    i("invalid length: " + a);
                }
              }

              var Aa = [],
                  za,
                  Ba;

              for (za = 3; 258 >= za; za++) Ba = xa(), Aa[za] = Ba[2] << 24 | Ba[1] << 16 | Ba[0];

              var Ca = H ? new Uint32Array(Aa) : Aa;

              function sa(a, c) {
                function b(a, c) {
                  var b = a.G,
                      d = [],
                      e = 0,
                      f;
                  f = Ca[a.length];
                  d[e++] = f & 65535;
                  d[e++] = f >> 16 & 255;
                  d[e++] = f >> 24;
                  var g;

                  switch (v) {
                    case 1 === b:
                      g = [0, b - 1, 0];
                      break;

                    case 2 === b:
                      g = [1, b - 2, 0];
                      break;

                    case 3 === b:
                      g = [2, b - 3, 0];
                      break;

                    case 4 === b:
                      g = [3, b - 4, 0];
                      break;

                    case 6 >= b:
                      g = [4, b - 5, 1];
                      break;

                    case 8 >= b:
                      g = [5, b - 7, 1];
                      break;

                    case 12 >= b:
                      g = [6, b - 9, 2];
                      break;

                    case 16 >= b:
                      g = [7, b - 13, 2];
                      break;

                    case 24 >= b:
                      g = [8, b - 17, 3];
                      break;

                    case 32 >= b:
                      g = [9, b - 25, 3];
                      break;

                    case 48 >= b:
                      g = [10, b - 33, 4];
                      break;

                    case 64 >= b:
                      g = [11, b - 49, 4];
                      break;

                    case 96 >= b:
                      g = [12, b - 65, 5];
                      break;

                    case 128 >= b:
                      g = [13, b - 97, 5];
                      break;

                    case 192 >= b:
                      g = [14, b - 129, 6];
                      break;

                    case 256 >= b:
                      g = [15, b - 193, 6];
                      break;

                    case 384 >= b:
                      g = [16, b - 257, 7];
                      break;

                    case 512 >= b:
                      g = [17, b - 385, 7];
                      break;

                    case 768 >= b:
                      g = [18, b - 513, 8];
                      break;

                    case 1024 >= b:
                      g = [19, b - 769, 8];
                      break;

                    case 1536 >= b:
                      g = [20, b - 1025, 9];
                      break;

                    case 2048 >= b:
                      g = [21, b - 1537, 9];
                      break;

                    case 3072 >= b:
                      g = [22, b - 2049, 10];
                      break;

                    case 4096 >= b:
                      g = [23, b - 3073, 10];
                      break;

                    case 6144 >= b:
                      g = [24, b - 4097, 11];
                      break;

                    case 8192 >= b:
                      g = [25, b - 6145, 11];
                      break;

                    case 12288 >= b:
                      g = [26, b - 8193, 12];
                      break;

                    case 16384 >= b:
                      g = [27, b - 12289, 12];
                      break;

                    case 24576 >= b:
                      g = [28, b - 16385, 13];
                      break;

                    case 32768 >= b:
                      g = [29, b - 24577, 13];
                      break;

                    default:
                      i("invalid distance");
                  }

                  f = g;
                  d[e++] = f[0];
                  d[e++] = f[1];
                  d[e++] = f[2];
                  var h, j;
                  h = 0;

                  for (j = d.length; h < j; ++h) l[q++] = d[h];

                  t[d[0]]++;
                  z[d[3]]++;
                  E = a.length + c - 1;
                  n = null;
                }

                var e,
                    f,
                    d,
                    g,
                    h,
                    m = {},
                    j,
                    s,
                    n,
                    l = H ? new Uint16Array(2 * c.length) : [],
                    q = 0,
                    E = 0,
                    t = new (H ? Uint32Array : Array)(286),
                    z = new (H ? Uint32Array : Array)(30),
                    K = a.w,
                    A;

                if (!H) {
                  for (d = 0; 285 >= d;) t[d++] = 0;

                  for (d = 0; 29 >= d;) z[d++] = 0;
                }

                t[256] = 1;
                e = 0;

                for (f = c.length; e < f; ++e) {
                  d = h = 0;

                  for (g = 3; d < g && e + d !== f; ++d) h = h << 8 | c[e + d];

                  m[h] === r && (m[h] = []);
                  j = m[h];

                  if (!(0 < E--)) {
                    for (; 0 < j.length && 32768 < e - j[0];) j.shift();

                    if (e + 3 >= f) {
                      n && b(n, -1);
                      d = 0;

                      for (g = f - e; d < g; ++d) A = c[e + d], l[q++] = A, ++t[A];

                      break;
                    }

                    if (0 < j.length) {
                      var x = r,
                          B = r,
                          k = 0,
                          p = r,
                          D = r,
                          C = r,
                          da = r,
                          W = c.length,
                          D = 0,
                          da = j.length;

                      a: for (; D < da; D++) {
                        x = j[da - D - 1];
                        p = 3;

                        if (3 < k) {
                          for (C = k; 3 < C; C--) if (c[x + C - 1] !== c[e + C - 1]) continue a;

                          p = k;
                        }

                        for (; 258 > p && e + p < W && c[x + p] === c[e + p];) ++p;

                        p > k && (B = x, k = p);
                        if (258 === p) break;
                      }

                      s = new wa(k, e - B);
                      n ? n.length < s.length ? (A = c[e - 1], l[q++] = A, ++t[A], b(s, 0)) : b(n, -1) : s.length < K ? n = s : b(s, 0);
                    } else n ? b(n, -1) : (A = c[e], l[q++] = A, ++t[A]);
                  }

                  j.push(e);
                }

                l[q++] = 256;
                t[256]++;
                a.L = t;
                a.K = z;
                return H ? l.subarray(0, q) : l;
              }

              function ta(a, c) {
                function b(a) {
                  var c = z[a][K[a]];
                  c === n ? (b(a + 1), b(a + 1)) : --E[c];
                  ++K[a];
                }

                var e = a.length,
                    f = new la(572),
                    d = new (H ? Uint8Array : Array)(e),
                    g,
                    h,
                    m,
                    j,
                    s;
                if (!H) for (j = 0; j < e; j++) d[j] = 0;

                for (j = 0; j < e; ++j) 0 < a[j] && f.push(j, a[j]);

                g = Array(f.length / 2);
                h = new (H ? Uint32Array : Array)(f.length / 2);
                if (1 === g.length) return d[f.pop().index] = 1, d;
                j = 0;

                for (s = f.length / 2; j < s; ++j) g[j] = f.pop(), h[j] = g[j].value;

                var n = h.length,
                    l = new (H ? Uint16Array : Array)(c),
                    q = new (H ? Uint8Array : Array)(c),
                    E = new (H ? Uint8Array : Array)(n),
                    t = Array(c),
                    z = Array(c),
                    K = Array(c),
                    A = (1 << c) - n,
                    x = 1 << c - 1,
                    B,
                    k,
                    p,
                    D,
                    C;
                l[c - 1] = n;

                for (k = 0; k < c; ++k) A < x ? q[k] = 0 : (q[k] = 1, A -= x), A <<= 1, l[c - 2 - k] = (l[c - 1 - k] / 2 | 0) + n;

                l[0] = q[0];
                t[0] = Array(l[0]);
                z[0] = Array(l[0]);

                for (k = 1; k < c; ++k) l[k] > 2 * l[k - 1] + q[k] && (l[k] = 2 * l[k - 1] + q[k]), t[k] = Array(l[k]), z[k] = Array(l[k]);

                for (B = 0; B < n; ++B) E[B] = c;

                for (p = 0; p < l[c - 1]; ++p) t[c - 1][p] = h[p], z[c - 1][p] = p;

                for (B = 0; B < c; ++B) K[B] = 0;

                1 === q[c - 1] && (--E[0], ++K[c - 1]);

                for (k = c - 2; 0 <= k; --k) {
                  D = B = 0;
                  C = K[k + 1];

                  for (p = 0; p < l[k]; p++) D = t[k + 1][C] + t[k + 1][C + 1], D > h[B] ? (t[k][p] = D, z[k][p] = n, C += 2) : (t[k][p] = h[B], z[k][p] = B, ++B);

                  K[k] = 0;
                  1 === q[k] && b(k);
                }

                m = E;
                j = 0;

                for (s = g.length; j < s; ++j) d[g[j].index] = m[j];

                return d;
              }

              function ua(a) {
                var c = new (H ? Uint16Array : Array)(a.length),
                    b = [],
                    e = [],
                    f = 0,
                    d,
                    g,
                    h,
                    m;
                d = 0;

                for (g = a.length; d < g; d++) b[a[d]] = (b[a[d]] | 0) + 1;

                d = 1;

                for (g = 16; d <= g; d++) e[d] = f, f += b[d] | 0, f > 1 << d && i("overcommitted"), f <<= 1;

                65536 > f && i("undercommitted");
                d = 0;

                for (g = a.length; d < g; d++) {
                  f = e[a[d]];
                  e[a[d]] += 1;
                  h = c[d] = 0;

                  for (m = a[d]; h < m; h++) c[d] = c[d] << 1 | f & 1, f >>>= 1;
                }

                return c;
              }

              console.log('pptest importing cc 3.33');
              function Da(a, c) {
                this.input = a;
                this.a = new (H ? Uint8Array : Array)(32768);
                this.h = U.j;
                var b = {},
                    e;
                if ((c || !(c = {})) && "number" === typeof c.compressionType) this.h = c.compressionType;

                for (e in c) b[e] = c[e];

                b.outputBuffer = this.a;
                this.z = new ma(this.input, b);
              }

              var U = qa;

              Da.prototype.n = function () {
                var a,
                    c,
                    b,
                    e,
                    f,
                    d,
                    g,
                    h = 0;
                g = this.a;
                a = Ea;

                switch (a) {
                  case Ea:
                    c = Math.LOG2E * Math.log(32768) - 8;
                    break;

                  default:
                    i(Error("invalid compression method"));
                }

                b = c << 4 | a;
                g[h++] = b;

                switch (a) {
                  case Ea:
                    switch (this.h) {
                      case U.NONE:
                        f = 0;
                        break;

                      case U.r:
                        f = 1;
                        break;

                      case U.j:
                        f = 2;
                        break;

                      default:
                        i(Error("unsupported compression type"));
                    }

                    break;

                  default:
                    i(Error("invalid compression method"));
                }

                e = f << 6 | 0;
                g[h++] = e | 31 - (256 * b + e) % 31;
                d = ba(this.input);
                this.z.b = h;
                g = this.z.n();
                h = g.length;
                H && (g = new Uint8Array(g.buffer), g.length <= h + 4 && (this.a = new Uint8Array(g.length + 4), this.a.set(g), g = this.a), g = g.subarray(0, h + 4));
                g[h++] = d >> 24 & 255;
                g[h++] = d >> 16 & 255;
                g[h++] = d >> 8 & 255;
                g[h++] = d & 255;
                return g;
              };

              y("Zlib.Deflate", Da);
              y("Zlib.Deflate.compress", function (a, c) {
                return new Da(a, c).n();
              });
              y("Zlib.Deflate.CompressionType", U);
              y("Zlib.Deflate.CompressionType.NONE", U.NONE);
              y("Zlib.Deflate.CompressionType.FIXED", U.r);
              y("Zlib.Deflate.CompressionType.DYNAMIC", U.j);

              function V(a, c) {
                this.k = [];
                this.l = 32768;
                this.e = this.g = this.c = this.q = 0;
                this.input = H ? new Uint8Array(a) : a;
                this.s = !1;
                this.m = Fa;
                this.B = !1;
                if (c || !(c = {})) c.index && (this.c = c.index), c.bufferSize && (this.l = c.bufferSize), c.bufferType && (this.m = c.bufferType), c.resize && (this.B = c.resize);

                switch (this.m) {
                  case Ga:
                    this.b = 32768;
                    this.a = new (H ? Uint8Array : Array)(32768 + this.l + 258);
                    break;

                  case Fa:
                    this.b = 0;
                    this.a = new (H ? Uint8Array : Array)(this.l);
                    this.f = this.J;
                    this.t = this.H;
                    this.o = this.I;
                    break;

                  default:
                    i(Error("invalid inflate mode"));
                }
              }

              var Ga = 0,
                  Fa = 1,
                  Ha = {
                D: Ga,
                C: Fa
              };

              V.prototype.p = function () {
                for (; !this.s;) {
                  var a = X(this, 3);
                  a & 1 && (this.s = v);
                  a >>>= 1;

                  switch (a) {
                    case 0:
                      var c = this.input,
                          b = this.c,
                          e = this.a,
                          f = this.b,
                          d = r,
                          g = r,
                          h = r,
                          m = e.length,
                          j = r;
                      this.e = this.g = 0;
                      d = c[b++];
                      d === r && i(Error("invalid uncompressed block header: LEN (first byte)"));
                      g = d;
                      d = c[b++];
                      d === r && i(Error("invalid uncompressed block header: LEN (second byte)"));
                      g |= d << 8;
                      d = c[b++];
                      d === r && i(Error("invalid uncompressed block header: NLEN (first byte)"));
                      h = d;
                      d = c[b++];
                      d === r && i(Error("invalid uncompressed block header: NLEN (second byte)"));
                      h |= d << 8;
                      g === ~h && i(Error("invalid uncompressed block header: length verify"));
                      b + g > c.length && i(Error("input buffer is broken"));

                      switch (this.m) {
                        case Ga:
                          for (; f + g > e.length;) {
                            j = m - f;
                            g -= j;
                            if (H) e.set(c.subarray(b, b + j), f), f += j, b += j;else for (; j--;) e[f++] = c[b++];
                            this.b = f;
                            e = this.f();
                            f = this.b;
                          }

                          break;

                        case Fa:
                          for (; f + g > e.length;) e = this.f({
                            v: 2
                          });

                          break;

                        default:
                          i(Error("invalid inflate mode"));
                      }

                      if (H) e.set(c.subarray(b, b + g), f), f += g, b += g;else for (; g--;) e[f++] = c[b++];
                      this.c = b;
                      this.b = f;
                      this.a = e;
                      break;

                    case 1:
                      this.o(Ia, Ja);
                      break;

                    case 2:
                      Ka(this);
                      break;

                    default:
                      i(Error("unknown BTYPE: " + a));
                  }
                }

                return this.t();
              };

              var La = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
                  Za = H ? new Uint16Array(La) : La,
                  $a = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258],
                  ab = H ? new Uint16Array($a) : $a,
                  bb = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0],
                  cb = H ? new Uint8Array(bb) : bb,
                  db = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577],
                  eb = H ? new Uint16Array(db) : db,
                  fb = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13],
                  gb = H ? new Uint8Array(fb) : fb,
                  hb = new (H ? Uint8Array : Array)(288),
                  Y,
                  ib;
              Y = 0;

              for (ib = hb.length; Y < ib; ++Y) hb[Y] = 143 >= Y ? 8 : 255 >= Y ? 9 : 279 >= Y ? 7 : 8;

              var Ia = S(hb),
                  jb = new (H ? Uint8Array : Array)(30),
                  kb,
                  lb;
              kb = 0;

              for (lb = jb.length; kb < lb; ++kb) jb[kb] = 5;

              var Ja = S(jb);

              function X(a, c) {
                for (var b = a.g, e = a.e, f = a.input, d = a.c, g; e < c;) g = f[d++], g === r && i(Error("input buffer is broken")), b |= g << e, e += 8;

                g = b & (1 << c) - 1;
                a.g = b >>> c;
                a.e = e - c;
                a.c = d;
                return g;
              }

              function mb(a, c) {
                for (var b = a.g, e = a.e, f = a.input, d = a.c, g = c[0], h = c[1], m, j, s; e < h;) m = f[d++], m === r && i(Error("input buffer is broken")), b |= m << e, e += 8;

                j = g[b & (1 << h) - 1];
                s = j >>> 16;
                a.g = b >> s;
                a.e = e - s;
                a.c = d;
                return j & 65535;
              }

              function Ka(a) {
                function c(a, b, c) {
                  var d, e, f, g;

                  for (g = 0; g < a;) switch (d = mb(this, b), d) {
                    case 16:
                      for (f = 3 + X(this, 2); f--;) c[g++] = e;

                      break;

                    case 17:
                      for (f = 3 + X(this, 3); f--;) c[g++] = 0;

                      e = 0;
                      break;

                    case 18:
                      for (f = 11 + X(this, 7); f--;) c[g++] = 0;

                      e = 0;
                      break;

                    default:
                      e = c[g++] = d;
                  }

                  return c;
                }

                var b = X(a, 5) + 257,
                    e = X(a, 5) + 1,
                    f = X(a, 4) + 4,
                    d = new (H ? Uint8Array : Array)(Za.length),
                    g,
                    h,
                    m,
                    j;

                for (j = 0; j < f; ++j) d[Za[j]] = X(a, 3);

                g = S(d);
                h = new (H ? Uint8Array : Array)(b);
                m = new (H ? Uint8Array : Array)(e);
                a.o(S(c.call(a, b, g, h)), S(c.call(a, e, g, m)));
              }

              V.prototype.o = function (a, c) {
                var b = this.a,
                    e = this.b;
                this.u = a;

                for (var f = b.length - 258, d, g, h, m; 256 !== (d = mb(this, a));) if (256 > d) e >= f && (this.b = e, b = this.f(), e = this.b), b[e++] = d;else {
                  g = d - 257;
                  m = ab[g];
                  0 < cb[g] && (m += X(this, cb[g]));
                  d = mb(this, c);
                  h = eb[d];
                  0 < gb[d] && (h += X(this, gb[d]));
                  e >= f && (this.b = e, b = this.f(), e = this.b);

                  for (; m--;) b[e] = b[e++ - h];
                }

                for (; 8 <= this.e;) this.e -= 8, this.c--;

                this.b = e;
              };

              V.prototype.I = function (a, c) {
                var b = this.a,
                    e = this.b;
                this.u = a;

                for (var f = b.length, d, g, h, m; 256 !== (d = mb(this, a));) if (256 > d) e >= f && (b = this.f(), f = b.length), b[e++] = d;else {
                  g = d - 257;
                  m = ab[g];
                  0 < cb[g] && (m += X(this, cb[g]));
                  d = mb(this, c);
                  h = eb[d];
                  0 < gb[d] && (h += X(this, gb[d]));
                  e + m > f && (b = this.f(), f = b.length);

                  for (; m--;) b[e] = b[e++ - h];
                }

                for (; 8 <= this.e;) this.e -= 8, this.c--;

                this.b = e;
              };

              V.prototype.f = function () {
                var a = new (H ? Uint8Array : Array)(this.b - 32768),
                    c = this.b - 32768,
                    b,
                    e,
                    f = this.a;
                if (H) a.set(f.subarray(32768, a.length));else {
                  b = 0;

                  for (e = a.length; b < e; ++b) a[b] = f[b + 32768];
                }
                this.k.push(a);
                this.q += a.length;
                if (H) f.set(f.subarray(c, c + 32768));else for (b = 0; 32768 > b; ++b) f[b] = f[c + b];
                this.b = 32768;
                return f;
              };

              V.prototype.J = function (a) {
                var c,
                    b = this.input.length / this.c + 1 | 0,
                    e,
                    f,
                    d,
                    g = this.input,
                    h = this.a;
                a && ("number" === typeof a.v && (b = a.v), "number" === typeof a.F && (b += a.F));
                2 > b ? (e = (g.length - this.c) / this.u[2], d = 258 * (e / 2) | 0, f = d < h.length ? h.length + d : h.length << 1) : f = h.length * b;
                H ? (c = new Uint8Array(f), c.set(h)) : c = h;
                return this.a = c;
              };

              V.prototype.t = function () {
                var a = 0,
                    c = this.a,
                    b = this.k,
                    e,
                    f = new (H ? Uint8Array : Array)(this.q + (this.b - 32768)),
                    d,
                    g,
                    h,
                    m;
                if (0 === b.length) return H ? this.a.subarray(32768, this.b) : this.a.slice(32768, this.b);
                d = 0;

                for (g = b.length; d < g; ++d) {
                  e = b[d];
                  h = 0;

                  for (m = e.length; h < m; ++h) f[a++] = e[h];
                }

                d = 32768;

                for (g = this.b; d < g; ++d) f[a++] = c[d];

                this.k = [];
                return this.buffer = f;
              };

              V.prototype.H = function () {
                var a,
                    c = this.b;
                H ? this.B ? (a = new Uint8Array(c), a.set(this.a.subarray(0, c))) : a = this.a.subarray(0, c) : (this.a.length > c && (this.a.length = c), a = this.a);
                return this.buffer = a;
              };

              function nb(a, c) {
                var b, e;
                this.input = a;
                this.c = 0;
                if (c || !(c = {})) c.index && (this.c = c.index), c.verify && (this.M = c.verify);
                b = a[this.c++];
                e = a[this.c++];

                switch (b & 15) {
                  case Ea:
                    this.method = Ea;
                    break;

                  default:
                    i(Error("unsupported compression method"));
                }

                0 !== ((b << 8) + e) % 31 && i(Error("invalid fcheck flag:" + ((b << 8) + e) % 31));
                e & 32 && i(Error("fdict flag is not supported"));
                this.A = new V(a, {
                  index: this.c,
                  bufferSize: c.bufferSize,
                  bufferType: c.bufferType,
                  resize: c.resize
                });
              }

              nb.prototype.p = function () {
                var a = this.input,
                    c,
                    b;
                c = this.A.p();
                this.c = this.A.c;
                this.M && (b = (a[this.c++] << 24 | a[this.c++] << 16 | a[this.c++] << 8 | a[this.c++]) >>> 0, b !== ba(c) && i(Error("invalid adler-32 checksum")));
                return c;
              };

              y("Zlib.Inflate", nb);
              y("Zlib.Inflate.BufferType", Ha);
              Ha.ADAPTIVE = Ha.C;
              Ha.BLOCK = Ha.D;
              y("Zlib.Inflate.prototype.decompress", nb.prototype.p);
              var tb = new (H ? Uint8Array : Array)(288),
                  Z,
                  ub;
              Z = 0;

              for (ub = tb.length; Z < ub; ++Z) tb[Z] = 143 >= Z ? 8 : 255 >= Z ? 9 : 279 >= Z ? 7 : 8;

              S(tb);
              var vb = new (H ? Uint8Array : Array)(30),
                  wb,
                  xb;
              wb = 0;

              for (xb = vb.length; wb < xb; ++wb) vb[wb] = 5;

              S(vb);
              var Ea = 8;
            }).call(window$1);
            var _p = window$1.Zlib;
            _p.Deflate = _p["Deflate"];
            _p.Deflate.compress = _p.Deflate["compress"];
            _p.Inflate = _p["Inflate"];
            _p.Inflate.BufferType = _p.Inflate["BufferType"];
            _p.Inflate.prototype.decompress = _p.Inflate.prototype["decompress"];

            class PNGReader {
              constructor(data) {
                this.pos = 8;
                this.palette = [];
                this.imgData = [];
                this.text = {};
                this.width = 0;
                this.height = 0;
                this.bits = 0;
                this.colorType = 0;
                this.compressionMethod = 0;
                this.filterMethod = 0;
                this.interlaceMethod = 0;
                this.colors = 0;
                this.hasAlphaChannel = false;
                this.pixelBitlength = 0;
                this.data = data;
                this.transparency = {
                  indexed: [],
                  rgb: 0,
                  grayscale: 0
                };
                let frame;
                let i = 0;
                let _i = 0;
                let _j = 0;
                let chunkSize = 0;

                while (true) {
                  chunkSize = this.readUInt32();

                  const section = (() => {
                    const _results = [];

                    for (i = _i = 0; _i < 4; i = ++_i) {
                      _results.push(String.fromCharCode(this.data[this.pos++]));
                    }

                    return _results;
                  }).call(this).join('');

                  switch (section) {
                    case 'IHDR':
                      this.width = this.readUInt32();
                      this.height = this.readUInt32();
                      this.bits = this.data[this.pos++];
                      this.colorType = this.data[this.pos++];
                      this.compressionMethod = this.data[this.pos++];
                      this.filterMethod = this.data[this.pos++];
                      this.interlaceMethod = this.data[this.pos++];
                      break;

                    case 'acTL':
                      this.animation = {
                        numFrames: this.readUInt32(),
                        numPlays: this.readUInt32() || Infinity,
                        frames: []
                      };
                      break;

                    case 'PLTE':
                      this.palette = this.read(chunkSize);
                      break;

                    case 'fcTL':
                      if (frame) {
                        this.animation.frames.push(frame);
                      }

                      this.pos += 4;
                      frame = {
                        width: this.readUInt32(),
                        height: this.readUInt32(),
                        xOffset: this.readUInt32(),
                        yOffset: this.readUInt32()
                      };
                      const delayNum = this.readUInt16();
                      const delayDen = this.readUInt16() || 100;
                      frame.delay = 1000 * delayNum / delayDen;
                      frame.disposeOp = this.data[this.pos++];
                      frame.blendOp = this.data[this.pos++];
                      frame.data = [];
                      break;

                    case 'IDAT':
                    case 'fdAT':
                      if (section === 'fdAT') {
                        this.pos += 4;
                        chunkSize -= 4;
                      }

                      data = (frame != null ? frame.data : void 0) || this.imgData;

                      for (i = _i = 0; chunkSize >= 0 ? _i < chunkSize : _i > chunkSize; i = chunkSize >= 0 ? ++_i : --_i) {
                        data.push(this.data[this.pos++]);
                      }

                      break;

                    case 'tRNS':
                      this.transparency = {};

                      switch (this.colorType) {
                        case 3:
                          this.transparency.indexed = this.read(chunkSize);
                          const ccshort = 255 - this.transparency.indexed.length;

                          if (ccshort > 0) {
                            for (i = _j = 0; ccshort >= 0 ? _j < ccshort : _j > ccshort; i = ccshort >= 0 ? ++_j : --_j) {
                              this.transparency.indexed.push(255);
                            }
                          }

                          break;

                        case 0:
                          this.transparency.grayscale = this.read(chunkSize)[0];
                          break;

                        case 2:
                          this.transparency.rgb = this.read(chunkSize);
                      }

                      break;

                    case 'tEXt':
                      const text = this.read(chunkSize);
                      const index = text.indexOf(0);
                      const key = String.fromCharCode.apply(String, text.slice(0, index));
                      this.text[key] = String.fromCharCode.apply(String, text.slice(index + 1));
                      break;

                    case 'IEND':
                      if (frame) {
                        this.animation.frames.push(frame);
                      }

                      this.colors = (() => {
                        switch (this.colorType) {
                          case 0:
                          case 3:
                          case 4:
                            return 1;

                          case 2:
                          case 6:
                            return 3;
                        }
                      }).call(this);

                      const _ref = this.colorType;
                      this.hasAlphaChannel = _ref === 4 || _ref === 6;
                      const colors = this.colors + (this.hasAlphaChannel ? 1 : 0);
                      this.pixelBitlength = this.bits * colors;

                      this.colorSpace = (() => {
                        switch (this.colors) {
                          case 1:
                            return 'DeviceGray';

                          case 3:
                            return 'DeviceRGB';
                        }
                      }).call(this);

                      if (!(this.imgData instanceof Uint8Array)) {
                        this.imgData = new Uint8Array(this.imgData);
                      }

                      return;

                    default:
                      this.pos += chunkSize;
                  }

                  this.pos += 4;

                  if (this.pos > this.data.length) {
                    throw new Error(getError(6017));
                  }
                }
              }

              read(bytes) {
                let i = 0;
                let _i = 0;
                const _results = [];

                for (i = _i = 0; bytes >= 0 ? _i < bytes : _i > bytes; i = bytes >= 0 ? ++_i : --_i) {
                  _results.push(this.data[this.pos++]);
                }

                return _results;
              }

              readUInt32() {
                const b1 = this.data[this.pos++] << 24;
                const b2 = this.data[this.pos++] << 16;
                const b3 = this.data[this.pos++] << 8;
                const b4 = this.data[this.pos++];
                return b1 | b2 | b3 | b4;
              }

              readUInt16() {
                const b1 = this.data[this.pos++] << 8;
                const b2 = this.data[this.pos++];
                return b1 | b2;
              }

              decodePixels(data) {
                if (data == null) {
                  data = this.imgData;
                }

                if (data.length === 0) {
                  return new Uint8Array(0);
                }

                const inflate = new _p.Inflate(data, {
                  index: 0,
                  verify: false
                });
                data = inflate.decompress();
                const pixelBytes = this.pixelBitlength / 8;
                const scanlineLength = pixelBytes * this.width;
                const pixels = new Uint8Array(scanlineLength * this.height);
                const length = data.length;
                let row = 0;
                let pos = 0;
                let c = 0;
                let ccbyte = 0;
                let col = 0;
                let i = 0;
                let _i = 0;
                let _j = 0;
                let _k = 0;
                let _l = 0;
                let _m = 0;
                let left = 0;
                let p = 0;
                let pa = 0;
                let paeth = 0;
                let pb = 0;
                let pc = 0;
                let upper = 0;
                let upperLeft = 0;

                while (pos < length) {
                  switch (data[pos++]) {
                    case 0:
                      for (i = _i = 0; _i < scanlineLength; i = _i += 1) {
                        pixels[c++] = data[pos++];
                      }

                      break;

                    case 1:
                      for (i = _j = 0; _j < scanlineLength; i = _j += 1) {
                        ccbyte = data[pos++];
                        left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
                        pixels[c++] = (ccbyte + left) % 256;
                      }

                      break;

                    case 2:
                      for (i = _k = 0; _k < scanlineLength; i = _k += 1) {
                        ccbyte = data[pos++];
                        col = (i - i % pixelBytes) / pixelBytes;
                        upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
                        pixels[c++] = (upper + ccbyte) % 256;
                      }

                      break;

                    case 3:
                      for (i = _l = 0; _l < scanlineLength; i = _l += 1) {
                        ccbyte = data[pos++];
                        col = (i - i % pixelBytes) / pixelBytes;
                        left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
                        upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
                        pixels[c++] = (ccbyte + Math.floor((left + upper) / 2)) % 256;
                      }

                      break;

                    case 4:
                      for (i = _m = 0; _m < scanlineLength; i = _m += 1) {
                        ccbyte = data[pos++];
                        col = (i - i % pixelBytes) / pixelBytes;
                        left = i < pixelBytes ? 0 : pixels[c - pixelBytes];

                        if (row === 0) {
                          upper = upperLeft = 0;
                        } else {
                          upper = pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
                          upperLeft = col && pixels[(row - 1) * scanlineLength + (col - 1) * pixelBytes + i % pixelBytes];
                        }

                        p = left + upper - upperLeft;
                        pa = Math.abs(p - left);
                        pb = Math.abs(p - upper);
                        pc = Math.abs(p - upperLeft);

                        if (pa <= pb && pa <= pc) {
                          paeth = left;
                        } else if (pb <= pc) {
                          paeth = upper;
                        } else {
                          paeth = upperLeft;
                        }

                        pixels[c++] = (ccbyte + paeth) % 256;
                      }

                      break;

                    default:
                      throw new Error(getError(6018, data[pos - 1]));
                  }

                  row++;
                }

                return pixels;
              }

              copyToImageData(imageData, pixels) {
                let alpha = this.hasAlphaChannel;
                let palette;
                let colors = this.colors;

                if (this.palette.length) {
                  palette = this._decodedPalette != null ? this._decodedPalette : this._decodedPalette = this.decodePalette();
                  colors = 4;
                  alpha = true;
                }

                const data = imageData.data || imageData;
                const length = data.length;
                const input = palette || pixels;
                let i = 0;
                let j = 0;
                let k = 0;
                let v = 0;

                if (colors === 1) {
                  while (i < length) {
                    k = palette ? pixels[i / 4] * 4 : j;
                    v = input[k++];
                    data[i++] = v;
                    data[i++] = v;
                    data[i++] = v;
                    data[i++] = alpha ? input[k++] : 255;
                    j = k;
                  }
                } else {
                  while (i < length) {
                    k = palette ? pixels[i / 4] * 4 : j;
                    data[i++] = input[k++];
                    data[i++] = input[k++];
                    data[i++] = input[k++];
                    data[i++] = alpha ? input[k++] : 255;
                    j = k;
                  }
                }
              }

              decodePalette() {
                const palette = this.palette;
                const transparency = this.transparency.indexed || [];
                const ret = new Uint8Array((transparency.length || 0) + palette.length);
                let pos = 0;
                let c = 0;
                let _ref1 = 0;

                for (let i = 0, _i = 0, _ref = palette.length; _i < _ref; i = _i += 3) {
                  ret[pos++] = palette[i];
                  ret[pos++] = palette[i + 1];
                  ret[pos++] = palette[i + 2];
                  _ref1 = transparency[c++];
                  ret[pos++] = _ref1 != null ? _ref1 : 255;
                }

                return ret;
              }

              render(canvas) {
                canvas.width = this.width;
                canvas.height = this.height;
                const ctx = canvas.getContext('2d');
                const data = ctx.createImageData(this.width, this.height);
                this.copyToImageData(data, this.decodePixels(null));
                return ctx.putImageData(data, 0, 0);
              }

            }

            console.log('pptest importing cc 3.35');
            class TiffReader {
              constructor() {
                this._littleEndian = false;
                this._tiffData = [];
                this._fileDirectories = [];
              }

              getUint8(offset) {
                return this._tiffData[offset];
              }

              getUint16(offset) {
                if (this._littleEndian) return this._tiffData[offset + 1] << 8 | this._tiffData[offset];else return this._tiffData[offset] << 8 | this._tiffData[offset + 1];
              }

              getUint32(offset) {
                const a = this._tiffData;
                if (this._littleEndian) return a[offset + 3] << 24 | a[offset + 2] << 16 | a[offset + 1] << 8 | a[offset];else return a[offset] << 24 | a[offset + 1] << 16 | a[offset + 2] << 8 | a[offset + 3];
              }

              checkLittleEndian() {
                const BOM = this.getUint16(0);

                if (BOM === 0x4949) {
                  this._littleEndian = true;
                } else if (BOM === 0x4D4D) {
                  this._littleEndian = false;
                } else {
                  console.log(BOM);
                  throw TypeError(getError(6019));
                }

                return this._littleEndian;
              }

              hasTowel() {
                if (this.getUint16(2) !== 42) {
                  throw RangeError(getError(6020));
                }

                return true;
              }

              getFieldTypeName(fieldType) {
                const typeNames = fieldTypeNames;

                if (fieldType in typeNames) {
                  return typeNames[fieldType];
                }

                return null;
              }

              getFieldTagName(fieldTag) {
                const tagNames = fieldTagNames;

                if (fieldTag in tagNames) {
                  return tagNames[fieldTag];
                } else {
                  logID(6021, fieldTag);
                  return `Tag${fieldTag}`;
                }
              }

              getFieldTypeLength(fieldTypeName) {
                if (['BYTE', 'ASCII', 'SBYTE', 'UNDEFINED'].indexOf(fieldTypeName) !== -1) {
                  return 1;
                } else if (['SHORT', 'SSHORT'].indexOf(fieldTypeName) !== -1) {
                  return 2;
                } else if (['LONG', 'SLONG', 'FLOAT'].indexOf(fieldTypeName) !== -1) {
                  return 4;
                } else if (['RATIONAL', 'SRATIONAL', 'DOUBLE'].indexOf(fieldTypeName) !== -1) {
                  return 8;
                }

                return 0;
              }

              getFieldValues(fieldTagName, fieldTypeName, typeCount, valueOffset) {
                const fieldValues = [];
                const fieldTypeLength = this.getFieldTypeLength(fieldTypeName);
                const fieldValueSize = fieldTypeLength * typeCount;

                if (fieldValueSize <= 4) {
                  if (this._littleEndian === false) fieldValues.push(valueOffset >>> (4 - fieldTypeLength) * 8);else fieldValues.push(valueOffset);
                } else {
                  for (let i = 0; i < typeCount; i++) {
                    const indexOffset = fieldTypeLength * i;

                    if (fieldTypeLength >= 8) {
                      if (['RATIONAL', 'SRATIONAL'].indexOf(fieldTypeName) !== -1) {
                        fieldValues.push(this.getUint32(valueOffset + indexOffset));
                        fieldValues.push(this.getUint32(valueOffset + indexOffset + 4));
                      } else {
                        logID(8000);
                      }
                    } else {
                      fieldValues.push(this.getBytes(fieldTypeLength, valueOffset + indexOffset));
                    }
                  }
                }

                if (fieldTypeName === 'ASCII') {
                  fieldValues.forEach((e, i, a) => {
                    a[i] = String.fromCharCode(e);
                  });
                }

                return fieldValues;
              }

              getBytes(numBytes, offset) {
                if (numBytes <= 0) {
                  logID(8001);
                } else if (numBytes <= 1) {
                  return this.getUint8(offset);
                } else if (numBytes <= 2) {
                  return this.getUint16(offset);
                } else if (numBytes <= 3) {
                  return this.getUint32(offset) >>> 8;
                } else if (numBytes <= 4) {
                  return this.getUint32(offset);
                } else {
                  logID(8002);
                }

                return 0;
              }

              getBits(numBits, byteOffset, bitOffset) {
                bitOffset = bitOffset || 0;
                const extraBytes = Math.floor(bitOffset / 8);
                const newByteOffset = byteOffset + extraBytes;
                const totalBits = bitOffset + numBits;
                const shiftRight = 32 - numBits;
                let shiftLeft = 0;
                let rawBits = 0;

                if (totalBits <= 0) {
                  logID(6023);
                } else if (totalBits <= 8) {
                  shiftLeft = 24 + bitOffset;
                  rawBits = this.getUint8(newByteOffset);
                } else if (totalBits <= 16) {
                  shiftLeft = 16 + bitOffset;
                  rawBits = this.getUint16(newByteOffset);
                } else if (totalBits <= 32) {
                  shiftLeft = bitOffset;
                  rawBits = this.getUint32(newByteOffset);
                } else {
                  logID(6022);
                }

                return {
                  bits: rawBits << shiftLeft >>> shiftRight,
                  byteOffset: newByteOffset + Math.floor(totalBits / 8),
                  bitOffset: totalBits % 8
                };
              }

              parseFileDirectory(offset) {
                const numDirEntries = this.getUint16(offset);
                const tiffFields = [];
                let i = 0;
                let entryCount = 0;

                for (i = offset + 2, entryCount = 0; entryCount < numDirEntries; i += 12, entryCount++) {
                  const fieldTag = this.getUint16(i);
                  const fieldType = this.getUint16(i + 2);
                  const typeCount = this.getUint32(i + 4);
                  const valueOffset = this.getUint32(i + 8);
                  const fieldTagName = this.getFieldTagName(fieldTag);
                  const fieldTypeName = this.getFieldTypeName(fieldType);
                  const fieldValues = this.getFieldValues(fieldTagName, fieldTypeName, typeCount, valueOffset);
                  tiffFields[fieldTagName] = {
                    type: fieldTypeName,
                    values: fieldValues
                  };
                }

                this._fileDirectories.push(tiffFields);

                const nextIFDByteOffset = this.getUint32(i);

                if (nextIFDByteOffset !== 0x00000000) {
                  this.parseFileDirectory(nextIFDByteOffset);
                }
              }

              clampColorSample(colorSample, bitsPerSample) {
                const multiplier = Math.pow(2, 8 - bitsPerSample);
                return Math.floor(colorSample * multiplier + (multiplier - 1));
              }

              parseTIFF(tiffData, canvas) {
                canvas = canvas || document.createElement('canvas');
                this._tiffData = tiffData;
                this._canvas = canvas;
                this.checkLittleEndian();

                if (!this.hasTowel()) {
                  return;
                }

                const firstIFDByteOffset = this.getUint32(4);
                this._fileDirectories.length = 0;
                this.parseFileDirectory(firstIFDByteOffset);
                const fileDirectory = this._fileDirectories[0];
                const imageWidth = fileDirectory.ImageWidth.values[0];
                const imageLength = fileDirectory.ImageLength.values[0];
                this._canvas.width = imageWidth;
                this._canvas.height = imageLength;
                const strips = [];
                const compression = fileDirectory.Compression ? fileDirectory.Compression.values[0] : 1;
                const samplesPerPixel = fileDirectory.SamplesPerPixel.values[0];
                const sampleProperties = [];
                let bitsPerPixel = 0;
                let hasBytesPerPixel = false;
                fileDirectory.BitsPerSample.values.forEach((bitsPerSample, i, bitsPerSampleValues) => {
                  sampleProperties[i] = {
                    bitsPerSample,
                    hasBytesPerSample: false,
                    bytesPerSample: undefined
                  };

                  if (bitsPerSample % 8 === 0) {
                    sampleProperties[i].hasBytesPerSample = true;
                    sampleProperties[i].bytesPerSample = bitsPerSample / 8;
                  }

                  bitsPerPixel += bitsPerSample;
                }, this);
                let bytesPerPixel = 0;

                if (bitsPerPixel % 8 === 0) {
                  hasBytesPerPixel = true;
                  bytesPerPixel = bitsPerPixel / 8;
                }

                const stripOffsetValues = fileDirectory.StripOffsets.values;
                const numStripOffsetValues = stripOffsetValues.length;
                let stripByteCountValues;

                if (fileDirectory.StripByteCounts) {
                  stripByteCountValues = fileDirectory.StripByteCounts.values;
                } else {
                  logID(8003);

                  if (numStripOffsetValues === 1) {
                    stripByteCountValues = [Math.ceil(imageWidth * imageLength * bitsPerPixel / 8)];
                  } else {
                    throw Error(getError(6024));
                  }
                }

                let blockLength = 1;
                let iterations = 1;

                for (let i = 0; i < numStripOffsetValues; i++) {
                  const stripOffset = stripOffsetValues[i];
                  strips[i] = [];
                  const stripByteCount = stripByteCountValues[i];

                  for (let byteOffset = 0, bitOffset = 0, jIncrement = 1, getHeader = true, pixel = [], numBytes = 0, sample = 0, currentSample = 0; byteOffset < stripByteCount; byteOffset += jIncrement) {
                    switch (compression) {
                      case 1:
                        pixel = [];

                        for (let m = 0; m < samplesPerPixel; m++) {
                          const s = sampleProperties[m];

                          if (s.hasBytesPerSample) {
                            const sampleOffset = s.bytesPerSample * m;
                            pixel.push(this.getBytes(s.bytesPerSample, stripOffset + byteOffset + sampleOffset));
                          } else {
                            const sampleInfo = this.getBits(s.bitsPerSample, stripOffset + byteOffset, bitOffset);
                            pixel.push(sampleInfo.bits);
                            byteOffset = sampleInfo.byteOffset - stripOffset;
                            bitOffset = sampleInfo.bitOffset;
                            throw RangeError(getError(6025));
                          }
                        }

                        strips[i].push(pixel);

                        if (hasBytesPerPixel) {
                          jIncrement = bytesPerPixel;
                        } else {
                          jIncrement = 0;
                          throw RangeError(getError(6026));
                        }

                        break;

                      case 2:
                        break;

                      case 3:
                        break;

                      case 4:
                        break;

                      case 5:
                        break;

                      case 6:
                        break;

                      case 7:
                        break;

                      case 32773:
                        if (getHeader) {
                          getHeader = false;
                          const header = this.getUint8(stripOffset + byteOffset);

                          if (header >= 0 && header <= 127) {
                            blockLength = header + 1;
                          } else if (header >= -127 && header <= -1) {
                            iterations = -header + 1;
                          } else {
                              getHeader = true;
                            }
                        } else {
                          const currentByte = this.getUint8(stripOffset + byteOffset);

                          for (let m = 0; m < iterations; m++) {
                            const s = sampleProperties[sample];

                            if (s.hasBytesPerSample) {
                              currentSample = currentSample << 8 * numBytes | currentByte;
                              numBytes++;

                              if (numBytes === s.bytesPerSample) {
                                pixel.push(currentSample);
                                currentSample = numBytes = 0;
                                sample++;
                              }
                            } else {
                              throw RangeError(getError(6025));
                            }

                            if (sample === samplesPerPixel) {
                              strips[i].push(pixel);
                              pixel = [];
                              sample = 0;
                            }
                          }

                          blockLength--;

                          if (blockLength === 0) {
                            getHeader = true;
                          }
                        }

                        jIncrement = 1;
                        break;
                    }
                  }
                }

                if (canvas.getContext) {
                  const ctx = this._canvas.getContext('2d');

                  ctx.fillStyle = 'rgba(255, 255, 255, 0)';
                  const rowsPerStrip = fileDirectory.RowsPerStrip ? fileDirectory.RowsPerStrip.values[0] : imageLength;
                  const numStrips = strips.length;
                  const imageLengthModRowsPerStrip = imageLength % rowsPerStrip;
                  const rowsInLastStrip = imageLengthModRowsPerStrip === 0 ? rowsPerStrip : imageLengthModRowsPerStrip;
                  let numRowsInStrip = rowsPerStrip;
                  let numRowsInPreviousStrip = 0;
                  const photometricInterpretation = fileDirectory.PhotometricInterpretation.values[0];
                  let extraSamplesValues = [];
                  let numExtraSamples = 0;

                  if (fileDirectory.ExtraSamples) {
                    extraSamplesValues = fileDirectory.ExtraSamples.values;
                    numExtraSamples = extraSamplesValues.length;
                  }

                  let colorMapValues = [];
                  let colorMapSampleSize = 0;

                  if (fileDirectory.ColorMap) {
                    colorMapValues = fileDirectory.ColorMap.values;
                    colorMapSampleSize = Math.pow(2, sampleProperties[0].bitsPerSample);
                  }

                  for (let i = 0; i < numStrips; i++) {
                    if (i + 1 === numStrips) {
                      numRowsInStrip = rowsInLastStrip;
                    }

                    const numPixels = strips[i].length;
                    const yPadding = numRowsInPreviousStrip * i;

                    for (let y = 0, j = 0; y < numRowsInStrip && j < numPixels; y++) {
                      for (let x = 0; x < imageWidth; x++, j++) {
                        const pixelSamples = strips[i][j];
                        let red = 0;
                        let green = 0;
                        let blue = 0;
                        let opacity = 1.0;

                        if (numExtraSamples > 0) {
                          for (let k = 0; k < numExtraSamples; k++) {
                            if (extraSamplesValues[k] === 1 || extraSamplesValues[k] === 2) {
                              opacity = pixelSamples[3 + k] / 256;
                              break;
                            }
                          }
                        }

                        switch (photometricInterpretation) {
                          case 0:
                            let invertValue = 0;

                            if (sampleProperties[0].hasBytesPerSample) {
                              invertValue = Math.pow(0x10, sampleProperties[0].bytesPerSample * 2);
                            }

                            pixelSamples.forEach((sample, index, samples) => {
                              samples[index] = invertValue - sample;
                            });

                          case 1:
                            red = green = blue = this.clampColorSample(pixelSamples[0], sampleProperties[0].bitsPerSample);
                            break;

                          case 2:
                            red = this.clampColorSample(pixelSamples[0], sampleProperties[0].bitsPerSample);
                            green = this.clampColorSample(pixelSamples[1], sampleProperties[1].bitsPerSample);
                            blue = this.clampColorSample(pixelSamples[2], sampleProperties[2].bitsPerSample);
                            break;

                          case 3:
                            if (colorMapValues === undefined) {
                              throw Error(getError(6027));
                            }

                            const colorMapIndex = pixelSamples[0];
                            red = this.clampColorSample(colorMapValues[colorMapIndex], 16);
                            green = this.clampColorSample(colorMapValues[colorMapSampleSize + colorMapIndex], 16);
                            blue = this.clampColorSample(colorMapValues[2 * colorMapSampleSize + colorMapIndex], 16);
                            break;

                          default:
                            throw RangeError(getError(6028, photometricInterpretation));
                        }

                        ctx.fillStyle = `rgba(${red}, ${green}, ${blue}, ${opacity})`;
                        ctx.fillRect(x, yPadding + y, 1, 1);
                      }
                    }

                    numRowsInPreviousStrip = numRowsInStrip;
                  }
                }

                return this._canvas;
              }

            }
            const fieldTagNames = {
              0x013B: 'Artist',
              0x0102: 'BitsPerSample',
              0x0109: 'CellLength',
              0x0108: 'CellWidth',
              0x0140: 'ColorMap',
              0x0103: 'Compression',
              0x8298: 'Copyright',
              0x0132: 'DateTime',
              0x0152: 'ExtraSamples',
              0x010A: 'FillOrder',
              0x0121: 'FreeByteCounts',
              0x0120: 'FreeOffsets',
              0x0123: 'GrayResponseCurve',
              0x0122: 'GrayResponseUnit',
              0x013C: 'HostComputer',
              0x010E: 'ImageDescription',
              0x0101: 'ImageLength',
              0x0100: 'ImageWidth',
              0x010F: 'Make',
              0x0119: 'MaxSampleValue',
              0x0118: 'MinSampleValue',
              0x0110: 'Model',
              0x00FE: 'NewSubfileType',
              0x0112: 'Orientation',
              0x0106: 'PhotometricInterpretation',
              0x011C: 'PlanarConfiguration',
              0x0128: 'ResolutionUnit',
              0x0116: 'RowsPerStrip',
              0x0115: 'SamplesPerPixel',
              0x0131: 'Software',
              0x0117: 'StripByteCounts',
              0x0111: 'StripOffsets',
              0x00FF: 'SubfileType',
              0x0107: 'Threshholding',
              0x011A: 'XResolution',
              0x011B: 'YResolution',
              0x0146: 'BadFaxLines',
              0x0147: 'CleanFaxData',
              0x0157: 'ClipPath',
              0x0148: 'ConsecutiveBadFaxLines',
              0x01B1: 'Decode',
              0x01B2: 'DefaultImageColor',
              0x010D: 'DocumentName',
              0x0150: 'DotRange',
              0x0141: 'HalftoneHints',
              0x015A: 'Indexed',
              0x015B: 'JPEGTables',
              0x011D: 'PageName',
              0x0129: 'PageNumber',
              0x013D: 'Predictor',
              0x013F: 'PrimaryChromaticities',
              0x0214: 'ReferenceBlackWhite',
              0x0153: 'SampleFormat',
              0x022F: 'StripRowCounts',
              0x014A: 'SubIFDs',
              0x0124: 'T4Options',
              0x0125: 'T6Options',
              0x0145: 'TileByteCounts',
              0x0143: 'TileLength',
              0x0144: 'TileOffsets',
              0x0142: 'TileWidth',
              0x012D: 'TransferFunction',
              0x013E: 'WhitePoint',
              0x0158: 'XClipPathUnits',
              0x011E: 'XPosition',
              0x0211: 'YCbCrCoefficients',
              0x0213: 'YCbCrPositioning',
              0x0212: 'YCbCrSubSampling',
              0x0159: 'YClipPathUnits',
              0x011F: 'YPosition',
              0x9202: 'ApertureValue',
              0xA001: 'ColorSpace',
              0x9004: 'DateTimeDigitized',
              0x9003: 'DateTimeOriginal',
              0x8769: 'Exif IFD',
              0x9000: 'ExifVersion',
              0x829A: 'ExposureTime',
              0xA300: 'FileSource',
              0x9209: 'Flash',
              0xA000: 'FlashpixVersion',
              0x829D: 'FNumber',
              0xA420: 'ImageUniqueID',
              0x9208: 'LightSource',
              0x927C: 'MakerNote',
              0x9201: 'ShutterSpeedValue',
              0x9286: 'UserComment',
              0x83BB: 'IPTC',
              0x8773: 'ICC Profile',
              0x02BC: 'XMP',
              0xA480: 'GDAL_METADATA',
              0xA481: 'GDAL_NODATA',
              0x8649: 'Photoshop'
            };
            const fieldTypeNames = {
              0x0001: 'BYTE',
              0x0002: 'ASCII',
              0x0003: 'SHORT',
              0x0004: 'LONG',
              0x0005: 'RATIONAL',
              0x0006: 'SBYTE',
              0x0007: 'UNDEFINED',
              0x0008: 'SSHORT',
              0x0009: 'SLONG',
              0x000A: 'SRATIONAL',
              0x000B: 'FLOAT',
              0x000C: 'DOUBLE'
            };

            const BASE64_KEYS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
            const BASE64_VALUES = new Array(123);

            for (let i = 0; i < 123; ++i) {
              BASE64_VALUES[i] = 64;
            }

            for (let i = 0; i < 64; ++i) {
              BASE64_VALUES[BASE64_KEYS.charCodeAt(i)] = i;
            }

            var Base64 = {
              name: 'Jacob__Codec__Base64'
            };

            Base64.decode = function Jacob__Codec__Base64__decode(input) {
              var output = [],
                  chr1,
                  chr2,
                  chr3,
                  enc1,
                  enc2,
                  enc3,
                  enc4,
                  i = 0;
              input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

              while (i < input.length) {
                enc1 = BASE64_VALUES[input.charCodeAt(i++)];
                enc2 = BASE64_VALUES[input.charCodeAt(i++)];
                enc3 = BASE64_VALUES[input.charCodeAt(i++)];
                enc4 = BASE64_VALUES[input.charCodeAt(i++)];
                chr1 = enc1 << 2 | enc2 >> 4;
                chr2 = (enc2 & 15) << 4 | enc3 >> 2;
                chr3 = (enc3 & 3) << 6 | enc4;
                output.push(String.fromCharCode(chr1));

                if (enc3 !== 64) {
                  output.push(String.fromCharCode(chr2));
                }

                if (enc4 !== 64) {
                  output.push(String.fromCharCode(chr3));
                }
              }

              output = output.join('');
              return output;
            };

            Base64.decodeAsArray = function Jacob__Codec__Base64___decodeAsArray(input, bytes) {
              var dec = this.decode(input),
                  ar = [],
                  i,
                  j,
                  len;

              for (i = 0, len = dec.length / bytes; i < len; i++) {
                ar[i] = 0;

                for (j = bytes - 1; j >= 0; --j) {
                  ar[i] += dec.charCodeAt(i * bytes + j) << j * 8;
                }
              }

              return ar;
            };

            var GZip = function Jacob__GZip(data) {
              this.data = data;
              this.debug = false;
              this.gpflags = undefined;
              this.files = 0;
              this.unzipped = [];
              this.buf32k = new Array(32768);
              this.bIdx = 0;
              this.modeZIP = false;
              this.bytepos = 0;
              this.bb = 1;
              this.bits = 0;
              this.nameBuf = [];
              this.fileout = undefined;
              this.literalTree = new Array(GZip.LITERALS);
              this.distanceTree = new Array(32);
              this.treepos = 0;
              this.Places = null;
              this.len = 0;
              this.fpos = new Array(17);
              this.fpos[0] = 0;
              this.flens = undefined;
              this.fmax = undefined;
            };

            GZip.gunzip = function (string) {
              if (string.constructor === Array) ; else if (string.constructor === String) ;

              var gzip = new GZip(string);
              return gzip.gunzip()[0][0];
            };

            GZip.HufNode = function () {
              this.b0 = 0;
              this.b1 = 0;
              this.jump = null;
              this.jumppos = -1;
            };

            GZip.LITERALS = 288;
            GZip.NAMEMAX = 256;
            GZip.bitReverse = [0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0, 0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0, 0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8, 0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8, 0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4, 0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4, 0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec, 0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc, 0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2, 0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2, 0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea, 0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa, 0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6, 0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6, 0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee, 0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe, 0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1, 0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1, 0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9, 0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9, 0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5, 0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5, 0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed, 0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd, 0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3, 0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3, 0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb, 0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb, 0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7, 0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7, 0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef, 0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff];
            GZip.cplens = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];
            GZip.cplext = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99];
            GZip.cpdist = [0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d, 0x0011, 0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1, 0x0101, 0x0181, 0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01, 0x1001, 0x1801, 0x2001, 0x3001, 0x4001, 0x6001];
            GZip.cpdext = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
            GZip.border = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];

            GZip.prototype.gunzip = function () {
              this.outputArr = [];
              this.nextFile();
              return this.unzipped;
            };

            GZip.prototype.readByte = function () {
              this.bits += 8;

              if (this.bytepos < this.data.length) {
                return this.data.charCodeAt(this.bytepos++);
              } else {
                return -1;
              }
            };

            GZip.prototype.byteAlign = function () {
              this.bb = 1;
            };

            GZip.prototype.readBit = function () {
              var carry;
              this.bits++;
              carry = this.bb & 1;
              this.bb >>= 1;

              if (this.bb === 0) {
                this.bb = this.readByte();
                carry = this.bb & 1;
                this.bb = this.bb >> 1 | 0x80;
              }

              return carry;
            };

            GZip.prototype.readBits = function (a) {
              var res = 0,
                  i = a;

              while (i--) res = res << 1 | this.readBit();

              if (a) res = GZip.bitReverse[res] >> 8 - a;
              return res;
            };

            GZip.prototype.flushBuffer = function () {
              this.bIdx = 0;
            };

            GZip.prototype.addBuffer = function (a) {
              this.buf32k[this.bIdx++] = a;
              this.outputArr.push(String.fromCharCode(a));
              if (this.bIdx === 0x8000) this.bIdx = 0;
            };

            GZip.prototype.IsPat = function () {
              while (1) {
                if (this.fpos[this.len] >= this.fmax) return -1;
                if (this.flens[this.fpos[this.len]] === this.len) return this.fpos[this.len]++;
                this.fpos[this.len]++;
              }
            };

            GZip.prototype.Rec = function () {
              var curplace = this.Places[this.treepos];
              var tmp;

              if (this.len === 17) {
                return -1;
              }

              this.treepos++;
              this.len++;
              tmp = this.IsPat();

              if (tmp >= 0) {
                curplace.b0 = tmp;
              } else {
                curplace.b0 = 0x8000;
                if (this.Rec()) return -1;
              }

              tmp = this.IsPat();

              if (tmp >= 0) {
                curplace.b1 = tmp;
                curplace.jump = null;
              } else {
                curplace.b1 = 0x8000;
                curplace.jump = this.Places[this.treepos];
                curplace.jumppos = this.treepos;
                if (this.Rec()) return -1;
              }

              this.len--;
              return 0;
            };

            GZip.prototype.CreateTree = function (currentTree, numval, lengths, show) {
              var i;
              this.Places = currentTree;
              this.treepos = 0;
              this.flens = lengths;
              this.fmax = numval;

              for (i = 0; i < 17; i++) this.fpos[i] = 0;

              this.len = 0;

              if (this.Rec()) {
                return -1;
              }

              return 0;
            };

            GZip.prototype.DecodeValue = function (currentTree) {
              var len,
                  i,
                  xtreepos = 0,
                  X = currentTree[xtreepos],
                  b;

              while (1) {
                b = this.readBit();

                if (b) {
                  if (!(X.b1 & 0x8000)) {
                    return X.b1;
                  }

                  X = X.jump;
                  len = currentTree.length;

                  for (i = 0; i < len; i++) {
                    if (currentTree[i] === X) {
                      xtreepos = i;
                      break;
                    }
                  }
                } else {
                  if (!(X.b0 & 0x8000)) {
                    return X.b0;
                  }

                  xtreepos++;
                  X = currentTree[xtreepos];
                }
              }

              return -1;
            };

            GZip.prototype.DeflateLoop = function () {
              var last, c, type, i, len;

              do {
                last = this.readBit();
                type = this.readBits(2);

                if (type === 0) {
                  var blockLen, cSum;
                  this.byteAlign();
                  blockLen = this.readByte();
                  blockLen |= this.readByte() << 8;
                  cSum = this.readByte();
                  cSum |= this.readByte() << 8;

                  if ((blockLen ^ ~cSum) & 0xffff) {
                    document.write("BlockLen checksum mismatch\n");
                  }

                  while (blockLen--) {
                    c = this.readByte();
                    this.addBuffer(c);
                  }
                } else if (type === 1) {
                  var j;

                  while (1) {
                    j = GZip.bitReverse[this.readBits(7)] >> 1;

                    if (j > 23) {
                      j = j << 1 | this.readBit();

                      if (j > 199) {
                        j -= 128;
                        j = j << 1 | this.readBit();
                      } else {
                        j -= 48;

                        if (j > 143) {
                          j = j + 136;
                        }
                      }
                    } else {
                      j += 256;
                    }

                    if (j < 256) {
                      this.addBuffer(j);
                    } else if (j === 256) {
                      break;
                    } else {
                      var len, dist;
                      j -= 256 + 1;
                      len = this.readBits(GZip.cplext[j]) + GZip.cplens[j];
                      j = GZip.bitReverse[this.readBits(5)] >> 3;

                      if (GZip.cpdext[j] > 8) {
                        dist = this.readBits(8);
                        dist |= this.readBits(GZip.cpdext[j] - 8) << 8;
                      } else {
                        dist = this.readBits(GZip.cpdext[j]);
                      }

                      dist += GZip.cpdist[j];

                      for (j = 0; j < len; j++) {
                        var c = this.buf32k[this.bIdx - dist & 0x7fff];
                        this.addBuffer(c);
                      }
                    }
                  }
                } else if (type === 2) {
                  var j, n, literalCodes, distCodes, lenCodes;
                  var ll = new Array(288 + 32);
                  literalCodes = 257 + this.readBits(5);
                  distCodes = 1 + this.readBits(5);
                  lenCodes = 4 + this.readBits(4);

                  for (j = 0; j < 19; j++) {
                    ll[j] = 0;
                  }

                  for (j = 0; j < lenCodes; j++) {
                    ll[GZip.border[j]] = this.readBits(3);
                  }

                  len = this.distanceTree.length;

                  for (i = 0; i < len; i++) this.distanceTree[i] = new GZip.HufNode();

                  if (this.CreateTree(this.distanceTree, 19, ll, 0)) {
                    this.flushBuffer();
                    return 1;
                  }

                  n = literalCodes + distCodes;
                  i = 0;

                  while (i < n) {
                    j = this.DecodeValue(this.distanceTree);

                    if (j < 16) {
                      ll[i++] = j;
                    } else if (j === 16) {
                      var l;
                      j = 3 + this.readBits(2);

                      if (i + j > n) {
                        this.flushBuffer();
                        return 1;
                      }

                      l = i ? ll[i - 1] : 0;

                      while (j--) {
                        ll[i++] = l;
                      }
                    } else {
                      if (j === 17) {
                        j = 3 + this.readBits(3);
                      } else {
                        j = 11 + this.readBits(7);
                      }

                      if (i + j > n) {
                        this.flushBuffer();
                        return 1;
                      }

                      while (j--) {
                        ll[i++] = 0;
                      }
                    }
                  }

                  len = this.literalTree.length;

                  for (i = 0; i < len; i++) this.literalTree[i] = new GZip.HufNode();

                  if (this.CreateTree(this.literalTree, literalCodes, ll, 0)) {
                    this.flushBuffer();
                    return 1;
                  }

                  len = this.literalTree.length;

                  for (i = 0; i < len; i++) this.distanceTree[i] = new GZip.HufNode();

                  var ll2 = new Array();

                  for (i = literalCodes; i < ll.length; i++) ll2[i - literalCodes] = ll[i];

                  if (this.CreateTree(this.distanceTree, distCodes, ll2, 0)) {
                    this.flushBuffer();
                    return 1;
                  }

                  while (1) {
                    j = this.DecodeValue(this.literalTree);

                    if (j >= 256) {
                      var len, dist;
                      j -= 256;

                      if (j === 0) {
                        break;
                      }

                      j--;
                      len = this.readBits(GZip.cplext[j]) + GZip.cplens[j];
                      j = this.DecodeValue(this.distanceTree);

                      if (GZip.cpdext[j] > 8) {
                        dist = this.readBits(8);
                        dist |= this.readBits(GZip.cpdext[j] - 8) << 8;
                      } else {
                        dist = this.readBits(GZip.cpdext[j]);
                      }

                      dist += GZip.cpdist[j];

                      while (len--) {
                        var c = this.buf32k[this.bIdx - dist & 0x7fff];
                        this.addBuffer(c);
                      }
                    } else {
                      this.addBuffer(j);
                    }
                  }
                }
              } while (!last);

              this.flushBuffer();
              this.byteAlign();
              return 0;
            };

            GZip.prototype.unzipFile = function (name) {
              var i;
              this.gunzip();

              for (i = 0; i < this.unzipped.length; i++) {
                if (this.unzipped[i][1] === name) {
                  return this.unzipped[i][0];
                }
              }
            };

            GZip.prototype.nextFile = function () {
              this.outputArr = [];
              this.modeZIP = false;
              var tmp = [];
              tmp[0] = this.readByte();
              tmp[1] = this.readByte();

              if (tmp[0] === 0x78 && tmp[1] === 0xda) {
                this.DeflateLoop();
                this.unzipped[this.files] = [this.outputArr.join(''), "geonext.gxt"];
                this.files++;
              }

              if (tmp[0] === 0x1f && tmp[1] === 0x8b) {
                this.skipdir();
                this.unzipped[this.files] = [this.outputArr.join(''), "file"];
                this.files++;
              }

              if (tmp[0] === 0x50 && tmp[1] === 0x4b) {
                this.modeZIP = true;
                tmp[2] = this.readByte();
                tmp[3] = this.readByte();

                if (tmp[2] === 0x03 && tmp[3] === 0x04) {
                  tmp[0] = this.readByte();
                  tmp[1] = this.readByte();
                  this.gpflags = this.readByte();
                  this.gpflags |= this.readByte() << 8;
                  var method = this.readByte();
                  method |= this.readByte() << 8;
                  this.readByte();
                  this.readByte();
                  this.readByte();
                  this.readByte();
                  var compSize = this.readByte();
                  compSize |= this.readByte() << 8;
                  compSize |= this.readByte() << 16;
                  compSize |= this.readByte() << 24;
                  var size = this.readByte();
                  size |= this.readByte() << 8;
                  size |= this.readByte() << 16;
                  size |= this.readByte() << 24;
                  var filelen = this.readByte();
                  filelen |= this.readByte() << 8;
                  var extralen = this.readByte();
                  extralen |= this.readByte() << 8;
                  i = 0;
                  this.nameBuf = [];

                  while (filelen--) {
                    var c = this.readByte();

                    if (c === "/" | c === ":") {
                      i = 0;
                    } else if (i < GZip.NAMEMAX - 1) {
                      this.nameBuf[i++] = String.fromCharCode(c);
                    }
                  }

                  if (!this.fileout) this.fileout = this.nameBuf;
                  var i = 0;

                  while (i < extralen) {
                    c = this.readByte();
                    i++;
                  }

                  if (method === 8) {
                    this.DeflateLoop();
                    this.unzipped[this.files] = [this.outputArr.join(''), this.nameBuf.join('')];
                    this.files++;
                  }

                  this.skipdir();
                }
              }
            };

            GZip.prototype.skipdir = function () {
              var tmp = [];
              var compSize, size, os, i, c;

              if (this.gpflags & 8) {
                tmp[0] = this.readByte();
                tmp[1] = this.readByte();
                tmp[2] = this.readByte();
                tmp[3] = this.readByte();
                compSize = this.readByte();
                compSize |= this.readByte() << 8;
                compSize |= this.readByte() << 16;
                compSize |= this.readByte() << 24;
                size = this.readByte();
                size |= this.readByte() << 8;
                size |= this.readByte() << 16;
                size |= this.readByte() << 24;
              }

              if (this.modeZIP) this.nextFile();
              tmp[0] = this.readByte();

              if (tmp[0] !== 8) {
                return 0;
              }

              this.gpflags = this.readByte();
              this.readByte();
              this.readByte();
              this.readByte();
              this.readByte();
              this.readByte();
              os = this.readByte();

              if (this.gpflags & 4) {
                tmp[0] = this.readByte();
                tmp[2] = this.readByte();
                this.len = tmp[0] + 256 * tmp[1];

                for (i = 0; i < this.len; i++) this.readByte();
              }

              if (this.gpflags & 8) {
                i = 0;
                this.nameBuf = [];

                while (c = this.readByte()) {
                  if (c === "7" || c === ":") i = 0;
                  if (i < GZip.NAMEMAX - 1) this.nameBuf[i++] = c;
                }
              }

              if (this.gpflags & 16) {
                while (c = this.readByte()) {}
              }

              if (this.gpflags & 2) {
                this.readByte();
                this.readByte();
              }

              this.DeflateLoop();
              size = this.readByte();
              size |= this.readByte() << 8;
              size |= this.readByte() << 16;
              size |= this.readByte() << 24;
              if (this.modeZIP) this.nextFile();
            };

            var codec = {
              name: 'Jacob__Codec'
            };
            codec.Base64 = Base64;
            codec.GZip = GZip;

            codec.unzip = function () {
              return codec.GZip.gunzip.apply(codec.GZip, arguments);
            };

            codec.unzipBase64 = function () {
              var buffer = codec.Base64.decode.apply(codec.Base64, arguments);

              try {
                return codec.GZip.gunzip.call(codec.GZip, buffer);
              } catch (e) {
                return buffer.slice(7);
              }
            };

            codec.unzipBase64AsArray = function (input, bytes) {
              bytes = bytes || 1;
              var dec = this.unzipBase64(input),
                  ar = [],
                  i,
                  j,
                  len;

              for (i = 0, len = dec.length / bytes; i < len; i++) {
                ar[i] = 0;

                for (j = bytes - 1; j >= 0; --j) {
                  ar[i] += dec.charCodeAt(i * bytes + j) << j * 8;
                }
              }

              return ar;
            };

            codec.unzipAsArray = function (input, bytes) {
              bytes = bytes || 1;
              var dec = this.unzip(input),
                  ar = [],
                  i,
                  j,
                  len;

              for (i = 0, len = dec.length / bytes; i < len; i++) {
                ar[i] = 0;

                for (j = bytes - 1; j >= 0; --j) {
                  ar[i] += dec.charCodeAt(i * bytes + j) << j * 8;
                }
              }

              return ar;
            };

            var _dec$1h, _dec2$19, _dec3$W, _dec4$S, _dec5$N, _dec6$I, _dec7$H, _dec8$D, _dec9$A, _dec10$y, _dec11$v, _dec12$u, _dec13$r, _dec14$n, _dec15$n, _dec16$m, _dec17$j, _dec18$i, _dec19$i, _dec20$h, _dec21$g, _dec22$f, _dec23$f, _dec24$d, _dec25$d, _dec26$c, _dec27$c, _dec28$b, _dec29$a, _dec30$9, _dec31$8, _dec32$8, _dec33$6, _dec34$5, _dec35$4, _dec36$4, _dec37$4, _dec38$4, _dec39$4, _dec40$4, _dec41$4, _dec42$4, _dec43$4, _dec44$3, _dec45$3, _dec46$2, _dec47$2, _dec48$1, _dec49$1, _dec50$1, _class$1h, _class2$16, _descriptor$15, _descriptor2$$, _descriptor3$P, _descriptor4$M, _descriptor5$E, _descriptor6$w, _descriptor7$p, _descriptor8$l, _descriptor9$g, _descriptor10$f, _descriptor11$e, _descriptor12$c, _descriptor13$9, _descriptor14$6, _descriptor15$5, _descriptor16$5, _descriptor17$4, _descriptor18$3, _descriptor19$2, _descriptor20$1, _descriptor21$1, _descriptor22$1, _descriptor23$1, _descriptor24$1, _descriptor25$1, _descriptor26$1, _descriptor27$1, _descriptor28$1, _descriptor29$1, _descriptor30$1, _descriptor31$1, _descriptor32$1, _descriptor33$1, _descriptor34$1, _descriptor35$1, _descriptor36$1, _descriptor37$1, _descriptor38$1, _descriptor39$1, _descriptor40$1, _descriptor41, _descriptor42, _descriptor43, _class3$n, _temp$1a;
            let ImageFormat;

            console.log('pptest importing cc 3.351');
            (function (ImageFormat) {
              ImageFormat[ImageFormat["JPG"] = 0] = "JPG";
              ImageFormat[ImageFormat["PNG"] = 1] = "PNG";
              ImageFormat[ImageFormat["TIFF"] = 2] = "TIFF";
              ImageFormat[ImageFormat["WEBP"] = 3] = "WEBP";
              ImageFormat[ImageFormat["PVR"] = 4] = "PVR";
              ImageFormat[ImageFormat["ETC"] = 5] = "ETC";
              ImageFormat[ImageFormat["S3TC"] = 6] = "S3TC";
              ImageFormat[ImageFormat["ATITC"] = 7] = "ATITC";
              ImageFormat[ImageFormat["TGA"] = 8] = "TGA";
              ImageFormat[ImageFormat["RAWDATA"] = 9] = "RAWDATA";
              ImageFormat[ImageFormat["UNKNOWN"] = 10] = "UNKNOWN";
            })(ImageFormat || (ImageFormat = {}));

            console.log('pptest importing cc 3.352');
            function getImageFormatByData(imgData) {
              if (imgData.length > 8 && imgData[0] === 0x89 && imgData[1] === 0x50 && imgData[2] === 0x4E && imgData[3] === 0x47 && imgData[4] === 0x0D && imgData[5] === 0x0A && imgData[6] === 0x1A && imgData[7] === 0x0A) {
                return ImageFormat.PNG;
              }

              if (imgData.length > 2 && (imgData[0] === 0x49 && imgData[1] === 0x49 || imgData[0] === 0x4d && imgData[1] === 0x4d || imgData[0] === 0xff && imgData[1] === 0xd8)) {
                return ImageFormat.TIFF;
              }

              return ImageFormat.UNKNOWN;
            }

            function getParticleComponents(node) {
              const parent = node.parent;
              const comp = node.getComponent(ParticleSystem2D);

              if (!parent || !comp) {
                return node.getComponentsInChildren(ParticleSystem2D);
              }

              return getParticleComponents(parent);
            }

            let ParticleSystem2D = exports('ParticleSystem2D', (_dec$1h = ccclass('cc.ParticleSystem2D'), _dec2$19 = menu$1(), _dec3$W = tooltip(), _dec4$S = type$1(ParticleAsset), _dec5$N = tooltip(), _dec6$I = type$1(SpriteFrame), _dec7$H = tooltip(), _dec8$D = tooltip(), _dec9$A = tooltip(), _dec10$y = tooltip(), _dec11$v = tooltip(), _dec12$u = tooltip(), _dec13$r = tooltip(), _dec14$n = tooltip(), _dec15$n = visible(), _dec16$m = tooltip(), _dec17$j = tooltip(), _dec18$i = tooltip(), _dec19$i = tooltip(), _dec20$h = tooltip(), _dec21$g = tooltip(), _dec22$f = tooltip(), _dec23$f = tooltip(), _dec24$d = tooltip(), _dec25$d = tooltip(), _dec26$c = tooltip(), _dec27$c = tooltip(), _dec28$b = tooltip(), _dec29$a = type$1(PositionType), _dec30$9 = tooltip(), _dec31$8 = tooltip(), _dec32$8 = type$1(EmitterMode), _dec33$6 = tooltip(), _dec34$5 = tooltip(), _dec35$4 = tooltip(), _dec36$4 = tooltip(), _dec37$4 = tooltip(), _dec38$4 = tooltip(), _dec39$4 = tooltip(), _dec40$4 = tooltip(), _dec41$4 = tooltip(), _dec42$4 = tooltip(), _dec43$4 = tooltip(), _dec44$3 = tooltip(), _dec45$3 = tooltip(), _dec46$2 = tooltip(), _dec47$2 = tooltip(), _dec48$1 = tooltip(), _dec49$1 = tooltip(), _dec50$1 = formerlySerializedAs('preview'), _dec$1h(_class$1h = _dec2$19(_class$1h = playOnFocus(_class$1h = executeInEditMode(_class$1h = (_class2$16 = (_temp$1a = _class3$n = class ParticleSystem2D extends Renderable2D {
              get custom() {
                return this._custom;
              }

              set custom(value) {

                if (this._custom !== value) {
                  this._custom = value;

                  this._applyFile();
                }
              }

              get file() {
                return this._file;
              }

              set file(value) {
                if (this._file !== value) {
                  this._file = value;

                  if (value) {
                    this._applyFile();
                  } else {
                    this.custom = true;
                  }
                }
              }

              get spriteFrame() {
                return this._spriteFrame;
              }

              set spriteFrame(value) {
                const lastSprite = this._renderSpriteFrame;

                if (lastSprite === value) {
                  return;
                }

                this._renderSpriteFrame = value;

                if (!value || value._uuid) {
                  this._spriteFrame = value;
                }

                this._applySpriteFrame();
              }

              get particleCount() {
                return this._simulator.particles.length;
              }

              get totalParticles() {
                return this._totalParticles;
              }

              set totalParticles(value) {
                if (this._totalParticles === value) return;
                this._totalParticles = value;
              }

              get startColor() {
                return this._startColor;
              }

              set startColor(val) {
                this._startColor.r = val.r;
                this._startColor.g = val.g;
                this._startColor.b = val.b;
                this._startColor.a = val.a;
              }

              get startColorVar() {
                return this._startColorVar;
              }

              set startColorVar(val) {
                this._startColorVar.r = val.r;
                this._startColorVar.g = val.g;
                this._startColorVar.b = val.b;
                this._startColorVar.a = val.a;
              }

              set color(value) {}

              get color() {
                return this._color;
              }

              get endColor() {
                return this._endColor;
              }

              set endColor(val) {
                this._endColor.r = val.r;
                this._endColor.g = val.g;
                this._endColor.b = val.b;
                this._endColor.a = val.a;
              }

              get endColorVar() {
                return this._endColorVar;
              }

              set endColorVar(val) {
                this._endColorVar.r = val.r;
                this._endColorVar.g = val.g;
                this._endColorVar.b = val.b;
                this._endColorVar.a = val.a;
              }

              get positionType() {
                return this._positionType;
              }

              set positionType(val) {
                this._positionType = val;

                this._updateMaterial();
              }

              get preview() {
                return this._preview;
              }

              set preview(val) {
                if (val) {
                  this._startPreview();
                } else {
                  this._stopPreview();
                }

                this._preview = val;
              }

              get stopped() {
                return this._stopped;
              }

              get active() {
                return this._simulator.active;
              }

              get assembler() {
                return this._assembler;
              }

              constructor() {
                super();

                _initializerDefineProperty(this, "duration", _descriptor$15, this);

                _initializerDefineProperty(this, "emissionRate", _descriptor2$$, this);

                _initializerDefineProperty(this, "life", _descriptor3$P, this);

                _initializerDefineProperty(this, "lifeVar", _descriptor4$M, this);

                _initializerDefineProperty(this, "angle", _descriptor5$E, this);

                _initializerDefineProperty(this, "angleVar", _descriptor6$w, this);

                _initializerDefineProperty(this, "startSize", _descriptor7$p, this);

                _initializerDefineProperty(this, "startSizeVar", _descriptor8$l, this);

                _initializerDefineProperty(this, "endSize", _descriptor9$g, this);

                _initializerDefineProperty(this, "endSizeVar", _descriptor10$f, this);

                _initializerDefineProperty(this, "startSpin", _descriptor11$e, this);

                _initializerDefineProperty(this, "startSpinVar", _descriptor12$c, this);

                _initializerDefineProperty(this, "endSpin", _descriptor13$9, this);

                _initializerDefineProperty(this, "endSpinVar", _descriptor14$6, this);

                _initializerDefineProperty(this, "sourcePos", _descriptor15$5, this);

                _initializerDefineProperty(this, "posVar", _descriptor16$5, this);

                _initializerDefineProperty(this, "emitterMode", _descriptor17$4, this);

                _initializerDefineProperty(this, "gravity", _descriptor18$3, this);

                _initializerDefineProperty(this, "speed", _descriptor19$2, this);

                _initializerDefineProperty(this, "speedVar", _descriptor20$1, this);

                _initializerDefineProperty(this, "tangentialAccel", _descriptor21$1, this);

                _initializerDefineProperty(this, "tangentialAccelVar", _descriptor22$1, this);

                _initializerDefineProperty(this, "radialAccel", _descriptor23$1, this);

                _initializerDefineProperty(this, "radialAccelVar", _descriptor24$1, this);

                _initializerDefineProperty(this, "rotationIsDir", _descriptor25$1, this);

                _initializerDefineProperty(this, "startRadius", _descriptor26$1, this);

                _initializerDefineProperty(this, "startRadiusVar", _descriptor27$1, this);

                _initializerDefineProperty(this, "endRadius", _descriptor28$1, this);

                _initializerDefineProperty(this, "endRadiusVar", _descriptor29$1, this);

                _initializerDefineProperty(this, "rotatePerS", _descriptor30$1, this);

                _initializerDefineProperty(this, "rotatePerSVar", _descriptor31$1, this);

                this.aspectRatio = 1;

                _initializerDefineProperty(this, "playOnLoad", _descriptor32$1, this);

                _initializerDefineProperty(this, "autoRemoveOnFinish", _descriptor33$1, this);

                _initializerDefineProperty(this, "_preview", _descriptor34$1, this);

                _initializerDefineProperty(this, "_custom", _descriptor35$1, this);

                _initializerDefineProperty(this, "_file", _descriptor36$1, this);

                _initializerDefineProperty(this, "_spriteFrame", _descriptor37$1, this);

                _initializerDefineProperty(this, "_totalParticles", _descriptor38$1, this);

                _initializerDefineProperty(this, "_startColor", _descriptor39$1, this);

                _initializerDefineProperty(this, "_startColorVar", _descriptor40$1, this);

                _initializerDefineProperty(this, "_endColor", _descriptor41, this);

                _initializerDefineProperty(this, "_endColorVar", _descriptor42, this);

                _initializerDefineProperty(this, "_positionType", _descriptor43, this);

                this._stopped = true;
                this.initProperties();
              }

              onEnable() {
                super.onEnable();

                this._updateMaterial();
              }

              onDestroy() {
                super.onDestroy();

                if (this.autoRemoveOnFinish) {
                  this.autoRemoveOnFinish = false;
                }

                this._simulator.uvFilled = 0;

                if (this._simulator.renderData && this._assembler) {
                  this._assembler.removeData(this._simulator.renderData);
                }
              }

              initProperties() {
                this._previewTimer = null;
                this._focused = false;
                this.aspectRatio = 1;
                this._simulator = new Simulator(this);
              }

              onFocusInEditor() {
                this._focused = true;
                const components = getParticleComponents(this.node);

                for (let i = 0; i < components.length; ++i) {
                  components[i]._startPreview();
                }
              }

              onLostFocusInEditor() {
                this._focused = false;
                const components = getParticleComponents(this.node);

                for (let i = 0; i < components.length; ++i) {
                  components[i]._stopPreview();
                }
              }

              _startPreview() {
                if (this._preview) {
                  this.resetSystem();
                }
              }

              _stopPreview() {
                if (this._preview) {
                  this.resetSystem();
                  this.stopSystem();
                }

                if (this._previewTimer) {
                  clearInterval(this._previewTimer);
                }
              }

              __preload() {
                super.__preload();

                if (this._custom && this.spriteFrame && !this._renderSpriteFrame) {
                  this._applySpriteFrame();
                } else if (this._file) {
                  if (this._custom) {
                    const missCustomTexture = !this._getTexture();

                    if (missCustomTexture) {
                      this._applyFile();
                    }
                  } else {
                    this._applyFile();
                  }
                }

                {
                  if (this.playOnLoad) {
                    this.resetSystem();
                  }
                }
              }

              _flushAssembler() {
                const assembler = ParticleSystem2D.Assembler.getAssembler(this);

                if (this._assembler !== assembler) {
                  this._assembler = assembler;
                }

                if (this._assembler && this._assembler.createData) {
                  this._simulator.renderData = this._assembler.createData(this);
                }
              }

              lateUpdate(dt) {
                if (!this._simulator.finished) {
                  this._simulator.step(dt);
                }
              }

              addParticle() {}

              stopSystem() {
                this._stopped = true;

                this._simulator.stop();
              }

              resetSystem() {
                this._stopped = false;

                this._simulator.reset();

                this._renderFlag = this._canRender();
              }

              isFull() {
                return this.particleCount >= this.totalParticles;
              }

              _applyFile() {
                const file = this._file;

                if (file) {
                  if (!file) {
                    errorID(6029);
                    return;
                  }

                  if (!this.isValid) {
                    return;
                  }

                  this._plistFile = file.nativeUrl;

                  if (!this._custom) {
                    const isDiffFrame = this._spriteFrame !== file.spriteFrame;
                    if (isDiffFrame) this.spriteFrame = file.spriteFrame;

                    this._initWithDictionary(file._nativeAsset);
                  }

                  if (!this._spriteFrame) {
                    if (file.spriteFrame) {
                      this.spriteFrame = file.spriteFrame;
                    } else if (this._custom) {
                      this._initTextureWithDictionary(file._nativeAsset);
                    }
                  } else if (!this._renderSpriteFrame && this._spriteFrame) {
                    this._applySpriteFrame();
                  }
                }
              }

              _initTextureWithDictionary(dict) {
                if (dict.spriteFrameUuid) {
                  const spriteFrameUuid = dict.spriteFrameUuid;
                  assetManager.loadAny(spriteFrameUuid, (err, spriteFrame) => {
                    if (err) {
                      dict.spriteFrameUuid = undefined;

                      this._initTextureWithDictionary(dict);

                      error(err);
                    } else {
                      this.spriteFrame = spriteFrame;
                    }
                  });
                } else {
                  const imgPath = changeBasename(this._plistFile, dict.textureFileName || '');

                  if (dict.textureFileName) {
                    assetManager.loadRemote(imgPath, (err, imageAsset) => {
                      if (err) {
                        dict.textureFileName = undefined;

                        this._initTextureWithDictionary(dict);

                        error(err);
                      } else {
                        if (imageAsset) {
                          this.spriteFrame = SpriteFrame.createWithImage(imageAsset);
                        } else {
                          this.spriteFrame = SpriteFrame.createWithImage(builtinResMgr.get('white-texture'));
                        }
                      }
                    });
                  } else if (dict.textureImageData) {
                    const textureData = dict.textureImageData;

                    if (textureData && textureData.length > 0) {
                      let imageAsset = assetManager.assets.get(imgPath);

                      if (!imageAsset) {
                        const buffer = codec.unzipBase64AsArray(textureData, 1);

                        if (!buffer) {
                          warnID(6030, this._file.name);
                          return false;
                        }

                        const imageFormat = getImageFormatByData(buffer);

                        if (imageFormat !== ImageFormat.TIFF && imageFormat !== ImageFormat.PNG) {
                          warnID(6031, this._file.name);
                          return false;
                        }

                        const canvasObj = document.createElement('canvas');

                        if (imageFormat === ImageFormat.PNG) {
                          const myPngObj = new PNGReader(buffer);
                          myPngObj.render(canvasObj);
                        } else {
                          if (!this._tiffReader) {
                            this._tiffReader = new TiffReader();
                          }

                          this._tiffReader.parseTIFF(buffer, canvasObj);
                        }

                        imageAsset = new ImageAsset(canvasObj);
                        assetManager.assets.add(imgPath, imageAsset);
                      }

                      if (!imageAsset) {
                        warnID(6032, this._file.name);
                      }

                      if (imageAsset) {
                        this.spriteFrame = SpriteFrame.createWithImage(imageAsset);
                      } else {
                        this.spriteFrame = SpriteFrame.createWithImage(builtinResMgr.get('white-texture'));
                      }
                    } else {
                      return false;
                    }
                  }
                }

                return true;
              }

              _initWithDictionary(dict) {
                this.totalParticles = parseInt(dict.maxParticles || 0);
                this.life = parseFloat(dict.particleLifespan || 0);
                this.lifeVar = parseFloat(dict.particleLifespanVariance || 0);
                const _tempEmissionRate = dict.emissionRate;

                if (_tempEmissionRate) {
                  this.emissionRate = _tempEmissionRate;
                } else {
                  this.emissionRate = Math.min(this.totalParticles / this.life, Number.MAX_VALUE);
                }

                this.duration = parseFloat(dict.duration || 0);
                this._srcBlendFactor = parseInt(dict.blendFuncSource || BlendFactor.SRC_ALPHA);
                this._dstBlendFactor = parseInt(dict.blendFuncDestination || BlendFactor.ONE_MINUS_SRC_ALPHA);
                const locStartColor = this._startColor;
                locStartColor.r = parseFloat(dict.startColorRed || 0) * 255;
                locStartColor.g = parseFloat(dict.startColorGreen || 0) * 255;
                locStartColor.b = parseFloat(dict.startColorBlue || 0) * 255;
                locStartColor.a = parseFloat(dict.startColorAlpha || 0) * 255;
                const locStartColorVar = this._startColorVar;
                locStartColorVar.r = parseFloat(dict.startColorVarianceRed || 0) * 255;
                locStartColorVar.g = parseFloat(dict.startColorVarianceGreen || 0) * 255;
                locStartColorVar.b = parseFloat(dict.startColorVarianceBlue || 0) * 255;
                locStartColorVar.a = parseFloat(dict.startColorVarianceAlpha || 0) * 255;
                const locEndColor = this._endColor;
                locEndColor.r = parseFloat(dict.finishColorRed || 0) * 255;
                locEndColor.g = parseFloat(dict.finishColorGreen || 0) * 255;
                locEndColor.b = parseFloat(dict.finishColorBlue || 0) * 255;
                locEndColor.a = parseFloat(dict.finishColorAlpha || 0) * 255;
                const locEndColorVar = this._endColorVar;
                locEndColorVar.r = parseFloat(dict.finishColorVarianceRed || 0) * 255;
                locEndColorVar.g = parseFloat(dict.finishColorVarianceGreen || 0) * 255;
                locEndColorVar.b = parseFloat(dict.finishColorVarianceBlue || 0) * 255;
                locEndColorVar.a = parseFloat(dict.finishColorVarianceAlpha || 0) * 255;
                this.startSize = parseFloat(dict.startParticleSize || 0);
                this.startSizeVar = parseFloat(dict.startParticleSizeVariance || 0);
                this.endSize = parseFloat(dict.finishParticleSize || 0);
                this.endSizeVar = parseFloat(dict.finishParticleSizeVariance || 0);
                this.positionType = parseFloat(dict.positionType !== undefined ? dict.positionType : PositionType.FREE);
                this.sourcePos.set(0, 0);
                this.posVar.set(parseFloat(dict.sourcePositionVariancex || 0), parseFloat(dict.sourcePositionVariancey || 0));
                this.angle = parseFloat(dict.angle || 0);
                this.angleVar = parseFloat(dict.angleVariance || 0);
                this.startSpin = parseFloat(dict.rotationStart || 0);
                this.startSpinVar = parseFloat(dict.rotationStartVariance || 0);
                this.endSpin = parseFloat(dict.rotationEnd || 0);
                this.endSpinVar = parseFloat(dict.rotationEndVariance || 0);
                this.emitterMode = parseInt(dict.emitterType || EmitterMode.GRAVITY);

                if (this.emitterMode === EmitterMode.GRAVITY) {
                  this.gravity.set(parseFloat(dict.gravityx || 0), parseFloat(dict.gravityy || 0));
                  this.speed = parseFloat(dict.speed || 0);
                  this.speedVar = parseFloat(dict.speedVariance || 0);
                  this.radialAccel = parseFloat(dict.radialAcceleration || 0);
                  this.radialAccelVar = parseFloat(dict.radialAccelVariance || 0);
                  this.tangentialAccel = parseFloat(dict.tangentialAcceleration || 0);
                  this.tangentialAccelVar = parseFloat(dict.tangentialAccelVariance || 0);
                  let locRotationIsDir = dict.rotationIsDir || '';

                  if (locRotationIsDir !== null) {
                    locRotationIsDir = locRotationIsDir.toString().toLowerCase();
                    this.rotationIsDir = locRotationIsDir === 'true' || locRotationIsDir === '1';
                  } else {
                    this.rotationIsDir = false;
                  }
                } else if (this.emitterMode === EmitterMode.RADIUS) {
                  this.startRadius = parseFloat(dict.maxRadius || 0);
                  this.startRadiusVar = parseFloat(dict.maxRadiusVariance || 0);
                  this.endRadius = parseFloat(dict.minRadius || 0);
                  this.endRadiusVar = parseFloat(dict.minRadiusVariance || 0);
                  this.rotatePerS = parseFloat(dict.rotatePerSecond || 0);
                  this.rotatePerSVar = parseFloat(dict.rotatePerSecondVariance || 0);
                } else {
                  warnID(6009);
                  return false;
                }

                this._initTextureWithDictionary(dict);

                return true;
              }

              _syncAspect() {
                if (this._renderSpriteFrame) {
                  const frameRect = this._renderSpriteFrame.rect;
                  this.aspectRatio = frameRect.width / frameRect.height;
                }
              }

              _applySpriteFrame() {
                this._renderSpriteFrame = this._renderSpriteFrame || this._spriteFrame;

                if (this._renderSpriteFrame) {
                  if (this._renderSpriteFrame.texture) {
                    this._simulator.updateUVs(true);

                    this._syncAspect();

                    this._updateMaterial();

                    this._stopped = false;
                    this._renderFlag = this._canRender();
                  }
                } else {
                  this.resetSystem();
                }
              }

              _getTexture() {
                return this._renderSpriteFrame && this._renderSpriteFrame.texture;
              }

              _updateMaterial() {
                const mat = this.getMaterialInstance(0);
                if (mat) mat.recompileShaders({
                  USE_LOCAL: this._positionType !== PositionType.FREE
                });
              }

              _finishedSimulation() {

                this.resetSystem();
                this.stopSystem();
                this._renderFlag = this._canRender();

                if (this.autoRemoveOnFinish && this._stopped) {
                  this.node.destroy();
                }
              }

              _canRender() {
                return super._canRender() && !this._stopped && this._renderSpriteFrame !== null;
              }

              _render(render) {
                if (this._positionType === PositionType.RELATIVE) {
                  render.commitComp(this, this._renderSpriteFrame, this._assembler, this.node.parent);
                } else if (this.positionType === PositionType.GROUPED) {
                  render.commitComp(this, this._renderSpriteFrame, this._assembler, this.node);
                } else {
                  render.commitComp(this, this._renderSpriteFrame, this._assembler, null);
                }
              }

            }, _class3$n.EmitterMode = EmitterMode, _class3$n.PositionType = PositionType, _class3$n.DURATION_INFINITY = DURATION_INFINITY, _class3$n.START_SIZE_EQUAL_TO_END_SIZE = START_SIZE_EQUAL_TO_END_SIZE, _class3$n.START_RADIUS_EQUAL_TO_END_RADIUS = START_RADIUS_EQUAL_TO_END_RADIUS, _temp$1a), (_applyDecoratedDescriptor(_class2$16.prototype, "custom", [editable, _dec3$W], Object.getOwnPropertyDescriptor(_class2$16.prototype, "custom"), _class2$16.prototype), _applyDecoratedDescriptor(_class2$16.prototype, "file", [_dec4$S, _dec5$N], Object.getOwnPropertyDescriptor(_class2$16.prototype, "file"), _class2$16.prototype), _applyDecoratedDescriptor(_class2$16.prototype, "spriteFrame", [_dec6$I, _dec7$H], Object.getOwnPropertyDescriptor(_class2$16.prototype, "spriteFrame"), _class2$16.prototype), _applyDecoratedDescriptor(_class2$16.prototype, "totalParticles", [editable, _dec8$D], Object.getOwnPropertyDescriptor(_class2$16.prototype, "totalParticles"), _class2$16.prototype), _descriptor$15 = _applyDecoratedDescriptor(_class2$16.prototype, "duration", [serializable, editable, _dec9$A], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return -1;
              }
            }), _descriptor2$$ = _applyDecoratedDescriptor(_class2$16.prototype, "emissionRate", [serializable, editable, _dec10$y], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 10;
              }
            }), _descriptor3$P = _applyDecoratedDescriptor(_class2$16.prototype, "life", [serializable, editable, _dec11$v], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            }), _descriptor4$M = _applyDecoratedDescriptor(_class2$16.prototype, "lifeVar", [serializable, editable, _dec12$u], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _applyDecoratedDescriptor(_class2$16.prototype, "startColor", [editable, _dec13$r], Object.getOwnPropertyDescriptor(_class2$16.prototype, "startColor"), _class2$16.prototype), _applyDecoratedDescriptor(_class2$16.prototype, "startColorVar", [editable, _dec14$n], Object.getOwnPropertyDescriptor(_class2$16.prototype, "startColorVar"), _class2$16.prototype), _applyDecoratedDescriptor(_class2$16.prototype, "color", [_dec15$n], Object.getOwnPropertyDescriptor(_class2$16.prototype, "color"), _class2$16.prototype), _applyDecoratedDescriptor(_class2$16.prototype, "endColor", [editable, _dec16$m], Object.getOwnPropertyDescriptor(_class2$16.prototype, "endColor"), _class2$16.prototype), _applyDecoratedDescriptor(_class2$16.prototype, "endColorVar", [editable, _dec17$j], Object.getOwnPropertyDescriptor(_class2$16.prototype, "endColorVar"), _class2$16.prototype), _descriptor5$E = _applyDecoratedDescriptor(_class2$16.prototype, "angle", [serializable, editable, _dec18$i], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 90;
              }
            }), _descriptor6$w = _applyDecoratedDescriptor(_class2$16.prototype, "angleVar", [serializable, editable, _dec19$i], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 20;
              }
            }), _descriptor7$p = _applyDecoratedDescriptor(_class2$16.prototype, "startSize", [serializable, editable, _dec20$h], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 50;
              }
            }), _descriptor8$l = _applyDecoratedDescriptor(_class2$16.prototype, "startSizeVar", [serializable, editable, _dec21$g], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor9$g = _applyDecoratedDescriptor(_class2$16.prototype, "endSize", [serializable, editable, _dec22$f], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor10$f = _applyDecoratedDescriptor(_class2$16.prototype, "endSizeVar", [serializable, editable, _dec23$f], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor11$e = _applyDecoratedDescriptor(_class2$16.prototype, "startSpin", [serializable, editable, _dec24$d], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor12$c = _applyDecoratedDescriptor(_class2$16.prototype, "startSpinVar", [serializable, editable, _dec25$d], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor13$9 = _applyDecoratedDescriptor(_class2$16.prototype, "endSpin", [serializable, editable, _dec26$c], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor14$6 = _applyDecoratedDescriptor(_class2$16.prototype, "endSpinVar", [serializable, editable, _dec27$c], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor15$5 = _applyDecoratedDescriptor(_class2$16.prototype, "sourcePos", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Vec2.ZERO.clone();
              }
            }), _descriptor16$5 = _applyDecoratedDescriptor(_class2$16.prototype, "posVar", [serializable, editable, _dec28$b], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Vec2.ZERO.clone();
              }
            }), _applyDecoratedDescriptor(_class2$16.prototype, "positionType", [_dec29$a, _dec30$9], Object.getOwnPropertyDescriptor(_class2$16.prototype, "positionType"), _class2$16.prototype), _applyDecoratedDescriptor(_class2$16.prototype, "preview", [editable, _dec31$8], Object.getOwnPropertyDescriptor(_class2$16.prototype, "preview"), _class2$16.prototype), _descriptor17$4 = _applyDecoratedDescriptor(_class2$16.prototype, "emitterMode", [serializable, editable, _dec32$8, _dec33$6], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return EmitterMode.GRAVITY;
              }
            }), _descriptor18$3 = _applyDecoratedDescriptor(_class2$16.prototype, "gravity", [serializable, editable, _dec34$5], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return Vec2.ZERO.clone();
              }
            }), _descriptor19$2 = _applyDecoratedDescriptor(_class2$16.prototype, "speed", [serializable, editable, _dec35$4], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 180;
              }
            }), _descriptor20$1 = _applyDecoratedDescriptor(_class2$16.prototype, "speedVar", [serializable, editable, _dec36$4], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 50;
              }
            }), _descriptor21$1 = _applyDecoratedDescriptor(_class2$16.prototype, "tangentialAccel", [serializable, editable, _dec37$4], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 80;
              }
            }), _descriptor22$1 = _applyDecoratedDescriptor(_class2$16.prototype, "tangentialAccelVar", [serializable, editable, _dec38$4], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor23$1 = _applyDecoratedDescriptor(_class2$16.prototype, "radialAccel", [serializable, editable, _dec39$4], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor24$1 = _applyDecoratedDescriptor(_class2$16.prototype, "radialAccelVar", [serializable, editable, _dec40$4], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor25$1 = _applyDecoratedDescriptor(_class2$16.prototype, "rotationIsDir", [serializable, editable, _dec41$4], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor26$1 = _applyDecoratedDescriptor(_class2$16.prototype, "startRadius", [serializable, editable, _dec42$4], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor27$1 = _applyDecoratedDescriptor(_class2$16.prototype, "startRadiusVar", [serializable, editable, _dec43$4], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor28$1 = _applyDecoratedDescriptor(_class2$16.prototype, "endRadius", [serializable, editable, _dec44$3], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor29$1 = _applyDecoratedDescriptor(_class2$16.prototype, "endRadiusVar", [serializable, editable, _dec45$3], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor30$1 = _applyDecoratedDescriptor(_class2$16.prototype, "rotatePerS", [serializable, editable, _dec46$2], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor31$1 = _applyDecoratedDescriptor(_class2$16.prototype, "rotatePerSVar", [serializable, editable, _dec47$2], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor32$1 = _applyDecoratedDescriptor(_class2$16.prototype, "playOnLoad", [serializable, editable, _dec48$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _descriptor33$1 = _applyDecoratedDescriptor(_class2$16.prototype, "autoRemoveOnFinish", [serializable, editable, _dec49$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor34$1 = _applyDecoratedDescriptor(_class2$16.prototype, "_preview", [_dec50$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _descriptor35$1 = _applyDecoratedDescriptor(_class2$16.prototype, "_custom", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor36$1 = _applyDecoratedDescriptor(_class2$16.prototype, "_file", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor37$1 = _applyDecoratedDescriptor(_class2$16.prototype, "_spriteFrame", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor38$1 = _applyDecoratedDescriptor(_class2$16.prototype, "_totalParticles", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 150;
              }
            }), _descriptor39$1 = _applyDecoratedDescriptor(_class2$16.prototype, "_startColor", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Color$1(255, 255, 255, 255);
              }
            }), _descriptor40$1 = _applyDecoratedDescriptor(_class2$16.prototype, "_startColorVar", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Color$1(0, 0, 0, 0);
              }
            }), _descriptor41 = _applyDecoratedDescriptor(_class2$16.prototype, "_endColor", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Color$1(255, 255, 255, 0);
              }
            }), _descriptor42 = _applyDecoratedDescriptor(_class2$16.prototype, "_endColorVar", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return new Color$1(0, 0, 0, 0);
              }
            }), _descriptor43 = _applyDecoratedDescriptor(_class2$16.prototype, "_positionType", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return PositionType.FREE;
              }
            })), _class2$16)) || _class$1h) || _class$1h) || _class$1h) || _class$1h));

            var _dec$1i, _dec2$1a, _dec3$X, _dec4$T, _class$1i, _class2$17, _descriptor$16, _descriptor2$10, _descriptor3$Q, _descriptor4$N, _descriptor5$F, _descriptor6$x, _class3$o, _temp$1b;

            class Point$1 {
              constructor(point, dir) {
                this.point = new Vec2();
                this.dir = new Vec2();
                this.distance = 0;
                this.time = 0;
                if (point) this.point.set(point);
                if (dir) this.dir.set(dir);
              }

              setPoint(x, y) {
                this.point.x = x;
                this.point.y = y;
              }

              setDir(x, y) {
                this.dir.x = x;
                this.dir.y = y;
              }

            }

            let MotionStreak = exports('MotionStreak', (_dec$1i = ccclass('cc.MotionStreak'), _dec2$1a = menu$1(), _dec3$X = help(), _dec4$T = type$1(Texture2D), _dec$1i(_class$1i = executeInEditMode(_class$1i = playOnFocus(_class$1i = _dec2$1a(_class$1i = _dec3$X(_class$1i = (_class2$17 = (_temp$1b = _class3$o = class MotionStreak extends Renderable2D {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "_preview", _descriptor$16, this);

                _initializerDefineProperty(this, "_fadeTime", _descriptor2$10, this);

                _initializerDefineProperty(this, "_minSeg", _descriptor3$Q, this);

                _initializerDefineProperty(this, "_stroke", _descriptor4$N, this);

                _initializerDefineProperty(this, "_texture", _descriptor5$F, this);

                _initializerDefineProperty(this, "_fastMode", _descriptor6$x, this);

                this._points = [];
              }

              get preview() {
                return this._preview;
              }

              set preview(val) {
                this._preview = val;
                this.reset();
              }

              get fadeTime() {
                return this._fadeTime;
              }

              set fadeTime(val) {
                this._fadeTime = val;
                this.reset();
              }

              get minSeg() {
                return this._minSeg;
              }

              set minSeg(val) {
                this._minSeg = val;
              }

              get stroke() {
                return this._stroke;
              }

              set stroke(val) {
                this._stroke = val;
              }

              get texture() {
                return this._texture;
              }

              set texture(val) {
                if (this._texture === val) return;
                this._texture = val;
              }

              get fastMode() {
                return this._fastMode;
              }

              set fastMode(val) {
                this._fastMode = val;
              }

              get points() {
                return this._points;
              }

              onEnable() {
                super.onEnable();
                this.reset();
              }

              _flushAssembler() {
                const assembler = MotionStreak.Assembler.getAssembler(this);

                if (this._assembler !== assembler) {
                  this._assembler = assembler;
                }

                if (!this._renderData) {
                  if (this._assembler && this._assembler.createData) {
                    this._renderData = this._assembler.createData(this);
                    this._renderData.material = this.material;
                  }
                }
              }

              onFocusInEditor() {
                if (this._preview) {
                  this.reset();
                }
              }

              onLostFocusInEditor() {
                if (this._preview) {
                  this.reset();
                }
              }

              reset() {
                this._points.length = 0;
                if (this._renderData) this._renderData.clear();
              }

              lateUpdate(dt) {
                if (this._assembler) this._assembler.update(this, dt);
              }

              _render(render) {
                render.commitComp(this, this._texture, this._assembler, null);
              }

            }, _class3$o.Point = Point$1, _temp$1b), (_applyDecoratedDescriptor(_class2$17.prototype, "preview", [editable], Object.getOwnPropertyDescriptor(_class2$17.prototype, "preview"), _class2$17.prototype), _applyDecoratedDescriptor(_class2$17.prototype, "fadeTime", [editable], Object.getOwnPropertyDescriptor(_class2$17.prototype, "fadeTime"), _class2$17.prototype), _applyDecoratedDescriptor(_class2$17.prototype, "minSeg", [editable], Object.getOwnPropertyDescriptor(_class2$17.prototype, "minSeg"), _class2$17.prototype), _applyDecoratedDescriptor(_class2$17.prototype, "stroke", [editable], Object.getOwnPropertyDescriptor(_class2$17.prototype, "stroke"), _class2$17.prototype), _applyDecoratedDescriptor(_class2$17.prototype, "texture", [_dec4$T], Object.getOwnPropertyDescriptor(_class2$17.prototype, "texture"), _class2$17.prototype), _applyDecoratedDescriptor(_class2$17.prototype, "fastMode", [editable], Object.getOwnPropertyDescriptor(_class2$17.prototype, "fastMode"), _class2$17.prototype), _descriptor$16 = _applyDecoratedDescriptor(_class2$17.prototype, "_preview", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor2$10 = _applyDecoratedDescriptor(_class2$17.prototype, "_fadeTime", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            }), _descriptor3$Q = _applyDecoratedDescriptor(_class2$17.prototype, "_minSeg", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            }), _descriptor4$N = _applyDecoratedDescriptor(_class2$17.prototype, "_stroke", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 64;
              }
            }), _descriptor5$F = _applyDecoratedDescriptor(_class2$17.prototype, "_texture", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor6$x = _applyDecoratedDescriptor(_class2$17.prototype, "_fastMode", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            })), _class2$17)) || _class$1i) || _class$1i) || _class$1i) || _class$1i) || _class$1i));

            const _tangent = new Vec2();

            const _normal = new Vec2();

            const _vec2 = new Vec2();

            function normal(out, dir) {
              out.x = -dir.y;
              out.y = dir.x;
              return out;
            }

            const MotionStreakAssembler = {
              createData(comp) {
                const renderData = comp.requestRenderData();
                renderData.dataLength = 4;
                renderData.vertexCount = 16;
                renderData.indicesCount = (16 - 2) * 3;
                return renderData;
              },

              update(comp, dt) {
                const stroke = comp.stroke / 2;
                const node = comp.node;
                const matrix = node.worldMatrix;
                const tx = matrix.m12;
                const ty = matrix.m13;
                const points = comp.points;
                let cur;

                if (points.length > 1) {
                  const point = points[0];
                  const difx = point.point.x - tx;
                  const dify = point.point.y - ty;

                  if (difx * difx + dify * dify < comp.minSeg) {
                    cur = point;
                  }
                }

                if (!cur) {
                  cur = new MotionStreak.Point();
                  points.unshift(cur);
                }

                cur.setPoint(tx, ty);
                cur.time = comp.fadeTime + dt;
                let verticesCount = 0;
                let indicesCount = 0;

                if (points.length < 2) {
                  return;
                }

                const renderData = comp.renderData;
                this.updateRenderDataCache(comp, renderData);
                const color = comp.color;
                const cr = color.r;
                const cg = color.g;
                const cb = color.b;
                const ca = color.a;
                const prev = points[1];
                prev.distance = Vec2.subtract(_vec2, cur.point, prev.point).length();

                _vec2.normalize();

                prev.setDir(_vec2.x, _vec2.y);
                cur.setDir(_vec2.x, _vec2.y);
                renderData.dataLength = points.length * 2;
                const data = renderData.data;
                const fadeTime = comp.fadeTime;
                let findLast = false;

                for (let i = points.length - 1; i >= 0; i--) {
                  const p = points[i];
                  const point = p.point;
                  const dir = p.dir;
                  p.time -= dt;

                  if (p.time < 0) {
                    points.splice(i, 1);
                    continue;
                  }

                  const progress = p.time / fadeTime;
                  const next = points[i - 1];

                  if (!findLast) {
                    if (!next) {
                      points.splice(i, 1);
                      continue;
                    }

                    point.x = next.point.x - dir.x * progress;
                    point.y = next.point.y - dir.y * progress;
                  }

                  findLast = true;
                  normal(_normal, dir);
                  const da = progress * ca;
                  const c = (da << 24 >>> 0) + (cb << 16) + (cg << 8) + cr;
                  let offset = verticesCount;
                  data[offset].x = point.x + _normal.x * stroke;
                  data[offset].y = point.y + _normal.y * stroke;
                  data[offset].u = 1;
                  data[offset].v = progress;
                  data[offset].color._val = c;
                  offset += 1;
                  data[offset].x = point.x - _normal.x * stroke;
                  data[offset].y = point.y - _normal.y * stroke;
                  data[offset].u = 0;
                  data[offset].v = progress;
                  data[offset].color._val = c;
                  verticesCount += 2;
                }

                indicesCount = verticesCount <= 2 ? 0 : (verticesCount - 2) * 3;
                renderData.vertexCount = verticesCount;
                renderData.indicesCount = indicesCount;
              },

              updateRenderDataCache(comp, renderData) {
                if (renderData.passDirty) {
                  renderData.updatePass(comp);
                }

                if (renderData.nodeDirty) {
                  renderData.updateNode(comp);
                }

                if (renderData.textureDirty && comp.texture) {
                  renderData.updateTexture(comp.texture);
                  renderData.material = comp.getRenderMaterial(0);
                }

                if (renderData.hashDirty) {
                  renderData.updateHash();
                }
              },

              updateRenderData(comp) {},

              fillBuffers(comp, renderer) {
                const renderData = comp.renderData;
                const dataList = renderData.data;
                const node = comp.node;
                let buffer = renderer.acquireBufferBatch();
                let vertexOffset = buffer.byteOffset >> 2;
                let indicesOffset = buffer.indicesOffset;
                let vertexId = buffer.vertexOffset;
                const isRecreate = buffer.request(renderData.vertexCount, renderData.indicesCount);

                if (!isRecreate) {
                  buffer = renderer.currBufferBatch;
                  indicesOffset = 0;
                  vertexId = 0;
                }

                const vBuf = buffer.vData;
                const iBuf = buffer.iData;
                const vertexCount = renderData.vertexCount;
                const indicesCount = renderData.indicesCount;

                for (let i = 0; i < vertexCount; i++) {
                  const vert = dataList[i];
                  vBuf[vertexOffset++] = vert.x;
                  vBuf[vertexOffset++] = vert.y;
                  vBuf[vertexOffset++] = vert.z;
                  vBuf[vertexOffset++] = vert.u;
                  vBuf[vertexOffset++] = vert.v;
                  Color$1.toArray(vBuf, vert.color, vertexOffset);
                  vertexOffset += 4;
                }

                for (let i = 0, l = indicesCount; i < l; i += 2) {
                  const start = vertexId + i;
                  iBuf[indicesOffset++] = start;
                  iBuf[indicesOffset++] = start + 2;
                  iBuf[indicesOffset++] = start + 1;
                  iBuf[indicesOffset++] = start + 1;
                  iBuf[indicesOffset++] = start + 2;
                  iBuf[indicesOffset++] = start + 3;
                }
              }

            };
            const MotionStreakAssemblerManager = exports('MotionStreakAssemblerManager', {
              getAssembler(comp) {
                return MotionStreakAssembler;
              }

            });
            MotionStreak.Assembler = MotionStreakAssemblerManager;

            const ParticleAssembler = {
              maxParticleDeltaTime: 0,

              createData(comp) {
                return MeshRenderData.add();
              },

              removeData(data) {
                MeshRenderData.remove(data);
              },

              updateRenderData() {},

              fillBuffers(comp, renderer) {
                if (comp === null) {
                  return;
                }

                const renderData = comp._simulator.renderData;

                if (renderData.vertexCount === 0 || renderData.indicesCount === 0) {
                  return;
                }

                let buffer = renderer.acquireBufferBatch();
                let vertexOffset = buffer.byteOffset >> 2;
                let indicesOffset = buffer.indicesOffset;
                let vertexId = buffer.vertexOffset;
                const isRecreate = buffer.request(renderData.vertexCount, renderData.indicesCount);

                if (!isRecreate) {
                  buffer = renderer.currBufferBatch;
                  vertexOffset = 0;
                  indicesOffset = 0;
                  vertexId = 0;
                }

                const vBuf = buffer.vData;
                const iBuf = buffer.iData;
                const vData = renderData.vData;
                const iData = renderData.iData;
                const vLen = renderData.vertexCount * 9;

                for (let i = 0; i < vLen; i++) {
                  vBuf[vertexOffset++] = vData[i];
                }

                const iLen = renderData.indicesCount;

                for (let i = 0; i < iLen; i++) {
                  iBuf[indicesOffset++] = iData[i] + vertexId;
                }
              }

            };
            const ParticleSystem2DAssembler = exports('ParticleSystem2DAssembler', {
              getAssembler(comp) {
                if (!ParticleAssembler.maxParticleDeltaTime) {
                  ParticleAssembler.maxParticleDeltaTime = legacyCC.game.frameTime / 1000 * 2;
                }

                return ParticleAssembler;
              }

            });
            ParticleSystem2D.Assembler = ParticleSystem2DAssembler;

            let AudioEvent;

            console.log('pptest importing cc 3.353');
            (function (AudioEvent) {
              AudioEvent["PLAYED"] = "play";
              AudioEvent["PAUSED"] = "pause";
              AudioEvent["STOPPED"] = "stop";
              AudioEvent["SEEKED"] = "seeked";
              AudioEvent["ENDED"] = "ended";
              AudioEvent["INTERRUPTION_BEGIN"] = "interruptionBegin";
              AudioEvent["INTERRUPTION_END"] = "interruptionEnd";
              AudioEvent["USER_GESTURE"] = "on_gesture";
            })(AudioEvent || (AudioEvent = {}));
            console.log('pptest importing cc 3.354');

            let AudioType = {};

            console.log('pptest importing cc 3.355');
            // (function (AudioType) {
              AudioType[AudioType["DOM_AUDIO"] = 0] = "DOM_AUDIO";
              AudioType[AudioType["WEB_AUDIO"] = 1] = "WEB_AUDIO";
              AudioType[AudioType["MINIGAME_AUDIO"] = 2] = "MINIGAME_AUDIO";
              AudioType[AudioType["NATIVE_AUDIO"] = 3] = "NATIVE_AUDIO";
              AudioType[AudioType["UNKNOWN_AUDIO"] = 4] = "UNKNOWN_AUDIO";
            // })(AudioType || (AudioType = {}));
            console.log('pptest importing cc 3.356');

            let AudioState = {};

            console.log('pptest importing cc 3.357');
            // (function (AudioState) {
              AudioState[AudioState["INIT"] = 0] = "INIT";
              AudioState[AudioState["PLAYING"] = 1] = "PLAYING";
              AudioState[AudioState["PAUSED"] = 2] = "PAUSED";
              AudioState[AudioState["STOPPED"] = 3] = "STOPPED";
              AudioState[AudioState["INTERRUPTED"] = 4] = "INTERRUPTED";
            // })(AudioState || (AudioState = {}));
            console.log('pptest importing cc 3.358');

            let operationId = 0;

            function _tryCallingRecursively(target, opInfo) {
              if (opInfo.invoking) {
                return;
              }

              opInfo.invoking = true;
              opInfo.func.call(target, ...opInfo.args).then(() => {
                opInfo.invoking = false;

                target._operationQueue.shift();

                target._eventTarget.emit(opInfo.id.toString());

                const nextOpInfo = target._operationQueue[0];
                nextOpInfo && _tryCallingRecursively(target, nextOpInfo);
              }).catch(e => {});
            }

            function enqueueOperation(target, propertyKey, descriptor) {
              const originalOperation = descriptor.value;

              descriptor.value = function (...args) {
                return new Promise(resolve => {
                  const id = operationId++;
                  const instance = this;

                  instance._operationQueue.push({
                    id,
                    func: originalOperation,
                    args,
                    invoking: false
                  });

                  instance._eventTarget.once(id.toString(), resolve);

                  const opInfo = instance._operationQueue[0];

                  _tryCallingRecursively(instance, opInfo);
                });
              };
            }

            var _class$1j, _class2$18, _temp$1c;
            const audioEngine = jsb.AudioEngine;
            const urlCount = {};
            const INVALID_AUDIO_ID = -1;
            class OneShotAudio {
              get onPlay() {
                return this._onPlayCb;
              }

              set onPlay(cb) {
                this._onPlayCb = cb;
              }

              get onEnd() {
                return this._onEndCb;
              }

              set onEnd(cb) {
                this._onEndCb = cb;
              }

              constructor(url, volume) {
                this._id = INVALID_AUDIO_ID;
                this._url = void 0;
                this._volume = void 0;
                this._onPlayCb = void 0;
                this._onEndCb = void 0;
                this._url = url;
                this._volume = volume;
              }

              play() {
                var _this$onPlay;

                console.log('pptest play oneShotAudio ' + this._url);
                this._id = jsb.AudioEngine.play2d(this._url, false, this._volume);
                jsb.AudioEngine.setFinishCallback(this._id, () => {
                  var _this$onEnd;

                  (_this$onEnd = this.onEnd) === null || _this$onEnd === void 0 ? void 0 : _this$onEnd.call(this);
                });
                (_this$onPlay = this.onPlay) === null || _this$onPlay === void 0 ? void 0 : _this$onPlay.call(this);
              }

              stop() {
                if (this._id === INVALID_AUDIO_ID) {
                  return;
                }

                jsb.AudioEngine.stop(this._id);
              }

            }
            let AudioPlayer = (_class$1j = (_temp$1c = _class2$18 = class AudioPlayer {
              constructor(url) {
                this._url = void 0;
                this._id = INVALID_AUDIO_ID;
                this._state = AudioState.INIT;
                this._eventTarget = new EventTarget();
                this._operationQueue = [];
                this._cachedState = {
                  duration: 1,
                  loop: false,
                  currentTime: 0,
                  volume: 1
                };
                this._url = url;
                systemInfo.on('hide', this._onHide, this);
                systemInfo.on('show', this._onShow, this);
              }

              destroy() {
                systemInfo.on('hide', this._onHide, this);
                systemInfo.on('show', this._onShow, this);

                if (--urlCount[this._url] <= 0) {
                  audioEngine.uncache(this._url);
                }
              }

              _onHide() {
                if (this._state === AudioState.PLAYING) {
                  this.pause().then(() => {
                    this._state = AudioState.INTERRUPTED;

                    this._eventTarget.emit(AudioEvent.INTERRUPTION_BEGIN);
                  }).catch(e => {});
                }
              }

              _onShow() {
                if (this._state === AudioState.INTERRUPTED) {
                  this.play().then(() => {
                    this._eventTarget.emit(AudioEvent.INTERRUPTION_END);
                  }).catch(e => {});
                }
              }

              static load(url) {
                return new Promise((resolve, reject) => {
                  AudioPlayer.loadNative(url).then(url => {
                    resolve(new AudioPlayer(url));
                  }).catch(err => reject(err));
                });
              }

              static loadNative(url) {
                return new Promise((resolve, reject) => {
                  resolve(url);
                  // if (systemInfo.platform === Platform.WIN32) {
                  //   resolve(url);
                  // } else {
                  //   audioEngine.preload(url, isSuccess => {
                  //     if (isSuccess) {
                  //       resolve(url);
                  //     } else {
                  //       reject(new Error('load audio failed'));
                  //     }
                  //   });
                  // }
                });
              }

              static loadOneShotAudio(url, volume) {
                return new Promise((resolve, reject) => {
                  AudioPlayer.loadNative(url).then(url => {
                    resolve(new OneShotAudio(url, volume));
                  }).catch(reject);
                });
              }

              get _isValid() {
                return this._id !== INVALID_AUDIO_ID;
              }

              get src() {
                return this._url;
              }

              get type() {
                return AudioType.NATIVE_AUDIO;
              }

              get state() {
                return this._state;
              }

              get loop() {
                if (!this._isValid) {
                  return this._cachedState.loop;
                }

                return audioEngine.isLoop(this._id);
              }

              set loop(val) {
                if (this._isValid) {
                  audioEngine.setLoop(this._id, val);
                }

                this._cachedState.loop = val;
              }

              get volume() {
                if (!this._isValid) {
                  return this._cachedState.volume;
                }

                return audioEngine.getVolume(this._id);
              }

              set volume(val) {
                val = clamp01(val);

                if (this._isValid) {
                  audioEngine.setVolume(this._id, val);
                }

                this._cachedState.volume = val;
              }

              get duration() {
                if (!this._isValid) {
                  return this._cachedState.duration;
                }

                return audioEngine.getDuration(this._id);
              }

              get currentTime() {
                if (!this._isValid) {
                  return this._cachedState.currentTime;
                }

                return audioEngine.getCurrentTime(this._id);
              }

              seek(time) {
                return new Promise(resolve => {
                  if (this._isValid) {
                    audioEngine.setCurrentTime(this._id, time);
                  }

                  this._cachedState.currentTime = time;
                  return resolve();
                });
              }

              play() {
                return new Promise(resolve => {
                  if (this._isValid) {
                    console.log('pptest resume audio ' + this._id);
                    if (this._state === AudioState.PAUSED || this._state === AudioState.INTERRUPTED) {
                      audioEngine.resume(this._id);
                    } else if (this._state === AudioState.PLAYING) {
                      audioEngine.pause(this._id);
                      audioEngine.setCurrentTime(this._id, 0);
                      audioEngine.resume(this._id);
                    }
                  } else {
                    console.log('pptest play audio ' + this._url);
                    this._id = audioEngine.play2d(this._url, this._cachedState.loop, this._cachedState.volume);

                    if (this._isValid) {
                      if (this._cachedState.currentTime !== 0) {
                        audioEngine.setCurrentTime(this._id, this._cachedState.currentTime);
                        this._cachedState.currentTime = 0;
                      }

                      audioEngine.setFinishCallback(this._id, () => {
                        this._cachedState.currentTime = 0;
                        this._id = INVALID_AUDIO_ID;
                        this._state = AudioState.INIT;

                        this._eventTarget.emit(AudioEvent.ENDED);
                      });
                    }
                  }

                  this._state = AudioState.PLAYING;
                  resolve();
                });
              }

              pause() {
                return new Promise(resolve => {
                  if (this._isValid) {
                    audioEngine.pause(this._id);
                  }

                  this._state = AudioState.PAUSED;
                  resolve();
                });
              }

              stop() {
                return new Promise(resolve => {
                  if (this._isValid) {
                    audioEngine.stop(this._id);
                  }

                  this._state = AudioState.STOPPED;
                  this._id = INVALID_AUDIO_ID;
                  this._cachedState.currentTime = 0;
                  resolve();
                });
              }

              onInterruptionBegin(cb) {
                this._eventTarget.on(AudioEvent.INTERRUPTION_BEGIN, cb);
              }

              offInterruptionBegin(cb) {
                this._eventTarget.off(AudioEvent.INTERRUPTION_BEGIN, cb);
              }

              onInterruptionEnd(cb) {
                this._eventTarget.on(AudioEvent.INTERRUPTION_END, cb);
              }

              offInterruptionEnd(cb) {
                this._eventTarget.off(AudioEvent.INTERRUPTION_END, cb);
              }

              onEnded(cb) {
                this._eventTarget.on(AudioEvent.ENDED, cb);
              }

              offEnded(cb) {
                this._eventTarget.off(AudioEvent.ENDED, cb);
              }

            }, _class2$18.maxAudioChannel = 10, _temp$1c), (_applyDecoratedDescriptor(_class$1j.prototype, "seek", [enqueueOperation], Object.getOwnPropertyDescriptor(_class$1j.prototype, "seek"), _class$1j.prototype), _applyDecoratedDescriptor(_class$1j.prototype, "play", [enqueueOperation], Object.getOwnPropertyDescriptor(_class$1j.prototype, "play"), _class$1j.prototype), _applyDecoratedDescriptor(_class$1j.prototype, "pause", [enqueueOperation], Object.getOwnPropertyDescriptor(_class$1j.prototype, "pause"), _class$1j.prototype), _applyDecoratedDescriptor(_class$1j.prototype, "stop", [enqueueOperation], Object.getOwnPropertyDescriptor(_class$1j.prototype, "stop"), _class$1j.prototype)), _class$1j);
            legacyCC.AudioPlayer = AudioPlayer;

            var _dec$1j, _class$1k, _class2$19, _descriptor$17, _class3$p, _temp$1d;
            let AudioClip = exports('AudioClip', (_dec$1j = ccclass('cc.AudioClip'), _dec$1j(_class$1k = (_class2$19 = (_temp$1d = _class3$p = class AudioClip extends Asset {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "_duration", _descriptor$17, this);

                this._loadMode = AudioType.UNKNOWN_AUDIO;
                this._meta = null;
                this._player = null;
              }

              destroy() {
                var _this$_player;

                const destroyResult = super.destroy();
                (_this$_player = this._player) === null || _this$_player === void 0 ? void 0 : _this$_player.destroy();
                this._player = null;

                if (this._meta) {
                  this._meta.player = null;
                }

                return destroyResult;
              }

              set _nativeAsset(meta) {
                this._meta = meta;

                if (meta) {
                  this._loadMode = meta.type;
                  this._player = meta.player;
                } else {
                  this._meta = null;
                  this._loadMode = AudioType.UNKNOWN_AUDIO;
                  this._duration = 0;
                }
              }

              get _nativeAsset() {
                return this._meta;
              }

              get _nativeDep() {
                return {
                  uuid: this._uuid,
                  audioLoadMode: this.loadMode,
                  ext: this._native,
                  __isNative__: true
                };
              }

              get loadMode() {
                return this._loadMode;
              }

              validate() {
                return !!this._meta;
              }

              getDuration() {
                if (this._duration) {
                  return this._duration;
                }

                return this._meta ? this._meta.duration : 0;
              }

              get state() {
                return this._player ? this._player.state : AudioState.INIT;
              }

              getCurrentTime() {
                return this._player ? this._player.currentTime : 0;
              }

              getVolume() {
                return this._player ? this._player.volume : 0;
              }

              getLoop() {
                return this._player ? this._player.loop : false;
              }

              setCurrentTime(time) {
                var _this$_player2;

                (_this$_player2 = this._player) === null || _this$_player2 === void 0 ? void 0 : _this$_player2.seek(time).catch(e => {});
              }

              setVolume(volume) {
                if (this._player) {
                  this._player.volume = volume;
                }
              }

              setLoop(loop) {
                if (this._player) {
                  this._player.loop = loop;
                }
              }

              play() {
                var _this$_player3;

                (_this$_player3 = this._player) === null || _this$_player3 === void 0 ? void 0 : _this$_player3.play().catch(e => {});
              }

              pause() {
                var _this$_player4;

                (_this$_player4 = this._player) === null || _this$_player4 === void 0 ? void 0 : _this$_player4.pause().catch(e => {});
              }

              stop() {
                var _this$_player5;

                (_this$_player5 = this._player) === null || _this$_player5 === void 0 ? void 0 : _this$_player5.stop().catch(e => {});
              }

              playOneShot(volume = 1) {
                if (this._nativeAsset) {
                  AudioPlayer.loadOneShotAudio(this._nativeAsset.url, volume).then(oneShotAudio => {
                    oneShotAudio.play();
                  }).catch(e => {});
                }
              }

            }, _class3$p.AudioType = AudioType, _temp$1d), (_descriptor$17 = _applyDecoratedDescriptor(_class2$19.prototype, "_duration", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _applyDecoratedDescriptor(_class2$19.prototype, "_nativeDep", [override], Object.getOwnPropertyDescriptor(_class2$19.prototype, "_nativeDep"), _class2$19.prototype)), _class2$19)) || _class$1k));
            legacyCC.AudioClip = AudioClip;

            function loadAudioPlayer(url, options, onComplete) {
              console.log('pptest loadAudioPlayer 1');
              AudioPlayer.load(url, {
                audioLoadMode: options.audioLoadMode
              }).then(player => {
                console.log('pptest loadAudioPlayer 2');
                const audioMeta = {
                  player,
                  url,
                  duration: player.duration,
                  type: player.type
                };
                onComplete(null, audioMeta);
              }).catch(err => {
                onComplete(err);
              });
              console.log('pptest loadAudioPlayer 3');
            }

            function createAudioClip(id, data, options, onComplete) {
              const out = new AudioClip();
              out._nativeUrl = id;
              out._nativeAsset = data;
              out._duration = data.duration;
              onComplete(null, out);
            }

            console.log('pptest importing cc 3.38');
            downloader.register({
              '.mp3': loadAudioPlayer,
              '.ogg': loadAudioPlayer,
              '.wav': loadAudioPlayer,
              '.m4a': loadAudioPlayer
            });
            factory.register({
              '.mp3': createAudioClip,
              '.ogg': createAudioClip,
              '.wav': createAudioClip,
              '.m4a': createAudioClip
            });

            class AudioManager {
              constructor() {
                this._oneShotAudioInfoList = [];
                this._audioPlayerInfoList = [];
              }

              _findIndex(audioInfoList, audio) {
                return audioInfoList.findIndex(item => item.audio === audio);
              }

              _tryAddPlaying(audioInfoList, audio) {
                const idx = this._findIndex(audioInfoList, audio);

                if (idx > -1) {
                  audioInfoList[idx].playTime = performance.now();
                  return false;
                }

                audioInfoList.push({
                  audio,
                  playTime: performance.now()
                });
                return true;
              }

              addPlaying(audio) {
                if (audio instanceof AudioPlayer) {
                  if (this._tryAddPlaying(this._audioPlayerInfoList, audio)) {
                    return;
                  }
                } else {
                  this._tryAddPlaying(this._oneShotAudioInfoList, audio);
                }
              }

              _tryRemovePlaying(audioInfoList, audio) {
                const idx = this._findIndex(audioInfoList, audio);

                if (idx === -1) {
                  return false;
                }

                fastRemoveAt(audioInfoList, idx);
                return true;
              }

              removePlaying(audio) {
                if (audio instanceof AudioPlayer) {
                  if (this._tryRemovePlaying(this._audioPlayerInfoList, audio)) {
                    return;
                  }
                } else {
                  this._tryRemovePlaying(this._oneShotAudioInfoList, audio);
                }
              }

              discardOnePlayingIfNeeded() {
                if (this._audioPlayerInfoList.length + this._oneShotAudioInfoList.length < AudioPlayer.maxAudioChannel) {
                  return;
                }

                let audioInfoToDiscard;

                if (this._oneShotAudioInfoList.length > 0) {
                  this._oneShotAudioInfoList.forEach(audioInfo => {
                    if (!audioInfoToDiscard || audioInfo.playTime < audioInfoToDiscard.playTime) {
                      audioInfoToDiscard = audioInfo;
                    }
                  });
                } else {
                  this._audioPlayerInfoList.forEach(audioInfo => {
                    if (!audioInfoToDiscard || audioInfo.playTime < audioInfoToDiscard.playTime) {
                      audioInfoToDiscard = audioInfo;
                    }
                  });
                }

                if (audioInfoToDiscard) {
                  audioInfoToDiscard.audio.stop();
                  this.removePlaying(audioInfoToDiscard.audio);
                }
              }

            }
            const audioManager = new AudioManager();

            var _dec$1k, _dec2$1b, _dec3$Y, _dec4$U, _dec5$O, _dec6$J, _dec7$I, _dec8$E, _dec9$B, _dec10$z, _class$1l, _class2$1a, _descriptor$18, _descriptor2$11, _descriptor3$R, _descriptor4$O, _class3$q, _temp$1e;
            var AudioSourceEventType;

            (function (AudioSourceEventType) {
              AudioSourceEventType["STARTED"] = "started";
              AudioSourceEventType["ENDED"] = "ended";
            })(AudioSourceEventType || (AudioSourceEventType = {}));

            let AudioSource = function (v) { return exports({ AudioSource: v, AudioSourceComponent: v }), v; }((_dec$1k = ccclass('cc.AudioSource'), _dec2$1b = help(), _dec3$Y = menu$1(), _dec4$U = type$1(AudioClip), _dec5$O = type$1(AudioClip), _dec6$J = tooltip(), _dec7$I = tooltip(), _dec8$E = tooltip(), _dec9$B = range(), _dec10$z = tooltip(), _dec$1k(_class$1l = _dec2$1b(_class$1l = _dec3$Y(_class$1l = (_class2$1a = (_temp$1e = _class3$q = class AudioSource extends Component {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "_clip", _descriptor$18, this);

                this._player = null;

                _initializerDefineProperty(this, "_loop", _descriptor2$11, this);

                _initializerDefineProperty(this, "_playOnAwake", _descriptor3$R, this);

                _initializerDefineProperty(this, "_volume", _descriptor4$O, this);

                this._cachedCurrentTime = 0;
                this._operationsBeforeLoading = [];
                this._isLoaded = false;
                this._lastSetClip = null;
              }

              static get maxAudioChannel() {
                return AudioPlayer.maxAudioChannel;
              }

              set clip(val) {
                if (val === this._clip) {
                  return;
                }

                this._clip = val;

                this._syncPlayer();
              }

              get clip() {
                return this._clip;
              }

              _syncPlayer() {
                const clip = this._clip;
                this._isLoaded = false;

                if (this._lastSetClip === clip) {
                  return;
                }

                if (!clip) {
                  this._lastSetClip = null;
                  return;
                }

                if (!clip._nativeAsset) {
                  console.error('Invalid audio clip');
                  return;
                }

                this._lastSetClip = clip;
                AudioPlayer.load(clip._nativeAsset.url, {
                  audioLoadMode: clip.loadMode
                }).then(player => {
                  if (this._lastSetClip !== clip) {
                    player.destroy();
                    return;
                  }

                  this._isLoaded = true;

                  if (this._player) {
                    this._player.offEnded();

                    this._player.offInterruptionBegin();

                    this._player.offInterruptionEnd();

                    this._player.destroy();
                  }

                  this._player = player;
                  player.onEnded(() => {
                    audioManager.removePlaying(player);
                    this.node.emit(AudioSourceEventType.ENDED, this);
                  });
                  player.onInterruptionBegin(() => {
                    audioManager.removePlaying(player);
                  });
                  player.onInterruptionEnd(() => {
                    audioManager.addPlaying(player);
                  });

                  this._syncStates();
                }).catch(e => {});
              }

              set loop(val) {
                this._loop = val;
                this._player && (this._player.loop = val);
              }

              get loop() {
                return this._loop;
              }

              set playOnAwake(val) {
                this._playOnAwake = val;
              }

              get playOnAwake() {
                return this._playOnAwake;
              }

              set volume(val) {
                if (Number.isNaN(val)) {
                  console.warn('illegal audio volume!');
                  return;
                }

                val = clamp$1(val, 0, 1);

                if (this._player) {
                  this._player.volume = val;
                  this._volume = this._player.volume;
                } else {
                  this._volume = val;
                }
              }

              get volume() {
                return this._volume;
              }

              onLoad() {
                this._syncPlayer();
              }

              onEnable() {
                if (this._playOnAwake && !this.playing) {
                  this.play();
                }
              }

              onDisable() {
                const rootNode = this._getRootNode();

                if (rootNode === null || rootNode === void 0 ? void 0 : rootNode._persistNode) {
                  return;
                }

                this.pause();
              }

              onDestroy() {
                var _this$_player;

                this.stop();
                (_this$_player = this._player) === null || _this$_player === void 0 ? void 0 : _this$_player.destroy();
                this._player = null;
              }

              _getRootNode() {
                var _currentNode, _currentNode$parent;

                let currentNode = this.node;
                let currentGrandparentNode = (_currentNode = currentNode) === null || _currentNode === void 0 ? void 0 : (_currentNode$parent = _currentNode.parent) === null || _currentNode$parent === void 0 ? void 0 : _currentNode$parent.parent;

                while (currentGrandparentNode) {
                  var _currentNode2, _currentNode3, _currentNode3$parent;

                  currentNode = (_currentNode2 = currentNode) === null || _currentNode2 === void 0 ? void 0 : _currentNode2.parent;
                  currentGrandparentNode = (_currentNode3 = currentNode) === null || _currentNode3 === void 0 ? void 0 : (_currentNode3$parent = _currentNode3.parent) === null || _currentNode3$parent === void 0 ? void 0 : _currentNode3$parent.parent;
                }

                return currentNode;
              }

              play() {
                var _this$_player3;

                if (!this._isLoaded) {
                  this._operationsBeforeLoading.push('play');

                  return;
                }

                audioManager.discardOnePlayingIfNeeded();

                if (this.state === AudioState.PLAYING) {
                  var _this$_player2;

                  (_this$_player2 = this._player) === null || _this$_player2 === void 0 ? void 0 : _this$_player2.stop().catch(e => {});
                }

                (_this$_player3 = this._player) === null || _this$_player3 === void 0 ? void 0 : _this$_player3.play().then(() => {
                  audioManager.addPlaying(this._player);
                  this.node.emit(AudioSourceEventType.STARTED, this);
                }).catch(e => {});
              }

              pause() {
                var _this$_player4;

                if (!this._isLoaded) {
                  this._operationsBeforeLoading.push('pause');

                  return;
                }

                (_this$_player4 = this._player) === null || _this$_player4 === void 0 ? void 0 : _this$_player4.pause().then(() => {
                  audioManager.removePlaying(this._player);
                }).catch(e => {});
              }

              stop() {
                var _this$_player5;

                if (!this._isLoaded) {
                  this._operationsBeforeLoading.push('stop');

                  return;
                }

                (_this$_player5 = this._player) === null || _this$_player5 === void 0 ? void 0 : _this$_player5.stop().then(() => {
                  audioManager.removePlaying(this._player);
                }).catch(e => {});
              }

              playOneShot(clip, volumeScale = 1) {
                if (!clip._nativeAsset) {
                  console.error('Invalid audio clip');
                  return;
                }

                AudioPlayer.loadOneShotAudio(clip._nativeAsset.url, this._volume * volumeScale, {
                  audioLoadMode: clip.loadMode
                }).then(oneShotAudio => {
                  audioManager.discardOnePlayingIfNeeded();

                  oneShotAudio.onPlay = () => {
                    audioManager.addPlaying(oneShotAudio);
                  };

                  oneShotAudio.onEnd = () => {
                    audioManager.removePlaying(oneShotAudio);
                  };

                  oneShotAudio.play();
                }).catch(e => {});
              }

              _syncStates() {
                if (!this._player) {
                  return;
                }

                this._player.seek(this._cachedCurrentTime).then(() => {
                  if (this._player) {
                    this._player.loop = this._loop;
                    this._player.volume = this._volume;

                    this._operationsBeforeLoading.forEach(opName => {
                      var _this$opName;

                      (_this$opName = this[opName]) === null || _this$opName === void 0 ? void 0 : _this$opName.call(this);
                    });

                    this._operationsBeforeLoading.length = 0;
                  }
                }).catch(e => {});
              }

              set currentTime(num) {
                var _this$_player6;

                if (Number.isNaN(num)) {
                  console.warn('illegal audio time!');
                  return;
                }

                num = clamp$1(num, 0, this.duration);
                this._cachedCurrentTime = num;
                (_this$_player6 = this._player) === null || _this$_player6 === void 0 ? void 0 : _this$_player6.seek(this._cachedCurrentTime).catch(e => {});
              }

              get currentTime() {
                return this._player ? this._player.currentTime : this._cachedCurrentTime;
              }

              get duration() {
                var _this$_clip$getDurati, _this$_clip;

                return (_this$_clip$getDurati = (_this$_clip = this._clip) === null || _this$_clip === void 0 ? void 0 : _this$_clip.getDuration()) !== null && _this$_clip$getDurati !== void 0 ? _this$_clip$getDurati : this._player ? this._player.currentTime : 0;
              }

              get state() {
                return this._player ? this._player.state : AudioState.INIT;
              }

              get playing() {
                return this.state === AudioSource.AudioState.PLAYING;
              }

            }, _class3$q.AudioState = AudioState, _class3$q.EventType = AudioSourceEventType, _temp$1e), (_descriptor$18 = _applyDecoratedDescriptor(_class2$1a.prototype, "_clip", [_dec4$U], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor2$11 = _applyDecoratedDescriptor(_class2$1a.prototype, "_loop", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor3$R = _applyDecoratedDescriptor(_class2$1a.prototype, "_playOnAwake", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _descriptor4$O = _applyDecoratedDescriptor(_class2$1a.prototype, "_volume", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            }), _applyDecoratedDescriptor(_class2$1a.prototype, "clip", [_dec5$O, _dec6$J], Object.getOwnPropertyDescriptor(_class2$1a.prototype, "clip"), _class2$1a.prototype), _applyDecoratedDescriptor(_class2$1a.prototype, "loop", [_dec7$I], Object.getOwnPropertyDescriptor(_class2$1a.prototype, "loop"), _class2$1a.prototype), _applyDecoratedDescriptor(_class2$1a.prototype, "playOnAwake", [_dec8$E], Object.getOwnPropertyDescriptor(_class2$1a.prototype, "playOnAwake"), _class2$1a.prototype), _applyDecoratedDescriptor(_class2$1a.prototype, "volume", [_dec9$B, _dec10$z], Object.getOwnPropertyDescriptor(_class2$1a.prototype, "volume"), _class2$1a.prototype)), _class2$1a)) || _class$1l) || _class$1l) || _class$1l));

            replaceProperty(AudioClip, 'AudioClip', [{
              name: 'PlayingState',
              newName: 'AudioState',
              target: AudioSource,
              targetName: 'AudioSource'
            }]);
            markAsWarning(AudioClip.prototype, 'AudioClip.prototype', ['state', 'play', 'pause', 'stop', 'playOneShot', 'setCurrentTime', 'setVolume', 'setLoop', 'getCurrentTime', 'getVolume', 'getLoop'].map(item => ({
              name: item,
              suggest: `please use AudioSource.prototype.${item} instead`
            })));

            legacyCC.AudioSourceComponent = AudioSource;
            js.setClassAlias(AudioSource, 'cc.AudioSourceComponent');

            var _dec$1l, _class$1m, _class2$1b, _descriptor$19, _temp$1f;
            let VideoClip = exports('VideoClip', (_dec$1l = ccclass('cc.VideoClip'), _dec$1l(_class$1m = (_class2$1b = (_temp$1f = class VideoClip extends Asset {
              constructor() {
                super();

                _initializerDefineProperty(this, "_duration", _descriptor$19, this);

                this._video = null;
              }

              set _nativeAsset(clip) {
                this._video = clip;

                if (clip) {
                  this._duration = clip.duration;
                } else {
                  this._duration = 0;
                }
              }

              get _nativeAsset() {
                return this._video;
              }

            }, _temp$1f), (_descriptor$19 = _applyDecoratedDescriptor(_class2$1b.prototype, "_duration", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            })), _class2$1b)) || _class$1m));

            function downloadVideo(url, options, onComplete) {
              const video = document.createElement('video');
              const source = document.createElement('source');
              video.appendChild(source);
              const req = new XMLHttpRequest();
              req.open('GET', url, true);
              req.responseType = 'blob';

              req.onload = function onload() {
                if (this.status === 200 || this.status === 0) {
                  source.src = URL.createObjectURL(this.response);
                  onComplete(null, video);
                } else {
                  onComplete(new Error(`${req.status}(no response)`));
                }
              };

              req.onerror = function onerror() {
                const message = `load video failure - ${url}`;
                log(message);
                onComplete(new Error(message));
              };

              req.send();
            }

            function createVideoClip(id, data, options, onComplete) {
              const out = new VideoClip();
              out._nativeUrl = id;
              out._nativeAsset = data;
              onComplete(null, out);
            }

            downloader.register({
              '.mp4': downloadVideo,
              '.avi': downloadVideo,
              '.mov': downloadVideo,
              '.mpg': downloadVideo,
              '.mpeg': downloadVideo,
              '.rm': downloadVideo,
              '.rmvb': downloadVideo
            });
            factory.register({
              '.mp4': createVideoClip,
              '.avi': createVideoClip,
              '.mov': createVideoClip,
              '.mpg': createVideoClip,
              '.mpeg': createVideoClip,
              '.rm': createVideoClip,
              '.rmvb': createVideoClip
            });

            const ResourceType = Enum({
              REMOTE: 0,
              LOCAL: 1
            });
            let EventType$6;

            (function (EventType) {
              EventType["NONE"] = "none";
              EventType["PLAYING"] = "playing";
              EventType["PAUSED"] = "paused";
              EventType["STOPPED"] = "stopped";
              EventType["COMPLETED"] = "completed";
              EventType["META_LOADED"] = "meta-loaded";
              EventType["READY_TO_PLAY"] = "ready-to-play";
              EventType["ERROR"] = "error";
              EventType["CLICKED"] = "clicked";
            })(EventType$6 || (EventType$6 = {}));

            let READY_STATE;

            (function (READY_STATE) {
              READY_STATE[READY_STATE["HAVE_NOTHING"] = 0] = "HAVE_NOTHING";
              READY_STATE[READY_STATE["HAVE_METADATA"] = 1] = "HAVE_METADATA";
              READY_STATE[READY_STATE["HAVE_CURRENT_DATA"] = 2] = "HAVE_CURRENT_DATA";
              READY_STATE[READY_STATE["HAVE_FUTURE_DATA"] = 3] = "HAVE_FUTURE_DATA";
              READY_STATE[READY_STATE["HAVE_ENOUGH_DATA"] = 4] = "HAVE_ENOUGH_DATA";
            })(READY_STATE || (READY_STATE = {}));

            class VideoPlayerImpl {
              constructor(component) {
                this._componentEventList = new Map();
                this._state = EventType$6.NONE;
                this._video = null;
                this._onHide = void 0;
                this._onShow = void 0;
                this._interrupted = false;
                this._loaded = false;
                this._loadedMeta = false;
                this._ignorePause = false;
                this._fullScreenOnAwake = false;
                this._visible = true;
                this._playing = false;
                this._cachedCurrentTime = -1;
                this._waitingFullscreen = false;
                this._waitingPlay = false;
                this._keepAspectRatio = false;
                this._component = null;
                this._uiTrans = null;
                this._node = null;
                this._stayOnBottom = false;
                this._dirty = false;
                this._forceUpdate = false;
                this._w = 0;
                this._h = 0;
                this._m00 = 0;
                this._m01 = 0;
                this._m04 = 0;
                this._m05 = 0;
                this._m12 = 0;
                this._m13 = 0;
                this._component = component;
                this._node = component.node;
                this._uiTrans = component.node.getComponent(UITransform);

                this._onHide = () => {
                  if (!this.video || this._state !== EventType$6.PLAYING) {
                    return;
                  }

                  this.video.pause();
                  this._interrupted = true;
                };

                this._onShow = () => {
                  if (!this._interrupted || !this.video) {
                    return;
                  }

                  this.video.play();
                  this._interrupted = false;
                };

                legacyCC.game.on(legacyCC.Game.EVENT_HIDE, this._onHide);
                legacyCC.game.on(legacyCC.Game.EVENT_SHOW, this._onShow);
              }

              get fullScreenOnAwake() {
                return this._fullScreenOnAwake;
              }

              get loaded() {
                return this._loaded;
              }

              get componentEventList() {
                return this._componentEventList;
              }

              get video() {
                return this._video;
              }

              get state() {
                return this._state;
              }

              get isPlaying() {
                return this._playing;
              }

              get UICamera() {
                return director.root.batcher2D.getFirstRenderCamera(this._node);
              }

              onLoadedMetadata(e) {
                this._loadedMeta = true;
                this._forceUpdate = true;

                if (this._visible) {
                  this.enable();
                } else {
                  this.disable();
                }

                this.dispatchEvent(EventType$6.META_LOADED);
                const video = e.target;

                if (this._keepAspectRatio && video) {
                  this.syncUITransform(video.videoWidth, video.videoHeight);
                }

                this.delayedFullScreen();
                this.delayedPlay();
              }

              onCanPlay(e) {
                this._loaded = true;
                this.dispatchEvent(EventType$6.READY_TO_PLAY);
              }

              onPlay(e) {
                this._playing = true;
                this.dispatchEvent(EventType$6.PLAYING);
              }

              onPlaying(e) {
                this.dispatchEvent(EventType$6.PLAYING);
              }

              onPause(e) {
                if (this._ignorePause) {
                  this._ignorePause = false;
                  return;
                }

                this._playing = false;
                this.dispatchEvent(EventType$6.PAUSED);
              }

              onStoped(e) {
                this._playing = false;
                this._ignorePause = false;
                this.dispatchEvent(EventType$6.STOPPED);
              }

              onEnded(e) {
                this.dispatchEvent(EventType$6.COMPLETED);
              }

              onClick(e) {
                this.dispatchEvent(EventType$6.CLICKED);
              }

              onError(e) {
                this.dispatchEvent(EventType$6.ERROR);
                const video = e.target;

                if (video && video.error) {
                  error(`Error ${video.error.code}; details: ${video.error.message}`);
                }
              }

              play() {
                if (this._loadedMeta || this._loaded) {
                  this.canPlay();
                } else {
                  this._waitingPlay = true;
                }
              }

              delayedPlay() {
                if (this._waitingPlay) {
                  this.canPlay();
                  this._waitingPlay = false;
                }
              }

              syncFullScreenOnAwake(enabled) {
                this._fullScreenOnAwake = enabled;

                if (this._loadedMeta || this._loaded) {
                  this.canFullScreen(enabled);
                } else {
                  this._waitingFullscreen = true;
                }
              }

              delayedFullScreen() {
                if (this._waitingFullscreen) {
                  this.canFullScreen(this._fullScreenOnAwake);
                  this._waitingFullscreen = false;
                }
              }

              dispatchEvent(key) {
                const callback = this._componentEventList.get(key);

                if (callback) {
                  this._state = key;
                  callback.call(this);
                }
              }

              syncUITransform(width, height) {
                if (this._uiTrans) {
                  this._uiTrans.width = width;
                  this._uiTrans.height = height;
                }
              }

              syncCurrentTime() {
                if (!this.video) {
                  return;
                }

                if (this._cachedCurrentTime !== -1 && this.video.currentTime !== this._cachedCurrentTime) {
                  this.seekTo(this._cachedCurrentTime);
                  this._cachedCurrentTime = -1;
                }
              }

              destroy() {
                this.removeVideoPlayer();

                this._componentEventList.clear();

                legacyCC.game.off(legacyCC.Game.EVENT_HIDE, this._onHide);
                legacyCC.game.off(legacyCC.Game.EVENT_SHOW, this._onShow);
              }

            }
            legacyCC.internal.VideoPlayerImpl = VideoPlayerImpl;

            const MIN_ZINDEX = -(2 ** 15);

            const _mat4_temp$2 = mat4();

            class VideoPlayerImplWeb extends VideoPlayerImpl {
              constructor(component) {
                super(component);
                this._eventList = new Map();
                this._clearColorA = -1;
                this._clearFlag = void 0;
              }

              addListener(type, handler) {
                if (!this._video) {
                  return;
                }

                this._eventList.set(type, handler);

                this._video.addEventListener(type, handler);
              }

              removeAllListeners() {
                this._eventList.forEach((handler, type) => {
                  if (!this._video) {
                    return;
                  }

                  this._video.removeEventListener(type, handler);
                });

                this._eventList.clear();
              }

              canPlay() {
                if (this.video) {
                  const promise = this.video.play();

                  if (window.Promise && promise instanceof Promise) {
                    promise.catch(error => {}).then(() => {
                      this.syncCurrentTime();
                    });
                  }
                }
              }

              pause() {
                if (this.video) {
                  this.video.pause();
                  this._cachedCurrentTime = this.video.currentTime;
                }
              }

              resume() {
                this.play();
              }

              stop() {
                if (this.video) {
                  this._ignorePause = true;
                  this.video.currentTime = 0;
                  this.video.pause();
                  this._cachedCurrentTime = 0;
                  setTimeout(() => {
                    this._ignorePause = false;
                    this.dispatchEvent(EventType$6.STOPPED);
                  }, 0);
                }
              }

              syncClip(clip) {
                this.removeVideoPlayer();

                if (!clip) {
                  return;
                }

                this.createVideoPlayer(clip.nativeUrl);
              }

              syncURL(url) {
                this.removeVideoPlayer();

                if (!url) {
                  return;
                }

                this.createVideoPlayer(url);
              }

              syncPlaybackRate(val) {
                if (sys.browserType === BrowserType.UC) {
                  warn('playbackRate is not supported by the uc mobile browser.');
                  return;
                }

                if (this.video) {
                  this.video.playbackRate = val;
                }
              }

              syncVolume(val) {
                if (this.video) {
                  this.video.volume = val;
                }
              }

              syncMute(enabled) {
                if (this.video) {
                  this.video.muted = enabled;
                }
              }

              syncLoop(enabled) {
                if (this.video) {
                  this.video.loop = enabled;
                }
              }

              getDuration() {
                if (!this.video) {
                  return 0;
                }

                return this.video.duration;
              }

              getCurrentTime() {
                if (this.video) {
                  return this.video.currentTime;
                }

                return -1;
              }

              seekTo(val) {
                if (this.video) {
                  this.video.currentTime = val;
                }
              }

              canFullScreen(enabled) {
                const video = this._video;

                if (!video || video.readyState !== READY_STATE.HAVE_ENOUGH_DATA) {
                  return;
                }

                if (sys.os === OS.IOS && sys.isBrowser) {
                  if (enabled) {
                    if (video.webkitEnterFullscreen) {
                      video.webkitEnterFullscreen();
                    }
                  } else if (video.webkitExitFullscreen) {
                    video.webkitExitFullscreen();
                  }

                  this._fullScreenOnAwake = video.webkitDisplayingFullscreen;
                  return;
                }

                if (!screen.supportsFullScreen) {
                  this._fullScreenOnAwake = enabled;
                  this._forceUpdate = true;
                  this.syncMatrix();
                  return;
                }

                if (enabled) {
                  if (sys.browserType === BrowserType.IE) {
                    video.style.transform = '';
                  }

                  video.setAttribute('x5-video-player-fullscreen', 'true');
                  screen.requestFullScreen(video, document => {
                    const fullscreenElement = sys.browserType === BrowserType.IE ? document.msFullscreenElement : document.fullscreenElement;
                    this._fullScreenOnAwake = fullscreenElement === video;
                  }, () => {
                    this._fullScreenOnAwake = false;
                  });
                } else {
                  video.removeAttribute('x5-video-player-fullscreen');
                  screen.exitFullScreen();
                }
              }

              syncStayOnBottom(enabled) {
                if (this._video) {
                  this._video.style['z-index'] = enabled ? MIN_ZINDEX : 0;
                  this._stayOnBottom = enabled;
                }

                this._dirty = true;
              }

              syncKeepAspectRatio(enabled) {
                this._keepAspectRatio = enabled;

                if (enabled && this._loadedMeta && this._video) {
                  this.syncUITransform(this._video.videoWidth, this._video.videoHeight);
                }
              }

              removeVideoPlayer() {
                const video = this._video;

                if (video) {
                  if (contains(game.container, video)) {
                    game.container.removeChild(video);
                    this.removeAllListeners();
                  }
                }

                this._cachedCurrentTime = 0;
                this._playing = false;
                this._loaded = false;
                this._loadedMeta = false;
                this._video = null;
              }

              createVideoPlayer(url) {
                const video = this._video = document.createElement('video');
                video.className = 'cocosVideo';
                video.style.visibility = 'hidden';
                video.style.position = 'absolute';
                video.style.bottom = '0px';
                video.style.left = '0px';
                video.style['transform-origin'] = '0px 100% 0px';
                video.style['-webkit-transform-origin'] = '0px 100% 0px';
                video.setAttribute('preload', 'auto');
                video.setAttribute('webkit-playsinline', '');
                video.setAttribute('x5-playsinline', '');
                video.setAttribute('playsinline', '');

                this._bindDomEvent();

                game.container.appendChild(video);
                const source = document.createElement('source');
                video.appendChild(source);
                source.src = url;
              }

              _bindDomEvent() {
                const video = this._video;
                this.addListener('loadedmetadata', this.onLoadedMetadata.bind(this));
                this.addListener('canplay', this.onCanPlay.bind(this));
                this.addListener('canplaythrough', this.onCanPlay.bind(this));
                this.addListener('play', this.onPlay.bind(this));
                this.addListener('playing', this.onPlaying.bind(this));
                this.addListener('pause', this.onPause.bind(this));
                this.addListener('click', this.onClick.bind(this));
                this.addListener('ended', this.onEnded.bind(this));
                this.addListener('error', this.onError.bind(this));
              }

              onCanPlay(e) {
                const video = e.target;

                if (this._loaded && video) {
                  return;
                }

                switch (video.readyState) {
                  case READY_STATE.HAVE_METADATA:
                  case READY_STATE.HAVE_ENOUGH_DATA:
                    {
                      super.onCanPlay(e);
                      break;
                    }
                }
              }

              enable() {
                if (this._video) {
                  this._visible = true;

                  if (this._video.style.visibility === 'visible') {
                    return;
                  }

                  this._video.style.visibility = 'visible';
                }
              }

              disable(noPause) {
                if (this._video) {
                  if (!noPause && this._playing) {
                    this._video.pause();
                  }

                  this._visible = false;

                  if (this._video.style.visibility === 'hidden') {
                    return;
                  }

                  this._video.style.visibility = 'hidden';
                }
              }

              syncMatrix() {
                if (!this._video || !this._visible || !this._component) return;
                const camera = this.UICamera;

                if (!camera) {
                  return;
                }

                if (screen.fullScreen()) {
                  return;
                }

                if (this._dirty) {
                  this._dirty = false;

                  if (this._stayOnBottom) {
                    this._clearColorA = camera.clearColor.w;
                    this._clearFlag = camera.clearFlag;
                    camera.clearColor.w = 0;
                    camera.clearFlag = ClearFlagBit.ALL;
                  } else if (this._clearFlag) {
                    camera.clearColor.w = this._clearColorA;
                    camera.clearFlag = this._clearFlag;
                    this._clearColorA = -1;
                    this._clearFlag = null;
                  }
                }

                this._component.node.getWorldMatrix(_mat4_temp$2);

                camera.update(true);
                camera.worldMatrixToScreen(_mat4_temp$2, _mat4_temp$2, game.canvas.width, game.canvas.height);
                let width = 0;
                let height = 0;

                if (this._fullScreenOnAwake) {
                  width = visibleRect.width;
                  height = visibleRect.height;
                } else {
                  width = this._uiTrans.contentSize.width;
                  height = this._uiTrans.contentSize.height;
                }

                if (!this._forceUpdate && this._m00 === _mat4_temp$2.m00 && this._m01 === _mat4_temp$2.m01 && this._m04 === _mat4_temp$2.m04 && this._m05 === _mat4_temp$2.m05 && this._m12 === _mat4_temp$2.m12 && this._m13 === _mat4_temp$2.m13 && this._w === width && this._h === height) {
                  return;
                }

                this._m00 = _mat4_temp$2.m00;
                this._m01 = _mat4_temp$2.m01;
                this._m04 = _mat4_temp$2.m04;
                this._m05 = _mat4_temp$2.m05;
                this._m12 = _mat4_temp$2.m12;
                this._m13 = _mat4_temp$2.m13;
                this._w = width;
                this._h = height;
                const dpr = screenAdapter.devicePixelRatio;
                const scaleX = 1 / dpr;
                const scaleY = 1 / dpr;
                const container = game.container;
                const sx = _mat4_temp$2.m00 * scaleX;
                const b = _mat4_temp$2.m01;
                const c = _mat4_temp$2.m04;
                const sy = _mat4_temp$2.m05 * scaleY;
                this._video.style.width = `${this._w}px`;
                this._video.style.height = `${this._h}px`;

                if (sys.browserType !== BrowserType.MOBILE_QQ) {
                  this._video.style.objectFit = this._keepAspectRatio ? 'none' : 'fill';
                } else {
                  warn('keepAspectRatio is not supported by the qq mobile browser.');
                }

                const w = this._w * scaleX;
                const h = this._h * scaleY;
                const {
                  x,
                  y
                } = this._uiTrans.anchorPoint;
                const appx = w * _mat4_temp$2.m00 * x;
                const appy = h * _mat4_temp$2.m05 * y;
                const offsetX = container && container.style.paddingLeft ? parseInt(container.style.paddingLeft) : 0;
                const offsetY = container && container.style.paddingBottom ? parseInt(container.style.paddingBottom) : 0;
                const tx = _mat4_temp$2.m12 * scaleX - appx + offsetX;
                const ty = _mat4_temp$2.m13 * scaleY - appy + offsetY;
                const matrix = `matrix(${sx},${-b},${-c},${sy},${tx},${-ty})`;
                this._video.style.transform = matrix;
                this._video.style['-webkit-transform'] = matrix;

                if (sys.browserType !== BrowserType.IE) {
                  this._forceUpdate = false;
                }
              }

            }

            class VideoPlayerImplManager {
              static getImpl(component) {
                return new VideoPlayerImplWeb(component);
              }

            }
            legacyCC.internal.VideoPlayerImplManager = VideoPlayerImplManager;

            var _dec$1m, _dec2$1c, _dec3$Z, _dec4$V, _dec5$P, _dec6$K, _dec7$J, _dec8$F, _dec9$C, _dec10$A, _dec11$w, _dec12$v, _dec13$s, _dec14$o, _dec15$o, _dec16$n, _dec17$k, _dec18$j, _dec19$j, _dec20$i, _dec21$h, _dec22$g, _dec23$g, _class$1n, _class2$1c, _descriptor$1a, _descriptor2$12, _descriptor3$S, _descriptor4$P, _descriptor5$G, _descriptor6$y, _descriptor7$q, _descriptor8$m, _descriptor9$h, _descriptor10$g, _descriptor11$f, _descriptor12$d, _class3$r, _temp$1g;
            let VideoPlayer = exports('VideoPlayer', (_dec$1m = ccclass('cc.VideoPlayer'), _dec2$1c = help(), _dec3$Z = menu$1(), _dec4$V = requireComponent(UITransform), _dec5$P = type$1(VideoClip), _dec6$K = type$1(ResourceType), _dec7$J = tooltip(), _dec8$F = tooltip(), _dec9$C = type$1(VideoClip), _dec10$A = tooltip(), _dec11$w = tooltip(), _dec12$v = range(), _dec13$s = tooltip(), _dec14$o = range(), _dec15$o = tooltip(), _dec16$n = tooltip(), _dec17$k = tooltip(), _dec18$j = tooltip(), _dec19$j = tooltip(), _dec20$i = tooltip(), _dec21$h = type$1([EventHandler]), _dec22$g = displayOrder(), _dec23$g = tooltip(), _dec$1m(_class$1n = _dec2$1c(_class$1n = _dec3$Z(_class$1n = _dec4$V(_class$1n = executeInEditMode(_class$1n = (_class2$1c = (_temp$1g = _class3$r = class VideoPlayer extends Component {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "_resourceType", _descriptor$1a, this);

                _initializerDefineProperty(this, "_remoteURL", _descriptor2$12, this);

                _initializerDefineProperty(this, "_clip", _descriptor3$S, this);

                _initializerDefineProperty(this, "_playOnAwake", _descriptor4$P, this);

                _initializerDefineProperty(this, "_volume", _descriptor5$G, this);

                _initializerDefineProperty(this, "_mute", _descriptor6$y, this);

                _initializerDefineProperty(this, "_playbackRate", _descriptor7$q, this);

                _initializerDefineProperty(this, "_loop", _descriptor8$m, this);

                _initializerDefineProperty(this, "_fullScreenOnAwake", _descriptor9$h, this);

                _initializerDefineProperty(this, "_stayOnBottom", _descriptor10$g, this);

                _initializerDefineProperty(this, "_keepAspectRatio", _descriptor11$f, this);

                this._impl = null;
                this._cachedCurrentTime = 0;

                _initializerDefineProperty(this, "videoPlayerEvent", _descriptor12$d, this);
              }

              get resourceType() {
                return this._resourceType;
              }

              set resourceType(val) {
                if (this._resourceType !== val) {
                  this._resourceType = val;
                  this.syncSource();
                }
              }

              get remoteURL() {
                return this._remoteURL;
              }

              set remoteURL(val) {
                if (this._remoteURL !== val) {
                  this._remoteURL = val;
                  this.syncSource();
                }
              }

              get clip() {
                return this._clip;
              }

              set clip(val) {
                if (this._clip !== val) {
                  this._clip = val;
                  this.syncSource();
                }
              }

              get playOnAwake() {
                return this._playOnAwake;
              }

              set playOnAwake(value) {
                this._playOnAwake = value;
              }

              get playbackRate() {
                return this._playbackRate;
              }

              set playbackRate(value) {
                this._playbackRate = value;

                if (this._impl) {
                  this._impl.syncPlaybackRate(value);
                }
              }

              get volume() {
                return this._volume;
              }

              set volume(value) {
                this._volume = value;

                if (this._impl) {
                  this._impl.syncVolume(value);
                }
              }

              get mute() {
                return this._mute;
              }

              set mute(value) {
                this._mute = value;

                if (this._impl) {
                  this._impl.syncMute(value);
                }
              }

              get loop() {
                return this._loop;
              }

              set loop(value) {
                this._loop = value;

                if (this._impl) {
                  this._impl.syncLoop(value);
                }
              }

              get keepAspectRatio() {
                return this._keepAspectRatio;
              }

              set keepAspectRatio(value) {
                if (this._keepAspectRatio !== value) {
                  this._keepAspectRatio = value;

                  if (this._impl) {
                    this._impl.syncKeepAspectRatio(value);
                  }
                }
              }

              get fullScreenOnAwake() {
                {
                  if (this._impl) {
                    this._fullScreenOnAwake = this._impl.fullScreenOnAwake;
                    return this._fullScreenOnAwake;
                  }
                }

                return this._fullScreenOnAwake;
              }

              set fullScreenOnAwake(value) {
                if (this._fullScreenOnAwake !== value) {
                  this._fullScreenOnAwake = value;

                  if (this._impl) {
                    this._impl.syncFullScreenOnAwake(value);
                  }
                }
              }

              get stayOnBottom() {
                return this._stayOnBottom;
              }

              set stayOnBottom(value) {
                if (this._stayOnBottom !== value) {
                  this._stayOnBottom = value;

                  if (this._impl) {
                    this._impl.syncStayOnBottom(value);
                  }
                }
              }

              get nativeVideo() {
                return this._impl && this._impl.video || null;
              }

              get currentTime() {
                if (!this._impl) {
                  return this._cachedCurrentTime;
                }

                return this._impl.getCurrentTime();
              }

              set currentTime(val) {
                if (Number.isNaN(val)) {
                  warn(`illegal video time! value:${val}`);
                  return;
                }

                val = clamp$1(val, 0, this.duration);
                this._cachedCurrentTime = val;

                if (this._impl) {
                  this._impl.seekTo(val);
                }
              }

              get duration() {
                if (!this._impl) {
                  return 0;
                }

                return this._impl.getDuration();
              }

              get state() {
                if (!this._impl) {
                  return EventType$6.NONE;
                }

                return this._impl.state;
              }

              get isPlaying() {
                if (!this._impl) {
                  return false;
                }

                return this._impl.isPlaying;
              }

              syncSource() {
                if (!this._impl) {
                  return;
                }

                if (this._resourceType === ResourceType.REMOTE) {
                  this._impl.syncURL(this._remoteURL);
                } else {
                  this._impl.syncClip(this._clip);
                }
              }

              __preload() {

                this._impl = VideoPlayerImplManager.getImpl(this);
                this.syncSource();

                this._impl.syncLoop(this._loop);

                this._impl.syncVolume(this._volume);

                this._impl.syncMute(this._mute);

                this._impl.seekTo(this._cachedCurrentTime);

                this._impl.syncPlaybackRate(this._playbackRate);

                this._impl.syncStayOnBottom(this._stayOnBottom);

                this._impl.syncKeepAspectRatio(this._keepAspectRatio);

                this._impl.syncFullScreenOnAwake(this._fullScreenOnAwake);

                this._impl.componentEventList.set(EventType$6.META_LOADED, this.onMetaLoaded.bind(this));

                this._impl.componentEventList.set(EventType$6.READY_TO_PLAY, this.onReadyToPlay.bind(this));

                this._impl.componentEventList.set(EventType$6.PLAYING, this.onPlaying.bind(this));

                this._impl.componentEventList.set(EventType$6.PAUSED, this.onPaused.bind(this));

                this._impl.componentEventList.set(EventType$6.STOPPED, this.onStopped.bind(this));

                this._impl.componentEventList.set(EventType$6.COMPLETED, this.onCompleted.bind(this));

                this._impl.componentEventList.set(EventType$6.ERROR, this.onError.bind(this));

                if (this._playOnAwake && this._impl.loaded) {
                  this.play();
                }
              }

              onEnable() {
                if (this._impl) {
                  this._impl.enable();
                }
              }

              onDisable() {
                if (this._impl) {
                  this._impl.disable();
                }
              }

              onDestroy() {
                if (this._impl) {
                  this._impl.destroy();

                  this._impl = null;
                }
              }

              update(dt) {
                if (this._impl) {
                  this._impl.syncMatrix();
                }
              }

              onMetaLoaded() {
                EventHandler.emitEvents(this.videoPlayerEvent, this, EventType$6.META_LOADED);
                this.node.emit('meta-loaded', this);
              }

              onReadyToPlay() {
                if (this._playOnAwake && !this.isPlaying) {
                  this.play();
                }

                EventHandler.emitEvents(this.videoPlayerEvent, this, EventType$6.READY_TO_PLAY);
                this.node.emit(EventType$6.READY_TO_PLAY, this);
              }

              onPlaying() {
                EventHandler.emitEvents(this.videoPlayerEvent, this, EventType$6.PLAYING);
                this.node.emit(EventType$6.PLAYING, this);
              }

              onPaused() {
                EventHandler.emitEvents(this.videoPlayerEvent, this, EventType$6.PAUSED);
                this.node.emit(EventType$6.PAUSED, this);
              }

              onStopped() {
                EventHandler.emitEvents(this.videoPlayerEvent, this, EventType$6.STOPPED);
                this.node.emit(EventType$6.STOPPED, this);
              }

              onCompleted() {
                EventHandler.emitEvents(this.videoPlayerEvent, this, EventType$6.COMPLETED);
                this.node.emit(EventType$6.COMPLETED, this);
              }

              onError() {
                EventHandler.emitEvents(this.videoPlayerEvent, this, EventType$6.ERROR);
                this.node.emit(EventType$6.ERROR, this);
              }

              play() {
                if (this._impl) {
                  this._impl.play();
                }
              }

              resume() {
                if (this._impl) {
                  this._impl.resume();
                }
              }

              pause() {
                if (this._impl) {
                  this._impl.pause();
                }
              }

              stop() {
                if (this._impl) {
                  this._impl.stop();
                }
              }

            }, _class3$r.EventType = EventType$6, _class3$r.ResourceType = ResourceType, _temp$1g), (_descriptor$1a = _applyDecoratedDescriptor(_class2$1c.prototype, "_resourceType", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return ResourceType.LOCAL;
              }
            }), _descriptor2$12 = _applyDecoratedDescriptor(_class2$1c.prototype, "_remoteURL", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            }), _descriptor3$S = _applyDecoratedDescriptor(_class2$1c.prototype, "_clip", [_dec5$P, serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor4$P = _applyDecoratedDescriptor(_class2$1c.prototype, "_playOnAwake", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _descriptor5$G = _applyDecoratedDescriptor(_class2$1c.prototype, "_volume", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1.0;
              }
            }), _descriptor6$y = _applyDecoratedDescriptor(_class2$1c.prototype, "_mute", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor7$q = _applyDecoratedDescriptor(_class2$1c.prototype, "_playbackRate", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            }), _descriptor8$m = _applyDecoratedDescriptor(_class2$1c.prototype, "_loop", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor9$h = _applyDecoratedDescriptor(_class2$1c.prototype, "_fullScreenOnAwake", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor10$g = _applyDecoratedDescriptor(_class2$1c.prototype, "_stayOnBottom", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor11$f = _applyDecoratedDescriptor(_class2$1c.prototype, "_keepAspectRatio", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _applyDecoratedDescriptor(_class2$1c.prototype, "resourceType", [_dec6$K, _dec7$J], Object.getOwnPropertyDescriptor(_class2$1c.prototype, "resourceType"), _class2$1c.prototype), _applyDecoratedDescriptor(_class2$1c.prototype, "remoteURL", [_dec8$F], Object.getOwnPropertyDescriptor(_class2$1c.prototype, "remoteURL"), _class2$1c.prototype), _applyDecoratedDescriptor(_class2$1c.prototype, "clip", [_dec9$C, _dec10$A], Object.getOwnPropertyDescriptor(_class2$1c.prototype, "clip"), _class2$1c.prototype), _applyDecoratedDescriptor(_class2$1c.prototype, "playOnAwake", [_dec11$w], Object.getOwnPropertyDescriptor(_class2$1c.prototype, "playOnAwake"), _class2$1c.prototype), _applyDecoratedDescriptor(_class2$1c.prototype, "playbackRate", [slide, _dec12$v, _dec13$s], Object.getOwnPropertyDescriptor(_class2$1c.prototype, "playbackRate"), _class2$1c.prototype), _applyDecoratedDescriptor(_class2$1c.prototype, "volume", [slide, _dec14$o, _dec15$o], Object.getOwnPropertyDescriptor(_class2$1c.prototype, "volume"), _class2$1c.prototype), _applyDecoratedDescriptor(_class2$1c.prototype, "mute", [_dec16$n], Object.getOwnPropertyDescriptor(_class2$1c.prototype, "mute"), _class2$1c.prototype), _applyDecoratedDescriptor(_class2$1c.prototype, "loop", [_dec17$k], Object.getOwnPropertyDescriptor(_class2$1c.prototype, "loop"), _class2$1c.prototype), _applyDecoratedDescriptor(_class2$1c.prototype, "keepAspectRatio", [_dec18$j], Object.getOwnPropertyDescriptor(_class2$1c.prototype, "keepAspectRatio"), _class2$1c.prototype), _applyDecoratedDescriptor(_class2$1c.prototype, "fullScreenOnAwake", [_dec19$j], Object.getOwnPropertyDescriptor(_class2$1c.prototype, "fullScreenOnAwake"), _class2$1c.prototype), _applyDecoratedDescriptor(_class2$1c.prototype, "stayOnBottom", [_dec20$i], Object.getOwnPropertyDescriptor(_class2$1c.prototype, "stayOnBottom"), _class2$1c.prototype), _descriptor12$d = _applyDecoratedDescriptor(_class2$1c.prototype, "videoPlayerEvent", [serializable, _dec21$h, _dec22$g, _dec23$g], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            })), _class2$1c)) || _class$1n) || _class$1n) || _class$1n) || _class$1n) || _class$1n));
            legacyCC.internal.VideoPlayer = VideoPlayer;

            replaceProperty(VideoPlayer.prototype, 'VideoPlayer.prototype', [{
              name: 'onPasued',
              newName: 'onPaused'
            }]);

            let EventType$7;

            console.log('pptest importing cc 3.4');
            (function (EventType) {
              EventType["NONE"] = "none";
              EventType["LOADING"] = "loading";
              EventType["LOADED"] = "loaded";
              EventType["ERROR"] = "error";
            })(EventType$7 || (EventType$7 = {}));

            class WebViewImpl {
              constructor(component) {
                this._componentEventList = new Map();
                this._state = EventType$7.NONE;
                this._wrapper = void 0;
                this._webview = null;
                this._loaded = false;
                this._forceUpdate = false;
                this._component = null;
                this._uiTrans = null;
                this._node = null;
                this._w = 0;
                this._h = 0;
                this._m00 = 0;
                this._m01 = 0;
                this._m04 = 0;
                this._m05 = 0;
                this._m12 = 0;
                this._m13 = 0;
                this._component = component;
                this._node = component.node;
                this._uiTrans = component.node.getComponent(UITransform);
                this.reset();
                this.createWebView();
              }

              reset() {
                this._wrapper = null;
                this._webview = null;
                this._loaded = false;
                this._w = 0;
                this._h = 0;
                this._m00 = 0;
                this._m01 = 0;
                this._m04 = 0;
                this._m05 = 0;
                this._m12 = 0;
                this._m13 = 0;
                this._state = EventType$7.NONE;
                this._forceUpdate = false;
              }

              get loaded() {
                return this._loaded;
              }

              get componentEventList() {
                return this._componentEventList;
              }

              get webview() {
                return this._webview;
              }

              get state() {
                return this._state;
              }

              get UICamera() {
                return director.root.batcher2D.getFirstRenderCamera(this._node);
              }

              dispatchEvent(key, ...args) {
                const callback = this._componentEventList.get(key);

                if (callback) {
                  this._state = key;
                  callback.call(this, args);
                }
              }

              destroy() {
                this.removeWebView();
                this._wrapper = null;
                this._webview = null;
                this._loaded = false;
                this._component = null;
                this._uiTrans = null;
                this._forceUpdate = false;

                this._componentEventList.clear();
              }

            }
            legacyCC.internal.WebViewImpl = WebViewImpl;

            const _mat4_temp$3 = mat4();

            class WebViewImplWeb extends WebViewImpl {
              constructor(component) {
                super(component);
              }

              _bindDomEvent() {
                if (!this.webview) {
                  return;
                }

                const onLoaded = e => {
                  this._forceUpdate = true;
                  this.dispatchEvent(EventType$7.LOADED);
                  const iframe = e.target;
                  const body = iframe.contentDocument && iframe.contentDocument.body;

                  if (body && body.innerHTML.includes('404')) {
                    this.dispatchEvent(EventType$7.ERROR, body.innerHTML);
                  }
                };

                this.webview.addEventListener('load', onLoaded);
              }

              loadURL(url) {
                if (this.webview) {
                  this.webview.src = url;
                  this.dispatchEvent(EventType$7.LOADING);
                }
              }

              createWebView() {
                const wrapper = document.createElement('div');
                this._wrapper = wrapper;
                wrapper.id = 'webview-wrapper';
                wrapper.style['-webkit-overflow'] = 'auto';
                wrapper.style['-webkit-overflow-scrolling'] = 'touch';
                wrapper.style.position = 'absolute';
                wrapper.style.bottom = '0px';
                wrapper.style.left = '0px';
                wrapper.style.transformOrigin = '0px 100% 0px';
                wrapper.style['-webkit-transform-origin'] = '0px 100% 0px';
                game.container.appendChild(wrapper);
                const webview = document.createElement('iframe');
                this._webview = webview;
                webview.id = 'webview';
                webview.style.border = 'none';
                webview.style.width = '100%';
                webview.style.height = '100%';
                wrapper.appendChild(webview);

                this._bindDomEvent();
              }

              removeWebView() {
                const wrapper = this._wrapper;

                if (contains(game.container, wrapper)) {
                  game.container.removeChild(wrapper);
                }

                this.reset();
              }

              enable() {
                if (this._wrapper) {
                  this._wrapper.style.visibility = 'visible';
                }
              }

              disable() {
                if (this._wrapper) {
                  this._wrapper.style.visibility = 'hidden';
                }
              }

              evaluateJS(str) {
                if (this.webview) {
                  const win = this.webview.contentWindow;

                  if (win) {
                    try {
                      win.eval(str);
                    } catch (e) {
                      this.dispatchEvent(EventType$7.ERROR, e);
                      error(e);
                    }
                  }
                }
              }

              setOnJSCallback(callback) {
                warn('The platform does not support');
              }

              setJavascriptInterfaceScheme(scheme) {
                warn('The platform does not support');
              }

              syncMatrix() {
                if (!this._wrapper || !this._uiTrans || !this._component || this._wrapper.style.visibility === 'hidden') return;
                const camera = this.UICamera;

                if (!camera) {
                  return;
                }

                this._component.node.getWorldMatrix(_mat4_temp$3);

                camera.update(true);
                camera.worldMatrixToScreen(_mat4_temp$3, _mat4_temp$3, game.canvas.width, game.canvas.height);
                const {
                  width,
                  height
                } = this._uiTrans.contentSize;

                if (!this._forceUpdate && this._m00 === _mat4_temp$3.m00 && this._m01 === _mat4_temp$3.m01 && this._m04 === _mat4_temp$3.m04 && this._m05 === _mat4_temp$3.m05 && this._m12 === _mat4_temp$3.m12 && this._m13 === _mat4_temp$3.m13 && this._w === width && this._h === height) {
                  return;
                }

                this._m00 = _mat4_temp$3.m00;
                this._m01 = _mat4_temp$3.m01;
                this._m04 = _mat4_temp$3.m04;
                this._m05 = _mat4_temp$3.m05;
                this._m12 = _mat4_temp$3.m12;
                this._m13 = _mat4_temp$3.m13;
                this._w = width;
                this._h = height;
                const dpr = screenAdapter.devicePixelRatio;
                const scaleX = 1 / dpr;
                const scaleY = 1 / dpr;
                const container = game.container;
                const sx = _mat4_temp$3.m00 * scaleX;
                const b = _mat4_temp$3.m01;
                const c = _mat4_temp$3.m04;
                const sy = _mat4_temp$3.m05 * scaleY;
                this._wrapper.style.width = `${width}px`;
                this._wrapper.style.height = `${height}px`;
                const w = this._w * scaleX;
                const h = this._h * scaleY;
                const appx = w * _mat4_temp$3.m00 * this._uiTrans.anchorX;
                const appy = h * _mat4_temp$3.m05 * this._uiTrans.anchorY;
                const offsetX = container && container.style.paddingLeft ? parseInt(container.style.paddingLeft) : 0;
                const offsetY = container && container.style.paddingBottom ? parseInt(container.style.paddingBottom) : 0;
                const tx = _mat4_temp$3.m12 * scaleX - appx + offsetX;
                const ty = _mat4_temp$3.m13 * scaleY - appy + offsetY;
                const matrix = `matrix(${sx},${-b},${-c},${sy},${tx},${-ty})`;
                this._wrapper.style.transform = matrix;
                this._wrapper.style['-webkit-transform'] = matrix;
                this._forceUpdate = false;
              }

            }

            class WebViewImplManager {
              static getImpl(component) {
                return new WebViewImplWeb(component);
              }

            }
            legacyCC.internal.WebViewImplManager = WebViewImplManager;

            var _dec$1n, _dec2$1d, _dec3$_, _dec4$W, _dec5$Q, _dec6$L, _dec7$K, _dec8$G, _class$1o, _class2$1d, _descriptor$1b, _descriptor2$13, _class3$s, _temp$1h;
            let WebView = exports('WebView', (_dec$1n = ccclass('cc.WebView'), _dec2$1d = help(), _dec3$_ = menu$1(), _dec4$W = requireComponent(UITransform), _dec5$Q = tooltip(), _dec6$L = type$1([EventHandler]), _dec7$K = displayOrder(), _dec8$G = tooltip(), _dec$1n(_class$1o = _dec2$1d(_class$1o = _dec3$_(_class$1o = _dec4$W(_class$1o = executeInEditMode(_class$1o = (_class2$1d = (_temp$1h = _class3$s = class WebView extends Component {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "_url", _descriptor$1b, this);

                this._impl = null;

                _initializerDefineProperty(this, "webviewEvents", _descriptor2$13, this);
              }

              get url() {
                return this._url;
              }

              set url(val) {
                this._url = val;

                if (this._impl) {
                  this._impl.loadURL(val);
                }
              }

              get nativeWebView() {
                return this._impl && this._impl.webview || null;
              }

              get state() {
                if (!this._impl) {
                  return EventType$7.NONE;
                }

                return this._impl.state;
              }

              setJavascriptInterfaceScheme(scheme) {
                if (this._impl) {
                  this._impl.setJavascriptInterfaceScheme(scheme);
                }
              }

              setOnJSCallback(callback) {
                if (this._impl) {
                  this._impl.setOnJSCallback(callback);
                }
              }

              evaluateJS(str) {
                if (this._impl) {
                  this._impl.evaluateJS(str);
                }
              }

              __preload() {

                this._impl = WebViewImplManager.getImpl(this);

                this._impl.componentEventList.set(EventType$7.LOADING, this.onLoading.bind(this));

                this._impl.componentEventList.set(EventType$7.LOADED, this.onLoaded.bind(this));

                this._impl.componentEventList.set(EventType$7.ERROR, this.onError.bind(this));

                this._impl.loadURL(this._url);
              }

              onLoading() {
                EventHandler.emitEvents(this.webviewEvents, this, EventType$7.LOADING);
                this.node.emit(EventType$7.LOADING, this);
              }

              onLoaded() {
                EventHandler.emitEvents(this.webviewEvents, this, EventType$7.LOADED);
                this.node.emit(EventType$7.LOADED, this);
              }

              onError(...args) {
                EventHandler.emitEvents(this.webviewEvents, this, EventType$7.ERROR, args);
                this.node.emit(EventType$7.ERROR, this, args);
              }

              onEnable() {
                if (this._impl) {
                  this._impl.enable();
                }
              }

              onDisable() {
                if (this._impl) {
                  this._impl.disable();
                }
              }

              onDestroy() {
                if (this._impl) {
                  this._impl.destroy();

                  this._impl = null;
                }
              }

              update(dt) {
                if (this._impl) {
                  this._impl.syncMatrix();
                }
              }

            }, _class3$s.EventType = EventType$7, _temp$1h), (_descriptor$1b = _applyDecoratedDescriptor(_class2$1d.prototype, "_url", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 'https://cocos.com';
              }
            }), _applyDecoratedDescriptor(_class2$1d.prototype, "url", [_dec5$Q], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "url"), _class2$1d.prototype), _descriptor2$13 = _applyDecoratedDescriptor(_class2$1d.prototype, "webviewEvents", [serializable, _dec6$L, _dec7$K, _dec8$G], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            })), _class2$1d)) || _class$1o) || _class$1o) || _class$1o) || _class$1o) || _class$1o));
            legacyCC.internal.WebView = WebView;

            class Action {
              constructor() {
                this.originalTarget = null;
                this.target = null;
                this.tag = Action.TAG_INVALID;
              }

              clone() {
                const action = new Action();
                action.originalTarget = null;
                action.target = null;
                action.tag = this.tag;
                return action;
              }

              isDone() {
                return true;
              }

              startWithTarget(target) {
                this.originalTarget = target;
                this.target = target;
              }

              stop() {
                this.target = null;
              }

              step(dt) {
                logID(1006);
              }

              update(dt) {
                logID(1007);
              }

              getTarget() {
                return this.target;
              }

              setTarget(target) {
                this.target = target;
              }

              getOriginalTarget() {
                return this.originalTarget;
              }

              setOriginalTarget(originalTarget) {
                this.originalTarget = originalTarget;
              }

              getTag() {
                return this.tag;
              }

              setTag(tag) {
                this.tag = tag;
              }

              reverse() {
                logID(1008);
                return null;
              }

              retain() {}

              release() {}

            }
            Action.TAG_INVALID = -1;
            class FiniteTimeAction extends Action {
              constructor(...args) {
                super(...args);
                this._duration = 0;
                this._timesForRepeat = 1;
              }

              getDuration() {
                return this._duration * (this._timesForRepeat || 1);
              }

              setDuration(duration) {
                this._duration = duration;
              }

              clone() {
                return new FiniteTimeAction();
              }

            }

            let ID_COUNTER = 0;

            class HashElement {
              constructor() {
                this.actions = [];
                this.target = null;
                this.actionIndex = 0;
                this.currentAction = null;
                this.paused = false;
                this.lock = false;
              }

            }

            class ActionManager {
              constructor() {
                this._hashTargets = new Map();
                this._arrayTargets = [];
                this._currentTarget = void 0;
                this._elementPool = [];
              }

              _searchElementByTarget(arr, target) {
                for (let k = 0; k < arr.length; k++) {
                  if (target === arr[k].target) return arr[k];
                }

                return null;
              }

              _getElement(target, paused) {
                let element = this._elementPool.pop();

                if (!element) {
                  element = new HashElement();
                }

                element.target = target;
                element.paused = !!paused;
                return element;
              }

              _putElement(element) {
                element.actions.length = 0;
                element.actionIndex = 0;
                element.currentAction = null;
                element.paused = false;
                element.target = null;
                element.lock = false;

                this._elementPool.push(element);
              }

              addAction(action, target, paused) {
                if (!action || !target) {
                  errorID(1000);
                  return;
                }

                if (target.uuid == null) {
                  target.uuid = `_TWEEN_UUID_${ID_COUNTER++}`;
                }

                let element = this._hashTargets.get(target);

                if (!element) {
                  element = this._getElement(target, paused);

                  this._hashTargets.set(target, element);

                  this._arrayTargets.push(element);
                } else if (!element.actions) {
                  element.actions = [];
                }

                element.target = target;
                element.actions.push(action);
                action.startWithTarget(target);
              }

              removeAllActions() {
                const locTargets = this._arrayTargets;

                for (let i = 0; i < locTargets.length; i++) {
                  const element = locTargets[i];
                  if (element) this._putElement(element);
                }

                this._arrayTargets.length = 0;
                this._hashTargets = new Map();
              }

              removeAllActionsFromTarget(target) {
                if (target == null) return;

                const element = this._hashTargets.get(target);

                if (element) {
                  element.actions.length = 0;

                  this._deleteHashElement(element);
                }
              }

              removeAction(action) {
                if (action == null) return;
                const target = action.getOriginalTarget();

                const element = this._hashTargets.get(target);

                if (element) {
                  for (let i = 0; i < element.actions.length; i++) {
                    if (element.actions[i] === action) {
                      element.actions.splice(i, 1);
                      if (element.actionIndex >= i) element.actionIndex--;
                      break;
                    }
                  }
                }
              }

              _removeActionByTag(tag, element, target) {
                for (let i = 0, l = element.actions.length; i < l; ++i) {
                  const action = element.actions[i];

                  if (action && action.getTag() === tag) {
                    if (target && action.getOriginalTarget() !== target) {
                      continue;
                    }

                    this._removeActionAtIndex(i, element);

                    break;
                  }
                }
              }

              _removeAllActionsByTag(tag, element, target) {
                for (let i = element.actions.length - 1; i >= 0; --i) {
                  const action = element.actions[i];

                  if (action && action.getTag() === tag) {
                    if (target && action.getOriginalTarget() !== target) {
                      continue;
                    }

                    this._removeActionAtIndex(i, element);
                  }
                }
              }

              removeActionByTag(tag, target) {
                if (tag === Action.TAG_INVALID) logID(1002);
                const hashTargets = this._hashTargets;

                if (target) {
                  const element = hashTargets.get(target);

                  if (element) {
                    this._removeActionByTag(tag, element, target);
                  }
                } else {
                  hashTargets.forEach(element => {
                    this._removeActionByTag(tag, element);
                  });
                }
              }

              removeAllActionsByTag(tag, target) {
                if (tag === Action.TAG_INVALID) logID(1002);
                const hashTargets = this._hashTargets;

                if (target) {
                  const element = hashTargets.get(target);

                  if (element) {
                    this._removeAllActionsByTag(tag, element, target);
                  }
                } else {
                  hashTargets.forEach(element => {
                    this._removeAllActionsByTag(tag, element);
                  });
                }
              }

              getActionByTag(tag, target) {
                if (tag === Action.TAG_INVALID) logID(1004);

                const element = this._hashTargets.get(target);

                if (element) {
                  if (element.actions != null) {
                    for (let i = 0; i < element.actions.length; ++i) {
                      const action = element.actions[i];

                      if (action && action.getTag() === tag) {
                        return action;
                      }
                    }
                  }

                  logID(1005, tag);
                }

                return null;
              }

              getNumberOfRunningActionsInTarget(target) {
                const element = this._hashTargets.get(target);

                if (element) {
                  return element.actions ? element.actions.length : 0;
                }

                return 0;
              }

              pauseTarget(target) {
                const element = this._hashTargets.get(target);

                if (element) element.paused = true;
              }

              resumeTarget(target) {
                const element = this._hashTargets.get(target);

                if (element) element.paused = false;
              }

              pauseAllRunningActions() {
                const idsWithActions = [];
                const locTargets = this._arrayTargets;

                for (let i = 0; i < locTargets.length; i++) {
                  const element = locTargets[i];

                  if (element && !element.paused) {
                    element.paused = true;
                    idsWithActions.push(element.target);
                  }
                }

                return idsWithActions;
              }

              resumeTargets(targetsToResume) {
                if (!targetsToResume) return;

                for (let i = 0; i < targetsToResume.length; i++) {
                  if (targetsToResume[i]) this.resumeTarget(targetsToResume[i]);
                }
              }

              pauseTargets(targetsToPause) {
                if (!targetsToPause) return;

                for (let i = 0; i < targetsToPause.length; i++) {
                  if (targetsToPause[i]) this.pauseTarget(targetsToPause[i]);
                }
              }

              purgeSharedManager() {
                legacyCC.director.getScheduler().unscheduleUpdate(this);
              }

              _removeActionAtIndex(index, element) {
                const action = element.actions[index];
                element.actions.splice(index, 1);
                if (element.actionIndex >= index) element.actionIndex--;

                if (element.actions.length === 0) {
                  this._deleteHashElement(element);
                }
              }

              _deleteHashElement(element) {
                let ret = false;

                if (element && !element.lock) {
                  if (this._hashTargets.get(element.target)) {
                    this._hashTargets.delete(element.target);

                    const targets = this._arrayTargets;

                    for (let i = 0, l = targets.length; i < l; i++) {
                      if (targets[i] === element) {
                        targets.splice(i, 1);
                        break;
                      }
                    }

                    this._putElement(element);

                    ret = true;
                  }
                }

                return ret;
              }

              update(dt) {
                const locTargets = this._arrayTargets;
                let locCurrTarget;

                for (let elt = 0; elt < locTargets.length; elt++) {
                  this._currentTarget = locTargets[elt];
                  locCurrTarget = this._currentTarget;
                  const target = locCurrTarget.target;

                  if (target instanceof CCObject && !target.isValid) {
                    this.removeAllActionsFromTarget(target);
                    elt--;
                    continue;
                  }

                  if (!locCurrTarget.paused && locCurrTarget.actions) {
                    locCurrTarget.lock = true;

                    for (locCurrTarget.actionIndex = 0; locCurrTarget.actionIndex < locCurrTarget.actions.length; locCurrTarget.actionIndex++) {
                      locCurrTarget.currentAction = locCurrTarget.actions[locCurrTarget.actionIndex];
                      if (!locCurrTarget.currentAction) continue;
                      locCurrTarget.currentAction.step(dt * (locCurrTarget.currentAction._speedMethod ? locCurrTarget.currentAction._speed : 1));

                      if (locCurrTarget.currentAction && locCurrTarget.currentAction.isDone()) {
                        locCurrTarget.currentAction.stop();
                        const action = locCurrTarget.currentAction;
                        locCurrTarget.currentAction = null;
                        this.removeAction(action);
                      }

                      locCurrTarget.currentAction = null;
                    }

                    locCurrTarget.lock = false;
                  }

                  if (locCurrTarget.actions.length === 0) {
                    if (this._deleteHashElement(locCurrTarget)) {
                      elt--;
                    }
                  }
                }
              }

            }

            class TweenSystem extends System {
              constructor(...args) {
                super(...args);
                this.actionMgr = new ActionManager();
              }

              get ActionManager() {
                return this.actionMgr;
              }

              update(dt) {
                {
                  this.actionMgr.update(dt);
                }
              }

            } exports('TweenSystem', TweenSystem);
            TweenSystem.ID = 'TWEEN';
            TweenSystem.instance = void 0;
            director.on(Director.EVENT_INIT, () => {
              const sys = new TweenSystem();
              TweenSystem.instance = sys;
              director.registerSystem(TweenSystem.ID, sys, System.Priority.MEDIUM);
            });

            class ActionInstant extends FiniteTimeAction {
              isDone() {
                return true;
              }

              step(dt) {
                this.update(1);
              }

              update(dt) {}

              reverse() {
                return this.clone();
              }

              clone() {
                return new ActionInstant();
              }

            }
            class Show extends ActionInstant {
              update(dt) {
                const _renderComps = this.target.getComponentsInChildren(RenderableComponent);

                for (let i = 0; i < _renderComps.length; ++i) {
                  const render = _renderComps[i];
                  render.enabled = true;
                }
              }

              reverse() {
                return new Hide();
              }

              clone() {
                return new Show();
              }

            }
            function show() {
              return new Show();
            }
            class Hide extends ActionInstant {
              update(dt) {
                const _renderComps = this.target.getComponentsInChildren(RenderableComponent);

                for (let i = 0; i < _renderComps.length; ++i) {
                  const render = _renderComps[i];
                  render.enabled = false;
                }
              }

              reverse() {
                return new Show();
              }

              clone() {
                return new Hide();
              }

            }
            function hide() {
              return new Hide();
            }
            class RemoveSelf extends ActionInstant {
              constructor(isNeedCleanUp) {
                super();
                this._isNeedCleanUp = true;
                isNeedCleanUp !== undefined && this.init(isNeedCleanUp);
              }

              update(dt) {
                this.target.removeFromParent();

                if (this._isNeedCleanUp) {
                  this.target.destroy();
                }
              }

              init(isNeedCleanUp) {
                this._isNeedCleanUp = isNeedCleanUp;
                return true;
              }

              reverse() {
                return new RemoveSelf(this._isNeedCleanUp);
              }

              clone() {
                return new RemoveSelf(this._isNeedCleanUp);
              }

            }
            function removeSelf(isNeedCleanUp) {
              return new RemoveSelf(isNeedCleanUp);
            }
            class CallFunc extends ActionInstant {
              constructor(selector, selectorTarget, data) {
                super();
                this._selectorTarget = null;
                this._function = null;
                this._data = null;
                this.initWithFunction(selector, selectorTarget, data);
              }

              initWithFunction(selector, selectorTarget, data) {
                if (selector) {
                  this._function = selector;
                }

                if (selectorTarget) {
                  this._selectorTarget = selectorTarget;
                }

                if (data !== undefined) {
                  this._data = data;
                }

                return true;
              }

              execute() {
                if (this._function) {
                  this._function.call(this._selectorTarget, this.target, this._data);
                }
              }

              update(dt) {
                this.execute();
              }

              getTargetCallback() {
                return this._selectorTarget;
              }

              setTargetCallback(sel) {
                if (sel !== this._selectorTarget) {
                  if (this._selectorTarget) {
                    this._selectorTarget = null;
                  }

                  this._selectorTarget = sel;
                }
              }

              clone() {
                const action = new CallFunc();
                action.initWithFunction(this._function, this._selectorTarget, this._data);
                return action;
              }

            }
            function callFunc(selector, selectorTarget, data) {
              return new CallFunc(selector, selectorTarget, data);
            }

            class ActionInterval extends FiniteTimeAction {
              constructor(d) {
                super();
                this.MAX_VALUE = 2;
                this._elapsed = 0;
                this._firstTick = false;
                this._easeList = [];
                this._speed = 1;
                this._repeatForever = false;
                this._repeatMethod = false;
                this._speedMethod = false;

                if (d !== undefined && !isNaN(d)) {
                  this.initWithDuration(d);
                }
              }

              getElapsed() {
                return this._elapsed;
              }

              initWithDuration(d) {
                this._duration = d === 0 ? macro.FLT_EPSILON : d;
                this._elapsed = 0;
                this._firstTick = true;
                return true;
              }

              isDone() {
                return this._elapsed >= this._duration;
              }

              _cloneDecoration(action) {
                action._repeatForever = this._repeatForever;
                action._speed = this._speed;
                action._timesForRepeat = this._timesForRepeat;
                action._easeList = this._easeList;
                action._speedMethod = this._speedMethod;
                action._repeatMethod = this._repeatMethod;
              }

              _reverseEaseList(action) {
                if (this._easeList) {
                  action._easeList = [];

                  for (let i = 0; i < this._easeList.length; i++) {
                    action._easeList.push(this._easeList[i]);
                  }
                }
              }

              clone() {
                const action = new ActionInterval(this._duration);

                this._cloneDecoration(action);

                return action;
              }

              easing(easeObj) {
                if (this._easeList) this._easeList.length = 0;else this._easeList = [];

                for (let i = 0; i < arguments.length; i++) this._easeList.push(arguments[i]);

                return this;
              }

              _computeEaseTime(dt) {
                return dt;
              }

              step(dt) {
                if (this._firstTick) {
                  this._firstTick = false;
                  this._elapsed = 0;
                } else this._elapsed += dt;

                let t = this._elapsed / (this._duration > 0.0000001192092896 ? this._duration : 0.0000001192092896);
                t = t < 1 ? t : 1;
                this.update(t > 0 ? t : 0);

                if (this._repeatMethod && this._timesForRepeat > 1 && this.isDone()) {
                  if (!this._repeatForever) {
                    this._timesForRepeat--;
                  }

                  this.startWithTarget(this.target);
                  this.step(this._elapsed - this._duration);
                }
              }

              startWithTarget(target) {
                Action.prototype.startWithTarget.call(this, target);
                this._elapsed = 0;
                this._firstTick = true;
              }

              reverse() {
                logID(1010);
                return this;
              }

              setAmplitudeRate(amp) {
                logID(1011);
              }

              getAmplitudeRate() {
                logID(1012);
                return 0;
              }

              speed(speed) {
                if (speed <= 0) {
                  logID(1013);
                  return this;
                }

                this._speedMethod = true;
                this._speed *= speed;
                return this;
              }

              getSpeed() {
                return this._speed;
              }

              setSpeed(speed) {
                this._speed = speed;
                return this;
              }

              repeat(times) {
                times = Math.round(times);

                if (isNaN(times) || times < 1) {
                  logID(1014);
                  return this;
                }

                this._repeatMethod = true;
                this._timesForRepeat *= times;
                return this;
              }

              repeatForever() {
                this._repeatMethod = true;
                this._timesForRepeat = this.MAX_VALUE;
                this._repeatForever = true;
                return this;
              }

            }
            class Sequence extends ActionInterval {
              constructor(tempArray) {
                super();
                this._actions = [];
                this._split = 0;
                this._last = 0;
                this._reversed = false;
                const paramArray = tempArray instanceof Array ? tempArray : arguments;

                if (paramArray.length === 1) {
                  errorID(1019);
                  return;
                }

                const last = paramArray.length - 1;
                if (last >= 0 && paramArray[last] == null) logID(1015);

                if (last >= 0) {
                  let prev = paramArray[0];
                  let action1;

                  for (let i = 1; i < last; i++) {
                    if (paramArray[i]) {
                      action1 = prev;
                      prev = Sequence._actionOneTwo(action1, paramArray[i]);
                    }
                  }

                  this.initWithTwoActions(prev, paramArray[last]);
                }
              }

              initWithTwoActions(actionOne, actionTwo) {
                if (!actionOne || !actionTwo) {
                  errorID(1025);
                  return false;
                }

                let durationOne = actionOne._duration;
                let durationTwo = actionTwo._duration;
                durationOne *= actionOne._repeatMethod ? actionOne._timesForRepeat : 1;
                durationTwo *= actionTwo._repeatMethod ? actionTwo._timesForRepeat : 1;
                const d = durationOne + durationTwo;
                this.initWithDuration(d);
                this._actions[0] = actionOne;
                this._actions[1] = actionTwo;
                return true;
              }

              clone() {
                const action = new Sequence();

                this._cloneDecoration(action);

                action.initWithTwoActions(this._actions[0].clone(), this._actions[1].clone());
                return action;
              }

              startWithTarget(target) {
                ActionInterval.prototype.startWithTarget.call(this, target);
                this._split = this._actions[0]._duration / this._duration;
                this._split *= this._actions[0]._repeatMethod ? this._actions[0]._timesForRepeat : 1;
                this._last = -1;
              }

              stop() {
                if (this._last !== -1) this._actions[this._last].stop();
                Action.prototype.stop.call(this);
              }

              update(dt) {
                let new_t;
                let found = 0;
                const locSplit = this._split;
                const locActions = this._actions;
                const locLast = this._last;
                let actionFound;
                dt = this._computeEaseTime(dt);

                if (dt < locSplit) {
                  new_t = locSplit !== 0 ? dt / locSplit : 1;

                  if (found === 0 && locLast === 1 && this._reversed) {
                    locActions[1].update(0);
                    locActions[1].stop();
                  }
                } else {
                  found = 1;
                  new_t = locSplit === 1 ? 1 : (dt - locSplit) / (1 - locSplit);

                  if (locLast === -1) {
                    locActions[0].startWithTarget(this.target);
                    locActions[0].update(1);
                    locActions[0].stop();
                  }

                  if (locLast === 0) {
                    locActions[0].update(1);
                    locActions[0].stop();
                  }
                }

                actionFound = locActions[found];
                if (locLast === found && actionFound.isDone()) return;
                if (locLast !== found) actionFound.startWithTarget(this.target);
                new_t *= actionFound._timesForRepeat;
                actionFound.update(new_t > 1 ? new_t % 1 : new_t);
                this._last = found;
              }

              reverse() {
                const action = Sequence._actionOneTwo(this._actions[1].reverse(), this._actions[0].reverse());

                this._cloneDecoration(action);

                this._reverseEaseList(action);

                action._reversed = true;
                return action;
              }

            }

            Sequence._actionOneTwo = function (actionOne, actionTwo) {
              const sequence = new Sequence();
              sequence.initWithTwoActions(actionOne, actionTwo);
              return sequence;
            };

            function sequence(tempArray) {
              const paramArray = tempArray instanceof Array ? tempArray : arguments;

              if (paramArray.length === 1) {
                errorID(1019);
                return null;
              }

              const last = paramArray.length - 1;
              if (last >= 0 && paramArray[last] == null) logID(1015);
              let result = null;

              if (last >= 0) {
                result = paramArray[0];

                for (let i = 1; i <= last; i++) {
                  if (paramArray[i]) {
                    result = Sequence._actionOneTwo(result, paramArray[i]);
                  }
                }
              }

              return result;
            }
            class Repeat extends ActionInterval {
              constructor(action, times) {
                super();
                this._times = 0;
                this._total = 0;
                this._nextDt = 0;
                this._actionInstant = false;
                this._innerAction = null;
                times !== undefined && this.initWithAction(action, times);
              }

              initWithAction(action, times) {
                const duration = action._duration * times;

                if (this.initWithDuration(duration)) {
                  this._times = times;
                  this._innerAction = action;

                  if (action instanceof ActionInstant) {
                    this._actionInstant = true;
                    this._times -= 1;
                  }

                  this._total = 0;
                  return true;
                }

                return false;
              }

              clone() {
                const action = new Repeat();

                this._cloneDecoration(action);

                action.initWithAction(this._innerAction.clone(), this._times);
                return action;
              }

              startWithTarget(target) {
                this._total = 0;
                this._nextDt = this._innerAction._duration / this._duration;
                ActionInterval.prototype.startWithTarget.call(this, target);

                this._innerAction.startWithTarget(target);
              }

              stop() {
                this._innerAction.stop();

                Action.prototype.stop.call(this);
              }

              update(dt) {
                dt = this._computeEaseTime(dt);
                const locInnerAction = this._innerAction;
                const locDuration = this._duration;
                const locTimes = this._times;
                let locNextDt = this._nextDt;

                if (dt >= locNextDt) {
                  while (dt > locNextDt && this._total < locTimes) {
                    locInnerAction.update(1);
                    this._total++;
                    locInnerAction.stop();
                    locInnerAction.startWithTarget(this.target);
                    locNextDt += locInnerAction._duration / locDuration;
                    this._nextDt = locNextDt > 1 ? 1 : locNextDt;
                  }

                  if (dt >= 1.0 && this._total < locTimes) {
                    locInnerAction.update(1);
                    this._total++;
                  }

                  if (!this._actionInstant) {
                    if (this._total === locTimes) {
                      locInnerAction.stop();
                    } else {
                      locInnerAction.update(dt - (locNextDt - locInnerAction._duration / locDuration));
                    }
                  }
                } else {
                  locInnerAction.update(dt * locTimes % 1.0);
                }
              }

              isDone() {
                return this._total === this._times;
              }

              reverse() {
                const action = new Repeat(this._innerAction.reverse(), this._times);

                this._cloneDecoration(action);

                this._reverseEaseList(action);

                return action;
              }

              setInnerAction(action) {
                if (this._innerAction !== action) {
                  this._innerAction = action;
                }
              }

              getInnerAction() {
                return this._innerAction;
              }

            }
            function repeat$1(action, times) {
              return new Repeat(action, times);
            }
            class RepeatForever extends ActionInterval {
              constructor(action) {
                super();
                this._innerAction = null;
                action && this.initWithAction(action);
              }

              initWithAction(action) {
                if (!action) {
                  errorID(1026);
                  return false;
                }

                this._innerAction = action;
                return true;
              }

              clone() {
                const action = new RepeatForever();

                this._cloneDecoration(action);

                action.initWithAction(this._innerAction.clone());
                return action;
              }

              startWithTarget(target) {
                ActionInterval.prototype.startWithTarget.call(this, target);

                this._innerAction.startWithTarget(target);
              }

              step(dt) {
                const locInnerAction = this._innerAction;
                locInnerAction.step(dt);

                if (locInnerAction.isDone()) {
                  locInnerAction.startWithTarget(this.target);
                  locInnerAction.step(locInnerAction.getElapsed() - locInnerAction._duration);
                }
              }

              isDone() {
                return false;
              }

              reverse() {
                const action = new RepeatForever(this._innerAction.reverse());

                this._cloneDecoration(action);

                this._reverseEaseList(action);

                return action;
              }

              setInnerAction(action) {
                if (this._innerAction !== action) {
                  this._innerAction = action;
                }
              }

              getInnerAction() {
                return this._innerAction;
              }

            }
            function repeatForever(action) {
              return new RepeatForever(action);
            }
            class Spawn extends ActionInterval {
              constructor(tempArray) {
                super();
                this._one = null;
                this._two = null;
                const paramArray = tempArray instanceof Array ? tempArray : arguments;

                if (paramArray.length === 1) {
                  errorID(1020);
                  return;
                }

                const last = paramArray.length - 1;
                if (last >= 0 && paramArray[last] == null) logID(1015);

                if (last >= 0) {
                  let prev = paramArray[0];
                  let action1;

                  for (let i = 1; i < last; i++) {
                    if (paramArray[i]) {
                      action1 = prev;
                      prev = Spawn._actionOneTwo(action1, paramArray[i]);
                    }
                  }

                  this.initWithTwoActions(prev, paramArray[last]);
                }
              }

              initWithTwoActions(action1, action2) {
                if (!action1 || !action2) {
                  errorID(1027);
                  return false;
                }

                let ret = false;
                const d1 = action1._duration;
                const d2 = action2._duration;

                if (this.initWithDuration(Math.max(d1, d2))) {
                  this._one = action1;
                  this._two = action2;

                  if (d1 > d2) {
                    this._two = Sequence._actionOneTwo(action2, delayTime(d1 - d2));
                  } else if (d1 < d2) {
                    this._one = Sequence._actionOneTwo(action1, delayTime(d2 - d1));
                  }

                  ret = true;
                }

                return ret;
              }

              clone() {
                const action = new Spawn();

                this._cloneDecoration(action);

                action.initWithTwoActions(this._one.clone(), this._two.clone());
                return action;
              }

              startWithTarget(target) {
                ActionInterval.prototype.startWithTarget.call(this, target);

                this._one.startWithTarget(target);

                this._two.startWithTarget(target);
              }

              stop() {
                this._one.stop();

                this._two.stop();

                Action.prototype.stop.call(this);
              }

              update(dt) {
                dt = this._computeEaseTime(dt);
                if (this._one) this._one.update(dt);
                if (this._two) this._two.update(dt);
              }

              reverse() {
                const action = Spawn._actionOneTwo(this._one.reverse(), this._two.reverse());

                this._cloneDecoration(action);

                this._reverseEaseList(action);

                return action;
              }

            }

            Spawn._actionOneTwo = function (action1, action2) {
              const pSpawn = new Spawn();
              pSpawn.initWithTwoActions(action1, action2);
              return pSpawn;
            };

            function spawn(tempArray) {
              const paramArray = tempArray instanceof Array ? tempArray : arguments;

              if (paramArray.length === 1) {
                errorID(1020);
                return null;
              }

              if (paramArray.length > 0 && paramArray[paramArray.length - 1] == null) logID(1015);
              let prev = paramArray[0];

              for (let i = 1; i < paramArray.length; i++) {
                if (paramArray[i] != null) prev = Spawn._actionOneTwo(prev, paramArray[i]);
              }

              return prev;
            }

            class DelayTime extends ActionInterval {
              update(dt) {}

              reverse() {
                const action = new DelayTime(this._duration);

                this._cloneDecoration(action);

                this._reverseEaseList(action);

                return action;
              }

              clone() {
                const action = new DelayTime();

                this._cloneDecoration(action);

                action.initWithDuration(this._duration);
                return action;
              }

            }

            function delayTime(d) {
              return new DelayTime(d);
            }
            class ReverseTime extends ActionInterval {
              constructor(action) {
                super();
                this._other = null;
                action && this.initWithAction(action);
              }

              initWithAction(action) {
                if (!action) {
                  errorID(1028);
                  return false;
                }

                if (action === this._other) {
                  errorID(1029);
                  return false;
                }

                if (ActionInterval.prototype.initWithDuration.call(this, action._duration)) {
                  this._other = action;
                  return true;
                }

                return false;
              }

              clone() {
                const action = new ReverseTime();

                this._cloneDecoration(action);

                action.initWithAction(this._other.clone());
                return action;
              }

              startWithTarget(target) {
                ActionInterval.prototype.startWithTarget.call(this, target);

                this._other.startWithTarget(target);
              }

              update(dt) {
                dt = this._computeEaseTime(dt);
                if (this._other) this._other.update(1 - dt);
              }

              reverse() {
                return this._other.clone();
              }

              stop() {
                this._other.stop();

                Action.prototype.stop.call(this);
              }

            }
            function reverseTime(action) {
              return new ReverseTime(action);
            }

            function TweenEasingAdapter(easingName) {
              const initialChar = easingName.charAt(0);

              if (/[A-Z]/.test(initialChar)) {
                easingName = easingName.replace(initialChar, initialChar.toLowerCase());
                const arr = easingName.split('-');

                if (arr.length === 2) {
                  const str0 = arr[0];

                  if (str0 === 'linear') {
                    easingName = 'linear';
                  } else {
                    const str1 = arr[1];

                    switch (str0) {
                      case 'quadratic':
                        easingName = `quad${str1}`;
                        break;

                      case 'quartic':
                        easingName = `quart${str1}`;
                        break;

                      case 'quintic':
                        easingName = `quint${str1}`;
                        break;

                      case 'sinusoidal':
                        easingName = `sine${str1}`;
                        break;

                      case 'exponential':
                        easingName = `expo${str1}`;
                        break;

                      case 'circular':
                        easingName = `circ${str1}`;
                        break;

                      default:
                        easingName = str0 + str1;
                        break;
                    }
                  }
                }
              }

              return easingName;
            }

            function TweenOptionChecker(opts) {
              const header = ' [Tween:] ';
              const message = ` option is not support in v + ${engineVersion}`;
              const _opts = opts;

              if (_opts.delay) {
                warn(`${header}delay${message}`);
              }

              if (_opts.repeat) {
                warn(`${header}repeat${message}`);
              }

              if (_opts.repeatDelay) {
                warn(`${header}repeatDelay${message}`);
              }

              if (_opts.interpolation) {
                warn(`${header}interpolation${message}`);
              }

              if (_opts.onStop) {
                warn(`${header}onStop${message}`);
              }
            }

            class TweenAction extends ActionInterval {
              constructor(duration, props, opts) {
                super();
                this._opts = void 0;
                this._props = void 0;
                this._originProps = void 0;

                if (opts == null) {
                  opts = Object.create(null);
                } else {
                  TweenOptionChecker(opts);

                  if (opts.easing && typeof opts.easing === 'string') {
                    opts.easing = TweenEasingAdapter(opts.easing);
                  }

                  if (!opts.progress) {
                    opts.progress = this.progress;
                  }

                  if (opts.easing && typeof opts.easing === 'string') {
                    const easingName = opts.easing;
                    opts.easing = easing[easingName];

                    if (!opts.easing) {
                      warnID(1031, easingName);
                    }
                  }
                }

                this._opts = opts;
                this._props = Object.create(null);

                for (const name in props) {
                  if (!props.hasOwnProperty(name)) continue;
                  let value = props[name];

                  if (typeof value === 'function') {
                    value = value();
                  }

                  if (value == null || typeof value === 'string') continue;
                  let customEasing;
                  let progress;

                  if (value.value !== undefined && (value.easing || value.progress)) {
                    if (typeof value.easing === 'string') {
                      customEasing = easing[value.easing];
                      if (!customEasing) warnID(1031, value.easing);
                    } else {
                      customEasing = value.easing;
                    }

                    progress = value.progress;
                    value = value.value;
                  }

                  const prop = Object.create(null);
                  prop.value = value;
                  prop.easing = customEasing;
                  prop.progress = progress;
                  this._props[name] = prop;
                }

                this._originProps = props;
                this.initWithDuration(duration);
              }

              clone() {
                const action = new TweenAction(this._duration, this._originProps, this._opts);

                this._cloneDecoration(action);

                return action;
              }

              startWithTarget(target) {
                ActionInterval.prototype.startWithTarget.call(this, target);
                const relative = !!this._opts.relative;
                const props = this._props;

                for (const property in props) {
                  const _t = target[property];

                  if (_t === undefined) {
                    continue;
                  }

                  const prop = props[property];
                  const value = prop.value;

                  if (typeof _t === 'number') {
                    prop.start = _t;
                    prop.current = _t;
                    prop.end = relative ? _t + value : value;
                  } else if (typeof _t === 'object') {
                    if (prop.start == null) {
                      prop.start = {};
                      prop.current = {};
                      prop.end = {};
                    }

                    for (const k in value) {
                      if (isNaN(_t[k])) continue;
                      prop.start[k] = _t[k];
                      prop.current[k] = _t[k];
                      prop.end[k] = relative ? _t[k] + value[k] : value[k];
                    }
                  }
                }

                if (this._opts.onStart) {
                  this._opts.onStart(this.target);
                }
              }

              update(t) {
                const target = this.target;
                if (!target) return;
                const props = this._props;
                const opts = this._opts;
                let easingTime = t;
                if (opts.easing) easingTime = opts.easing(t);
                const progress = opts.progress;

                for (const name in props) {
                  const prop = props[name];
                  const time = prop.easing ? prop.easing(t) : easingTime;
                  const interpolation = prop.progress ? prop.progress : progress;
                  const start = prop.start;
                  const end = prop.end;

                  if (typeof start === 'number') {
                    prop.current = interpolation(start, end, prop.current, time);
                  } else if (typeof start === 'object') {
                    for (const k in start) {
                      prop.current[k] = interpolation(start[k], end[k], prop.current[k], time);
                    }
                  }

                  target[name] = prop.current;
                }

                if (opts.onUpdate) {
                  opts.onUpdate(this.target, t);
                }

                if (t === 1 && opts.onComplete) {
                  opts.onComplete(this.target);
                }
              }

              progress(start, end, current, t) {
                return current = start + (end - start) * t;
              }

            } exports('TweenAction', TweenAction);

            class SetAction extends ActionInstant {
              constructor(props) {
                super();
                this._props = void 0;
                this._props = {};
                props !== undefined && this.init(props);
              }

              init(props) {
                for (const name in props) {
                  this._props[name] = props[name];
                }

                return true;
              }

              update() {
                const props = this._props;
                const target = this.target;

                for (const name in props) {
                  target[name] = props[name];
                }
              }

              clone() {
                const action = new SetAction();
                action.init(this._props);
                return action;
              }

            }

            class Tween {
              constructor(target) {
                this._actions = [];
                this._finalAction = null;
                this._target = null;
                this._tag = Action.TAG_INVALID;
                this._target = target === undefined ? null : target;
              }

              tag(tag) {
                this._tag = tag;
                return this;
              }

              then(other) {
                if (other instanceof Action) {
                  this._actions.push(other.clone());
                } else {
                  this._actions.push(other._union());
                }

                return this;
              }

              target(target) {
                this._target = target;
                return this;
              }

              start() {
                if (!this._target) {
                  warn('Please set target to tween first');
                  return this;
                }

                if (this._finalAction) {
                  TweenSystem.instance.ActionManager.removeAction(this._finalAction);
                }

                this._finalAction = this._union();

                this._finalAction.setTag(this._tag);

                TweenSystem.instance.ActionManager.addAction(this._finalAction, this._target, false);
                return this;
              }

              stop() {
                if (this._finalAction) {
                  TweenSystem.instance.ActionManager.removeAction(this._finalAction);
                }

                return this;
              }

              clone(target) {
                const action = this._union();

                return tween(target).then(action.clone());
              }

              union() {
                const action = this._union();

                this._actions.length = 0;

                this._actions.push(action);

                return this;
              }

              to(duration, props, opts) {
                opts = opts || Object.create(null);
                opts.relative = false;
                const action = new TweenAction(duration, props, opts);

                this._actions.push(action);

                return this;
              }

              by(duration, props, opts) {
                opts = opts || Object.create(null);
                opts.relative = true;
                const action = new TweenAction(duration, props, opts);

                this._actions.push(action);

                return this;
              }

              set(props) {
                const action = new SetAction(props);

                this._actions.push(action);

                return this;
              }

              delay(duration) {
                const action = delayTime(duration);

                this._actions.push(action);

                return this;
              }

              call(callback) {
                const action = callFunc(callback);

                this._actions.push(action);

                return this;
              }

              sequence(...args) {
                const action = Tween._wrappedSequence(...args);

                this._actions.push(action);

                return this;
              }

              parallel(...args) {
                const action = Tween._wrappedParallel(...args);

                this._actions.push(action);

                return this;
              }

              repeat(repeatTimes, embedTween) {
                if (repeatTimes === Infinity) {
                  return this.repeatForever(embedTween);
                }

                const actions = this._actions;
                let action;

                if (embedTween instanceof Tween) {
                  action = embedTween._union();
                } else {
                  action = actions.pop();
                }

                actions.push(repeat$1(action, repeatTimes));
                return this;
              }

              repeatForever(embedTween) {
                const actions = this._actions;
                let action;

                if (embedTween instanceof Tween) {
                  action = embedTween._union();
                } else {
                  action = actions.pop();
                }

                actions.push(repeatForever(action));
                return this;
              }

              reverseTime(embedTween) {
                const actions = this._actions;
                let action;

                if (embedTween instanceof Tween) {
                  action = embedTween._union();
                } else {
                  action = actions.pop();
                }

                actions.push(reverseTime(action));
                return this;
              }

              hide() {
                const action = hide();

                this._actions.push(action);

                return this;
              }

              show() {
                const action = show();

                this._actions.push(action);

                return this;
              }

              removeSelf() {
                const action = removeSelf(false);

                this._actions.push(action);

                return this;
              }

              static stopAll() {
                TweenSystem.instance.ActionManager.removeAllActions();
              }

              static stopAllByTag(tag, target) {
                TweenSystem.instance.ActionManager.removeAllActionsByTag(tag, target);
              }

              static stopAllByTarget(target) {
                TweenSystem.instance.ActionManager.removeAllActionsFromTarget(target);
              }

              _union() {
                const actions = this._actions;
                let action;

                if (actions.length === 1) {
                  action = actions[0];
                } else {
                  action = sequence(actions);
                }

                return action;
              }

              _destroy() {
                this.stop();
              }

              static _wrappedSequence(...args) {
                const tmp_args = Tween._tmp_args;
                tmp_args.length = 0;

                for (let l = args.length, i = 0; i < l; i++) {
                  const arg = tmp_args[i] = args[i];

                  if (arg instanceof Tween) {
                    tmp_args[i] = arg._union();
                  }
                }

                return sequence.apply(sequence, tmp_args);
              }

              static _wrappedParallel(...args) {
                const tmp_args = Tween._tmp_args;
                tmp_args.length = 0;

                for (let l = args.length, i = 0; i < l; i++) {
                  const arg = tmp_args[i] = args[i];

                  if (arg instanceof Tween) {
                    tmp_args[i] = arg._union();
                  }
                }

                return spawn.apply(spawn, tmp_args);
              }

            } exports('Tween', Tween);
            Tween._tmp_args = [];
            legacyCC.Tween = Tween;
            function tween(target) {
              return new Tween(target);
            }
            legacyCC.tween = tween;
            function tweenUtil(target) {
              warn('tweenUtil\' is deprecated, please use \'tween\' instead ');
              return new Tween(target);
            }
            legacyCC.tweenUtil = tweenUtil;

            class HeightField {
              constructor(w, h) {
                this.data = new Uint16Array();
                this.w = 0;
                this.h = 0;
                this.w = w;
                this.h = h;
                this.data = new Uint16Array(w * h);

                for (let i = 0; i < w * h; ++i) {
                  this.data[i] = 0;
                }
              }

              set(i, j, value) {
                this.data[j * this.w + i] = value;
              }

              get(i, j) {
                return this.data[j * this.w + i];
              }

              getClamp(i, j) {
                i = clamp$1(i, 0, this.w - 1);
                j = clamp$1(j, 0, this.h - 1);
                return this.get(i, j);
              }

              getAt(x, y) {
                const fx = x;
                const fy = y;
                let ix0 = Math.floor(fx);
                let iz0 = Math.floor(fy);
                let ix1 = ix0 + 1;
                let iz1 = iz0 + 1;
                const dx = fx - ix0;
                const dz = fy - iz0;
                ix0 = clamp$1(ix0, 0, this.w - 1);
                iz0 = clamp$1(iz0, 0, this.h - 1);
                ix1 = clamp$1(ix1, 0, this.w - 1);
                iz1 = clamp$1(iz1, 0, this.h - 1);
                let a = this.get(ix0, iz0);
                const b = this.get(ix1, iz0);
                const c = this.get(ix0, iz1);
                let d = this.get(ix1, iz1);
                const m = (b + c) * 0.5;

                if (dx + dz <= 1.0) {
                  d = m + (m - a);
                } else {
                  a = m + (m - d);
                }

                const h1 = a * (1.0 - dx) + b * dx;
                const h2 = c * (1.0 - dx) + d * dx;
                const h = h1 * (1.0 - dz) + h2 * dz;
                return h;
              }

            } exports('HeightField', HeightField);

            const TERRAIN_LOD_VERTS = 33;
            const TERRAIN_LOD_TILES = 32;
            const TERRAIN_LOD_LEVELS = 4;
            const TERRAIN_LOD_NORTH_INDEX = 0;
            const TERRAIN_LOD_SOUTH_INDEX = 1;
            const TERRAIN_LOD_WEST_INDEX = 2;
            const TERRAIN_LOD_EAST_INDEX = 3;
            const TERRAIN_LOD_MAX_DISTANCE = 100000000000000.0;
            class TerrainLodKey {
              constructor() {
                this.level = 0;
                this.north = 0;
                this.south = 0;
                this.west = 0;
                this.east = 0;
              }

              equals(rk) {
                return this.level === rk.level && this.north === rk.north && this.south === rk.south && this.west === rk.west && this.east === rk.east;
              }

            }
            class TerrainIndexPool {
              constructor() {
                this.size = 0;
                this.indices = null;
              }

            }
            class TerrainIndexData {
              constructor() {
                this.key = new TerrainLodKey();
                this.start = 0;
                this.size = 0;
                this.buffer = null;
                this.primCount = 0;
              }

            }
            class TerrainLod {
              static mapIndex(i, j, k) {
                return i * (TERRAIN_LOD_LEVELS * TERRAIN_LOD_LEVELS) + j * TERRAIN_LOD_LEVELS + k;
              }

              constructor() {
                this._bodyIndexPool = void 0;
                this._connecterIndexPool = void 0;
                this._indexMap = [];
                this._indexBuffer = new Uint16Array();
                this._bodyIndexPool = new Array(TERRAIN_LOD_LEVELS);

                for (let i = 0; i < TERRAIN_LOD_LEVELS; ++i) {
                  this._bodyIndexPool[i] = new TerrainIndexPool();
                }

                this._connecterIndexPool = new Array(TERRAIN_LOD_LEVELS * TERRAIN_LOD_LEVELS * 4);

                for (let i = 0; i < TERRAIN_LOD_LEVELS; ++i) {
                  for (let j = 0; j < TERRAIN_LOD_LEVELS; ++j) {
                    for (let k = 0; k < 4; ++k) {
                      this._connecterIndexPool[TerrainLod.mapIndex(i, j, k)] = new TerrainIndexPool();
                    }
                  }
                }

                for (let i = 0; i < TERRAIN_LOD_LEVELS; ++i) {
                  this._genBodyIndex(i);
                }

                for (let i = 0; i < TERRAIN_LOD_LEVELS; ++i) {
                  for (let j = 0; j < TERRAIN_LOD_LEVELS; ++j) {
                    this._genConnecterIndexNorth(i, j);

                    this._genConnecterIndexSouth(i, j);

                    this._genConnecterIndexWest(i, j);

                    this._genConnecterIndexEast(i, j);
                  }
                }

                const levels = TERRAIN_LOD_LEVELS;

                for (let l = 0; l < levels; ++l) {
                  for (let n = 0; n < levels; ++n) {
                    if (n < l) {
                      continue;
                    }

                    for (let s = 0; s < levels; ++s) {
                      if (s < l) {
                        continue;
                      }

                      for (let w = 0; w < levels; ++w) {
                        if (w < l) {
                          continue;
                        }

                        for (let e = 0; e < levels; ++e) {
                          if (e < l) {
                            continue;
                          }

                          const k = new TerrainLodKey();
                          k.level = l;
                          k.north = n;
                          k.south = s;
                          k.west = w;
                          k.east = e;

                          this._genIndexData(k);
                        }
                      }
                    }
                  }
                }
              }

              getIndexData(k) {
                for (let i = 0; i < this._indexMap.length; ++i) {
                  if (this._indexMap[i].key.equals(k)) {
                    return this._indexMap[i];
                  }
                }

                return null;
              }

              _genBodyIndex(level) {
                const step = 1 << level;
                let tiles = TERRAIN_LOD_TILES >> level;
                let start = 0;

                if (level < TERRAIN_LOD_LEVELS - 1) {
                  tiles -= 2;
                  start = step * TERRAIN_LOD_VERTS + step;
                }

                if (tiles === 0 || tiles === 0) {
                  return;
                }

                const count = tiles * tiles * 6;
                this._bodyIndexPool[level].indices = new Uint16Array(count);
                let index = 0;
                const indices = new Uint16Array(count);
                let row_c = start;
                let row_n = row_c + TERRAIN_LOD_VERTS * step;

                for (let y = 0; y < tiles; ++y) {
                  for (let x = 0; x < tiles; ++x) {
                    indices[index++] = row_n + x * step;
                    indices[index++] = row_n + (x + 1) * step;
                    indices[index++] = row_c + x * step;
                    indices[index++] = row_n + (x + 1) * step;
                    indices[index++] = row_c + (x + 1) * step;
                    indices[index++] = row_c + x * step;
                  }

                  row_c += TERRAIN_LOD_VERTS * step;
                  row_n += TERRAIN_LOD_VERTS * step;
                }

                this._bodyIndexPool[level].size = index;
                this._bodyIndexPool[level].indices = indices;
              }

              _genConnecterIndexNorth(level, connecter) {
                const connecterIndex = TerrainLod.mapIndex(level, connecter, TERRAIN_LOD_NORTH_INDEX);

                if (connecter < level || level === TERRAIN_LOD_LEVELS - 1) {
                  this._connecterIndexPool[connecterIndex].size = 0;
                  this._connecterIndexPool[connecterIndex].indices = null;
                  return;
                }

                const self_step = 1 << level;
                const neighbor_step = 1 << connecter;
                const self_tile = TERRAIN_LOD_TILES >> level;
                const count = self_tile * 2 + 2;
                let index = 0;
                const indices = new Uint16Array(count);
                indices[index++] = 0;
                indices[index++] = 0;

                for (let i = 1; i < self_tile; ++i) {
                  const x1 = i * self_step;
                  const y1 = self_step;
                  const x0 = x1 / neighbor_step * neighbor_step;
                  const y0 = y1 - self_step;
                  const index0 = y1 * TERRAIN_LOD_VERTS + x1;
                  const index1 = y0 * TERRAIN_LOD_VERTS + x0;
                  indices[index++] = index0;
                  indices[index++] = index1;
                }

                indices[index++] = TERRAIN_LOD_VERTS - 1;
                indices[index++] = TERRAIN_LOD_VERTS - 1;
                this._connecterIndexPool[connecterIndex].size = index;
                this._connecterIndexPool[connecterIndex].indices = indices;
              }

              _genConnecterIndexSouth(level, connecter) {
                const connecterIndex = TerrainLod.mapIndex(level, connecter, TERRAIN_LOD_SOUTH_INDEX);

                if (connecter < level || level === TERRAIN_LOD_LEVELS - 1) {
                  this._connecterIndexPool[connecterIndex].size = 0;
                  this._connecterIndexPool[connecterIndex].indices = null;
                  return;
                }

                const self_step = 1 << level;
                const neighbor_step = 1 << connecter;
                const self_tile = TERRAIN_LOD_TILES >> level;
                const count = self_tile * 2 + 2;
                let index = 0;
                const indices = new Uint16Array(count);
                indices[index++] = TERRAIN_LOD_TILES * TERRAIN_LOD_VERTS;
                indices[index++] = TERRAIN_LOD_TILES * TERRAIN_LOD_VERTS;

                for (let i = 1; i < self_tile; ++i) {
                  const x0 = i * self_step;
                  const y0 = TERRAIN_LOD_VERTS - 1 - self_step;
                  const x1 = x0 / neighbor_step * neighbor_step;
                  const y1 = y0 + self_step;
                  const index0 = y1 * TERRAIN_LOD_VERTS + x1;
                  const index1 = y0 * TERRAIN_LOD_VERTS + x0;
                  indices[index++] = index0;
                  indices[index++] = index1;
                }

                indices[index++] = TERRAIN_LOD_VERTS * TERRAIN_LOD_VERTS - 1;
                indices[index++] = TERRAIN_LOD_VERTS * TERRAIN_LOD_VERTS - 1;
                this._connecterIndexPool[connecterIndex].size = index;
                this._connecterIndexPool[connecterIndex].indices = indices;
              }

              _genConnecterIndexWest(level, connecter) {
                const connecterIndex = TerrainLod.mapIndex(level, connecter, TERRAIN_LOD_WEST_INDEX);

                if (connecter < level || level === TERRAIN_LOD_LEVELS - 1) {
                  this._connecterIndexPool[connecterIndex].size = 0;
                  this._connecterIndexPool[connecterIndex].indices = null;
                  return;
                }

                const self_step = 1 << level;
                const neighbor_step = 1 << connecter;
                const self_tile = TERRAIN_LOD_TILES >> level;
                const count = self_tile * 2 + 2;
                let index = 0;
                const indices = new Uint16Array(count);
                indices[index++] = 0;
                indices[index++] = 0;

                for (let i = 1; i < self_tile; ++i) {
                  const x0 = 0;
                  const y0 = i * self_step / neighbor_step * neighbor_step;
                  const x1 = self_step;
                  const y1 = i * self_step;
                  const index0 = y0 * TERRAIN_LOD_VERTS + x0;
                  const index1 = y1 * TERRAIN_LOD_VERTS + x1;
                  indices[index++] = index0;
                  indices[index++] = index1;
                }

                indices[index++] = TERRAIN_LOD_TILES * TERRAIN_LOD_VERTS;
                indices[index++] = TERRAIN_LOD_TILES * TERRAIN_LOD_VERTS;
                this._connecterIndexPool[connecterIndex].size = index;
                this._connecterIndexPool[connecterIndex].indices = indices;
              }

              _genConnecterIndexEast(level, connecter) {
                const connecterIndex = TerrainLod.mapIndex(level, connecter, TERRAIN_LOD_EAST_INDEX);

                if (connecter < level || level === TERRAIN_LOD_LEVELS - 1) {
                  this._connecterIndexPool[connecterIndex].size = 0;
                  this._connecterIndexPool[connecterIndex].indices = null;
                  return;
                }

                const self_step = 1 << level;
                const neighbor_step = 1 << connecter;
                const self_tile = TERRAIN_LOD_TILES >> level;
                const count = self_tile * 2 + 2;
                let index = 0;
                const indices = new Uint16Array(count);
                indices[index++] = TERRAIN_LOD_VERTS - 1;
                indices[index++] = TERRAIN_LOD_VERTS - 1;

                for (let i = 1; i < self_tile; ++i) {
                  const x0 = TERRAIN_LOD_VERTS - 1 - self_step;
                  const y0 = i * self_step;
                  const x1 = TERRAIN_LOD_VERTS - 1;
                  const y1 = i * self_step / neighbor_step * neighbor_step;
                  const index0 = y0 * TERRAIN_LOD_VERTS + x0;
                  const index1 = y1 * TERRAIN_LOD_VERTS + x1;
                  indices[index++] = index0;
                  indices[index++] = index1;
                }

                indices[index++] = TERRAIN_LOD_VERTS * TERRAIN_LOD_VERTS - 1;
                indices[index++] = TERRAIN_LOD_VERTS * TERRAIN_LOD_VERTS - 1;
                this._connecterIndexPool[connecterIndex].size = index;
                this._connecterIndexPool[connecterIndex].indices = indices;
              }

              _getConnenterIndex(i, j, k) {
                return this._connecterIndexPool[TerrainLod.mapIndex(i, j, k)];
              }

              _genIndexData(k) {
                let data = this.getIndexData(k);

                if (data != null) {
                  return data;
                }

                const body = this._bodyIndexPool[k.level];

                const north = this._getConnenterIndex(k.level, k.north, TERRAIN_LOD_NORTH_INDEX);

                const south = this._getConnenterIndex(k.level, k.south, TERRAIN_LOD_SOUTH_INDEX);

                const west = this._getConnenterIndex(k.level, k.west, TERRAIN_LOD_WEST_INDEX);

                const east = this._getConnenterIndex(k.level, k.east, TERRAIN_LOD_EAST_INDEX);

                data = new TerrainIndexData();
                data.size = 0;
                data.primCount = 0;

                if (body.indices != null) {
                  data.size += body.size;
                }

                if (north.indices) {
                  data.size += (north.size - 2) * 3;
                }

                if (south.indices) {
                  data.size += (south.size - 2) * 3;
                }

                if (west.indices) {
                  data.size += (west.size - 2) * 3;
                }

                if (east.indices) {
                  data.size += (east.size - 2) * 3;
                }

                if (data.size === 0) {
                  return null;
                }

                let index = 0;
                data.buffer = new Uint16Array(data.size);
                data.key.level = k.level;
                data.key.east = k.east;
                data.key.west = k.west;
                data.key.north = k.north;
                data.key.south = k.south;

                if (body.indices) {
                  for (let i = 0; i < body.size; ++i) {
                    data.buffer[index++] = body.indices[i];
                  }
                }

                if (north.indices) {
                  for (let i = 0; i < north.size - 2; i += 2) {
                    const a = north.indices[i + 0];
                    const b = north.indices[i + 1];
                    const c = north.indices[i + 2];
                    const d = north.indices[i + 3];
                    data.buffer[index++] = a;
                    data.buffer[index++] = c;
                    data.buffer[index++] = b;
                    data.buffer[index++] = c;
                    data.buffer[index++] = d;
                    data.buffer[index++] = b;
                  }
                }

                if (south.indices) {
                  for (let i = 0; i < south.size - 2; i += 2) {
                    const a = south.indices[i + 0];
                    const b = south.indices[i + 1];
                    const c = south.indices[i + 2];
                    const d = south.indices[i + 3];
                    data.buffer[index++] = a;
                    data.buffer[index++] = c;
                    data.buffer[index++] = b;
                    data.buffer[index++] = c;
                    data.buffer[index++] = d;
                    data.buffer[index++] = b;
                  }
                }

                if (west.indices) {
                  for (let i = 0; i < west.size - 2; i += 2) {
                    const a = west.indices[i + 0];
                    const b = west.indices[i + 1];
                    const c = west.indices[i + 2];
                    const d = west.indices[i + 3];
                    data.buffer[index++] = a;
                    data.buffer[index++] = c;
                    data.buffer[index++] = b;
                    data.buffer[index++] = c;
                    data.buffer[index++] = d;
                    data.buffer[index++] = b;
                  }
                }

                if (east.indices) {
                  for (let i = 0; i < east.size - 2; i += 2) {
                    const a = east.indices[i + 0];
                    const b = east.indices[i + 1];
                    const c = east.indices[i + 2];
                    const d = east.indices[i + 3];
                    data.buffer[index++] = a;
                    data.buffer[index++] = c;
                    data.buffer[index++] = b;
                    data.buffer[index++] = c;
                    data.buffer[index++] = d;
                    data.buffer[index++] = b;
                  }
                }

                data.primCount = index / 3;
                data.start = this._indexBuffer.length;

                this._indexMap.push(data);

                const temp = new Uint16Array(data.start + data.size);
                temp.set(this._indexBuffer, 0);
                temp.set(data.buffer, data.start);
                this._indexBuffer = temp;
                return data;
              }

            }

            var _dec$1o, _class$1p, _class2$1e, _descriptor$1c, _descriptor2$14, _descriptor3$T, _descriptor4$Q, _temp$1i, _dec2$1e, _class4$5, _class5$5, _descriptor5$H, _descriptor6$z, _descriptor7$r, _descriptor8$n, _descriptor9$i, _temp2$5, _dec3$$, _class7$1, _class8$1, _descriptor10$h, _descriptor11$g, _descriptor12$e, _descriptor13$a, _descriptor14$7, _temp3$1, _dec4$X, _dec5$R, _dec6$M, _dec7$L, _dec8$H, _dec9$D, _dec10$B, _dec11$x, _dec12$w, _dec13$t, _dec14$p, _dec15$p, _dec16$o, _dec17$l, _dec18$k, _dec19$k, _class10, _class11, _descriptor15$6, _descriptor16$6, _descriptor17$5, _descriptor18$4, _descriptor19$3, _descriptor20$2, _descriptor21$2, _descriptor22$2, _temp4;
            let TerrainInfo = exports('TerrainInfo', (_dec$1o = ccclass('cc.TerrainInfo'), _dec$1o(_class$1p = (_class2$1e = (_temp$1i = class TerrainInfo {
              constructor() {
                _initializerDefineProperty(this, "tileSize", _descriptor$1c, this);

                _initializerDefineProperty(this, "blockCount", _descriptor2$14, this);

                _initializerDefineProperty(this, "weightMapSize", _descriptor3$T, this);

                _initializerDefineProperty(this, "lightMapSize", _descriptor4$Q, this);
              }

              get size() {
                const sz = new Size$1(0, 0);
                sz.width = this.blockCount[0] * TERRAIN_BLOCK_TILE_COMPLEXITY * this.tileSize;
                sz.height = this.blockCount[1] * TERRAIN_BLOCK_TILE_COMPLEXITY * this.tileSize;
                return sz;
              }

              get tileCount() {
                const _tileCount = [0, 0];
                _tileCount[0] = this.blockCount[0] * TERRAIN_BLOCK_TILE_COMPLEXITY;
                _tileCount[1] = this.blockCount[1] * TERRAIN_BLOCK_TILE_COMPLEXITY;
                return _tileCount;
              }

              get vertexCount() {
                const _vertexCount = this.tileCount;
                _vertexCount[0] += 1;
                _vertexCount[1] += 1;
                return _vertexCount;
              }

            }, _temp$1i), (_descriptor$1c = _applyDecoratedDescriptor(_class2$1e.prototype, "tileSize", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            }), _descriptor2$14 = _applyDecoratedDescriptor(_class2$1e.prototype, "blockCount", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [1, 1];
              }
            }), _descriptor3$T = _applyDecoratedDescriptor(_class2$1e.prototype, "weightMapSize", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 128;
              }
            }), _descriptor4$Q = _applyDecoratedDescriptor(_class2$1e.prototype, "lightMapSize", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 128;
              }
            })), _class2$1e)) || _class$1p));
            let TerrainLayer = exports('TerrainLayer', (_dec2$1e = ccclass('cc.TerrainLayer'), _dec2$1e(_class4$5 = (_class5$5 = (_temp2$5 = class TerrainLayer {
              constructor() {
                _initializerDefineProperty(this, "detailMap", _descriptor5$H, this);

                _initializerDefineProperty(this, "normalMap", _descriptor6$z, this);

                _initializerDefineProperty(this, "tileSize", _descriptor7$r, this);

                _initializerDefineProperty(this, "metallic", _descriptor8$n, this);

                _initializerDefineProperty(this, "roughness", _descriptor9$i, this);
              }

            }, _temp2$5), (_descriptor5$H = _applyDecoratedDescriptor(_class5$5.prototype, "detailMap", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor6$z = _applyDecoratedDescriptor(_class5$5.prototype, "normalMap", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor7$r = _applyDecoratedDescriptor(_class5$5.prototype, "tileSize", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            }), _descriptor8$n = _applyDecoratedDescriptor(_class5$5.prototype, "metallic", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor9$i = _applyDecoratedDescriptor(_class5$5.prototype, "roughness", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            })), _class5$5)) || _class4$5));

            class TerrainRenderable extends RenderableComponent {
              constructor(...args) {
                super(...args);
                this._model = null;
                this._meshData = null;
                this._brushPass = null;
                this._brushMaterial = null;
                this._currentMaterial = null;
                this._currentMaterialLayers = 0;
              }

              destroy() {
                if (this._model != null) {
                  legacyCC.director.root.destroyModel(this._model);
                  this._model = null;
                }

                return super.destroy();
              }

              _destroyModel() {
                if (this._model != null) {
                  legacyCC.director.root.destroyModel(this._model);
                  this._model = null;
                }
              }

              _invalidMaterial() {
                if (this._currentMaterial == null) {
                  return;
                }

                this._clearMaterials();

                this._brushPass = null;
                this._currentMaterial = null;

                if (this._model != null) {
                  this._model.enabled = false;
                }
              }

              _updateMaterial(block, init) {
                if (this._meshData == null || this._model == null) {
                  return;
                }

                const nLayers = block.getMaxLayer();

                if (this._currentMaterial == null || nLayers !== this._currentMaterialLayers) {
                  this._currentMaterial = new Material();

                  this._currentMaterial.initialize({
                    effectAsset: block.getTerrain().getEffectAsset(),
                    defines: block._getMaterialDefines(nLayers)
                  });

                  if (this._brushMaterial !== null) {
                    const brushMaterialInstance = new Material();
                    brushMaterialInstance.copy(this._brushMaterial);
                    this._brushPass = null;

                    if (brushMaterialInstance.passes !== null && brushMaterialInstance.passes.length > 0) {
                      this._brushPass = brushMaterialInstance.passes[0];
                      const passes = this._currentMaterial.passes;
                      passes.push(this._brushPass);
                      brushMaterialInstance.passes.pop();
                    }
                  }

                  if (init) {
                    this._model.initSubModel(0, this._meshData, this._currentMaterial);
                  }

                  this.setMaterial(this._currentMaterial, 0);
                  this._currentMaterialLayers = nLayers;
                  this._model.enabled = true;
                  this._model.receiveShadow = block.getTerrain().receiveShadow;
                }
              }

              _onMaterialModified(idx, mtl) {
                if (this._model == null) {
                  return;
                }

                this._onRebuildPSO(idx, mtl || this._getBuiltinMaterial());
              }

              _onRebuildPSO(idx, material) {
                if (this._model) {
                  this._model.setSubModelMaterial(idx, material);
                }
              }

              _clearMaterials() {
                if (this._model == null) {
                  return;
                }

                this._onMaterialModified(0, null);
              }

              _getBuiltinMaterial() {
                return builtinResMgr.get('missing-material');
              }

            }

            let TerrainBlockLightmapInfo = exports('TerrainBlockLightmapInfo', (_dec3$$ = ccclass('cc.TerrainBlockLightmapInfo'), _dec3$$(_class7$1 = (_class8$1 = (_temp3$1 = class TerrainBlockLightmapInfo {
              constructor() {
                _initializerDefineProperty(this, "texture", _descriptor10$h, this);

                _initializerDefineProperty(this, "UOff", _descriptor11$g, this);

                _initializerDefineProperty(this, "VOff", _descriptor12$e, this);

                _initializerDefineProperty(this, "UScale", _descriptor13$a, this);

                _initializerDefineProperty(this, "VScale", _descriptor14$7, this);
              }

            }, _temp3$1), (_descriptor10$h = _applyDecoratedDescriptor(_class8$1.prototype, "texture", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor11$g = _applyDecoratedDescriptor(_class8$1.prototype, "UOff", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor12$e = _applyDecoratedDescriptor(_class8$1.prototype, "VOff", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor13$a = _applyDecoratedDescriptor(_class8$1.prototype, "UScale", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor14$7 = _applyDecoratedDescriptor(_class8$1.prototype, "VScale", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            })), _class8$1)) || _class7$1));
            class TerrainBlock {
              constructor(t, i, j) {
                this._terrain = void 0;
                this._node = void 0;
                this._renderable = void 0;
                this._index = [1, 1];
                this._weightMap = null;
                this._lightmapInfo = null;
                this._lodLevel = 0;
                this._lodKey = new TerrainLodKey();
                this._errorMetrics = [0, 0, 0, 0];
                this._LevelDistances = [TERRAIN_LOD_MAX_DISTANCE, TERRAIN_LOD_MAX_DISTANCE, TERRAIN_LOD_MAX_DISTANCE, TERRAIN_LOD_MAX_DISTANCE];
                this._bbMin = new Vec3();
                this._bbMax = new Vec3();
                this._terrain = t;
                this._index[0] = i;
                this._index[1] = j;
                this._lightmapInfo = t._getLightmapInfo(i, j);
                this._node = new Node('TerrainBlock');

                this._node.setParent(this._terrain.node);

                this._node.hideFlags |= CCObject.Flags.DontSave | CCObject.Flags.HideInHierarchy;
                this._node.layer = this._terrain.node.layer;
                this._renderable = this._node.addComponent(TerrainRenderable);
              }

              build() {
                const gfxDevice = director.root.device;
                const vertexData = new Float32Array(TERRAIN_BLOCK_VERTEX_SIZE * TERRAIN_BLOCK_VERTEX_COMPLEXITY * TERRAIN_BLOCK_VERTEX_COMPLEXITY);

                this._buildVertexData(vertexData);

                const vertexBuffer = gfxDevice.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, TERRAIN_BLOCK_VERTEX_SIZE * Float32Array.BYTES_PER_ELEMENT * TERRAIN_BLOCK_VERTEX_COMPLEXITY * TERRAIN_BLOCK_VERTEX_COMPLEXITY, TERRAIN_BLOCK_VERTEX_SIZE * Float32Array.BYTES_PER_ELEMENT));
                vertexBuffer.update(vertexData);

                this._buildBoundingBox();

                const gfxAttributes = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_NORMAL, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F)];
                this._renderable._meshData = new RenderingSubMesh([vertexBuffer], gfxAttributes, PrimitiveMode.TRIANGLE_LIST, this._terrain._getSharedIndexBuffer());
                this._renderable._model = legacyCC.director.root.createModel(Model);

                this._renderable._model.createBoundingShape(this._bbMin, this._bbMax);

                this._renderable._model.node = this._renderable._model.transform = this._node;

                if (this._renderable.node.scene != null) {
                  this.visible = true;
                }

                this._updateWeightMap();

                this._updateMaterial(true);

                this._updateLodBuffer(vertexData);

                this._updateIndexBuffer();
              }

              rebuild() {
                this._updateHeight();

                this._updateWeightMap();

                this._renderable._invalidMaterial();

                this._updateMaterial(false);
              }

              destroy() {
                this.visible = false;

                this._renderable._destroyModel();

                if (this._node != null && this._node.isValid) {
                  this._node.destroy();
                }

                if (this._weightMap != null) {
                  this._weightMap.destroy();
                }
              }

              update() {
                this._updateMaterial(false);

                const useNormalMap = this._terrain.useNormalMap;
                const usePBR = this._terrain.usePBR;

                const getDetailTex = layer => {
                  return layer !== null ? layer.detailMap : null;
                };

                const getNormalTex = layer => {
                  let normalTex = layer !== null ? layer.normalMap : null;

                  if (normalTex === null) {
                    normalTex = legacyCC.builtinResMgr.get('normal-texture');
                  }

                  return normalTex;
                };

                const mtl = this._renderable._currentMaterial;

                if (mtl !== null) {
                  const nlayers = this.getMaxLayer();
                  const uvScale = new Vec4(1, 1, 1, 1);
                  const roughness = new Vec4(1, 1, 1, 1);
                  const metallic = new Vec4(0, 0, 0, 0);

                  if (nlayers === 0) {
                    if (this.layers[0] !== -1) {
                      const l0 = this._terrain.getLayer(this.layers[0]);

                      if (l0 !== null) {
                        uvScale.x = 1.0 / l0.tileSize;
                        roughness.x = l0.roughness;
                        metallic.x = l0.metallic;
                      }

                      mtl.setProperty('detailMap0', getDetailTex(l0));

                      if (useNormalMap) {
                        mtl.setProperty('normalMap0', getNormalTex(l0));
                      }
                    } else {
                      mtl.setProperty('detailMap0', legacyCC.builtinResMgr.get('default-texture'));

                      if (useNormalMap) {
                        mtl.setProperty('normalMap0', legacyCC.builtinResMgr.get('normal-texture'));
                      }
                    }
                  } else if (nlayers === 1) {
                    const l0 = this._terrain.getLayer(this.layers[0]);

                    const l1 = this._terrain.getLayer(this.layers[1]);

                    if (l0 !== null) {
                      uvScale.x = 1.0 / l0.tileSize;
                      roughness.x = l0.roughness;
                      metallic.x = l0.metallic;
                    }

                    if (l1 !== null) {
                      uvScale.y = 1.0 / l1.tileSize;
                      roughness.y = l1.roughness;
                      metallic.y = l1.metallic;
                    }

                    mtl.setProperty('weightMap', this._weightMap);
                    mtl.setProperty('detailMap0', getDetailTex(l0));
                    mtl.setProperty('detailMap1', getDetailTex(l1));

                    if (useNormalMap) {
                      mtl.setProperty('normalMap0', getNormalTex(l0));
                      mtl.setProperty('normalMap1', getNormalTex(l1));
                    }
                  } else if (nlayers === 2) {
                    const l0 = this._terrain.getLayer(this.layers[0]);

                    const l1 = this._terrain.getLayer(this.layers[1]);

                    const l2 = this._terrain.getLayer(this.layers[2]);

                    if (l0 !== null) {
                      uvScale.x = 1.0 / l0.tileSize;
                      roughness.x = l0.roughness;
                      metallic.x = l0.metallic;
                    }

                    if (l1 !== null) {
                      uvScale.y = 1.0 / l1.tileSize;
                      roughness.y = l1.roughness;
                      metallic.y = l1.metallic;
                    }

                    if (l2 !== null) {
                      uvScale.z = 1.0 / l2.tileSize;
                      roughness.z = l2.roughness;
                      metallic.z = l2.metallic;
                    }

                    mtl.setProperty('weightMap', this._weightMap);
                    mtl.setProperty('detailMap0', getDetailTex(l0));
                    mtl.setProperty('detailMap1', getDetailTex(l1));
                    mtl.setProperty('detailMap2', getDetailTex(l2));

                    if (useNormalMap) {
                      mtl.setProperty('normalMap0', getNormalTex(l0));
                      mtl.setProperty('normalMap1', getNormalTex(l1));
                      mtl.setProperty('normalMap2', getNormalTex(l2));
                    }
                  } else if (nlayers === 3) {
                    const l0 = this._terrain.getLayer(this.layers[0]);

                    const l1 = this._terrain.getLayer(this.layers[1]);

                    const l2 = this._terrain.getLayer(this.layers[2]);

                    const l3 = this._terrain.getLayer(this.layers[3]);

                    if (l0 !== null) {
                      uvScale.x = 1.0 / l0.tileSize;
                      roughness.x = l0.roughness;
                      metallic.x = l0.metallic;
                    }

                    if (l1 !== null) {
                      uvScale.y = 1.0 / l1.tileSize;
                      roughness.y = l1.roughness;
                      metallic.y = l1.metallic;
                    }

                    if (l2 !== null) {
                      uvScale.z = 1.0 / l2.tileSize;
                      roughness.z = l2.roughness;
                      metallic.z = l2.metallic;
                    }

                    if (l3 !== null) {
                      uvScale.w = 1.0 / l3.tileSize;
                      roughness.w = l3.roughness;
                      metallic.w = l3.metallic;
                    }

                    mtl.setProperty('weightMap', this._weightMap);
                    mtl.setProperty('detailMap0', getDetailTex(l0));
                    mtl.setProperty('detailMap1', getDetailTex(l1));
                    mtl.setProperty('detailMap2', getDetailTex(l2));
                    mtl.setProperty('detailMap3', getDetailTex(l3));

                    if (useNormalMap) {
                      mtl.setProperty('normalMap0', getNormalTex(l0));
                      mtl.setProperty('normalMap1', getNormalTex(l1));
                      mtl.setProperty('normalMap2', getNormalTex(l2));
                      mtl.setProperty('normalMap3', getNormalTex(l3));
                    }
                  }

                  mtl.setProperty('UVScale', uvScale);

                  if (usePBR) {
                    mtl.setProperty('roughness', roughness);
                    mtl.setProperty('metallic', metallic);
                  }

                  if (this.lightmap !== null) {
                    mtl.setProperty('lightMap', this.lightmap);
                    mtl.setProperty('lightMapUVParam', this.lightmapUVParam);
                  }
                }
              }

              _updateLevel(camPos) {
                const maxLevel = TERRAIN_LOD_LEVELS - 1;
                const bbMin = new Vec3();
                const bbMax = new Vec3();
                Vec3.add(bbMin, this._bbMin, this._terrain.node.getWorldPosition());
                Vec3.add(bbMax, this._bbMax, this._terrain.node.getWorldPosition());
                const d1 = Vec3.distance(bbMin, camPos);
                const d2 = Vec3.distance(bbMax, camPos);
                let d = Math.min(d1, d2);
                d -= this._terrain.LodBias;
                this._lodLevel = 0;

                while (this._lodLevel < maxLevel) {
                  const ld1 = this._LevelDistances[this._lodLevel + 1];

                  if (d <= ld1) {
                    break;
                  }

                  ++this._lodLevel;
                }
              }

              setBrushMaterial(mtl) {
                if (this._renderable._brushMaterial !== mtl) {
                  this._renderable._invalidMaterial();

                  this._renderable._brushMaterial = mtl;
                }
              }

              _getBrushMaterial() {
                return this._renderable ? this._renderable._brushMaterial : null;
              }

              _getBrushPass() {
                return this._renderable ? this._renderable._brushPass : null;
              }

              get valid() {
                if (this._terrain === null) {
                  return false;
                }

                const blocks = this._terrain.getBlocks();

                for (let i = 0; i < blocks.length; ++i) {
                  if (blocks[i] === this) {
                    return true;
                  }
                }

                return false;
              }

              get material() {
                return this._renderable ? this._renderable._currentMaterial : null;
              }

              get layers() {
                return this._terrain.getBlockLayers(this._index[0], this._index[1]);
              }

              get weightmap() {
                return this._weightMap;
              }

              get lightmap() {
                return this._lightmapInfo ? this._lightmapInfo.texture : null;
              }

              get lightmapUVParam() {
                if (this._lightmapInfo != null) {
                  return new Vec4(this._lightmapInfo.UOff, this._lightmapInfo.VOff, this._lightmapInfo.UScale, this._lightmapInfo.VScale);
                }

                return new Vec4(0, 0, 0, 0);
              }

              set visible(val) {
                if (this._renderable._model !== null) {
                  if (val) {
                    if (this._terrain.node != null && this._terrain.node.scene != null && this._terrain.node.scene.renderScene != null && this._renderable._model.scene == null) {
                      this._terrain.node.scene.renderScene.addModel(this._renderable._model);
                    }
                  } else if (this._renderable._model.scene !== null) {
                    this._renderable._model.scene.removeModel(this._renderable._model);
                  }
                }
              }

              get visible() {
                if (this._renderable._model !== null) {
                  return this._renderable._model.scene !== null;
                }

                return false;
              }

              getTerrain() {
                return this._terrain;
              }

              getIndex() {
                return this._index;
              }

              getRect() {
                const rect = new Rect$1();
                rect.x = this._index[0] * TERRAIN_BLOCK_TILE_COMPLEXITY;
                rect.y = this._index[1] * TERRAIN_BLOCK_TILE_COMPLEXITY;
                rect.width = TERRAIN_BLOCK_TILE_COMPLEXITY;
                rect.height = TERRAIN_BLOCK_TILE_COMPLEXITY;
                return rect;
              }

              setLayer(index, layerId) {
                if (this.layers[index] !== layerId) {
                  this._terrain.setBlockLayer(this._index[0], this._index[1], index, layerId);

                  this._renderable._invalidMaterial();

                  this._updateMaterial(false);
                }
              }

              getLayer(index) {
                return this.layers[index];
              }

              getMaxLayer() {
                if (this.layers[3] >= 0) {
                  return 3;
                }

                if (this.layers[2] >= 0) {
                  return 2;
                }

                if (this.layers[1] >= 0) {
                  return 1;
                }

                return 0;
              }

              _getMaterialDefines(nlayers) {
                return {
                  LAYERS: nlayers + 1,
                  USE_LIGHTMAP: this.lightmap !== null ? 1 : 0,
                  USE_NORMALMAP: this._terrain.useNormalMap ? 1 : 0,
                  USE_PBR: this._terrain.usePBR ? 1 : 0
                };
              }

              _invalidMaterial() {
                this._renderable._invalidMaterial();
              }

              _updateMaterial(init) {
                this._renderable._updateMaterial(this, init);
              }

              _updateHeight() {
                if (this._renderable._meshData == null) {
                  return;
                }

                const vertexData = new Float32Array(TERRAIN_BLOCK_VERTEX_SIZE * TERRAIN_BLOCK_VERTEX_COMPLEXITY * TERRAIN_BLOCK_VERTEX_COMPLEXITY);

                this._buildVertexData(vertexData);

                this._renderable._meshData.vertexBuffers[0].update(vertexData);

                this._buildBoundingBox();

                this._renderable._model.createBoundingShape(this._bbMin, this._bbMax);

                this._renderable._model.updateWorldBound();

                this._updateLodBuffer(vertexData);

                this._updateIndexBuffer();
              }

              _updateWeightMap() {
                const nlayers = this.getMaxLayer();

                if (nlayers === 0) {
                  if (this._weightMap != null) {
                    this._weightMap.destroy();

                    this._weightMap = null;
                  }

                  return;
                }

                if (this._weightMap == null) {
                  this._weightMap = new Texture2D();

                  this._weightMap.create(this._terrain.weightMapSize, this._terrain.weightMapSize, PixelFormat.RGBA8888);

                  this._weightMap.setFilters(Filter$1.LINEAR, Filter$1.LINEAR);

                  this._weightMap.setWrapMode(WrapMode.CLAMP_TO_EDGE, WrapMode.CLAMP_TO_EDGE);
                }

                const weightData = new Uint8Array(this._terrain.weightMapSize * this._terrain.weightMapSize * 4);
                let weightIndex = 0;

                for (let j = 0; j < this._terrain.weightMapSize; ++j) {
                  for (let i = 0; i < this._terrain.weightMapSize; ++i) {
                    const x = this._index[0] * this._terrain.weightMapSize + i;
                    const y = this._index[1] * this._terrain.weightMapSize + j;

                    const w = this._terrain.getWeight(x, y);

                    weightData[weightIndex * 4 + 0] = Math.floor(w.x * 255);
                    weightData[weightIndex * 4 + 1] = Math.floor(w.y * 255);
                    weightData[weightIndex * 4 + 2] = Math.floor(w.z * 255);
                    weightData[weightIndex * 4 + 3] = Math.floor(w.w * 255);
                    weightIndex += 1;
                  }
                }

                this._weightMap.uploadData(weightData);
              }

              _updateLightmap(info) {
                this._lightmapInfo = info;

                this._invalidMaterial();
              }

              _updateLod() {
                const key = new TerrainLodKey();
                key.level = this._lodLevel;
                key.north = this._lodLevel;
                key.south = this._lodLevel;
                key.west = this._lodLevel;
                key.east = this._lodLevel;

                if (this._index[0] > 0) {
                  const n = this.getTerrain().getBlock(this._index[0] - 1, this._index[1]);
                  key.west = n._lodLevel;

                  if (key.west < this._lodLevel) {
                    key.west = this._lodLevel;
                  }
                }

                if (this._index[0] < this._terrain.info.blockCount[0] - 1) {
                  const n = this.getTerrain().getBlock(this._index[0] + 1, this._index[1]);
                  key.east = n._lodLevel;

                  if (key.east < this._lodLevel) {
                    key.east = this._lodLevel;
                  }
                }

                if (this._index[1] > 0) {
                  const n = this.getTerrain().getBlock(this._index[0], this._index[1] - 1);
                  key.north = n._lodLevel;

                  if (key.north < this._lodLevel) {
                    key.north = this._lodLevel;
                  }
                }

                if (this._index[1] < this._terrain.info.blockCount[1] - 1) {
                  const n = this.getTerrain().getBlock(this._index[0], this._index[1] + 1);
                  key.south = n._lodLevel;

                  if (key.south < this._lodLevel) {
                    key.south = this._lodLevel;
                  }
                }

                if (this._lodKey.equals(key)) {
                  return;
                }

                this._lodKey = key;

                this._updateIndexBuffer();
              }

              _resetLod() {
                const key = new TerrainLodKey();
                key.level = 0;
                key.north = 0;
                key.south = 0;
                key.west = 0;
                key.east = 0;

                if (this._lodKey.equals(key)) {
                  return;
                }

                this._lodKey = key;

                this._updateIndexBuffer();
              }

              _updateIndexBuffer() {
                if (this._renderable._meshData === null) {
                  return;
                }

                if (this._renderable._model === null) {
                  return;
                }

                if (this._renderable._model.subModels.length === 0) {
                  return;
                }

                const indexData = this._terrain._getIndexData(this._lodKey);

                if (indexData === null) {
                  return;
                }

                const model = this._renderable._model.subModels[0];
                model.inputAssembler.firstIndex = indexData.start;
                model.inputAssembler.indexCount = indexData.size;
              }

              _getHeight(x, y, verts) {
                const idx = TERRAIN_BLOCK_VERTEX_COMPLEXITY * y + x;
                return verts[idx * TERRAIN_BLOCK_VERTEX_SIZE + 1];
              }

              _updateLodBuffer(vertecs) {
                this._lodLevel = 0;
                this._lodKey = new TerrainLodKey();

                this._calcErrorMetrics(vertecs);

                this._calcLevelDistances(vertecs);
              }

              _calcErrorMetrics(vertecs) {
                this._errorMetrics[0] = 0;

                for (let i = 1; i < TERRAIN_LOD_LEVELS; ++i) {
                  this._errorMetrics[i] = this._calcErrorMetric(i, vertecs);
                }

                for (let i = 2; i < TERRAIN_LOD_LEVELS; ++i) {
                  this._errorMetrics[i] = Math.max(this._errorMetrics[i], this._errorMetrics[i - 1]);
                }
              }

              _calcErrorMetric(level, vertecs) {
                let err = 0.0;
                const step = 1 << level;
                const xSectionVerts = TERRAIN_BLOCK_VERTEX_COMPLEXITY;
                const ySectionVerts = TERRAIN_BLOCK_VERTEX_COMPLEXITY;
                const xSides = xSectionVerts - 1 >> level;
                const ySides = ySectionVerts - 1 >> level;

                for (let y = 0; y < ySectionVerts; y += step) {
                  for (let x = 0; x < xSides; ++x) {
                    const x0 = x * step;
                    const x1 = x0 + step;
                    const xm = (x1 + x0) / 2;

                    const h0 = this._getHeight(x0, y, vertecs);

                    const h1 = this._getHeight(x1, y, vertecs);

                    const hm = this._getHeight(xm, y, vertecs);

                    const hmi = (h0 + h1) / 2;
                    const delta = Math.abs(hm - hmi);
                    err = Math.max(err, delta);
                  }
                }

                for (let x = 0; x < xSectionVerts; x += step) {
                  for (let y = 0; y < ySides; ++y) {
                    const y0 = y * step;
                    const y1 = y0 + step;
                    const ym = (y0 + y1) / 2;

                    const h0 = this._getHeight(x, y0, vertecs);

                    const h1 = this._getHeight(x, y1, vertecs);

                    const hm = this._getHeight(x, ym, vertecs);

                    const hmi = (h0 + h1) / 2;
                    const delta = Math.abs(hm - hmi);
                    err = Math.max(err, delta);
                  }
                }

                for (let y = 0; y < ySides; ++y) {
                  const y0 = y * step;
                  const y1 = y0 + step;
                  const ym = (y0 + y1) / 2;

                  for (let x = 0; x < xSides; ++x) {
                    const x0 = x * step;
                    const x1 = x0 + step;
                    const xm = (x0 + x1) / 2;

                    const h0 = this._getHeight(x0, y0, vertecs);

                    const h1 = this._getHeight(x1, y1, vertecs);

                    const hm = this._getHeight(xm, ym, vertecs);

                    const hmi = (h0 + h1) / 2;
                    const delta = Math.abs(hm - hmi);
                    err = Math.max(err, delta);
                  }
                }

                return err;
              }

              _calcLevelDistances(vertecs) {
                const pixelerr = 4;
                const resolution = 768;
                const c = 1.0 / (2 * pixelerr / resolution);

                for (let i = 1; i < TERRAIN_LOD_LEVELS; ++i) {
                  const e = this._errorMetrics[i];
                  const d = e * c;
                  this._LevelDistances[i] = d;
                }
              }

              _buildVertexData(vertexData) {
                let index = 0;

                for (let j = 0; j < TERRAIN_BLOCK_VERTEX_COMPLEXITY; ++j) {
                  for (let i = 0; i < TERRAIN_BLOCK_VERTEX_COMPLEXITY; ++i) {
                    const x = this._index[0] * TERRAIN_BLOCK_TILE_COMPLEXITY + i;
                    const y = this._index[1] * TERRAIN_BLOCK_TILE_COMPLEXITY + j;

                    const position = this._terrain.getPosition(x, y);

                    const normal = this._terrain.getNormal(x, y);

                    const uv = new Vec2(i / TERRAIN_BLOCK_TILE_COMPLEXITY, j / TERRAIN_BLOCK_TILE_COMPLEXITY);
                    vertexData[index++] = position.x;
                    vertexData[index++] = position.y;
                    vertexData[index++] = position.z;
                    vertexData[index++] = normal.x;
                    vertexData[index++] = normal.y;
                    vertexData[index++] = normal.z;
                    vertexData[index++] = uv.x;
                    vertexData[index++] = uv.y;
                  }
                }
              }

              _buildBoundingBox() {
                this._bbMin.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);

                this._bbMax.set(Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE);

                for (let j = 0; j < TERRAIN_BLOCK_VERTEX_COMPLEXITY; ++j) {
                  for (let i = 0; i < TERRAIN_BLOCK_VERTEX_COMPLEXITY; ++i) {
                    const x = this._index[0] * TERRAIN_BLOCK_TILE_COMPLEXITY + i;
                    const y = this._index[1] * TERRAIN_BLOCK_TILE_COMPLEXITY + j;

                    const position = this._terrain.getPosition(x, y);

                    Vec3.min(this._bbMin, this._bbMin, position);
                    Vec3.max(this._bbMax, this._bbMax, position);
                  }
                }
              }

            } exports('TerrainBlock', TerrainBlock);
            let Terrain = exports('Terrain', (_dec4$X = ccclass('cc.Terrain'), _dec5$R = help(), _dec6$M = type$1(TerrainAsset), _dec7$L = type$1(EffectAsset), _dec8$H = visible(), _dec9$D = type$1(TerrainBlockLightmapInfo), _dec10$B = type$1(CCBoolean), _dec11$x = type$1(CCBoolean), _dec12$w = type$1(CCBoolean), _dec13$t = type$1(CCBoolean), _dec14$p = type$1(CCFloat), _dec15$p = type$1(TerrainAsset), _dec16$o = visible(), _dec17$l = type$1(EffectAsset), _dec18$k = visible(), _dec19$k = type$1(TerrainInfo), _dec4$X(_class10 = _dec5$R(_class10 = executeInEditMode(_class10 = disallowMultiple(_class10 = (_class11 = (_temp4 = class Terrain extends Component {
              constructor() {
                super();

                _initializerDefineProperty(this, "__asset", _descriptor15$6, this);

                _initializerDefineProperty(this, "_effectAsset", _descriptor16$6, this);

                _initializerDefineProperty(this, "_lightmapInfos", _descriptor17$5, this);

                _initializerDefineProperty(this, "_receiveShadow", _descriptor18$4, this);

                _initializerDefineProperty(this, "_useNormalmap", _descriptor19$3, this);

                _initializerDefineProperty(this, "_usePBR", _descriptor20$2, this);

                _initializerDefineProperty(this, "_lodEnable", _descriptor21$2, this);

                _initializerDefineProperty(this, "_lodBias", _descriptor22$2, this);

                this._buitinAsset = null;
                this._tileSize = 1;
                this._blockCount = [1, 1];
                this._weightMapSize = 128;
                this._lightMapSize = 128;
                this._heights = new Uint16Array();
                this._weights = new Uint8Array();
                this._normals = [];
                this._layerList = [];
                this._layerBuffer = [];
                this._blocks = [];
                this._lod = new TerrainLod();
                this._sharedIndexBuffer = null;

                for (let i = 0; i < TERRAIN_MAX_LAYER_COUNT; ++i) {
                  this._layerList.push(null);
                }
              }

              set _asset(value) {
                this.__asset = value;

                if (this._buitinAsset !== this.__asset) {
                  this._buitinAsset = this.__asset;

                  for (let i = 0; i < this._blocks.length; ++i) {
                    this._blocks[i].destroy();
                  }

                  this._blocks = [];

                  if (this.__asset === null) {
                    this._effectAsset = null;
                    this._lightmapInfos = [];
                    this._receiveShadow = false;
                    this._useNormalmap = false;
                    this._usePBR = false;
                    this._tileSize = 1;
                    this._blockCount = [1, 1];
                    this._weightMapSize = 128;
                    this._lightMapSize = 128;
                    this._heights = new Uint16Array();
                    this._weights = new Uint8Array();
                    this._normals = [];
                    this._layerBuffer = [];
                    this._blocks = [];
                    this._layerList = [];

                    for (let i = 0; i < TERRAIN_MAX_LAYER_COUNT; ++i) {
                      this._layerList.push(null);
                    }
                  }

                  if (legacyCC.director.root.device) {
                    this._buildImp();
                  }
                }
              }

              get _asset() {
                return this.__asset;
              }

              set effectAsset(value) {
                if (this._effectAsset === value) {
                  return;
                }

                this._effectAsset = value;

                for (let i = 0; i < this._blocks.length; ++i) {
                  this._blocks[i]._invalidMaterial();
                }
              }

              get effectAsset() {
                return this._effectAsset;
              }

              get receiveShadow() {
                return this._receiveShadow;
              }

              set receiveShadow(val) {
                this._receiveShadow = val;

                for (let i = 0; i < this._blocks.length; i++) {
                  this._blocks[i]._invalidMaterial();
                }
              }

              get useNormalMap() {
                return this._useNormalmap;
              }

              set useNormalMap(val) {
                this._useNormalmap = val;

                for (let i = 0; i < this._blocks.length; i++) {
                  this._blocks[i]._invalidMaterial();
                }
              }

              get usePBR() {
                return this._usePBR;
              }

              set usePBR(val) {
                this._usePBR = val;

                for (let i = 0; i < this._blocks.length; i++) {
                  this._blocks[i]._invalidMaterial();
                }
              }

              get lodEnable() {
                return this._lodEnable;
              }

              set lodEnable(val) {
                this._lodEnable = val;

                if (!this._lodEnable) {
                  for (let i = 0; i < this._blocks.length; i++) {
                    this._blocks[i]._resetLod();
                  }
                }
              }

              get LodBias() {
                return this._lodBias;
              }

              set LodBias(val) {
                this._lodBias = val;
              }

              get size() {
                const sz = new Size$1(0, 0);
                sz.width = this.blockCount[0] * TERRAIN_BLOCK_TILE_COMPLEXITY * this.tileSize;
                sz.height = this.blockCount[1] * TERRAIN_BLOCK_TILE_COMPLEXITY * this.tileSize;
                return sz;
              }

              get tileSize() {
                return this._tileSize;
              }

              get tileCount() {
                return [this.blockCount[0] * TERRAIN_BLOCK_TILE_COMPLEXITY, this.blockCount[1] * TERRAIN_BLOCK_TILE_COMPLEXITY];
              }

              get vertexCount() {
                const _vertexCount = this.tileCount;
                _vertexCount[0] += 1;
                _vertexCount[1] += 1;
                return _vertexCount;
              }

              get blockCount() {
                return this._blockCount;
              }

              get lightMapSize() {
                return this._lightMapSize;
              }

              get weightMapSize() {
                return this._weightMapSize;
              }

              get heights() {
                return this._heights;
              }

              get weights() {
                return this._weights;
              }

              get valid() {
                return this._blocks.length > 0;
              }

              get info() {
                const ti = new TerrainInfo();
                ti.tileSize = this.tileSize;
                ti.blockCount[0] = this.blockCount[0];
                ti.blockCount[1] = this.blockCount[1];
                ti.weightMapSize = this.weightMapSize;
                ti.lightMapSize = this.lightMapSize;
                return ti;
              }

              build(info) {
                this._tileSize = info.tileSize;
                this._blockCount[0] = info.blockCount[0];
                this._blockCount[1] = info.blockCount[1];
                this._weightMapSize = info.weightMapSize;
                this._lightMapSize = info.lightMapSize;
                return this._buildImp();
              }

              rebuild(info) {
                for (let i = 0; i < this._blocks.length; ++i) {
                  this._blocks[i].destroy();
                }

                this._blocks = [];

                this._rebuildLayerBuffer(info);

                this._rebuildHeights(info);

                this._rebuildWeights(info);

                this._tileSize = info.tileSize;
                this._blockCount[0] = info.blockCount[0];
                this._blockCount[1] = info.blockCount[1];
                this._weightMapSize = info.weightMapSize;
                this._lightMapSize = info.lightMapSize;

                this._buildNormals();

                for (let j = 0; j < this._blockCount[1]; ++j) {
                  for (let i = 0; i < this._blockCount[0]; ++i) {
                    this._blocks.push(new TerrainBlock(this, i, j));
                  }
                }

                for (let i = 0; i < this._blocks.length; ++i) {
                  this._blocks[i].build();
                }
              }

              importHeightField(hf, heightScale) {
                let index = 0;

                for (let j = 0; j < this.vertexCount[1]; ++j) {
                  for (let i = 0; i < this.vertexCount[0]; ++i) {
                    const u = i / this.tileCount[0];
                    const v = j / this.tileCount[1];
                    const h = hf.getAt(u * hf.w, v * hf.h) * heightScale;
                    this._heights[index++] = h;
                  }
                }

                this._buildNormals();

                for (let i = 0; i < this._blocks.length; ++i) {
                  this._blocks[i]._updateHeight();
                }
              }

              exportHeightField(hf, heightScale) {
                let index = 0;

                for (let j = 0; j < hf.h; ++j) {
                  for (let i = 0; i < hf.w; ++i) {
                    const u = i / (hf.w - 1);
                    const v = j / (hf.h - 1);
                    const x = u * this.size.width;
                    const y = v * this.size.height;
                    const h = this.getHeightAt(x, y);

                    if (h != null) {
                      hf.data[index++] = h * heightScale;
                    }
                  }
                }
              }

              exportAsset() {
                const asset = new TerrainAsset();
                asset.tileSize = this.tileSize;
                asset.blockCount = this.blockCount;
                asset.lightMapSize = this.lightMapSize;
                asset.weightMapSize = this.weightMapSize;
                asset.heights = this.heights;
                asset.weights = this.weights;
                asset.layerBuffer = new Array(this._blocks.length * 4);

                for (let i = 0; i < this._blocks.length; ++i) {
                  asset.layerBuffer[i * 4 + 0] = this._blocks[i].layers[0];
                  asset.layerBuffer[i * 4 + 1] = this._blocks[i].layers[1];
                  asset.layerBuffer[i * 4 + 2] = this._blocks[i].layers[2];
                  asset.layerBuffer[i * 4 + 3] = this._blocks[i].layers[3];
                }

                for (let i = 0; i < this._layerList.length; ++i) {
                  const temp = this._layerList[i];

                  if (temp && temp.detailMap && isValid(temp.detailMap)) {
                    const layer = new TerrainLayerInfo();
                    layer.slot = i;
                    layer.tileSize = temp.tileSize;
                    layer.detailMap = temp.detailMap;
                    layer.normalMap = temp.normalMap;
                    layer.metallic = temp.metallic;
                    layer.roughness = temp.roughness;
                    asset.layerInfos.push(layer);
                  }
                }

                return asset;
              }

              getEffectAsset() {
                if (this._effectAsset === null) {
                  return legacyCC.EffectAsset.get('terrain');
                }

                return this._effectAsset;
              }

              onEnable() {
                if (this._blocks.length === 0) {
                  this._buildImp();
                }

                for (let i = 0; i < this._blocks.length; ++i) {
                  this._blocks[i].visible = true;
                }

                legacyCC.director.root.pipeline.on(PipelineEventType.RENDER_CAMERA_BEGIN, this.onUpdateFromCamera, this);
              }

              onDisable() {
                legacyCC.director.root.pipeline.off(PipelineEventType.RENDER_CAMERA_BEGIN, this.onUpdateFromCamera, this);

                for (let i = 0; i < this._blocks.length; ++i) {
                  this._blocks[i].visible = false;
                }
              }

              onDestroy() {
                for (let i = 0; i < this._blocks.length; ++i) {
                  this._blocks[i].destroy();
                }

                this._blocks = [];

                for (let i = 0; i < this._layerList.length; ++i) {
                  this._layerList[i] = null;
                }

                if (this._sharedIndexBuffer != null) {
                  this._sharedIndexBuffer.destroy();
                }
              }

              onRestore() {
                this.onEnable();

                this._buildImp(true);
              }

              update(deltaTime) {
                for (let i = 0; i < this._blocks.length; ++i) {
                  this._blocks[i].update();
                }
              }

              onUpdateFromCamera(cam) {
                if (!this.lodEnable) {
                  return;
                }

                if (cam.scene !== this._getRenderScene()) {
                  return;
                }

                for (let i = 0; i < this._blocks.length; ++i) {
                  this._blocks[i]._updateLevel(cam.position);
                }

                for (let i = 0; i < this._blocks.length; ++i) {
                  this._blocks[i]._updateLod();
                }
              }

              addLayer(layer) {
                for (let i = 0; i < this._layerList.length; ++i) {
                  var _this$_layerList$i;

                  if (this._layerList[i] === null || this._layerList[i] && ((_this$_layerList$i = this._layerList[i]) === null || _this$_layerList$i === void 0 ? void 0 : _this$_layerList$i.detailMap) === null) {
                    this._layerList[i] = layer;
                    return i;
                  }
                }

                return -1;
              }

              setLayer(i, layer) {
                this._layerList[i] = layer;
              }

              removeLayer(id) {
                this._layerList[id] = null;
              }

              getLayer(id) {
                if (id === -1) {
                  return null;
                }

                return this._layerList[id];
              }

              getPosition(i, j) {
                const x = i * this._tileSize;
                const z = j * this._tileSize;
                const y = this.getHeight(i, j);
                return new Vec3(x, y, z);
              }

              getHeightField() {
                return this._heights;
              }

              setHeight(i, j, h) {
                h = clamp$1(h, TERRAIN_HEIGHT_FMIN, TERRAIN_HEIGHT_FMAX);
                this._heights[j * this.vertexCount[0] + i] = TERRAIN_HEIGHT_BASE + h / TERRAIN_HEIGHT_FACTORY;
              }

              getHeight(i, j) {
                return (this._heights[j * this.vertexCount[0] + i] - TERRAIN_HEIGHT_BASE) * TERRAIN_HEIGHT_FACTORY;
              }

              getHeightClamp(i, j) {
                i = clamp$1(i, 0, this.vertexCount[0] - 1);
                j = clamp$1(j, 0, this.vertexCount[1] - 1);
                return this.getHeight(i, j);
              }

              getHeightAt(x, y) {
                const fx = x / this.tileSize;
                const fy = y / this.tileSize;
                let ix0 = Math.floor(fx);
                let iz0 = Math.floor(fy);
                let ix1 = ix0 + 1;
                let iz1 = iz0 + 1;
                const dx = fx - ix0;
                const dz = fy - iz0;

                if (ix0 < 0 || ix0 > this.vertexCount[0] - 1 || iz0 < 0 || iz0 > this.vertexCount[1] - 1) {
                  return null;
                }

                ix0 = clamp$1(ix0, 0, this.vertexCount[0] - 1);
                iz0 = clamp$1(iz0, 0, this.vertexCount[1] - 1);
                ix1 = clamp$1(ix1, 0, this.vertexCount[0] - 1);
                iz1 = clamp$1(iz1, 0, this.vertexCount[1] - 1);
                let a = this.getHeight(ix0, iz0);
                const b = this.getHeight(ix1, iz0);
                const c = this.getHeight(ix0, iz1);
                let d = this.getHeight(ix1, iz1);
                const m = (b + c) * 0.5;

                if (dx + dz <= 1.0) {
                  d = m + (m - a);
                } else {
                  a = m + (m - d);
                }

                const h1 = a * (1.0 - dx) + b * dx;
                const h2 = c * (1.0 - dx) + d * dx;
                const h = h1 * (1.0 - dz) + h2 * dz;
                return h;
              }

              _setNormal(i, j, n) {
                const index = j * this.vertexCount[0] + i;
                this._normals[index * 3 + 0] = n.x;
                this._normals[index * 3 + 1] = n.y;
                this._normals[index * 3 + 2] = n.z;
              }

              getNormal(i, j) {
                const index = j * this.vertexCount[0] + i;
                const n = new Vec3();
                n.x = this._normals[index * 3 + 0];
                n.y = this._normals[index * 3 + 1];
                n.z = this._normals[index * 3 + 2];
                return n;
              }

              getNormalAt(x, y) {
                const fx = x / this.tileSize;
                const fy = y / this.tileSize;
                let ix0 = Math.floor(fx);
                let iz0 = Math.floor(fy);
                let ix1 = ix0 + 1;
                let iz1 = iz0 + 1;
                const dx = fx - ix0;
                const dz = fy - iz0;

                if (ix0 < 0 || ix0 > this.vertexCount[0] - 1 || iz0 < 0 || iz0 > this.vertexCount[1] - 1) {
                  return null;
                }

                ix0 = clamp$1(ix0, 0, this.vertexCount[0] - 1);
                iz0 = clamp$1(iz0, 0, this.vertexCount[1] - 1);
                ix1 = clamp$1(ix1, 0, this.vertexCount[0] - 1);
                iz1 = clamp$1(iz1, 0, this.vertexCount[1] - 1);
                const a = this.getNormal(ix0, iz0);
                const b = this.getNormal(ix1, iz0);
                const c = this.getNormal(ix0, iz1);
                const d = this.getNormal(ix1, iz1);
                const m = new Vec3();
                Vec3.add(m, b, c).multiplyScalar(0.5);

                if (dx + dz <= 1.0) {
                  d.set(m);
                  d.subtract(a);
                  d.add(m);
                } else {
                  a.set(m);
                  a.subtract(d);
                  a.add(m);
                }

                const n1 = new Vec3();
                const n2 = new Vec3();
                const n = new Vec3();
                Vec3.lerp(n1, a, b, dx);
                Vec3.lerp(n2, c, d, dx);
                Vec3.lerp(n, n1, n2, dz);
                return n;
              }

              setWeight(i, j, w) {
                const index = j * this._weightMapSize * this._blockCount[0] + i;
                this._weights[index * 4 + 0] = w.x * 255;
                this._weights[index * 4 + 1] = w.y * 255;
                this._weights[index * 4 + 2] = w.z * 255;
                this._weights[index * 4 + 3] = w.w * 255;
              }

              getWeight(i, j) {
                const index = j * this._weightMapSize * this._blockCount[0] + i;
                const w = new Vec4();
                w.x = this._weights[index * 4 + 0] / 255.0;
                w.y = this._weights[index * 4 + 1] / 255.0;
                w.z = this._weights[index * 4 + 2] / 255.0;
                w.w = this._weights[index * 4 + 3] / 255.0;
                return w;
              }

              getWeightAt(x, y) {
                const uWeigthComplexity = this.weightMapSize * this.blockCount[0];
                const vWeigthComplexity = this.weightMapSize * this.blockCount[1];

                if (uWeigthComplexity === 0 || vWeigthComplexity === 0) {
                  return null;
                }

                const fx = x / uWeigthComplexity;
                const fy = y / vWeigthComplexity;
                let ix0 = Math.floor(fx);
                let iz0 = Math.floor(fy);
                let ix1 = ix0 + 1;
                let iz1 = iz0 + 1;
                const dx = fx - ix0;
                const dz = fy - iz0;

                if (ix0 < 0 || ix0 > uWeigthComplexity - 1 || iz0 < 0 || iz0 > vWeigthComplexity - 1) {
                  return null;
                }

                ix0 = clamp$1(ix0, 0, uWeigthComplexity - 1);
                iz0 = clamp$1(iz0, 0, vWeigthComplexity - 1);
                ix1 = clamp$1(ix1, 0, uWeigthComplexity - 1);
                iz1 = clamp$1(iz1, 0, vWeigthComplexity - 1);
                let a = this.getWeight(ix0, iz0);
                const b = this.getWeight(ix1, iz0);
                const c = this.getWeight(ix0, iz1);
                let d = this.getWeight(ix1, iz1);
                const m = new Vec4();
                Vec4.add(m, b, c).multiplyScalar(0.5);

                if (dx + dz <= 1.0) {
                  d = new Vec4();
                  Vec4.subtract(d, m, a).add(m);
                } else {
                  a = new Vec4();
                  Vec4.subtract(a, m, d).add(m);
                }

                const n1 = new Vec4();
                const n2 = new Vec4();
                const n = new Vec4();
                Vec4.lerp(n1, a, b, dx);
                Vec4.lerp(n2, c, d, dx);
                Vec4.lerp(n, n1, n2, dz);
                return n;
              }

              getMaxWeightLayerAt(x, y) {
                const uWeigthComplexity = this.weightMapSize * this.blockCount[0];
                const vWeigthComplexity = this.weightMapSize * this.blockCount[1];

                if (uWeigthComplexity === 0 || vWeigthComplexity === 0) {
                  return null;
                }

                const fx = x / uWeigthComplexity;
                const fy = y / vWeigthComplexity;
                const ix0 = Math.floor(fx);
                const iz0 = Math.floor(fy);

                if (ix0 < 0 || ix0 > uWeigthComplexity - 1 || iz0 < 0 || iz0 > vWeigthComplexity - 1) {
                  return null;
                }

                const w = this.getWeight(ix0, iz0);
                const bx = Math.floor(x / this.weightMapSize);
                const by = Math.floor(y / this.weightMapSize);
                const block = this.getBlock(bx, by);
                let i = 0;

                if (w.y > w[i] && block.getLayer(1) !== -1) {
                  i = 1;
                }

                if (w.y > w[i] && block.getLayer(2) !== -1) {
                  i = 2;
                }

                if (w.z > w[i] && block.getLayer(3) !== -1) {
                  i = 3;
                }

                i = block.getLayer(i);
                return this.getLayer(i);
              }

              getBlockLayers(i, j) {
                const layerIndex = (j * this._blockCount[0] + i) * TERRAIN_MAX_BLEND_LAYERS;
                return [this._layerBuffer[layerIndex], this._layerBuffer[layerIndex + 1], this._layerBuffer[layerIndex + 2], this._layerBuffer[layerIndex + 3]];
              }

              getBlockLayer(i, j, index) {
                const layerIndex = (j * this._blockCount[0] + i) * TERRAIN_MAX_BLEND_LAYERS;
                return this._layerBuffer[layerIndex + index];
              }

              setBlockLayer(i, j, index, layerId) {
                const layerIndex = (j * this._blockCount[0] + i) * TERRAIN_MAX_BLEND_LAYERS;
                this._layerBuffer[layerIndex + index] = layerId;
              }

              getBlock(i, j) {
                return this._blocks[j * this._blockCount[0] + i];
              }

              getBlocks() {
                return this._blocks;
              }

              rayCheck(start, dir, step, worldSpace = true) {
                const MAX_COUNT = 2000;
                const trace = start;

                if (worldSpace) {
                  Vec3.subtract(trace, start, this.node.getWorldPosition());
                }

                const delta = new Vec3();
                delta.set(dir);
                delta.multiplyScalar(step);
                let position = null;

                if (dir.equals(new Vec3(0, 1, 0))) {
                  const y = this.getHeightAt(trace.x, trace.z);

                  if (y != null && trace.y <= y) {
                    position = new Vec3(trace.x, y, trace.z);
                  }
                } else if (dir.equals(new Vec3(0, -1, 0))) {
                  const y = this.getHeightAt(trace.x, trace.z);

                  if (y != null && trace.y >= y) {
                    position = new Vec3(trace.x, y, trace.z);
                  }
                } else {
                  let i = 0;

                  while (i++ < MAX_COUNT) {
                    const y = this.getHeightAt(trace.x, trace.z);

                    if (y != null && trace.y <= y) {
                      break;
                    }

                    trace.add(dir);
                  }

                  while (i++ < MAX_COUNT) {
                    const y = this.getHeightAt(trace.x, trace.z);

                    if (y != null && trace.y <= y) {
                      position = new Vec3(trace.x, y, trace.z);
                      break;
                    }

                    trace.add(delta);
                  }
                }

                return position;
              }

              _getSharedIndexBuffer() {
                if (this._sharedIndexBuffer == null) {
                  const gfxDevice = legacyCC.director.root.device;
                  this._sharedIndexBuffer = gfxDevice.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, Uint16Array.BYTES_PER_ELEMENT * this._lod._indexBuffer.length, Uint16Array.BYTES_PER_ELEMENT));

                  this._sharedIndexBuffer.update(this._lod._indexBuffer);
                }

                return this._sharedIndexBuffer;
              }

              _getIndexData(key) {
                return this._lod.getIndexData(key);
              }

              _resetLightmap(enble) {
                this._lightmapInfos.length = 0;

                if (enble) {
                  for (let i = 0; i < this._blockCount[0] * this._blockCount[1]; ++i) {
                    this._lightmapInfos.push(new TerrainBlockLightmapInfo());
                  }
                }
              }

              _updateLightmap(blockId, tex, uOff, vOff, uScale, vScale) {
                this._lightmapInfos[blockId].texture = tex;
                this._lightmapInfos[blockId].UOff = uOff;
                this._lightmapInfos[blockId].VOff = vOff;
                this._lightmapInfos[blockId].UScale = uScale;
                this._lightmapInfos[blockId].VScale = vScale;

                this._blocks[blockId]._updateLightmap(this._lightmapInfos[blockId]);
              }

              _getLightmapInfo(i, j) {
                const index = j * this._blockCount[0] + i;
                return index < this._lightmapInfos.length ? this._lightmapInfos[index] : null;
              }

              _calcNormal(x, z) {
                let flip = 1;
                const here = this.getPosition(x, z);
                let right;
                let up;

                if (x < this.vertexCount[0] - 1) {
                  right = this.getPosition(x + 1, z);
                } else {
                  flip *= -1;
                  right = this.getPosition(x - 1, z);
                }

                if (z < this.vertexCount[1] - 1) {
                  up = this.getPosition(x, z + 1);
                } else {
                  flip *= -1;
                  up = this.getPosition(x, z - 1);
                }

                right.subtract(here);
                up.subtract(here);
                const normal = new Vec3();
                normal.set(up);
                normal.cross(right);
                normal.multiplyScalar(flip);
                normal.normalize();
                return normal;
              }

              _buildNormals() {
                let index = 0;

                for (let y = 0; y < this.vertexCount[1]; ++y) {
                  for (let x = 0; x < this.vertexCount[0]; ++x) {
                    const n = this._calcNormal(x, y);

                    this._normals[index * 3 + 0] = n.x;
                    this._normals[index * 3 + 1] = n.y;
                    this._normals[index * 3 + 2] = n.z;
                    index += 1;
                  }
                }
              }

              _buildImp(restore = false) {
                if (this.valid) {
                  return;
                }

                const terrainAsset = this.__asset;

                if (this._buitinAsset != terrainAsset) {
                  this._buitinAsset = terrainAsset;
                }

                if (!restore && terrainAsset !== null) {
                  this._tileSize = terrainAsset.tileSize;
                  this._blockCount = terrainAsset.blockCount;
                  this._weightMapSize = terrainAsset.weightMapSize;
                  this._lightMapSize = terrainAsset.lightMapSize;
                  this._heights = terrainAsset.heights;
                  this._weights = terrainAsset.weights;
                  this._layerBuffer = terrainAsset.layerBuffer;

                  for (let i = 0; i < this._layerList.length; ++i) {
                    this._layerList[i] = null;
                  }

                  if (terrainAsset.version < TERRAIN_DATA_VERSION5) {
                    for (let i = 0; i < terrainAsset.layerBinaryInfos.length; ++i) {
                      const layer = new TerrainLayer();
                      const layerInfo = terrainAsset.layerBinaryInfos[i];
                      layer.tileSize = layerInfo.tileSize;
                      legacyCC.assetManager.loadAny(layerInfo.detailMapId, (err, asset) => {
                        layer.detailMap = asset;
                      });

                      if (layerInfo.normalMapId !== '') {
                        legacyCC.assetManager.loadAny(layerInfo.normalMapId, (err, asset) => {
                          layer.normalMap = asset;
                        });
                      }

                      layer.roughness = layerInfo.roughness;
                      layer.metallic = layerInfo.metallic;
                      this._layerList[layerInfo.slot] = layer;
                    }
                  } else {
                    for (let i = 0; i < terrainAsset.layerInfos.length; ++i) {
                      const layer = new TerrainLayer();
                      const layerInfo = terrainAsset.layerInfos[i];
                      layer.tileSize = layerInfo.tileSize;
                      layer.detailMap = layerInfo.detailMap;
                      layer.normalMap = layerInfo.normalMap;
                      layer.roughness = layerInfo.roughness;
                      layer.metallic = layerInfo.metallic;
                      this._layerList[layerInfo.slot] = layer;
                    }
                  }
                }

                if (this._blockCount[0] === 0 || this._blockCount[1] === 0) {
                  return;
                }

                const vertexCount = this.vertexCount[0] * this.vertexCount[1];

                if (this._heights === null || this._heights.length !== vertexCount) {
                  this._heights = new Uint16Array(vertexCount);
                  this._normals = new Array(vertexCount * 3);

                  for (let i = 0; i < vertexCount; ++i) {
                    this._heights[i] = TERRAIN_HEIGHT_BASE;
                    this._normals[i * 3 + 0] = 0;
                    this._normals[i * 3 + 1] = 1;
                    this._normals[i * 3 + 2] = 0;
                  }
                } else {
                  this._normals = new Array(vertexCount * 3);

                  this._buildNormals();
                }

                const layerBufferSize = this.blockCount[0] * this.blockCount[1] * TERRAIN_MAX_BLEND_LAYERS;

                if (this._layerBuffer === null || this._layerBuffer.length !== layerBufferSize) {
                  this._layerBuffer = new Array(layerBufferSize);

                  for (let i = 0; i < layerBufferSize; ++i) {
                    this._layerBuffer[i] = -1;
                  }
                }

                const weightMapComplexityU = this._weightMapSize * this._blockCount[0];
                const weightMapComplexityV = this._weightMapSize * this._blockCount[1];

                if (this._weights.length !== weightMapComplexityU * weightMapComplexityV * 4) {
                  this._weights = new Uint8Array(weightMapComplexityU * weightMapComplexityV * 4);

                  for (let i = 0; i < weightMapComplexityU * weightMapComplexityV; ++i) {
                    this._weights[i * 4 + 0] = 255;
                    this._weights[i * 4 + 1] = 0;
                    this._weights[i * 4 + 2] = 0;
                    this._weights[i * 4 + 3] = 0;
                  }
                }

                for (let j = 0; j < this._blockCount[1]; ++j) {
                  for (let i = 0; i < this._blockCount[0]; ++i) {
                    this._blocks.push(new TerrainBlock(this, i, j));
                  }
                }

                for (let i = 0; i < this._blocks.length; ++i) {
                  this._blocks[i].build();
                }
              }

              _rebuildHeights(info) {
                if (this.vertexCount[0] === info.vertexCount[0] && this.vertexCount[1] === info.vertexCount[1]) {
                  return false;
                }

                const heights = new Uint16Array(info.vertexCount[0] * info.vertexCount[1]);

                for (let i = 0; i < heights.length; ++i) {
                  heights[i] = TERRAIN_HEIGHT_BASE;
                }

                const w = Math.min(this.vertexCount[0], info.vertexCount[0]);
                const h = Math.min(this.vertexCount[1], info.vertexCount[1]);

                for (let j = 0; j < h; ++j) {
                  for (let i = 0; i < w; ++i) {
                    const index0 = j * info.vertexCount[0] + i;
                    const index1 = j * this.vertexCount[0] + i;
                    heights[index0] = this._heights[index1];
                  }
                }

                this._heights = heights;
                return true;
              }

              _rebuildLayerBuffer(info) {
                if (this.blockCount[0] === info.blockCount[0] && this.blockCount[1] === info.blockCount[1]) {
                  return false;
                }

                const layerBuffer = [];
                layerBuffer.length = info.blockCount[0] * info.blockCount[1] * TERRAIN_MAX_BLEND_LAYERS;

                for (let i = 0; i < layerBuffer.length; ++i) {
                  layerBuffer[i] = -1;
                }

                const w = Math.min(this.blockCount[0], info.blockCount[0]);
                const h = Math.min(this.blockCount[1], info.blockCount[1]);

                for (let j = 0; j < h; ++j) {
                  for (let i = 0; i < w; ++i) {
                    const index0 = j * info.blockCount[0] + i;
                    const index1 = j * this.blockCount[0] + i;

                    for (let l = 0; l < TERRAIN_MAX_BLEND_LAYERS; ++l) {
                      layerBuffer[index0 * TERRAIN_MAX_BLEND_LAYERS + l] = this._layerBuffer[index1 * TERRAIN_MAX_BLEND_LAYERS + l];
                    }
                  }
                }

                this._layerBuffer = layerBuffer;
                return true;
              }

              _rebuildWeights(info) {
                const oldWeightMapSize = this._weightMapSize;
                const oldWeightMapComplexityU = this._weightMapSize * this._blockCount[0];
                const oldWeightMapComplexityV = this._weightMapSize * this._blockCount[1];
                const weightMapComplexityU = info.weightMapSize * info.blockCount[0];
                const weightMapComplexityV = info.weightMapSize * info.blockCount[1];

                if (weightMapComplexityU === oldWeightMapComplexityU && weightMapComplexityV === oldWeightMapComplexityV) {
                  return false;
                }

                const weights = new Uint8Array(weightMapComplexityU * weightMapComplexityV * 4);

                for (let i = 0; i < weightMapComplexityU * weightMapComplexityV; ++i) {
                  weights[i * 4 + 0] = 255;
                  weights[i * 4 + 1] = 0;
                  weights[i * 4 + 2] = 0;
                  weights[i * 4 + 3] = 0;
                }

                const w = Math.min(info.blockCount[0], this._blockCount[0]);
                const h = Math.min(info.blockCount[1], this._blockCount[1]);

                const getOldWeight = (_i, _j, _weights) => {
                  const index = _j * oldWeightMapComplexityU + _i;
                  const weight = new Vec4();
                  weight.x = _weights[index * 4 + 0] / 255.0;
                  weight.y = _weights[index * 4 + 1] / 255.0;
                  weight.z = _weights[index * 4 + 2] / 255.0;
                  weight.w = _weights[index * 4 + 3] / 255.0;
                  return weight;
                };

                const sampleOldWeight = (_x, _y, _xOff, _yOff, _weights) => {
                  const ix0 = Math.floor(_x);
                  const iz0 = Math.floor(_y);
                  const ix1 = ix0 + 1;
                  const iz1 = iz0 + 1;
                  const dx = _x - ix0;
                  const dz = _y - iz0;
                  const a = getOldWeight(ix0 + _xOff, iz0 + _yOff, this._weights);
                  const b = getOldWeight(ix1 + _xOff, iz0 + _yOff, this._weights);
                  const c = getOldWeight(ix0 + _xOff, iz1 + _yOff, this._weights);
                  const d = getOldWeight(ix1 + _xOff, iz1 + _yOff, this._weights);
                  const m = new Vec4();
                  Vec4.add(m, b, c).multiplyScalar(0.5);

                  if (dx + dz <= 1.0) {
                    d.set(m);
                    d.subtract(a);
                    d.add(m);
                  } else {
                    a.set(m);
                    a.subtract(d);
                    a.add(m);
                  }

                  const n1 = new Vec4();
                  const n2 = new Vec4();
                  const n = new Vec4();
                  Vec4.lerp(n1, a, b, dx);
                  Vec4.lerp(n2, c, d, dx);
                  Vec4.lerp(n, n1, n2, dz);
                  return n;
                };

                for (let j = 0; j < h; ++j) {
                  for (let i = 0; i < w; ++i) {
                    const uOff = i * oldWeightMapSize;
                    const vOff = j * oldWeightMapSize;

                    for (let v = 0; v < info.weightMapSize; ++v) {
                      for (let u = 0; u < info.weightMapSize; ++u) {
                        let w;

                        if (info.weightMapSize === oldWeightMapSize) {
                          w = getOldWeight(u + uOff, v + vOff, this._weights);
                        } else {
                          const x = u / (info.weightMapSize - 1) * (oldWeightMapSize - 1);
                          const y = v / (info.weightMapSize - 1) * (oldWeightMapSize - 1);
                          w = sampleOldWeight(x, y, uOff, vOff, this._weights);
                        }

                        const du = i * info.weightMapSize + u;
                        const dv = j * info.weightMapSize + v;
                        const index = dv * weightMapComplexityU + du;
                        weights[index * 4 + 0] = w.x * 255;
                        weights[index * 4 + 1] = w.y * 255;
                        weights[index * 4 + 2] = w.z * 255;
                        weights[index * 4 + 3] = w.w * 255;
                      }
                    }
                  }
                }

                this._weights = weights;
                return true;
              }

            }, _temp4), (_descriptor15$6 = _applyDecoratedDescriptor(_class11.prototype, "__asset", [_dec6$M, serializable, disallowAnimation], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor16$6 = _applyDecoratedDescriptor(_class11.prototype, "_effectAsset", [_dec7$L, serializable, disallowAnimation, _dec8$H], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor17$5 = _applyDecoratedDescriptor(_class11.prototype, "_lightmapInfos", [_dec9$D, serializable, disallowAnimation], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor18$4 = _applyDecoratedDescriptor(_class11.prototype, "_receiveShadow", [_dec10$B, serializable, disallowAnimation], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor19$3 = _applyDecoratedDescriptor(_class11.prototype, "_useNormalmap", [_dec11$x, serializable, disallowAnimation], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor20$2 = _applyDecoratedDescriptor(_class11.prototype, "_usePBR", [_dec12$w, serializable, disallowAnimation], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor21$2 = _applyDecoratedDescriptor(_class11.prototype, "_lodEnable", [_dec13$t, serializable, disallowAnimation], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor22$2 = _applyDecoratedDescriptor(_class11.prototype, "_lodBias", [_dec14$p, serializable, disallowAnimation], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _applyDecoratedDescriptor(_class11.prototype, "_asset", [_dec15$p, _dec16$o], Object.getOwnPropertyDescriptor(_class11.prototype, "_asset"), _class11.prototype), _applyDecoratedDescriptor(_class11.prototype, "effectAsset", [_dec17$l, _dec18$k], Object.getOwnPropertyDescriptor(_class11.prototype, "effectAsset"), _class11.prototype), _applyDecoratedDescriptor(_class11.prototype, "receiveShadow", [editable], Object.getOwnPropertyDescriptor(_class11.prototype, "receiveShadow"), _class11.prototype), _applyDecoratedDescriptor(_class11.prototype, "useNormalMap", [editable], Object.getOwnPropertyDescriptor(_class11.prototype, "useNormalMap"), _class11.prototype), _applyDecoratedDescriptor(_class11.prototype, "usePBR", [editable], Object.getOwnPropertyDescriptor(_class11.prototype, "usePBR"), _class11.prototype), _applyDecoratedDescriptor(_class11.prototype, "lodEnable", [editable], Object.getOwnPropertyDescriptor(_class11.prototype, "lodEnable"), _class11.prototype), _applyDecoratedDescriptor(_class11.prototype, "LodBias", [editable], Object.getOwnPropertyDescriptor(_class11.prototype, "LodBias"), _class11.prototype), _applyDecoratedDescriptor(_class11.prototype, "info", [_dec19$k], Object.getOwnPropertyDescriptor(_class11.prototype, "info"), _class11.prototype)), _class11)) || _class10) || _class10) || _class10) || _class10));

            let Orientation;

            (function (Orientation) {
              Orientation[Orientation["ORTHO"] = 0] = "ORTHO";
              Orientation[Orientation["HEX"] = 1] = "HEX";
              Orientation[Orientation["ISO"] = 2] = "ISO";
            })(Orientation || (Orientation = {}));

            ccenum(Orientation);
            let Property;

            (function (Property) {
              Property[Property["NONE"] = 0] = "NONE";
              Property[Property["MAP"] = 1] = "MAP";
              Property[Property["LAYER"] = 2] = "LAYER";
              Property[Property["OBJECTGROUP"] = 3] = "OBJECTGROUP";
              Property[Property["OBJECT"] = 4] = "OBJECT";
              Property[Property["TILE"] = 5] = "TILE";
            })(Property || (Property = {}));

            ccenum(Property);
            let TileFlag;

            (function (TileFlag) {
              TileFlag[TileFlag["HORIZONTAL"] = 2147483648] = "HORIZONTAL";
              TileFlag[TileFlag["VERTICAL"] = 1073741824] = "VERTICAL";
              TileFlag[TileFlag["DIAGONAL"] = 536870912] = "DIAGONAL";
              TileFlag[TileFlag["FLIPPED_ALL"] = 4026531840] = "FLIPPED_ALL";
              TileFlag[TileFlag["FLIPPED_MASK"] = 268435455] = "FLIPPED_MASK";
            })(TileFlag || (TileFlag = {}));

            ccenum(TileFlag);
            let StaggerAxis;

            console.log('pptest importing cc 3.5');
            (function (StaggerAxis) {
              StaggerAxis[StaggerAxis["STAGGERAXIS_X"] = 0] = "STAGGERAXIS_X";
              StaggerAxis[StaggerAxis["STAGGERAXIS_Y"] = 1] = "STAGGERAXIS_Y";
            })(StaggerAxis || (StaggerAxis = {}));

            ccenum(StaggerAxis);
            let StaggerIndex;

            (function (StaggerIndex) {
              StaggerIndex[StaggerIndex["STAGGERINDEX_ODD"] = 0] = "STAGGERINDEX_ODD";
              StaggerIndex[StaggerIndex["STAGGERINDEX_EVEN"] = 1] = "STAGGERINDEX_EVEN";
            })(StaggerIndex || (StaggerIndex = {}));

            ccenum(StaggerIndex);
            let RenderOrder;

            (function (RenderOrder) {
              RenderOrder[RenderOrder["RightDown"] = 0] = "RightDown";
              RenderOrder[RenderOrder["RightUp"] = 1] = "RightUp";
              RenderOrder[RenderOrder["LeftDown"] = 2] = "LeftDown";
              RenderOrder[RenderOrder["LeftUp"] = 3] = "LeftUp";
            })(RenderOrder || (RenderOrder = {}));

            ccenum(RenderOrder);
            let TMXObjectType;

            (function (TMXObjectType) {
              TMXObjectType[TMXObjectType["RECT"] = 0] = "RECT";
              TMXObjectType[TMXObjectType["ELLIPSE"] = 1] = "ELLIPSE";
              TMXObjectType[TMXObjectType["POLYGON"] = 2] = "POLYGON";
              TMXObjectType[TMXObjectType["POLYLINE"] = 3] = "POLYLINE";
              TMXObjectType[TMXObjectType["IMAGE"] = 4] = "IMAGE";
              TMXObjectType[TMXObjectType["TEXT"] = 5] = "TEXT";
            })(TMXObjectType || (TMXObjectType = {}));

            ccenum(TMXObjectType);
            class TMXTilesetInfo {
              constructor() {
                this.name = '';
                this.firstGid = 0;
                this.spacing = 0;
                this.margin = 0;
                this.sourceImage = void 0;
                this.imageName = null;
                this.imageSize = new Size$1(0, 0);
                this.tileOffset = new Vec2(0, 0);
                this._tileSize = new Size$1(0, 0);
                this.collection = false;
              }

              rectForGID(gid_, result) {
                const rect = result || new Rect$1(0, 0, 0, 0);
                rect.width = this._tileSize.width;
                rect.height = this._tileSize.height;
                let gid = gid_;
                gid &= TileFlag.FLIPPED_MASK;
                gid -= this.firstGid;
                const max_x = Math.floor((this.imageSize.width - this.margin * 2 + this.spacing) / (this._tileSize.width + this.spacing));
                rect.x = Math.round(gid % max_x * (this._tileSize.width + this.spacing) + this.margin);
                rect.y = Math.round(Math.floor(gid / max_x) * (this._tileSize.height + this.spacing) + this.margin);
                return rect;
              }

            }
            class TMXObjectGroupInfo {
              constructor() {
                this.properties = {};
                this.name = '';
                this.objects = [];
                this.visible = true;
                this.opacity = 0;
                this.color = new Color$1(255, 255, 255, 255);
                this.offset = new Vec2(0, 0);
                this.draworder = 'topdown';
                this.tintColor = null;
              }

              getProperties() {
                return this.properties;
              }

              setProperties(value) {
                this.properties = value;
              }

            }
            class TMXLayerInfo {
              constructor() {
                this.properties = {};
                this.name = '';
                this.layerSize = null;
                this.tiles = [];
                this.visible = true;
                this.opacity = 0;
                this.ownTiles = true;
                this.minGID = 100000;
                this.maxGID = 0;
                this.offset = new Vec2(0, 0);
                this.tintColor = null;
              }

              getProperties() {
                return this.properties;
              }

              setProperties(value) {
                this.properties = value;
              }

            }
            TMXLayerInfo.ATTRIB_NONE = 1 << 0;
            TMXLayerInfo.ATTRIB_BASE64 = 1 << 1;
            TMXLayerInfo.ATTRIB_GZIP = 1 << 2;
            TMXLayerInfo.ATTRIB_ZLIB = 1 << 3;
            class TMXImageLayerInfo {
              constructor() {
                this.name = '';
                this.visible = true;
                this.width = 0;
                this.height = 0;
                this.offset = new Vec2(0, 0);
                this.opacity = 0;
                this.trans = new Color$1(255, 255, 255, 255);
                this.sourceImage = void 0;
                this.tintColor = null;
              }

            }

            function uint8ArrayToUint32Array(uint8Arr) {
              if (uint8Arr.length % 4 !== 0) return null;
              const arrLen = uint8Arr.length / 4;
              const retArr = window.Uint32Array ? new Uint32Array(arrLen) : [];

              for (let i = 0; i < arrLen; i++) {
                const offset = i * 4;
                retArr[i] = uint8Arr[offset] + uint8Arr[offset + 1] * (1 << 8) + uint8Arr[offset + 2] * (1 << 16) + uint8Arr[offset + 3] * (1 << 24);
              }

              return retArr;
            }

            function strToHAlign(value) {
              const hAlign = Label.HorizontalAlign;

              switch (value) {
                case 'center':
                  return hAlign.CENTER;

                case 'right':
                  return hAlign.RIGHT;

                default:
                  return hAlign.LEFT;
              }
            }

            function strToVAlign(value) {
              const vAlign = Label.VerticalAlign;

              switch (value) {
                case 'center':
                  return vAlign.CENTER;

                case 'bottom':
                  return vAlign.BOTTOM;

                default:
                  return vAlign.TOP;
              }
            }

            function strToColor(value) {
              if (!value) {
                return new Color$1(0, 0, 0, 255);
              }

              value = value.indexOf('#') !== -1 ? value.substring(1) : value;

              if (value.length === 8) {
                const a = parseInt(value.substr(0, 2), 16) || 255;
                const r = parseInt(value.substr(2, 2), 16) || 0;
                const g = parseInt(value.substr(4, 2), 16) || 0;
                const b = parseInt(value.substr(6, 2), 16) || 0;
                return new Color$1(r, g, b, a);
              } else {
                const r = parseInt(value.substr(0, 2), 16) || 0;
                const g = parseInt(value.substr(2, 2), 16) || 0;
                const b = parseInt(value.substr(4, 2), 16) || 0;
                return new Color$1(r, g, b, 255);
              }
            }

            function getPropertyList(node, map) {
              const res = [];
              const properties = node.getElementsByTagName('properties');

              for (let i = 0; i < properties.length; ++i) {
                const property = properties[i].getElementsByTagName('property');

                for (let j = 0; j < property.length; ++j) {
                  res.push(property[j]);
                }
              }

              map = map || {};

              for (let i = 0; i < res.length; i++) {
                const element = res[i];
                const name = element.getAttribute('name');
                const type = element.getAttribute('type') || 'string';
                let value = element.getAttribute('value');

                if (type === 'int') {
                  value = parseInt(value);
                } else if (type === 'float') {
                  value = parseFloat(value);
                } else if (type === 'bool') {
                  value = value === 'true';
                } else if (type === 'color') {
                  value = strToColor(value);
                }

                map[name] = value;
              }

              return map;
            }

            class TMXMapInfo {
              get mapSize() {
                return this._mapSize;
              }

              get tileSize() {
                return this._tileSize;
              }

              constructor(tmxFile, tsxContentMap, spfTexturesMap, textureSizes, imageLayerTextures) {
                this.properties = {};
                this.orientation = null;
                this.parentElement = null;
                this.parentGID = 0;
                this.layerAttrs = 0;
                this.storingCharacters = false;
                this.currentString = null;
                this.renderOrder = RenderOrder.RightDown;
                this._supportVersion = [1, 4, 0];
                this._objectGroups = [];
                this._allChildren = [];
                this._mapSize = new Size$1(0, 0);
                this._tileSize = new Size$1(0, 0);
                this._layers = [];
                this._tilesets = [];
                this._imageLayers = [];
                this._tileProperties = new Map();
                this._tileAnimations = {};
                this._tsxContentMap = null;
                this._spriteFrameMap = null;
                this._spfSizeMap = {};
                this._staggerAxis = null;
                this._staggerIndex = null;
                this._hexSideLength = 0;
                this._imageLayerSPF = null;
                this.initWithXML(tmxFile, tsxContentMap, spfTexturesMap, textureSizes, imageLayerTextures);
              }

              getOrientation() {
                return this.orientation;
              }

              setOrientation(value) {
                this.orientation = value;
              }

              getStaggerAxis() {
                return this._staggerAxis;
              }

              setStaggerAxis(value) {
                this._staggerAxis = value;
              }

              getStaggerIndex() {
                return this._staggerIndex;
              }

              setStaggerIndex(value) {
                this._staggerIndex = value;
              }

              getHexSideLength() {
                return this._hexSideLength;
              }

              setHexSideLength(value) {
                this._hexSideLength = value;
              }

              getMapSize() {
                return new Size$1(this._mapSize.width, this._mapSize.height);
              }

              setMapSize(value) {
                this._mapSize.width = value.width;
                this._mapSize.height = value.height;
              }

              get mapWidth() {
                return this._mapSize.width;
              }

              set mapWidth(width) {
                this._mapSize.width = width;
              }

              get mapHeight() {
                return this._mapSize.height;
              }

              set mapHeight(height) {
                this._mapSize.height = height;
              }

              getTileSize() {
                return new Size$1(this._tileSize.width, this._tileSize.height);
              }

              setTileSize(value) {
                this._tileSize.width = value.width;
                this._tileSize.height = value.height;
              }

              get tileWidth() {
                return this._tileSize.width;
              }

              set tileWidth(width) {
                this._tileSize.width = width;
              }

              get tileHeight() {
                return this._tileSize.height;
              }

              set tileHeight(height) {
                this._tileSize.height = height;
              }

              getLayers() {
                return this._layers;
              }

              setLayers(value) {
                this._allChildren.push(value);

                this._layers.push(value);
              }

              getImageLayers() {
                return this._imageLayers;
              }

              setImageLayers(value) {
                this._allChildren.push(value);

                this._imageLayers.push(value);
              }

              getTilesets() {
                return this._tilesets;
              }

              setTilesets(value) {
                this._tilesets.push(value);
              }

              getObjectGroups() {
                return this._objectGroups;
              }

              setObjectGroups(value) {
                this._allChildren.push(value);

                this._objectGroups.push(value);
              }

              getAllChildren() {
                return this._allChildren;
              }

              getParentElement() {
                return this.parentElement;
              }

              setParentElement(value) {
                this.parentElement = value;
              }

              getParentGID() {
                return this.parentGID;
              }

              setParentGID(value) {
                this.parentGID = value;
              }

              getLayerAttribs() {
                return this.layerAttrs;
              }

              setLayerAttribs(value) {
                this.layerAttrs = value;
              }

              getStoringCharacters() {
                return this.storingCharacters;
              }

              setStoringCharacters(value) {
                this.storingCharacters = value;
              }

              getProperties() {
                return this.properties;
              }

              setProperties(value) {
                this.properties = value;
              }

              initWithXML(tmxString, tsxMap, spfTextureMap, textureSizes, imageLayerTextures) {
                this._tilesets.length = 0;
                this._layers.length = 0;
                this._imageLayers.length = 0;
                this._tsxContentMap = tsxMap;
                this._spriteFrameMap = spfTextureMap;
                this._imageLayerSPF = imageLayerTextures;
                this._spfSizeMap = textureSizes;
                this._objectGroups.length = 0;
                this._allChildren.length = 0;
                this.properties = {};
                this._tileProperties = new Map();
                this._tileAnimations = new Map();
                this.currentString = '';
                this.storingCharacters = false;
                this.layerAttrs = TMXLayerInfo.ATTRIB_NONE;
                this.parentElement = null;
                return this.parseXMLString(tmxString);
              }

              parseXMLString(xmlStr, tilesetFirstGid) {
                const parser = new SAXParser();
                const mapXML = parser.parse(xmlStr);
                let i;
                const map = mapXML.documentElement;
                const orientationStr = map.getAttribute('orientation');
                const staggerAxisStr = map.getAttribute('staggeraxis');
                const staggerIndexStr = map.getAttribute('staggerindex');
                const hexSideLengthStr = map.getAttribute('hexsidelength');
                const renderorderStr = map.getAttribute('renderorder');
                const version = map.getAttribute('version') || '1.0.0';

                if (map.nodeName === 'map') {
                  const versionArr = version.split('.');
                  const supportVersion = this._supportVersion;

                  for (i = 0; i < supportVersion.length; i++) {
                    const v = parseInt(versionArr[i]) || 0;
                    const sv = supportVersion[i];

                    if (sv < v) {
                      logID(7216, version);
                      break;
                    }
                  }

                  if (orientationStr === 'orthogonal') this.orientation = Orientation.ORTHO;else if (orientationStr === 'isometric') this.orientation = Orientation.ISO;else if (orientationStr === 'hexagonal') this.orientation = Orientation.HEX;else if (orientationStr !== null) logID(7217, orientationStr);

                  if (renderorderStr === 'right-up') {
                    this.renderOrder = RenderOrder.RightUp;
                  } else if (renderorderStr === 'left-up') {
                    this.renderOrder = RenderOrder.LeftUp;
                  } else if (renderorderStr === 'left-down') {
                    this.renderOrder = RenderOrder.LeftDown;
                  } else {
                    this.renderOrder = RenderOrder.RightDown;
                  }

                  if (staggerAxisStr === 'x') {
                    this.setStaggerAxis(StaggerAxis.STAGGERAXIS_X);
                  } else if (staggerAxisStr === 'y') {
                    this.setStaggerAxis(StaggerAxis.STAGGERAXIS_Y);
                  }

                  if (staggerIndexStr === 'odd') {
                    this.setStaggerIndex(StaggerIndex.STAGGERINDEX_ODD);
                  } else if (staggerIndexStr === 'even') {
                    this.setStaggerIndex(StaggerIndex.STAGGERINDEX_EVEN);
                  }

                  if (hexSideLengthStr) {
                    this.setHexSideLength(parseFloat(hexSideLengthStr));
                  }

                  let mapSize = new Size$1(0, 0);
                  mapSize.width = parseFloat(map.getAttribute('width'));
                  mapSize.height = parseFloat(map.getAttribute('height'));
                  this.setMapSize(mapSize);
                  mapSize = new Size$1(0, 0);
                  mapSize.width = parseFloat(map.getAttribute('tilewidth'));
                  mapSize.height = parseFloat(map.getAttribute('tileheight'));
                  this.setTileSize(mapSize);
                  this.properties = getPropertyList(map);
                }

                let tilesets = map.getElementsByTagName('tileset');

                if (map.nodeName !== 'map') {
                  tilesets = [];
                  tilesets.push(map);
                }

                for (i = 0; i < tilesets.length; i++) {
                  const curTileset = tilesets[i];
                  const tsxName = curTileset.getAttribute('source');

                  if (tsxName) {
                    const currentFirstGID = parseInt(curTileset.getAttribute('firstgid'));
                    const tsxXmlString = this._tsxContentMap[tsxName];

                    if (tsxXmlString) {
                      this.parseXMLString(tsxXmlString, currentFirstGID);
                    }
                  } else {
                    const images = curTileset.getElementsByTagName('image');
                    const collection = images.length > 1;
                    const firstImage = images[0];
                    let firstImageName = firstImage.getAttribute('source');
                    firstImageName = firstImageName.replace(/\\/g, '/');
                    const tiles = curTileset.getElementsByTagName('tile');
                    const tileCount = tiles && tiles.length || 1;
                    let tile = null;
                    const tilesetName = curTileset.getAttribute('name') || '';
                    const tilesetSpacing = parseInt(curTileset.getAttribute('spacing')) || 0;
                    const tilesetMargin = parseInt(curTileset.getAttribute('margin')) || 0;
                    const fgid = tilesetFirstGid || parseInt(curTileset.getAttribute('firstgid')) || 0;
                    const tilesetSize = new Size$1(0, 0);
                    tilesetSize.width = parseFloat(curTileset.getAttribute('tilewidth'));
                    tilesetSize.height = parseFloat(curTileset.getAttribute('tileheight'));
                    const curTileOffset = curTileset.getElementsByTagName('tileoffset')[0];
                    let tileOffsetX = 0;
                    let tileOffsetY = 0;

                    if (curTileOffset) {
                      tileOffsetX = parseFloat(curTileOffset.getAttribute('x')) || 0;
                      tileOffsetY = parseFloat(curTileOffset.getAttribute('y')) || 0;
                    }

                    let tileset = null;

                    for (let tileIdx = 0; tileIdx < tileCount; tileIdx++) {
                      const curImage = images[tileIdx] ? images[tileIdx] : firstImage;
                      if (!curImage) continue;
                      let curImageName = curImage.getAttribute('source');
                      curImageName = curImageName.replace(/\\/g, '/');

                      if (!tileset || collection) {
                        tileset = new TMXTilesetInfo();
                        tileset.name = tilesetName;
                        tileset.firstGid = fgid & TileFlag.FLIPPED_MASK;
                        tileset.tileOffset.x = tileOffsetX;
                        tileset.tileOffset.y = tileOffsetY;
                        tileset.collection = collection;

                        if (!collection) {
                          tileset.imageName = curImageName;
                          tileset.imageSize.width = parseFloat(curImage.getAttribute('width')) || 0;
                          tileset.imageSize.height = parseFloat(curImage.getAttribute('height')) || 0;
                          tileset.sourceImage = this._spriteFrameMap[curImageName];

                          if (!tileset.sourceImage) {
                            const nameWithPostfix = TMXMapInfo.getNameWithPostfix(curImageName);
                            tileset.imageName = nameWithPostfix;
                            tileset.sourceImage = this._spriteFrameMap[nameWithPostfix];

                            if (!tileset.sourceImage) {
                              const shortName = TMXMapInfo.getShortName(curImageName);
                              tileset.imageName = shortName;
                              tileset.sourceImage = this._spriteFrameMap[shortName];

                              if (!tileset.sourceImage) {
                                console.error(`[error]: ${shortName} not find in [${Object.keys(this._spriteFrameMap).join(', ')}]`);
                                errorID(7221, curImageName);
                                console.warn(`Please try asset type of ${curImageName} to 'sprite-frame'`);
                              }
                            }
                          }
                        }

                        tileset.spacing = tilesetSpacing;
                        tileset.margin = tilesetMargin;
                        tileset._tileSize.width = tilesetSize.width;
                        tileset._tileSize.height = tilesetSize.height;
                        this.setTilesets(tileset);
                      }

                      tile = tiles && tiles[tileIdx];

                      if (!tile) {
                        continue;
                      }

                      this.parentGID = fgid + (parseInt(tile.getAttribute('id')) || 0);
                      const tileImages = tile.getElementsByTagName('image');

                      if (tileImages && tileImages.length > 0) {
                        const image = tileImages[0];
                        let imageName = image.getAttribute('source');
                        imageName = imageName.replace(/\\/g, '/');
                        tileset.imageName = imageName;
                        tileset.imageSize.width = parseFloat(image.getAttribute('width')) || 0;
                        tileset.imageSize.height = parseFloat(image.getAttribute('height')) || 0;
                        tileset._tileSize.width = tileset.imageSize.width;
                        tileset._tileSize.height = tileset.imageSize.height;
                        tileset.sourceImage = this._spriteFrameMap[imageName];

                        if (!tileset.sourceImage) {
                          const nameWithPostfix = TMXMapInfo.getNameWithPostfix(imageName);
                          tileset.imageName = nameWithPostfix;
                          tileset.sourceImage = this._spriteFrameMap[nameWithPostfix];

                          if (!tileset.sourceImage) {
                            const shortName = TMXMapInfo.getShortName(imageName);
                            tileset.imageName = shortName;
                            tileset.sourceImage = this._spriteFrameMap[shortName];

                            if (!tileset.sourceImage) {
                              errorID(7221, imageName);
                              console.warn(`Please try asset type of ${imageName} to 'sprite-frame'`);
                            }
                          }
                        }

                        tileset.firstGid = this.parentGID & TileFlag.FLIPPED_MASK;
                      }

                      const pid = (TileFlag.FLIPPED_MASK & this.parentGID) >>> 0;

                      this._tileProperties.set(pid, getPropertyList(tile));

                      const animations = tile.getElementsByTagName('animation');

                      if (animations && animations.length > 0) {
                        const animation = animations[0];
                        const framesData = animation.getElementsByTagName('frame');
                        const animationProp = {
                          frames: [],
                          dt: 0,
                          frameIdx: 0
                        };

                        this._tileAnimations.set(pid, animationProp);

                        const frames = animationProp.frames;

                        for (let frameIdx = 0; frameIdx < framesData.length; frameIdx++) {
                          const frame = framesData[frameIdx];
                          const tileid = fgid + (parseInt(frame.getAttribute('tileid')) || 0);
                          const duration = parseFloat(frame.getAttribute('duration')) || 0;
                          frames.push({
                            tileid: tileid,
                            duration: duration / 1000,
                            grid: null
                          });
                        }
                      }
                    }
                  }
                }

                const childNodes = map.childNodes;

                for (i = 0; i < childNodes.length; i++) {
                  const childNode = childNodes[i];

                  if (this._shouldIgnoreNode(childNode)) {
                    continue;
                  }

                  if (childNode.nodeName === 'imagelayer') {
                    const imageLayer = this._parseImageLayer(childNode);

                    if (imageLayer) {
                      this.setImageLayers(imageLayer);
                    }
                  }

                  if (childNode.nodeName === 'layer') {
                    const layer = this._parseLayer(childNode);

                    this.setLayers(layer);
                  }

                  if (childNode.nodeName === 'objectgroup') {
                    const objectGroup = this._parseObjectGroup(childNode);

                    this.setObjectGroups(objectGroup);
                  }
                }

                return map;
              }

              _shouldIgnoreNode(node) {
                return node.nodeType === 3 || node.nodeType === 8 || node.nodeType === 4;
              }

              _parseImageLayer(selLayer) {
                const datas = selLayer.getElementsByTagName('image');
                if (!datas || datas.length === 0) return null;
                const imageLayer = new TMXImageLayerInfo();
                imageLayer.name = selLayer.getAttribute('name');
                imageLayer.offset.x = parseFloat(selLayer.getAttribute('offsetx')) || 0;
                imageLayer.offset.y = parseFloat(selLayer.getAttribute('offsety')) || 0;
                const visible = selLayer.getAttribute('visible');
                imageLayer.visible = !(visible === '0');
                const opacity = selLayer.getAttribute('opacity');
                imageLayer.opacity = opacity ? Math.round(255 * parseFloat(opacity)) : 255;
                const tintColor = selLayer.getAttribute('tintcolor');
                imageLayer.tintColor = tintColor ? strToColor(tintColor) : null;
                const data = datas[0];
                const source = data.getAttribute('source');
                imageLayer.sourceImage = this._imageLayerSPF[source];
                imageLayer.width = parseInt(data.getAttribute('width')) || 0;
                imageLayer.height = parseInt(data.getAttribute('height')) || 0;
                imageLayer.trans = strToColor(data.getAttribute('trans'));

                if (!imageLayer.sourceImage) {
                  errorID(7221, source);
                  console.warn(`Please try asset type of ${source} to 'sprite-frame'`);
                  return null;
                }

                return imageLayer;
              }

              _parseLayer(selLayer) {
                const data = selLayer.getElementsByTagName('data')[0];
                const layer = new TMXLayerInfo();
                layer.name = selLayer.getAttribute('name');
                const layerSize = new Size$1(0, 0);
                layerSize.width = parseFloat(selLayer.getAttribute('width'));
                layerSize.height = parseFloat(selLayer.getAttribute('height'));
                layer.layerSize = layerSize;
                const visible = selLayer.getAttribute('visible');
                layer.visible = !(visible === '0');
                const opacity = selLayer.getAttribute('opacity');
                if (opacity) layer.opacity = Math.round(255 * parseFloat(opacity));else layer.opacity = 255;
                layer.offset = new Vec2(parseFloat(selLayer.getAttribute('offsetx')) || 0, parseFloat(selLayer.getAttribute('offsety')) || 0);
                const tintColor = selLayer.getAttribute('tintcolor');
                layer.tintColor = tintColor ? strToColor(tintColor) : null;
                let nodeValue = '';

                for (let j = 0; j < data.childNodes.length; j++) {
                  nodeValue += data.childNodes[j].nodeValue;
                }

                nodeValue = nodeValue.trim();
                const compression = data.getAttribute('compression');
                const encoding = data.getAttribute('encoding');

                if (compression && compression !== 'gzip' && compression !== 'zlib') {
                  logID(7218);
                  return null;
                }

                let tiles;

                switch (compression) {
                  case 'gzip':
                    tiles = codec.unzipBase64AsArray(nodeValue, 4);
                    break;

                  case 'zlib':
                    {
                      const inflator = new _p.Inflate(codec.Base64.decodeAsArray(nodeValue, 1));
                      tiles = uint8ArrayToUint32Array(inflator.decompress());
                      break;
                    }

                  case null:
                  case '':
                    if (encoding === 'base64') tiles = codec.Base64.decodeAsArray(nodeValue, 4);else if (encoding === 'csv') {
                      tiles = [];
                      const csvTiles = nodeValue.split(',');

                      for (let csvIdx = 0; csvIdx < csvTiles.length; csvIdx++) tiles.push(parseInt(csvTiles[csvIdx]));
                    } else {
                      const selDataTiles = data.getElementsByTagName('tile');
                      tiles = [];

                      for (let xmlIdx = 0; xmlIdx < selDataTiles.length; xmlIdx++) tiles.push(parseInt(selDataTiles[xmlIdx].getAttribute('gid')));
                    }
                    break;

                  default:
                    if (this.layerAttrs === TMXLayerInfo.ATTRIB_NONE) logID(7219);
                    break;
                }

                if (tiles) {
                  layer.tiles = new Uint32Array(tiles);
                }

                layer.properties = getPropertyList(selLayer);
                return layer;
              }

              _parseObjectGroup(selGroup) {
                const objectGroup = new TMXObjectGroupInfo();
                objectGroup.name = selGroup.getAttribute('name') || '';
                objectGroup.offset = new Vec2(parseFloat(selGroup.getAttribute('offsetx')), parseFloat(selGroup.getAttribute('offsety')));
                const opacity = selGroup.getAttribute('opacity');
                if (opacity) objectGroup.opacity = Math.round(255 * parseFloat(opacity));else objectGroup.opacity = 255;
                const tintColor = selGroup.getAttribute('tintcolor');
                objectGroup.tintColor = tintColor ? strToColor(tintColor) : null;
                const visible = selGroup.getAttribute('visible');
                if (visible && parseInt(visible) === 0) objectGroup.visible = false;
                const color = selGroup.getAttribute('color');
                if (color) objectGroup.color.fromHEX(color);
                const draworder = selGroup.getAttribute('draworder');
                if (draworder) objectGroup.draworder = draworder;
                objectGroup.setProperties(getPropertyList(selGroup));
                const objects = selGroup.getElementsByTagName('object');

                if (objects) {
                  for (let j = 0; j < objects.length; j++) {
                    const selObj = objects[j];
                    const objectProp = {};
                    objectProp.id = selObj.getAttribute('id') || j;
                    objectProp.name = selObj.getAttribute('name') || '';
                    objectProp.width = parseFloat(selObj.getAttribute('width')) || 0;
                    objectProp.height = parseFloat(selObj.getAttribute('height')) || 0;
                    objectProp.x = parseFloat(selObj.getAttribute('x')) || 0;
                    objectProp.y = parseFloat(selObj.getAttribute('y')) || 0;
                    objectProp.rotation = parseFloat(selObj.getAttribute('rotation')) || 0;
                    getPropertyList(selObj, objectProp);
                    const visibleAttr = selObj.getAttribute('visible');
                    objectProp.visible = !(visibleAttr && parseInt(visibleAttr) === 0);
                    const texts = selObj.getElementsByTagName('text');

                    if (texts && texts.length > 0) {
                      const text = texts[0];
                      objectProp.type = TMXObjectType.TEXT;
                      objectProp.wrap = text.getAttribute('wrap') === '1';
                      objectProp.color = strToColor(text.getAttribute('color'));
                      objectProp.halign = strToHAlign(text.getAttribute('halign'));
                      objectProp.valign = strToVAlign(text.getAttribute('valign'));
                      objectProp.pixelsize = parseInt(text.getAttribute('pixelsize')) || 16;
                      objectProp.text = text.childNodes[0].nodeValue;
                    }

                    const gid = selObj.getAttribute('gid');

                    if (gid) {
                      objectProp.gid = parseInt(gid);
                      objectProp.type = TMXObjectType.IMAGE;
                    }

                    const ellipse = selObj.getElementsByTagName('ellipse');

                    if (ellipse && ellipse.length > 0) {
                      objectProp.type = TMXObjectType.ELLIPSE;
                    }

                    const polygonProps = selObj.getElementsByTagName('polygon');

                    if (polygonProps && polygonProps.length > 0) {
                      objectProp.type = TMXObjectType.POLYGON;
                      const selPgPointStr = polygonProps[0].getAttribute('points');
                      if (selPgPointStr) objectProp.points = this._parsePointsString(selPgPointStr);
                    }

                    const polylineProps = selObj.getElementsByTagName('polyline');

                    if (polylineProps && polylineProps.length > 0) {
                      objectProp.type = TMXObjectType.POLYLINE;
                      const selPlPointStr = polylineProps[0].getAttribute('points');
                      if (selPlPointStr) objectProp.polylinePoints = this._parsePointsString(selPlPointStr);
                    }

                    if (!objectProp.type) {
                      objectProp.type = TMXObjectType.RECT;
                    }

                    objectGroup.objects.push(objectProp);
                  }

                  if (draworder !== 'index') {
                    objectGroup.objects.sort((a, b) => a.y - b.y);
                  }
                }

                return objectGroup;
              }

              _parsePointsString(pointsString) {
                if (!pointsString) return null;
                const points = [];
                const pointsStr = pointsString.split(' ');

                for (let i = 0; i < pointsStr.length; i++) {
                  const selPointStr = pointsStr[i].split(',');
                  points.push({
                    x: parseFloat(selPointStr[0]),
                    y: parseFloat(selPointStr[1])
                  });
                }

                return points;
              }

              setTileAnimations(animations) {
                this._tileAnimations = animations;
              }

              getTileAnimations() {
                return this._tileAnimations;
              }

              getTileProperties() {
                return this._tileProperties;
              }

              setTileProperties(tileProperties) {
                this._tileProperties = tileProperties;
              }

              getCurrentString() {
                return this.currentString;
              }

              setCurrentString(currentString) {
                this.currentString = currentString;
              }

              static getNameWithPostfix(name) {
                name = name.replace(/\\/g, '/');
                const slashIndex = name.lastIndexOf('/') + 1;
                const strLen = name.length;
                return name.substring(slashIndex, strLen);
              }

              static getShortName(name) {
                name = name.replace(/\\/g, '/');
                const slashIndex = name.lastIndexOf('/') + 1;
                let dotIndex = name.lastIndexOf('.');
                dotIndex = dotIndex < 0 ? name.length : dotIndex;
                return name.substring(slashIndex, dotIndex);
              }

            }

            var _dec$1p, _dec2$1f, _dec3$10, _dec4$Y, _dec5$S, _dec6$N, _dec7$M, _dec8$I, _dec9$E, _class$1q, _class2$1f, _descriptor$1d, _descriptor2$15, _temp$1j;
            let TiledTile = exports('TiledTile', (_dec$1p = ccclass('cc.TiledTile'), _dec2$1f = help(), _dec3$10 = menu$1(), _dec4$Y = requireComponent(UITransform), _dec5$S = type$1(CCInteger), _dec6$N = type$1(CCInteger), _dec7$M = type$1(CCInteger), _dec8$I = type$1(CCInteger), _dec9$E = type$1(CCInteger), _dec$1p(_class$1q = _dec2$1f(_class$1q = _dec3$10(_class$1q = _dec4$Y(_class$1q = executeInEditMode(_class$1q = (_class2$1f = (_temp$1j = class TiledTile extends Component {
              constructor() {
                super();
                this._layer = null;

                _initializerDefineProperty(this, "_x", _descriptor$1d, this);

                _initializerDefineProperty(this, "_y", _descriptor2$15, this);
              }

              get x() {
                return this._x;
              }

              set x(value) {
                if (value === this._x) return;

                if (this._layer && this._layer.isInvalidPosition(value, this._y)) {
                  warn(`Invalid x, the valid value is between [%s] ~ [%s]`, 0, this._layer.layerSize.width);
                  return;
                }

                this._resetTile();

                this._x = value;
                this.updateInfo();
              }

              get y() {
                return this._y;
              }

              set y(value) {
                if (value === this._y) return;

                if (this._layer && this._layer.isInvalidPosition(this._x, value)) {
                  warn(`Invalid y, the valid value is between [%s] ~ [%s]`, 0, this._layer.layerSize.height);
                  return;
                }

                this._resetTile();

                this._y = value;
                this.updateInfo();
              }

              get grid() {
                if (this._layer) {
                  return this._layer.getTileGIDAt(this._x, this._y);
                }

                return 0;
              }

              set grid(value) {
                if (this._layer) {
                  this._layer.setTileGIDAt(value, this._x, this._y);
                }
              }

              onEnable() {
                const parent = this.node.parent;
                this._layer = parent.getComponent('cc.TiledLayer');

                this._resetTile();

                this.updateInfo();
              }

              onDisable() {
                this._resetTile();
              }

              _resetTile() {
                if (this._layer && this._layer.getTiledTileAt(this._x, this._y) === this) {
                  this._layer.setTiledTileAt(this._x, this._y, null);
                }
              }

              updateInfo() {
                if (!this._layer) return;
                const x = this._x;
                const y = this._y;

                if (this._layer.getTiledTileAt(x, y)) {
                  warn('There is already a TiledTile at [%s, %s]', x, y);
                  return;
                }

                const p = this._layer.getPositionAt(x, y);

                this.node.setPosition(p.x, p.y);

                this._layer.setTiledTileAt(x, y, this);
              }

            }, _temp$1j), (_descriptor$1d = _applyDecoratedDescriptor(_class2$1f.prototype, "_x", [_dec5$S], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor2$15 = _applyDecoratedDescriptor(_class2$1f.prototype, "_y", [_dec6$N], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _applyDecoratedDescriptor(_class2$1f.prototype, "x", [_dec7$M], Object.getOwnPropertyDescriptor(_class2$1f.prototype, "x"), _class2$1f.prototype), _applyDecoratedDescriptor(_class2$1f.prototype, "y", [_dec8$I], Object.getOwnPropertyDescriptor(_class2$1f.prototype, "y"), _class2$1f.prototype), _applyDecoratedDescriptor(_class2$1f.prototype, "grid", [_dec9$E], Object.getOwnPropertyDescriptor(_class2$1f.prototype, "grid"), _class2$1f.prototype)), _class2$1f)) || _class$1q) || _class$1q) || _class$1q) || _class$1q) || _class$1q));

            function fillTextureGrids(tileset, texGrids, spFrame) {
              const spf = spFrame || tileset.sourceImage;
              const tex = spf.texture;
              const collection = tileset.collection;

              if (!tileset.imageSize.width || !tileset.imageSize.height) {
                const sourceImage = tileset.sourceImage;
                tileset.imageSize.width = sourceImage.width;
                tileset.imageSize.height = sourceImage.height;
              }

              const imageWidth = tileset.imageSize.width;
              const imageHeight = tileset.imageSize.height;
              const tw = tileset._tileSize.width;
              const th = tileset._tileSize.height;
              const texWidth = spf.width;
              const texHeight = spf.height;
              const spacing = tileset.spacing;
              const margin = tileset.margin;
              let count = 1;

              if (!collection) {
                const cols = Math.floor((imageWidth - margin * 2 + spacing) / (tw + spacing));
                const rows = Math.floor((imageHeight - margin * 2 + spacing) / (th + spacing));
                count = Math.max(1, rows * cols);
              }

              const firstGid = tileset.firstGid;
              let grid = null;
              let override = !!texGrids.get(firstGid);
              const maxGid = tileset.firstGid + count;
              let gid = firstGid;

              for (; gid < maxGid; ++gid) {
                if (override && !texGrids.get(gid)) {
                  override = false;
                }

                if (!override && texGrids.get(gid)) {
                  break;
                }

                grid = {
                  tileset,
                  x: 0,
                  y: 0,
                  width: tw,
                  height: th,
                  t: 0,
                  l: 0,
                  r: 0,
                  b: 0,
                  cx: 0,
                  cy: 0,
                  offsetX: 0,
                  offsetY: 0,
                  rotated: false,
                  gid: gid,
                  spriteFrame: spf,
                  texture: tex
                };
                tileset.rectForGID(gid, grid);

                if (!spFrame || count > 1) {
                  if (spFrame) {
                    grid._name = spFrame.name;
                    const lm = spFrame.unbiasUV[0];
                    const bm = spFrame.rotated ? spFrame.unbiasUV[1] : spFrame.unbiasUV[5];
                    grid.l = lm + grid.x / texWidth;
                    grid.t = bm + grid.y / texHeight;
                    grid.r = lm + (grid.x + grid.width) / texWidth;
                    grid.b = bm + (grid.y + grid.height) / texHeight;
                    grid._rect = new Rect$1(grid.x, grid.y, grid.width, grid.height);
                  } else {
                    grid.l = grid.x / texWidth;
                    grid.t = grid.y / texHeight;
                    grid.r = (grid.x + grid.width) / texWidth;
                    grid.b = (grid.y + grid.height) / texHeight;
                    grid._rect = new Rect$1(grid.x, grid.y, grid.width, grid.height);
                  }
                } else if (spFrame.rotated) {
                  grid._rotated = true;
                  grid._name = spFrame.name;
                  grid._rect = spFrame.getRect();
                  grid.l = spFrame.unbiasUV[0];
                  grid.t = spFrame.unbiasUV[1];
                  grid.r = spFrame.unbiasUV[4];
                  grid.b = spFrame.unbiasUV[3];
                } else {
                  grid._name = spFrame.name;
                  grid._rect = spFrame.getRect();
                  grid.l = spFrame.unbiasUV[0];
                  grid.t = spFrame.unbiasUV[5];
                  grid.r = spFrame.unbiasUV[2];
                  grid.b = spFrame.unbiasUV[1];
                }

                grid.cx = (grid.l + grid.r) / 2;
                grid.cy = (grid.t + grid.b) / 2;
                texGrids.set(gid, grid);
              }
            }

            var _dec$1q, _class$1r, _temp$1k, _dec2$1g, _class3$t, _temp2$6;

            const _mat4_temp$4 = new Mat4();

            const _vec2_temp$1 = new Vec2();

            const _vec3_temp = new Vec3();

            const _vec3_temp2 = new Vec3();

            const _tempRowCol = {
              row: 0,
              col: 0
            };
            let TiledUserNodeData = exports('TiledUserNodeData', (_dec$1q = ccclass('cc.TiledUserNodeData'), _dec$1q(_class$1r = (_temp$1k = class TiledUserNodeData extends Component {
              constructor() {
                super();
                this._index = -1;
                this._row = -1;
                this._col = -1;
                this._tiledLayer = null;
              }

            }, _temp$1k)) || _class$1r));
            let TiledLayer = exports('TiledLayer', (_dec2$1g = ccclass('cc.TiledLayer'), _dec2$1g(_class3$t = (_temp2$6 = class TiledLayer extends Renderable2D {
              get cullingRect() {
                return this._cullingRect;
              }

              get rightTop() {
                return this._rightTop;
              }

              get layerSize() {
                return this._layerSize;
              }

              get meshRenderDataArray() {
                return this._meshRenderDataArray;
              }

              get leftDownToCenterX() {
                return this._leftDownToCenterX;
              }

              get leftDownToCenterY() {
                return this._leftDownToCenterY;
              }

              constructor() {
                super();
                this._userNodeGrid = {};
                this._userNodeMap = {};
                this._userNodeDirty = false;
                this.tiledTiles = [];
                this._viewPort = {
                  x: -1,
                  y: -1,
                  width: -1,
                  height: -1
                };
                this._cullingRect = {
                  leftDown: {
                    row: -1,
                    col: -1
                  },
                  rightTop: {
                    row: -1,
                    col: -1
                  }
                };
                this._cullingDirty = true;
                this._rightTop = {
                  row: -1,
                  col: -1
                };
                this._layerInfo = null;
                this._mapInfo = null;
                this._topOffset = 0;
                this._downOffset = 0;
                this._leftOffset = 0;
                this._rightOffset = 0;
                this.tiles = [];
                this.vertices = [];
                this._verticesDirty = true;
                this._layerName = '';
                this._layerSize = void 0;
                this._minGID = void 0;
                this._maxGID = void 0;
                this._layerOrientation = null;
                this._opacity = void 0;
                this._tintColor = void 0;
                this.texGrids = null;
                this._textures = [];
                this._tilesets = [];
                this._leftDownToCenterX = 0;
                this._leftDownToCenterY = 0;
                this._hasTiledNodeGrid = false;
                this._hasAniGrid = false;
                this._animations = null;
                this._enableCulling = void 0;
                this.colorChanged = false;
                this._properties = void 0;
                this.renderOrder = void 0;
                this._staggerAxis = void 0;
                this._staggerIndex = void 0;
                this._hexSideLength = void 0;
                this._mapTileSize = void 0;
                this._odd_even = void 0;
                this._diffX1 = void 0;
                this._diffY1 = void 0;
                this._useAutomaticVertexZ = void 0;
                this._vertexZvalue = void 0;
                this._offset = void 0;
                this._meshRenderDataArray = null;
                this._meshRenderDataArrayIdx = 0;
              }

              hasTiledNode() {
                return this._hasTiledNodeGrid;
              }

              hasAnimation() {
                return this._hasAniGrid;
              }

              set enableCulling(value) {
                if (this._enableCulling !== value) {
                  this._enableCulling = value;
                  this._cullingDirty = true;
                  this.markForUpdateRenderData();
                }
              }

              get enableCulling() {
                return this._enableCulling;
              }

              addUserNode(node) {
                let dataComp = node.getComponent(TiledUserNodeData);

                if (dataComp) {
                  warn('CCTiledLayer:addUserNode node has been added');
                  return false;
                }

                dataComp = node.addComponent(TiledUserNodeData);
                node.parent = this.node;
                this._userNodeMap[node.uuid] = dataComp;
                dataComp._row = -1;
                dataComp._col = -1;
                dataComp._tiledLayer = this;

                this._nodeLocalPosToLayerPos(node.getPosition(), _vec2_temp$1);

                this._positionToRowCol(_vec2_temp$1.x, _vec2_temp$1.y, _tempRowCol);

                this._addUserNodeToGrid(dataComp, _tempRowCol);

                this._updateCullingOffsetByUserNode(node);

                node.on(NodeEventType.TRANSFORM_CHANGED, this._userNodePosChange, dataComp);
                node.on(NodeEventType.SIZE_CHANGED, this._userNodeSizeChange, dataComp);
                return true;
              }

              removeUserNode(node) {
                const dataComp = node.getComponent(TiledUserNodeData);

                if (!dataComp) {
                  warn('CCTiledLayer:removeUserNode node is not exist');
                  return false;
                }

                node.off(NodeEventType.TRANSFORM_CHANGED, this._userNodePosChange, dataComp);
                node.off(NodeEventType.SIZE_CHANGED, this._userNodeSizeChange, dataComp);

                this._removeUserNodeFromGrid(dataComp);

                delete this._userNodeMap[node.uuid];

                node._removeComponent(dataComp);

                dataComp.destroy();
                node.removeFromParent();
                return true;
              }

              destroyUserNode(node) {
                this.removeUserNode(node);
                node.destroy();
              }

              _nodeLocalPosToLayerPos(nodePos, out) {
                out.x = nodePos.x + this._leftDownToCenterX;
                out.y = nodePos.y + this._leftDownToCenterY;
              }

              getNodesByRowCol(row, col) {
                const rowData = this._userNodeGrid[row];
                if (!rowData) return null;
                return rowData[col];
              }

              getNodesCountByRow(row) {
                const rowData = this._userNodeGrid[row];
                if (!rowData) return 0;
                return rowData.count;
              }

              _updateAllUserNode() {
                this._userNodeGrid = {};

                for (const dataId in this._userNodeMap) {
                  const dataComp = this._userNodeMap[dataId];

                  this._nodeLocalPosToLayerPos(dataComp.node.getPosition(), _vec2_temp$1);

                  this._positionToRowCol(_vec2_temp$1.x, _vec2_temp$1.y, _tempRowCol);

                  this._addUserNodeToGrid(dataComp, _tempRowCol);

                  this._updateCullingOffsetByUserNode(dataComp.node);
                }
              }

              _updateCullingOffsetByUserNode(node_) {
                const node = node_._uiProps.uiTransformComp.contentSize;

                if (this._topOffset < node.height) {
                  this._topOffset = node.height;
                }

                if (this._downOffset < node.height) {
                  this._downOffset = node.height;
                }

                if (this._leftOffset < node.width) {
                  this._leftOffset = node.width;
                }

                if (this._rightOffset < node.width) {
                  this._rightOffset = node.width;
                }
              }

              _userNodeSizeChange() {
                const dataComp = this;
                const node = dataComp.node;
                const self = dataComp._tiledLayer;

                self._updateCullingOffsetByUserNode(node);

                self._userNodeDirty = true;
                self.markForUpdateRenderData();
              }

              _userNodePosChange() {
                const dataComp = this;
                const node = dataComp.node;
                const self = dataComp._tiledLayer;

                self._nodeLocalPosToLayerPos(node.getPosition(), _vec2_temp$1);

                self._positionToRowCol(_vec2_temp$1.x, _vec2_temp$1.y, _tempRowCol);

                self._limitInLayer(_tempRowCol);

                if (_tempRowCol.row === dataComp._row && _tempRowCol.col === dataComp._col) return;

                self._removeUserNodeFromGrid(dataComp);

                self._addUserNodeToGrid(dataComp, _tempRowCol);
              }

              _removeUserNodeFromGrid(dataComp) {
                const row = dataComp._row;
                const col = dataComp._col;
                const index = dataComp._index;
                const rowData = this._userNodeGrid[row];
                const colData = rowData && rowData[col];

                if (colData) {
                  rowData.count--;
                  colData.count--;
                  colData.list[index] = null;

                  if (colData.count <= 0) {
                    colData.list.length = 0;
                    colData.count = 0;
                  }
                }

                dataComp._row = -1;
                dataComp._col = -1;
                dataComp._index = -1;
                this._userNodeDirty = true;
                this.markForUpdateRenderData();
              }

              _limitInLayer(rowCol) {
                const row = rowCol.row;
                const col = rowCol.col;
                if (row < 0) rowCol.row = 0;
                if (row > this._rightTop.row) rowCol.row = this._rightTop.row;
                if (col < 0) rowCol.col = 0;
                if (col > this._rightTop.col) rowCol.col = this._rightTop.col;
              }

              _addUserNodeToGrid(dataComp, tempRowCol) {
                const row = tempRowCol.row;
                const col = tempRowCol.col;
                const rowData = this._userNodeGrid[row] = this._userNodeGrid[row] || {
                  count: 0
                };
                const colData = rowData[col] = rowData[col] || {
                  count: 0,
                  list: []
                };
                dataComp._row = row;
                dataComp._col = col;
                dataComp._index = colData.list.length;
                rowData.count++;
                colData.count++;
                colData.list.push(dataComp);
                this._userNodeDirty = true;
              }

              isUserNodeDirty() {
                return this._userNodeDirty;
              }

              setUserNodeDirty(value) {
                this._userNodeDirty = value;
              }

              onEnable() {
                super.onEnable();
                this.node.on(NodeEventType.ANCHOR_CHANGED, this._syncAnchorPoint, this);
                this.node.on(NodeEventType.TRANSFORM_CHANGED, this.updateCulling, this);
                this.node.on(NodeEventType.SIZE_CHANGED, this.updateCulling, this);
                this.node.parent.on(NodeEventType.TRANSFORM_CHANGED, this.updateCulling, this);
                this.node.parent.on(NodeEventType.SIZE_CHANGED, this.updateCulling, this);
                this.markForUpdateRenderData();
                this.scheduleOnce(this.updateCulling.bind(this));
              }

              onDisable() {
                super.onDisable();
                this.node.parent.off(NodeEventType.SIZE_CHANGED, this.updateCulling, this);
                this.node.parent.off(NodeEventType.TRANSFORM_CHANGED, this.updateCulling, this);
                this.node.off(NodeEventType.SIZE_CHANGED, this.updateCulling, this);
                this.node.off(NodeEventType.TRANSFORM_CHANGED, this.updateCulling, this);
                this.node.off(NodeEventType.ANCHOR_CHANGED, this._syncAnchorPoint, this);
              }

              _syncAnchorPoint() {
                const node = this.node;
                const trans = node._uiProps.uiTransformComp;
                const scale = node.getScale();
                this._leftDownToCenterX = trans.width * trans.anchorX * scale.x;
                this._leftDownToCenterY = trans.height * trans.anchorY * scale.y;
                this._cullingDirty = true;
                this.markForUpdateRenderData();
              }

              onDestroy() {
                super.onDestroy();
              }

              getLayerName() {
                return this._layerName;
              }

              setLayerName(layerName) {
                this._layerName = layerName;
              }

              getProperty(propertyName) {
                return this._properties[propertyName];
              }

              getPositionAt(pos, y) {
                let x;

                if (y !== undefined) {
                  x = Math.floor(pos);
                  y = Math.floor(y);
                } else {
                  x = Math.floor(pos.x);
                  y = Math.floor(pos.y);
                }

                switch (this._layerOrientation) {
                  case Orientation.ORTHO:
                    return this._positionForOrthoAt(x, y);

                  case Orientation.ISO:
                    return this._positionForIsoAt(x, y);

                  case Orientation.HEX:
                    return this._positionForHexAt(x, y);
                }

                return null;
              }

              isInvalidPosition(x, y) {
                return x >= this._layerSize.width || y >= this._layerSize.height || x < 0 || y < 0;
              }

              _positionForIsoAt(x, y) {
                let offsetX = 0;
                let offsetY = 0;

                const index = Math.floor(x) + Math.floor(y) * this._layerSize.width;

                const gidAndFlags = this.tiles[index];

                if (gidAndFlags) {
                  const gid = (gidAndFlags & TileFlag.FLIPPED_MASK) >>> 0;
                  const tileset = this.texGrids.get(gid).tileset;
                  const offset = tileset.tileOffset;
                  offsetX = offset.x;
                  offsetY = offset.y;
                }

                return new Vec2(this._mapTileSize.width * 0.5 * (this._layerSize.height + x - y - 1) + offsetX, this._mapTileSize.height * 0.5 * (this._layerSize.width - x + this._layerSize.height - y - 2) - offsetY);
              }

              _positionForOrthoAt(x, y) {
                let offsetX = 0;
                let offsetY = 0;

                const index = Math.floor(x) + Math.floor(y) * this._layerSize.width;

                const gidAndFlags = this.tiles[index];

                if (gidAndFlags) {
                  const gid = (gidAndFlags & TileFlag.FLIPPED_MASK) >>> 0;
                  const tileset = this.texGrids.get(gid).tileset;
                  const offset = tileset.tileOffset;
                  offsetX = offset.x;
                  offsetY = offset.y;
                }

                return new Vec2(x * this._mapTileSize.width + offsetX, (this._layerSize.height - y - 1) * this._mapTileSize.height - offsetY);
              }

              _positionForHexAt(col, row) {
                const tileWidth = this._mapTileSize.width;
                const tileHeight = this._mapTileSize.height;
                const rows = this._layerSize.height;

                const index = Math.floor(col) + Math.floor(row) * this._layerSize.width;

                const gid = (this.tiles[index] & TileFlag.FLIPPED_MASK) >>> 0;
                let offset;

                if (this.texGrids.get(gid)) {
                  offset = this.texGrids.get(gid).tileset.tileOffset;
                } else {
                  offset = {
                    x: 0,
                    y: 0
                  };
                }

                const odd_even = this._staggerIndex === StaggerIndex.STAGGERINDEX_ODD ? 1 : -1;
                let x = 0;
                let y = 0;
                let diffX = 0;
                let diffY = 0;

                switch (this._staggerAxis) {
                  case StaggerAxis.STAGGERAXIS_Y:
                    diffX = 0;

                    if (row % 2 === 1) {
                      diffX = tileWidth / 2 * odd_even;
                    }

                    x = col * tileWidth + diffX + offset.x;
                    y = (rows - row - 1) * (tileHeight - (tileHeight - this._hexSideLength) / 2) - offset.y;
                    break;

                  case StaggerAxis.STAGGERAXIS_X:
                    diffY = 0;

                    if (col % 2 === 1) {
                      diffY = tileHeight / 2 * -odd_even;
                    }

                    x = col * (tileWidth - (tileWidth - this._hexSideLength) / 2) + offset.x;
                    y = (rows - row - 1) * tileHeight + diffY - offset.y;
                    break;
                }

                return new Vec2(x, y);
              }

              setTilesGIDAt(gids, beginCol, beginRow, totalCols) {
                if (!gids || gids.length === 0 || totalCols <= 0) return;
                if (beginRow < 0) beginRow = 0;
                if (beginCol < 0) beginCol = 0;
                let gidsIdx = 0;
                const endCol = beginCol + totalCols;

                for (let row = beginRow;; row++) {
                  for (let col = beginCol; col < endCol; col++) {
                    if (gidsIdx >= gids.length) return;

                    this._updateTileForGID(gids[gidsIdx], col, row);

                    gidsIdx++;
                  }
                }
              }

              setTileGIDAt(gid, x, y, flags) {
                const ugid = (gid & TileFlag.FLIPPED_MASK) >>> 0;
                x = Math.floor(x);
                y = Math.floor(y);

                if (this.isInvalidPosition(x, y)) {
                  throw new Error('cc.TiledLayer.setTileGIDAt(): invalid position');
                }

                if (!this.tiles || !this._tilesets || this._tilesets.length === 0) {
                  logID(7238);
                  return;
                }

                if (ugid !== 0 && ugid < this._tilesets[0].firstGid) {
                  logID(7239, gid);
                  return;
                }

                flags = flags || 0;

                this._updateTileForGID((ugid | flags) >>> 0, x, y);
              }

              _updateTileForGID(gidAndFlags, x, y) {
                const idx = 0 | x + y * this._layerSize.width;
                if (idx >= this.tiles.length) return;
                const oldGIDAndFlags = this.tiles[idx];
                if (gidAndFlags === oldGIDAndFlags) return;
                const gid = (gidAndFlags & TileFlag.FLIPPED_MASK) >>> 0;
                const grid = this.texGrids.get(gid);

                if (grid) {
                  this.tiles[idx] = gidAndFlags;

                  this._updateVertex(x, y);
                } else {
                  this.tiles[idx] = 0;
                }

                this._cullingDirty = true;
              }

              getTileGIDAt(x, y) {
                if (this.isInvalidPosition(x, y)) {
                  throw new Error('cc.TiledLayer.getTileGIDAt(): invalid position');
                }

                if (!this.tiles) {
                  logID(7237);
                  return null;
                }

                const index = Math.floor(x) + Math.floor(y) * this._layerSize.width;

                const tile = this.tiles[index];
                return (tile & TileFlag.FLIPPED_MASK) >>> 0;
              }

              getTileFlagsAt(x, y) {
                if (this.isInvalidPosition(x, y)) {
                  throw new Error('TiledLayer.getTileFlagsAt: invalid position');
                }

                if (!this.tiles) {
                  logID(7240);
                  return null;
                }

                const idx = Math.floor(x) + Math.floor(y) * this._layerSize.width;

                const tile = this.tiles[idx];
                return (tile & TileFlag.FLIPPED_ALL) >>> 0;
              }

              setCullingDirty(value) {
                this._cullingDirty = value;
              }

              isCullingDirty() {
                return this._cullingDirty;
              }

              updateViewPort(x, y, width, height) {
                if (this._viewPort.width === width && this._viewPort.height === height && this._viewPort.x === x && this._viewPort.y === y) {
                  return;
                }

                this._viewPort.x = x;
                this._viewPort.y = y;
                this._viewPort.width = width;
                this._viewPort.height = height;
                let reserveLine = 1;

                if (this._layerOrientation === Orientation.ISO) {
                  reserveLine = 2;
                }

                const vpx = this._viewPort.x - this._offset.x + this._leftDownToCenterX;
                const vpy = this._viewPort.y - this._offset.y + this._leftDownToCenterY;
                let leftDownX = vpx - this._leftOffset;
                let leftDownY = vpy - this._downOffset;
                const rightTopX = vpx + width + this._rightOffset;
                const rightTopY = vpy + height + this._topOffset;
                const leftDown = this._cullingRect.leftDown;
                const rightTop = this._cullingRect.rightTop;
                if (leftDownX < 0) leftDownX = 0;
                if (leftDownY < 0) leftDownY = 0;

                this._positionToRowCol(leftDownX, leftDownY, _tempRowCol);

                _tempRowCol.row -= reserveLine;
                _tempRowCol.col -= reserveLine;
                _tempRowCol.row = _tempRowCol.row > 0 ? _tempRowCol.row : 0;
                _tempRowCol.col = _tempRowCol.col > 0 ? _tempRowCol.col : 0;

                if (_tempRowCol.row !== leftDown.row || _tempRowCol.col !== leftDown.col) {
                  leftDown.row = _tempRowCol.row;
                  leftDown.col = _tempRowCol.col;
                  this._cullingDirty = true;
                }

                if (rightTopX < 0 || rightTopY < 0) {
                  _tempRowCol.row = -1;
                  _tempRowCol.col = -1;
                } else {
                  this._positionToRowCol(rightTopX, rightTopY, _tempRowCol);

                  _tempRowCol.row++;
                  _tempRowCol.col++;
                }

                if (_tempRowCol.row > this._rightTop.row) _tempRowCol.row = this._rightTop.row;
                if (_tempRowCol.col > this._rightTop.col) _tempRowCol.col = this._rightTop.col;

                if (_tempRowCol.row !== rightTop.row || _tempRowCol.col !== rightTop.col) {
                  rightTop.row = _tempRowCol.row;
                  rightTop.col = _tempRowCol.col;
                  this._cullingDirty = true;
                  this.markForUpdateRenderData();
                }
              }

              _positionToRowCol(x, y, result) {
                const maptw = this._mapTileSize.width;
                const mapth = this._mapTileSize.height;
                const maptw2 = maptw * 0.5;
                const mapth2 = mapth * 0.5;
                let row = 0;
                let col = 0;
                let diffX2 = 0;
                let diffY2 = 0;
                const axis = this._staggerAxis;

                switch (this._layerOrientation) {
                  case Orientation.ORTHO:
                    col = Math.floor(x / maptw);
                    row = Math.floor(y / mapth);
                    break;

                  case Orientation.ISO:
                    col = Math.floor(x / maptw2);
                    row = Math.floor(y / mapth2);
                    break;

                  case Orientation.HEX:
                    if (axis === StaggerAxis.STAGGERAXIS_Y) {
                      row = Math.floor(y / (mapth - this._diffY1));
                      diffX2 = row % 2 === 1 ? maptw2 * this._odd_even : 0;
                      col = Math.floor((x - diffX2) / maptw);
                    } else {
                      col = Math.floor(x / (maptw - this._diffX1));
                      diffY2 = col % 2 === 1 ? mapth2 * -this._odd_even : 0;
                      row = Math.floor((y - diffY2) / mapth);
                    }

                    break;
                }

                result.row = row;
                result.col = col;
                return result;
              }

              updateCulling() {
                if (this._enableCulling) {
                  this.node.updateWorldTransform();
                  Mat4.invert(_mat4_temp$4, this.node.getWorldMatrix());
                  const camera = director.root.batcher2D.getFirstRenderCamera(this.node);

                  if (camera) {
                    _vec3_temp.x = 0;
                    _vec3_temp.y = 0;
                    _vec3_temp.z = 0;
                    _vec3_temp2.x = camera.width;
                    _vec3_temp2.y = camera.height;
                    _vec3_temp2.z = 0;
                    camera.screenToWorld(_vec3_temp, _vec3_temp);
                    camera.screenToWorld(_vec3_temp2, _vec3_temp2);
                    Vec3.transformMat4(_vec3_temp, _vec3_temp, _mat4_temp$4);
                    Vec3.transformMat4(_vec3_temp2, _vec3_temp2, _mat4_temp$4);
                    this.updateViewPort(_vec3_temp.x, _vec3_temp.y, _vec3_temp2.x - _vec3_temp.x, _vec3_temp2.y - _vec3_temp.y);
                  }
                }
              }

              getLayerOrientation() {
                return this._layerOrientation;
              }

              getProperties() {
                return this._properties;
              }

              _updateVertex(col, row) {
                const FLIPPED_MASK = TileFlag.FLIPPED_MASK;
                const vertices = this.vertices;
                const layerOrientation = this._layerOrientation;
                const tiles = this.tiles;

                if (!tiles) {
                  return;
                }

                const rightTop = this._rightTop;
                const maptw = this._mapTileSize.width;
                const mapth = this._mapTileSize.height;
                const maptw2 = maptw * 0.5;
                const mapth2 = mapth * 0.5;
                const rows = this._layerSize.height;
                const cols = this._layerSize.width;
                const grids = this.texGrids;
                let left = 0;
                let bottom = 0;
                let axis;
                let diffX1;
                let diffY1;
                let odd_even;
                let diffX2;
                let diffY2;

                if (layerOrientation === Orientation.HEX) {
                  axis = this._staggerAxis;
                  diffX1 = this._diffX1;
                  diffY1 = this._diffY1;
                  odd_even = this._odd_even;
                }

                let cullingCol = 0;
                let cullingRow = 0;
                let gridGID = 0;
                let topBorder = 0;
                let downBorder = 0;
                let leftBorder = 0;
                let rightBorder = 0;
                const index = row * cols + col;
                const gid = tiles[index];
                gridGID = (gid & FLIPPED_MASK) >>> 0;
                const grid = grids.get(gridGID);

                if (!grid) {
                  return;
                }

                if (this._animations.get(gridGID)) {
                  this._hasAniGrid = this._hasAniGrid || true;
                }

                switch (layerOrientation) {
                  case Orientation.ORTHO:
                    cullingCol = col;
                    cullingRow = rows - row - 1;
                    left = cullingCol * maptw;
                    bottom = cullingRow * mapth;
                    break;

                  case Orientation.ISO:
                    cullingCol = rows + col - row - 1;
                    cullingRow = rows + cols - col - row - 2;
                    left = maptw2 * cullingCol;
                    bottom = mapth2 * cullingRow;
                    break;

                  case Orientation.HEX:
                    diffX2 = axis === StaggerAxis.STAGGERAXIS_Y && row % 2 === 1 ? maptw2 * odd_even : 0;
                    diffY2 = axis === StaggerAxis.STAGGERAXIS_X && col % 2 === 1 ? mapth2 * -odd_even : 0;
                    left = col * (maptw - diffX1) + diffX2;
                    bottom = (rows - row - 1) * (mapth - diffY1) + diffY2;
                    cullingCol = col;
                    cullingRow = rows - row - 1;
                    break;
                }

                const rowData = vertices[cullingRow] = vertices[cullingRow] || {
                  minCol: 0,
                  maxCol: 0
                };
                const colData = rowData[cullingCol] = rowData[cullingCol] || {};

                if (rowData.minCol > cullingCol) {
                  rowData.minCol = cullingCol;
                }

                if (rowData.maxCol < cullingCol) {
                  rowData.maxCol = cullingCol;
                }

                if (rightTop.row < cullingRow) {
                  rightTop.row = cullingRow;
                }

                if (rightTop.col < cullingCol) {
                  rightTop.col = cullingCol;
                }

                const tileOffset = grid.tileset.tileOffset;
                left += this._offset.x + tileOffset.x + grid.offsetX;
                bottom += this._offset.y - tileOffset.y - grid.offsetY;
                topBorder = -tileOffset.y + grid.tileset._tileSize.height - mapth;
                topBorder = topBorder < 0 ? 0 : topBorder;
                downBorder = tileOffset.y < 0 ? 0 : tileOffset.y;
                leftBorder = -tileOffset.x < 0 ? 0 : -tileOffset.x;
                rightBorder = tileOffset.x + grid.tileset._tileSize.width - maptw;
                rightBorder = rightBorder < 0 ? 0 : rightBorder;

                if (this._rightOffset < leftBorder) {
                  this._rightOffset = leftBorder;
                }

                if (this._leftOffset < rightBorder) {
                  this._leftOffset = rightBorder;
                }

                if (this._topOffset < downBorder) {
                  this._topOffset = downBorder;
                }

                if (this._downOffset < topBorder) {
                  this._downOffset = topBorder;
                }

                colData.left = left;
                colData.bottom = bottom;
                colData.index = index;
                this._cullingDirty = true;
              }

              _updateVertices() {
                const vertices = this.vertices;
                vertices.length = 0;
                const tiles = this.tiles;

                if (!tiles) {
                  return;
                }

                const rightTop = this._rightTop;
                rightTop.row = -1;
                rightTop.col = -1;
                const rows = this._layerSize.height;
                const cols = this._layerSize.width;
                this._topOffset = 0;
                this._downOffset = 0;
                this._leftOffset = 0;
                this._rightOffset = 0;
                this._hasAniGrid = false;

                for (let row = 0; row < rows; ++row) {
                  for (let col = 0; col < cols; ++col) {
                    this._updateVertex(col, row);
                  }
                }

                this._verticesDirty = false;
              }

              getTiledTileAt(x, y, forceCreate) {
                if (this.isInvalidPosition(x, y)) {
                  throw new Error('TiledLayer.getTiledTileAt: invalid position');
                }

                if (!this.tiles) {
                  logID(7236);
                  return null;
                }

                const index = Math.floor(x) + Math.floor(y) * this._layerSize.width;

                let tile = this.tiledTiles[index];

                if (!tile && forceCreate) {
                  const node = new Node();
                  tile = node.addComponent(TiledTile);
                  tile._x = x;
                  tile._y = y;
                  tile._layer = this;
                  tile.updateInfo();
                  node.parent = this.node;
                  return tile;
                }

                return tile;
              }

              setTiledTileAt(x, y, tiledTile) {
                if (this.isInvalidPosition(x, y)) {
                  throw new Error('TiledLayer.setTiledTileAt: invalid position');
                }

                if (!this.tiles) {
                  logID(7236);
                  return null;
                }

                const index = Math.floor(x) + Math.floor(y) * this._layerSize.width;

                this.tiledTiles[index] = tiledTile;
                this._cullingDirty = true;

                if (tiledTile) {
                  this._hasTiledNodeGrid = true;
                } else {
                  this._hasTiledNodeGrid = this.tiledTiles.some(tiledNode => !!tiledNode);
                }

                return tiledTile;
              }

              getTexture(index) {
                index = index || 0;

                if (this._textures && index >= 0 && this._textures.length > index) {
                  return this._textures[index];
                }

                return null;
              }

              getTextures() {
                return this._textures;
              }

              setTexture(texture) {
                this.setTextures([texture]);
              }

              setTextures(textures) {
                this._textures = textures;
                this.markForUpdateRenderData();
              }

              getLayerSize() {
                return this._layerSize;
              }

              getMapTileSize() {
                return this._mapTileSize;
              }

              getTileSet(index) {
                index = index || 0;

                if (this._tilesets && index >= 0 && this._tilesets.length > index) {
                  return this._tilesets[index];
                }

                return null;
              }

              getTileSets() {
                return this._tilesets;
              }

              setTileSet(tileset) {
                this.setTileSets([tileset]);
              }

              setTileSets(tilesets) {
                this._tilesets = tilesets;
                const textures = this._textures = [];
                const texGrids = this.texGrids;
                texGrids.clear();

                for (let i = 0; i < tilesets.length; i++) {
                  const tileset = tilesets[i];

                  if (tileset) {
                    textures[i] = tileset.sourceImage;
                  }
                }

                for (let i = 0, l = tilesets.length; i < l; ++i) {
                  const tilesetInfo = tilesets[i];
                  if (!tilesetInfo) continue;
                  fillTextureGrids(tilesetInfo, texGrids, tilesetInfo.sourceImage);
                }

                this._prepareToRender();
              }

              init(layerInfo, mapInfo, tilesets, textures, texGrids) {
                this._cullingDirty = true;
                this._layerInfo = layerInfo;
                this._mapInfo = mapInfo;
                const size = layerInfo.layerSize;
                this._layerName = layerInfo.name;
                this.tiles = layerInfo.tiles;
                this._properties = layerInfo.properties;
                this._layerSize = size;
                this._minGID = layerInfo.minGID;
                this._maxGID = layerInfo.maxGID;
                this._opacity = layerInfo.opacity;

                if (layerInfo.tintColor) {
                  this._tintColor = layerInfo.tintColor;
                }

                this.renderOrder = mapInfo.renderOrder;
                this._staggerAxis = mapInfo.getStaggerAxis();
                this._staggerIndex = mapInfo.getStaggerIndex();
                this._hexSideLength = mapInfo.getHexSideLength();
                this._animations = mapInfo.getTileAnimations();
                this._tilesets = tilesets;
                this._textures = textures;
                this.texGrids = texGrids;
                this._layerOrientation = mapInfo.orientation;
                this._mapTileSize = mapInfo.getTileSize();
                const maptw = this._mapTileSize.width;
                const mapth = this._mapTileSize.height;
                const layerW = this._layerSize.width;
                const layerH = this._layerSize.height;

                if (this._layerOrientation === Orientation.HEX) {
                  let width = 0;
                  let height = 0;
                  this._odd_even = this._staggerIndex === StaggerIndex.STAGGERINDEX_ODD ? 1 : -1;

                  if (this._staggerAxis === StaggerAxis.STAGGERAXIS_X) {
                    this._diffX1 = (maptw - this._hexSideLength) / 2;
                    this._diffY1 = 0;
                    height = mapth * (layerH + 0.5);
                    width = (maptw + this._hexSideLength) * Math.floor(layerW / 2) + maptw * (layerW % 2);
                  } else {
                    this._diffX1 = 0;
                    this._diffY1 = (mapth - this._hexSideLength) / 2;
                    width = maptw * (layerW + 0.5);
                    height = (mapth + this._hexSideLength) * Math.floor(layerH / 2) + mapth * (layerH % 2);
                  }

                  this.node._uiProps.uiTransformComp.setContentSize(width, height);
                } else if (this._layerOrientation === Orientation.ISO) {
                  const wh = layerW + layerH;

                  this.node._uiProps.uiTransformComp.setContentSize(maptw * 0.5 * wh, mapth * 0.5 * wh);
                } else {
                  this.node._uiProps.uiTransformComp.setContentSize(layerW * maptw, layerH * mapth);
                }

                this._offset = new Vec2(layerInfo.offset.x, -layerInfo.offset.y);
                this._useAutomaticVertexZ = false;
                this._vertexZvalue = 0;

                this._syncAnchorPoint();

                this._prepareToRender();
              }

              _prepareToRender() {
                this._updateVertices();

                this._updateAllUserNode();
              }

              requestMeshRenderData() {
                if (!this._meshRenderDataArray) {
                  this._meshRenderDataArray = [];
                }

                const arr = this._meshRenderDataArray;

                while (arr.length > 0 && arr[arr.length - 1].subNodes && arr[arr.length - 1].subNodes.length === 0) {
                  arr.pop();
                }

                if (arr.length > 0) {
                  const last = arr[arr.length - 1];

                  if (last.renderData && last.renderData.byteCount === 0) {
                    return last;
                  }
                }

                const renderData = new MeshRenderData();
                const comb = {
                  renderData,
                  texture: null
                };
                Object.defineProperty(renderData, 'material', {
                  get: () => this.getRenderMaterial(0)
                });

                this._meshRenderDataArray.push(comb);

                return comb;
              }

              requestSubNodesData() {
                if (!this._meshRenderDataArray) {
                  this._meshRenderDataArray = [];
                }

                const arr = this._meshRenderDataArray;

                while (arr.length > 0 && arr[arr.length - 1].renderData && arr[arr.length - 1].renderData.byteCount === 0) {
                  arr.pop();
                }

                if (arr.length > 0) {
                  if (arr[arr.length - 1].subNodes && arr[arr.length - 1].subNodes.length === 0) {
                    return arr[arr.length - 1];
                  }
                }

                const renderData = [];
                const comb = {
                  subNodes: renderData
                };

                this._meshRenderDataArray.push(comb);

                return comb;
              }

              destroyRenderData() {
                if (this._meshRenderDataArray) {
                  this._meshRenderDataArray.forEach(rd => {
                    if (rd.renderData) rd.renderData.reset();
                  });

                  this._meshRenderDataArray.length = 0;
                }
              }

              _flushAssembler() {
                const assembler = TiledLayer.Assembler.getAssembler(this);

                if (this._assembler !== assembler) {
                  this._assembler = assembler;
                }

                if (!this._meshRenderDataArray) {
                  if (this._assembler && this._assembler.createData) {
                    this._assembler.createData(this);

                    this.markForUpdateRenderData();

                    this._updateColor();
                  }
                }
              }

              _render(ui) {
                if (this._meshRenderDataArray) {
                  for (let i = 0; i < this._meshRenderDataArray.length; i++) {
                    this._meshRenderDataArrayIdx = i;
                    const m = this._meshRenderDataArray[i];

                    if (m.subNodes) {
                      m.subNodes.forEach(c => {
                        if (c) ui.walk(c.node);
                      });
                    } else if (m.texture) {
                      ui.commitComp(this, m.texture, this._assembler, null);
                    }
                  }

                  this.node._static = true;
                }
              }

            }, _temp2$6)) || _class3$t));

            var _dec$1r, _dec2$1h, _dec3$11, _dec4$Z, _class$1s, _class2$1g, _temp$1l;
            let TiledObjectGroup = exports('TiledObjectGroup', (_dec$1r = ccclass('cc.TiledObjectGroup'), _dec2$1h = help(), _dec3$11 = requireComponent(UITransform), _dec4$Z = type$1(CCBoolean), _dec$1r(_class$1s = _dec2$1h(_class$1s = _dec3$11(_class$1s = (_class2$1g = (_temp$1l = class TiledObjectGroup extends Component {
              constructor(...args) {
                super(...args);
                this._premultiplyAlpha = false;
                this._groupName = void 0;
                this._positionOffset = void 0;
                this._mapInfo = void 0;
                this._properties = void 0;
                this._offset = void 0;
                this._opacity = void 0;
                this._tintColor = null;
                this._animations = void 0;
                this._hasAniObj = void 0;
                this._texGrids = void 0;
                this.aniObjects = void 0;
                this._objects = [];
              }

              get premultiplyAlpha() {
                return this._premultiplyAlpha;
              }

              set premultiplyAlpha(value) {
                this._premultiplyAlpha = value;
              }

              getPositionOffset() {
                return this._positionOffset;
              }

              getProperties() {
                return this._properties;
              }

              getGroupName() {
                return this._groupName;
              }

              getProperty(propertyName) {
                return this._properties[propertyName.toString()];
              }

              getObject(objectName) {
                for (let i = 0, len = this._objects.length; i < len; i++) {
                  const obj = this._objects[i];

                  if (obj && obj.name === objectName) {
                    return obj;
                  }
                }

                return null;
              }

              getObjects() {
                return this._objects;
              }

              get offset() {
                return this._offset;
              }

              _init(groupInfo, mapInfo, texGrids) {
                const FLIPPED_MASK = TileFlag.FLIPPED_MASK;
                const FLAG_HORIZONTAL = TileFlag.HORIZONTAL;
                const FLAG_VERTICAL = TileFlag.VERTICAL;
                this._groupName = groupInfo.name;
                this._positionOffset = groupInfo.offset;
                this._mapInfo = mapInfo;
                this._properties = groupInfo.getProperties();
                this._offset = new Vec2(groupInfo.offset.x, -groupInfo.offset.y);
                this._opacity = groupInfo.opacity;

                if (groupInfo.tintColor) {
                  this._tintColor = groupInfo.tintColor;
                }

                this._texGrids = texGrids;
                this._animations = mapInfo.getTileAnimations();
                this.aniObjects = [];
                this._hasAniObj = false;
                const mapSize = mapInfo.mapSize;
                const tileSize = mapInfo.tileSize;
                let width = 0;
                let height = 0;
                const colorVal = new Color$1();
                const iso = Orientation.ISO === mapInfo.orientation;

                if (mapInfo.orientation === Orientation.HEX) {
                  if (mapInfo.getStaggerAxis() === StaggerAxis.STAGGERAXIS_X) {
                    height = tileSize.height * (mapSize.height + 0.5);
                    width = (tileSize.width + mapInfo.getHexSideLength()) * Math.floor(mapSize.width / 2) + tileSize.width * (mapSize.width % 2);
                  } else {
                    width = tileSize.width * (mapSize.width + 0.5);
                    height = (tileSize.height + mapInfo.getHexSideLength()) * Math.floor(mapSize.height / 2) + tileSize.height * (mapSize.height % 2);
                  }
                } else if (iso) {
                  const wh = mapSize.width + mapSize.height;
                  width = tileSize.width * 0.5 * wh;
                  height = tileSize.height * 0.5 * wh;
                } else {
                  width = mapSize.width * tileSize.width;
                  height = mapSize.height * tileSize.height;
                }

                const transComp = this.node._uiProps.uiTransformComp;
                transComp.setContentSize(width, height);
                const leftTopX = width * transComp.anchorX;
                const leftTopY = height * (1 - transComp.anchorY);
                const objects = groupInfo.objects;
                const aliveNodes = {};

                for (let i = 0, l = objects.length; i < l; i++) {
                  const object = objects[i];
                  const objType = object.type;
                  object.offset = new Vec2(object.x, object.y);
                  const points = object.points || object.polylinePoints;

                  if (points) {
                    for (let pi = 0; pi < points.length; pi++) {
                      points[pi].y *= -1;
                    }
                  }

                  if (iso) {
                    const posIdxX = object.x / tileSize.height;
                    const posIdxY = object.y / tileSize.height;
                    object.x = tileSize.width * 0.5 * (mapSize.height + posIdxX - posIdxY);
                    object.y = tileSize.height * 0.5 * (mapSize.width + mapSize.height - posIdxX - posIdxY);
                  } else {
                    object.y = height - object.y;
                  }

                  if (objType === TMXObjectType.TEXT) {
                    const textName = `text${object.id}`;
                    aliveNodes[textName] = true;
                    let textNode = this.node.getChildByName(textName);

                    if (!textNode) {
                      textNode = new Node();
                    }

                    textNode.setRotationFromEuler(0, 0, -object.rotation);
                    textNode.setPosition(object.x - leftTopX, object.y - leftTopY);
                    textNode.name = textName;
                    textNode.parent = this.node;
                    textNode.setSiblingIndex(i);
                    let label = textNode.getComponent(Label);

                    if (!label) {
                      label = textNode.addComponent(Label);
                    }

                    const textTransComp = textNode._uiProps.uiTransformComp;
                    textNode.active = object.visible;
                    textTransComp.anchorX = 0;
                    textTransComp.anchorY = 1;

                    if (this._tintColor) {
                      colorVal.set(this._tintColor);
                      colorVal.a *= this._opacity / 255;
                      label.color.set(colorVal);
                    } else {
                      const c = label.color;
                      c.a *= this._opacity / 255;
                    }

                    label.overflow = Label.Overflow.SHRINK;
                    label.lineHeight = object.height;
                    label.string = object.text;
                    label.horizontalAlign = object.halign;
                    label.verticalAlign = object.valign;
                    label.fontSize = object.pixelsize;

                    textTransComp.setContentSize(object.width, object.height);
                  } else if (objType === TMXObjectType.IMAGE) {
                    const gid = object.gid;
                    const gridGID = (gid & FLIPPED_MASK) >>> 0;
                    const grid = texGrids.get(gridGID);
                    if (!grid) continue;
                    const tileset = grid.tileset;
                    const imgName = `img${object.id}`;
                    aliveNodes[imgName] = true;
                    let imgNode = this.node.getChildByName(imgName);
                    object.width = object.width || grid.width;
                    object.height = object.height || grid.height;

                    if (imgNode && imgNode._objFlags & CCObject.Flags.HideInHierarchy) {
                      imgNode.removeFromParent();
                      imgNode.hideFlags |= CCObject.Flags.DontSave;
                      imgNode.destroy();
                      imgNode = null;
                    }

                    if (!imgNode) {
                      imgNode = new Node();
                    }

                    if (this._animations.get(gridGID)) {
                      this.aniObjects.push({
                        object,
                        imgNode,
                        gridGID
                      });
                      this._hasAniObj = true;
                    }

                    const tileOffsetX = tileset.tileOffset.x;
                    const tileOffsetY = tileset.tileOffset.y;
                    imgNode.active = object.visible;
                    imgNode.setRotationFromEuler(0, 0, -object.rotation);
                    imgNode.setPosition(object.x - leftTopX, object.y - leftTopY);
                    imgNode.name = imgName;
                    imgNode.parent = this.node;
                    imgNode.setSiblingIndex(i);
                    let sprite = imgNode.getComponent(Sprite);

                    if (!sprite) {
                      sprite = imgNode.addComponent(Sprite);
                    }

                    const imgTrans = imgNode._uiProps.uiTransformComp;

                    if (iso) {
                      imgTrans.anchorX = 0.5 + tileOffsetX / object.width;
                      imgTrans.anchorY = tileOffsetY / object.height;
                    } else {
                      imgTrans.anchorX = tileOffsetX / object.width;
                      imgTrans.anchorY = tileOffsetY / object.height;
                    }

                    if (this._tintColor) {
                      colorVal.set(this._tintColor);
                      colorVal.a *= this._opacity / 255;
                      sprite.color.set(colorVal);
                    } else {
                      const c = sprite.color;
                      c.a *= this._opacity / 255;
                    }

                    sprite.sizeMode = Sprite.SizeMode.CUSTOM;
                    sprite._srcBlendFactor = this._premultiplyAlpha ? BlendFactor.ONE : BlendFactor.SRC_ALPHA;
                    sprite._dstBlendFactor = BlendFactor.ONE_MINUS_SRC_ALPHA;

                    sprite._updateBlendFunc();

                    let spf = grid.spriteFrame;

                    if (!spf) {
                      spf = new SpriteFrame();
                    } else {
                      spf = spf.clone();
                    }

                    if ((gid & FLAG_HORIZONTAL) >>> 0) {
                      spf.flipUVX = !spf.flipUVX;
                    }

                    if ((gid & FLAG_VERTICAL) >>> 0) {
                      spf.flipUVY = !spf.flipUVY;
                    }

                    spf.rotated = grid._rotated;
                    spf.rect = grid._rect;
                    sprite.spriteFrame = spf;

                    imgTrans.setContentSize(object.width, object.height);
                    sprite.markForUpdateRenderData();
                  }
                }

                this._objects = objects;
                const children = this.node.children;
                const uselessExp = /^(?:img|text)\d+$/;

                for (let i = 0, n = children.length; i < n; i++) {
                  const c = children[i];
                  const cName = c.name;
                  const isUseless = uselessExp.test(cName);
                  if (isUseless && !aliveNodes[cName]) c.destroy();
                }
              }

              update(dt) {
                if (!this._hasAniObj) {
                  return;
                }

                const aniObjects = this.aniObjects;
                const _texGrids = this._texGrids;
                const iso = Orientation.ISO === this._mapInfo.orientation;

                for (let i = 0, len = aniObjects.length; i < len; i++) {
                  const aniObj = aniObjects[i];
                  const gridGID = aniObj.gridGID;

                  const grid = _texGrids.get(gridGID);

                  if (!grid) {
                    continue;
                  }

                  const tileset = grid.tileset;
                  const object = aniObj.object;
                  const imgNode = aniObj.imgNode;
                  const tileOffsetX = tileset.tileOffset.x;
                  const tileOffsetY = tileset.tileOffset.y;
                  const imgTrans = imgNode._uiProps.uiTransformComp;

                  if (iso) {
                    imgTrans.anchorX = 0.5 + tileOffsetX / object.width;
                    imgTrans.anchorY = tileOffsetY / object.height;
                  } else {
                    imgTrans.anchorX = tileOffsetX / object.width;
                    imgTrans.anchorY = tileOffsetY / object.height;
                  }

                  const sp = imgNode.getComponent(Sprite);
                  const spf = sp.spriteFrame;
                  spf.rotated = grid._rotated;
                  spf.rect = grid._rect;
                  sp.spriteFrame = spf;
                  sp.markForUpdateRenderData();
                }
              }

            }, _temp$1l), (_applyDecoratedDescriptor(_class2$1g.prototype, "premultiplyAlpha", [_dec4$Z], Object.getOwnPropertyDescriptor(_class2$1g.prototype, "premultiplyAlpha"), _class2$1g.prototype)), _class2$1g)) || _class$1s) || _class$1s) || _class$1s));

            var _dec$1s, _dec2$1i, _dec3$12, _dec4$_, _dec5$T, _dec6$O, _dec7$N, _dec8$J, _class$1t, _class2$1h, _descriptor$1e, _descriptor2$16, _descriptor3$U, _descriptor4$R, _descriptor5$I, _descriptor6$A, _descriptor7$s, _descriptor8$o, _temp$1m;
            let TiledMapAsset = exports('TiledMapAsset', (_dec$1s = ccclass('cc.TiledMapAsset'), _dec2$1i = type$1([TextAsset]), _dec3$12 = type$1([CCString]), _dec4$_ = type$1([SpriteFrame]), _dec5$T = type$1([SpriteFrame]), _dec6$O = type$1([CCString]), _dec7$N = type$1([CCString]), _dec8$J = type$1([Size$1]), _dec$1s(_class$1t = (_class2$1h = (_temp$1m = class TiledMapAsset extends Asset {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "tmxXmlStr", _descriptor$1e, this);

                _initializerDefineProperty(this, "tsxFiles", _descriptor2$16, this);

                _initializerDefineProperty(this, "tsxFileNames", _descriptor3$U, this);

                _initializerDefineProperty(this, "spriteFrames", _descriptor4$R, this);

                _initializerDefineProperty(this, "imageLayerSpriteFrame", _descriptor5$I, this);

                _initializerDefineProperty(this, "imageLayerSpriteFrameNames", _descriptor6$A, this);

                _initializerDefineProperty(this, "spriteFrameNames", _descriptor7$s, this);

                _initializerDefineProperty(this, "spriteFrameSizes", _descriptor8$o, this);
              }

            }, _temp$1m), (_descriptor$1e = _applyDecoratedDescriptor(_class2$1h.prototype, "tmxXmlStr", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            }), _descriptor2$16 = _applyDecoratedDescriptor(_class2$1h.prototype, "tsxFiles", [serializable, _dec2$1i], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor3$U = _applyDecoratedDescriptor(_class2$1h.prototype, "tsxFileNames", [serializable, _dec3$12], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor4$R = _applyDecoratedDescriptor(_class2$1h.prototype, "spriteFrames", [serializable, _dec4$_], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor5$I = _applyDecoratedDescriptor(_class2$1h.prototype, "imageLayerSpriteFrame", [serializable, _dec5$T], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor6$A = _applyDecoratedDescriptor(_class2$1h.prototype, "imageLayerSpriteFrameNames", [serializable, _dec6$O], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor7$s = _applyDecoratedDescriptor(_class2$1h.prototype, "spriteFrameNames", [serializable, _dec7$N], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor8$o = _applyDecoratedDescriptor(_class2$1h.prototype, "spriteFrameSizes", [serializable, _dec8$J], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            })), _class2$1h)) || _class$1t));

            var _dec$1t, _dec2$1j, _dec3$13, _dec4$$, _dec5$U, _dec6$P, _class$1u, _class2$1i, _descriptor$1f, _descriptor2$17, _descriptor3$V, _class3$u, _temp$1n;
            let TiledMap = exports('TiledMap', (_dec$1t = ccclass('cc.TiledMap'), _dec2$1j = help(), _dec3$13 = menu$1(), _dec4$$ = requireComponent(UITransform), _dec5$U = type$1(TiledMapAsset), _dec6$P = displayOrder(), _dec$1t(_class$1u = _dec2$1j(_class$1u = _dec3$13(_class$1u = _dec4$$(_class$1u = executeInEditMode(_class$1u = (_class2$1i = (_temp$1n = _class3$u = class TiledMap extends Component {
              constructor(...args) {
                super(...args);
                this._texGrids = new Map();
                this._textures = [];
                this._tilesets = [];
                this._animations = new Map();
                this._imageLayers = [];
                this._layers = [];
                this._groups = [];
                this._images = [];
                this._properties = {};
                this._tileProperties = new Map();
                this._mapInfo = null;
                this._mapSize = new Size$1(0, 0);
                this._tileSize = new Size$1(0, 0);
                this._preloaded = false;
                this._mapOrientation = Orientation.ORTHO;

                _initializerDefineProperty(this, "_tmxFile", _descriptor$1f, this);

                _initializerDefineProperty(this, "_enableCulling", _descriptor2$17, this);

                _initializerDefineProperty(this, "cleanupImageCache", _descriptor3$V, this);
              }

              get tmxAsset() {
                return this._tmxFile;
              }

              set tmxAsset(value) {
                if (this._tmxFile !== value || EDITOR) {
                  this._tmxFile = value;

                  if (this._preloaded || EDITOR) {
                    this._applyFile();
                  }
                }
              }

              get enableCulling() {
                return this._enableCulling;
              }

              set enableCulling(value) {
                this._enableCulling = value;
                const layers = this._layers;

                for (let i = 0; i < layers.length; ++i) {
                  layers[i].enableCulling = value;
                }
              }

              getMapSize() {
                return this._mapSize;
              }

              getTileSize() {
                return this._tileSize;
              }

              getMapOrientation() {
                return this._mapOrientation;
              }

              getObjectGroups() {
                return this._groups;
              }

              getObjectGroup(groupName) {
                const groups = this._groups;

                for (let i = 0, l = groups.length; i < l; i++) {
                  const group = groups[i];

                  if (group && group.getGroupName() === groupName) {
                    return group;
                  }
                }

                return null;
              }

              getProperties() {
                return this._properties;
              }

              getLayers() {
                return this._layers;
              }

              getLayer(layerName) {
                const layers = this._layers;

                for (let i = 0, l = layers.length; i < l; i++) {
                  const layer = layers[i];

                  if (layer && layer.getLayerName() === layerName) {
                    return layer;
                  }
                }

                return null;
              }

              _changeLayer(layerName, replaceLayer) {
                const layers = this._layers;

                for (let i = 0, l = layers.length; i < l; i++) {
                  const layer = layers[i];

                  if (layer && layer.getLayerName() === layerName) {
                    layers[i] = replaceLayer;
                    return;
                  }
                }
              }

              getProperty(propertyName) {
                return this._properties[propertyName.toString()];
              }

              getPropertiesForGID(gid) {
                return this._tileProperties.get(gid);
              }

              __preload() {
                this._preloaded = true;

                if (!this._tmxFile) {
                  return;
                }

                this._applyFile();
              }

              onEnable() {
                this.node.on(NodeEventType.ANCHOR_CHANGED, this._syncAnchorPoint, this);
              }

              onDisable() {
                this.node.off(NodeEventType.ANCHOR_CHANGED, this._syncAnchorPoint, this);
              }

              _applyFile() {
                const spriteFrames = [];
                const spriteFramesCache = {};
                const file = this._tmxFile;

                if (file) {
                  let spfNames = file.spriteFrameNames;
                  const spfSizes = file.spriteFrameSizes;
                  const fSpriteFrames = file.spriteFrames;
                  const spfTexturesMap = {};
                  const spfTextureSizeMap = {};

                  for (let i = 0; i < spfNames.length; ++i) {
                    const texName = spfNames[i];
                    spfTextureSizeMap[texName] = spfSizes[i];
                    spriteFrames[i] = fSpriteFrames[i];
                    const frame = spriteFrames[i];

                    if (frame) {
                      spriteFramesCache[frame.name] = frame;
                      spfTexturesMap[texName] = frame;
                    }
                  }

                  const imageLayerTextures = {};
                  const texValues = file.imageLayerSpriteFrame;
                  spfNames = file.imageLayerSpriteFrameNames;

                  for (let i = 0; i < texValues.length; ++i) {
                    imageLayerTextures[spfNames[i]] = texValues[i];
                  }

                  const tsxFileNames = file.tsxFileNames;
                  const tsxFiles = file.tsxFiles;
                  const tsxContentMap = {};

                  for (let i = 0; i < tsxFileNames.length; ++i) {
                    if (tsxFileNames[i].length > 0) {
                      tsxContentMap[tsxFileNames[i]] = tsxFiles[i].text;
                    }
                  }

                  const mapInfo = new TMXMapInfo(file.tmxXmlStr, tsxContentMap, spfTexturesMap, spfTextureSizeMap, imageLayerTextures);
                  const tilesets = mapInfo.getTilesets();

                  if (!tilesets || tilesets.length === 0) {
                    logID(7241);
                  }

                  this._buildWithMapInfo(mapInfo);
                } else {
                  this._releaseMapInfo();
                }
              }

              _releaseMapInfo() {
                const layers = this._layers;

                for (let i = 0, l = layers.length; i < l; i++) {
                  layers[i].node.removeFromParent();
                  layers[i].node.destroy();
                }

                layers.length = 0;
                const groups = this._groups;

                for (let i = 0, l = groups.length; i < l; i++) {
                  groups[i].node.removeFromParent();
                  groups[i].node.destroy();
                }

                groups.length = 0;
                const images = this._images;

                for (let i = 0, l = images.length; i < l; i++) {
                  images[i].removeFromParent();
                  images[i].destroy();
                }

                images.length = 0;
              }

              _syncAnchorPoint() {
                const anchor = this.node._uiProps.uiTransformComp.anchorPoint;
                const leftTopX = this.node._uiProps.uiTransformComp.width * anchor.x;
                const leftTopY = this.node._uiProps.uiTransformComp.height * (1 - anchor.y);
                let i;
                let l;

                for (i = 0, l = this._layers.length; i < l; i++) {
                  const layerInfo = this._layers[i];
                  const layerNode = layerInfo.node;

                  layerNode._uiProps.uiTransformComp.setAnchorPoint(anchor);
                }

                for (i = 0, l = this._groups.length; i < l; i++) {
                  const groupInfo = this._groups[i];
                  const groupNode = groupInfo.node._uiProps.uiTransformComp;
                  groupNode.anchorX = 0.5;
                  groupNode.anchorY = 0.5;
                  const x = groupInfo.offset.x - leftTopX + groupNode.width * groupNode.anchorX;
                  const y = groupInfo.offset.y + leftTopY - groupNode.height * groupNode.anchorY;
                  groupInfo.node.setPosition(x, y);
                }

                for (i = 0, l = this._images.length; i < l; i++) {
                  const image = this._images[i]._uiProps.uiTransformComp;
                  image.anchorX = 0.5;
                  image.anchorY = 0.5;
                  const x = this._images[i]._offset.x - leftTopX + image.width * image.anchorX;
                  const y = this._images[i]._offset.y + leftTopY - image.height * image.anchorY;

                  this._images[i].setPosition(x, y);
                }
              }

              _fillAniGrids(texGrids, animations) {
                for (const i of animations.keys()) {
                  const animation = animations.get(i);
                  if (!animation) continue;
                  const frames = animation.frames;

                  for (let j = 0; j < frames.length; j++) {
                    const frame = frames[j];
                    frame.grid = texGrids.get(frame.tileid);
                  }
                }
              }

              _buildLayerAndGroup() {
                const tilesets = this._tilesets;
                const texGrids = this._texGrids;
                const animations = this._animations;
                texGrids.clear();

                for (let i = 0, l = tilesets.length; i < l; ++i) {
                  const tilesetInfo = tilesets[i];
                  if (!tilesetInfo) continue;

                  if (!tilesetInfo.sourceImage) {
                    console.warn(`Can't find the spriteFrame of tilesets ${i}`);
                    continue;
                  }

                  fillTextureGrids(tilesetInfo, texGrids, tilesetInfo.sourceImage);
                }

                this._fillAniGrids(texGrids, animations);

                let layers = this._layers;
                let groups = this._groups;
                let images = this._images;
                const oldNodeNames = {};

                for (let i = 0, n = layers.length; i < n; i++) {
                  oldNodeNames[layers[i].node.name] = true;
                }

                for (let i = 0, n = groups.length; i < n; i++) {
                  oldNodeNames[groups[i].node.name] = true;
                }

                for (let i = 0, n = images.length; i < n; i++) {
                  oldNodeNames[images[i].name] = true;
                }

                layers = this._layers = [];
                groups = this._groups = [];
                images = this._images = [];
                const mapInfo = this._mapInfo;
                const node = this.node;
                const layerInfos = mapInfo.getAllChildren();
                const textures = this._textures;
                let maxWidth = 0;
                let maxHeight = 0;

                if (layerInfos && layerInfos.length > 0) {
                  for (let i = 0, len = layerInfos.length; i < len; i++) {
                    const layerInfo = layerInfos[i];
                    const name = layerInfo.name;
                    let child = this.node.getChildByName(name);
                    oldNodeNames[name] = false;

                    if (!child) {
                      child = new Node();
                      child.name = name;
                      child.layer = node.layer;
                      node.addChild(child);
                    }

                    child.setSiblingIndex(i);
                    child.active = layerInfo.visible;

                    if (layerInfo instanceof TMXLayerInfo) {
                      let layer = child.getComponent(TiledLayer);

                      if (!layer) {
                        layer = child.addComponent(TiledLayer);
                      }

                      layer.init(layerInfo, mapInfo, tilesets, textures, texGrids);
                      layer.enableCulling = this._enableCulling;
                      layerInfo.ownTiles = false;
                      layers.push(layer);
                    } else if (layerInfo instanceof TMXObjectGroupInfo) {
                      let group = child.getComponent(TiledObjectGroup);

                      if (!group) {
                        group = child.addComponent(TiledObjectGroup);
                      }

                      group._init(layerInfo, mapInfo, texGrids);

                      groups.push(group);
                    } else if (layerInfo instanceof TMXImageLayerInfo) {
                      const texture = layerInfo.sourceImage;
                      child.layerInfo = layerInfo;
                      child._offset = new Vec2(layerInfo.offset.x, -layerInfo.offset.y);
                      let image = child.getComponent(Sprite);

                      if (!image) {
                        image = child.addComponent(Sprite);
                      }

                      const color = image.color;
                      color.a *= layerInfo.opacity;
                      image.spriteFrame = texture;

                      child._uiProps.uiTransformComp.setContentSize(texture.width, texture.height);

                      images.push(child);
                    }

                    maxWidth = Math.max(maxWidth, child._uiProps.uiTransformComp.width);
                    maxHeight = Math.max(maxHeight, child._uiProps.uiTransformComp.height);
                  }
                }

                const children = node.children;

                for (let i = 0, n = children.length; i < n; i++) {
                  const c = children[i];

                  if (oldNodeNames[c.name]) {
                    c.destroy();
                  }
                }

                this.node._uiProps.uiTransformComp.setContentSize(maxWidth, maxHeight);

                this._syncAnchorPoint();
              }

              _buildWithMapInfo(mapInfo) {
                this._mapInfo = mapInfo;
                this._mapSize = mapInfo.getMapSize();
                this._tileSize = mapInfo.getTileSize();
                this._mapOrientation = mapInfo.orientation;
                this._properties = mapInfo.properties;
                this._tileProperties = mapInfo.getTileProperties();
                this._imageLayers = mapInfo.getImageLayers();
                this._animations = mapInfo.getTileAnimations();
                this._tilesets = mapInfo.getTilesets();
                const tilesets = this._tilesets;
                this._textures.length = 0;
                const totalTextures = [];

                for (let i = 0, l = tilesets.length; i < l; ++i) {
                  const tilesetInfo = tilesets[i];
                  if (!tilesetInfo || !tilesetInfo.sourceImage) continue;
                  this._textures[i] = tilesetInfo.sourceImage;
                  totalTextures.push(tilesetInfo.sourceImage);
                }

                for (let i = 0; i < this._imageLayers.length; i++) {
                  const imageLayer = this._imageLayers[i];
                  if (!imageLayer || !imageLayer.sourceImage) continue;
                  totalTextures.push(imageLayer.sourceImage);
                }

                this._buildLayerAndGroup();

                if (this.cleanupImageCache) {
                  this._textures.forEach(tex => {
                    this.doCleanupImageCache(tex);
                  });
                }
              }

              doCleanupImageCache(texture) {
                if (texture._image instanceof HTMLImageElement) {
                  texture._image.src = '';
                  texture._image.destroy();
                } else if (sys.hasFeature(sys.Feature.IMAGE_BITMAP) && texture._image instanceof ImageBitmap) {
                  if (texture._image.close) texture._image.close();
                }

                texture._image = null;
              }

              update(dt) {
                const animations = this._animations;
                const texGrids = this._texGrids;

                for (const aniGID of animations.keys()) {
                  const animation = animations.get(aniGID);
                  const frames = animation.frames;
                  let frame = frames[animation.frameIdx];
                  animation.dt += dt;

                  if (frame.duration < animation.dt) {
                    animation.dt = 0;
                    animation.frameIdx++;

                    if (animation.frameIdx >= frames.length) {
                      animation.frameIdx = 0;
                    }

                    frame = frames[animation.frameIdx];
                  }

                  texGrids.set(aniGID, frame.grid);
                }

                for (const layer of this.getLayers()) {
                  if (layer.hasAnimation()) {
                    layer.markForUpdateRenderData();
                  }
                }
              }

            }, _class3$u.Orientation = Orientation, _class3$u.Property = Property, _class3$u.TileFlag = TileFlag, _class3$u.StaggerAxis = StaggerAxis, _class3$u.StaggerIndex = StaggerIndex, _class3$u.TMXObjectType = TMXObjectType, _class3$u.RenderOrder = RenderOrder, _temp$1n), (_descriptor$1f = _applyDecoratedDescriptor(_class2$1i.prototype, "_tmxFile", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _applyDecoratedDescriptor(_class2$1i.prototype, "tmxAsset", [_dec5$U, _dec6$P], Object.getOwnPropertyDescriptor(_class2$1i.prototype, "tmxAsset"), _class2$1i.prototype), _descriptor2$17 = _applyDecoratedDescriptor(_class2$1i.prototype, "_enableCulling", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _applyDecoratedDescriptor(_class2$1i.prototype, "enableCulling", [editable], Object.getOwnPropertyDescriptor(_class2$1i.prototype, "enableCulling"), _class2$1i.prototype), _descriptor3$V = _applyDecoratedDescriptor(_class2$1i.prototype, "cleanupImageCache", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            })), _class2$1i)) || _class$1u) || _class$1u) || _class$1u) || _class$1u) || _class$1u));

            const MaxGridsLimit = Math.ceil(65535 / 6);
            const vec3_temps$3 = [];

            for (let i = 0; i < 4; i++) {
              vec3_temps$3.push(new Vec3());
            }

            const _mat4_temp$5 = new Mat4();

            const _vec3u_temp = new Vec3();

            const _leftDown = {
              row: 0,
              col: 0
            };
            let _uva = {
              x: 0,
              y: 0
            };
            let _uvb = {
              x: 0,
              y: 0
            };
            let _uvc = {
              x: 0,
              y: 0
            };
            let _uvd = {
              x: 0,
              y: 0
            };

            let _renderData$1;

            let _fillGrids = 0;
            let _vfOffset = 0;
            let _moveX = 0;
            let _moveY = 0;
            let flipTexture;
            const simple$1 = {
              createData(layer) {
                const renderData = layer.requestMeshRenderData();
                const maxGrids = layer.rightTop.col * layer.rightTop.row;

                if (maxGrids * 4 > 65535) {
                  console.error('Vertex count exceeds 65535');
                }

                return renderData;
              },

              updateRenderData(comp, ui) {
                comp.updateCulling();
                const renderData = comp.requestMeshRenderData();
                _moveX = comp.leftDownToCenterX;
                _moveY = comp.leftDownToCenterY;
                _renderData$1 = renderData;

                if (comp.colorChanged || comp.isCullingDirty() || comp.isUserNodeDirty() || comp.hasAnimation() || comp.hasTiledNode()) {
                  comp.colorChanged = false;
                  comp.destroyRenderData();
                  let leftDown;
                  let rightTop;

                  if (comp.enableCulling) {
                    const cullingRect = comp.cullingRect;
                    leftDown = cullingRect.leftDown;
                    rightTop = cullingRect.rightTop;
                  } else {
                    leftDown = _leftDown;
                    rightTop = comp.rightTop;
                  }

                  switch (comp.renderOrder) {
                    case RenderOrder.RightDown:
                      traverseGrids(leftDown, rightTop, -1, 1, comp);
                      break;

                    case RenderOrder.LeftDown:
                      traverseGrids(leftDown, rightTop, -1, -1, comp);
                      break;

                    case RenderOrder.RightUp:
                      traverseGrids(leftDown, rightTop, 1, 1, comp);
                      break;

                    case RenderOrder.LeftUp:
                    default:
                      traverseGrids(leftDown, rightTop, 1, -1, comp);
                      break;
                  }

                  comp.setCullingDirty(false);
                  comp.setUserNodeDirty(false);
                }

                _renderData$1 = null;
              },

              updateColor(tiled) {
                const color = tiled.color;
                const colorV = new Float32Array(4);
                colorV[0] = color.r / 255;
                colorV[1] = color.g / 255;
                colorV[2] = color.b / 255;
                colorV[0] = color.a / 255;
                const rs = tiled.meshRenderDataArray;

                if (rs) {
                  for (const r of rs) {
                    if (!r.renderData) continue;
                    const renderData = r.renderData;
                    const vs = renderData.vData;

                    for (let i = renderData.vertexStart, l = renderData.vertexCount; i < l; i++) {
                      vs.set(colorV, i * 9 + 5);
                    }
                  }
                }
              },

              fillBuffers(layer, renderer) {
                if (!layer || !layer.meshRenderDataArray) return;
                const dataArray = layer.meshRenderDataArray;
                const node = layer.node;
                let buffer = renderer.acquireBufferBatch();
                let vertexOffset = buffer.byteOffset >> 2;
                let indicesOffset = buffer.indicesOffset;
                let vertexId = buffer.vertexOffset;
                const data = dataArray[layer._meshRenderDataArrayIdx];
                const renderData = data.renderData;
                const isRecreate = buffer.request(renderData.vertexCount, renderData.indicesCount);

                if (!isRecreate) {
                  buffer = renderer.currBufferBatch;
                  vertexOffset = 0;
                  indicesOffset = 0;
                  vertexId = 0;
                }

                const vBuf = buffer.vData;
                const iBuf = buffer.iData;
                const matrix = node.worldMatrix;
                const srcVBuf = renderData.vData;
                const srcVIdx = renderData.vertexStart;
                vBuf.set(srcVBuf.slice(srcVIdx, srcVIdx + renderData.vertexCount * 9), vertexOffset);

                for (let i = 0; i < renderData.vertexCount; i++) {
                  const pOffset = vertexOffset + i * 9;

                  _vec3u_temp.set(vBuf[pOffset], vBuf[pOffset + 1], vBuf[pOffset + 2]);

                  _vec3u_temp.transformMat4(matrix);

                  vBuf[pOffset] = _vec3u_temp.x;
                  vBuf[pOffset + 1] = _vec3u_temp.y;
                  vBuf[pOffset + 2] = _vec3u_temp.z;
                }

                const quadCount = renderData.vertexCount / 4;

                for (let i = 0; i < quadCount; i += 1) {
                  iBuf[indicesOffset] = vertexId;
                  iBuf[indicesOffset + 1] = vertexId + 1;
                  iBuf[indicesOffset + 2] = vertexId + 2;
                  iBuf[indicesOffset + 3] = vertexId + 2;
                  iBuf[indicesOffset + 4] = vertexId + 1;
                  iBuf[indicesOffset + 5] = vertexId + 3;
                  indicesOffset += 6;
                  vertexId += 4;
                }
              }

            };

            function _flipTexture(inGrid, gid) {
              if (inGrid._rotated) {
                _uva.x = inGrid.r;
                _uva.y = inGrid.t;
                _uvb.x = inGrid.l;
                _uvb.y = inGrid.t;
                _uvc.x = inGrid.r;
                _uvc.y = inGrid.b;
                _uvd.x = inGrid.l;
                _uvd.y = inGrid.b;
              } else {
                _uva.x = inGrid.l;
                _uva.y = inGrid.t;
                _uvb.x = inGrid.l;
                _uvb.y = inGrid.b;
                _uvc.x = inGrid.r;
                _uvc.y = inGrid.t;
                _uvd.x = inGrid.r;
                _uvd.y = inGrid.b;
              }

              let tempVal;

              if ((gid & TileFlag.DIAGONAL) >>> 0) {
                tempVal = _uvb;
                _uvb = _uvc;
                _uvc = tempVal;
              }

              if ((gid & TileFlag.HORIZONTAL) >>> 0) {
                tempVal = _uva;
                _uva = _uvc;
                _uvc = tempVal;
                tempVal = _uvb;
                _uvb = _uvd;
                _uvd = tempVal;
              }

              if ((gid & TileFlag.VERTICAL) >>> 0) {
                tempVal = _uva;
                _uva = _uvb;
                _uvb = tempVal;
                tempVal = _uvc;
                _uvc = _uvd;
                _uvd = tempVal;
              }
            }

            function switchRenderData(curTexIdx, grid, comp) {
              if (!curTexIdx) curTexIdx = grid.texture;

              if (!_renderData$1.texture) {
                _renderData$1.texture = curTexIdx;
              }

              _renderData$1 = comp.requestMeshRenderData();
              _renderData$1.texture = grid.texture;
            }

            function traverseGrids(leftDown, rightTop, rowMoveDir, colMoveDir, comp) {
              if (!_renderData$1 || rightTop.row < 0 || rightTop.col < 0) return;

              if (!_renderData$1.renderData) {
                _renderData$1 = comp.requestMeshRenderData();
              }

              let vertexBuf = _renderData$1.renderData.vData;
              _fillGrids = 0;
              _vfOffset = 0;
              const tiledTiles = comp.tiledTiles;
              const texGrids = comp.texGrids;
              const tiles = comp.tiles;
              const vertStep = 9;
              const vertStep2 = vertStep * 2;
              const vertStep3 = vertStep * 3;
              const vertices = comp.vertices;
              let rowData;
              let col;
              let cols;
              let row;
              let rows;
              let colData;
              let tileSize;
              let grid;
              let gid = 0;
              let left = 0;
              let bottom = 0;
              let right = 0;
              let top = 0;
              let tiledNode;
              let curTexIdx = null;
              let colNodesCount = 0;
              let checkColRange = true;
              const diamondTile = false;
              flipTexture =  _flipTexture;
              const color = new Float32Array(4);
              color[0] = comp.color.r / 255;
              color[1] = comp.color.g / 255;
              color[2] = comp.color.b / 255;
              color[3] = comp.color.a / 255;

              if (rowMoveDir === -1) {
                row = rightTop.row;
                rows = leftDown.row;
              } else {
                row = leftDown.row;
                rows = rightTop.row;
              }

              for (; (rows - row) * rowMoveDir >= 0; row += rowMoveDir) {
                rowData = vertices[row];
                colNodesCount = comp.getNodesCountByRow(row);
                checkColRange = rowData && colNodesCount === 0;

                if (colMoveDir === 1) {
                  col = checkColRange && leftDown.col < rowData.minCol ? rowData.minCol : leftDown.col;
                  cols = checkColRange && rightTop.col > rowData.maxCol ? rowData.maxCol : rightTop.col;
                } else {
                  col = checkColRange && rightTop.col > rowData.maxCol ? rowData.maxCol : rightTop.col;
                  cols = checkColRange && leftDown.col < rowData.minCol ? rowData.minCol : leftDown.col;
                }

                for (; (cols - col) * colMoveDir >= 0; col += colMoveDir) {
                  colData = rowData && rowData[col];

                  if (colNodesCount > 0) {
                    const nodes = comp.requestSubNodesData();
                    const celData = comp.getNodesByRowCol(row, col);

                    if (celData && celData.count > 0) {
                      nodes.subNodes = comp.getNodesByRowCol(row, col).list;
                      curTexIdx = null;
                      _renderData$1 = comp.requestMeshRenderData();
                    }
                  }

                  if (!colData) {
                    continue;
                  }

                  gid = tiles[colData.index];
                  grid = texGrids.get((gid & TileFlag.FLIPPED_MASK) >>> 0);
                  if (!grid) continue;

                  if (curTexIdx !== grid.texture) {
                    switchRenderData(curTexIdx, grid, comp);
                    curTexIdx = grid.texture;
                  }

                  tileSize = grid.tileset._tileSize;
                  left = colData.left - _moveX;
                  bottom = colData.bottom - _moveY;
                  right = left + tileSize.width;
                  top = bottom + tileSize.height;
                  tiledNode = tiledTiles[colData.index];

                  _renderData$1.renderData.reserve(4, 0);

                  _vfOffset = _renderData$1.renderData.vertexCount * 9;
                  vertexBuf = _renderData$1.renderData.vData;

                  if (!tiledNode) {
                    {
                      vertexBuf[_vfOffset] = left;
                      vertexBuf[_vfOffset + 1] = top;
                      vertexBuf[_vfOffset + vertStep] = left;
                      vertexBuf[_vfOffset + vertStep + 1] = bottom;
                      vertexBuf[_vfOffset + vertStep2] = right;
                      vertexBuf[_vfOffset + vertStep2 + 1] = top;
                      vertexBuf[_vfOffset + vertStep3] = right;
                      vertexBuf[_vfOffset + vertStep3 + 1] = bottom;
                    }

                    vertexBuf.set(color, _vfOffset + 5);
                    vertexBuf.set(color, _vfOffset + vertStep + 5);
                    vertexBuf.set(color, _vfOffset + vertStep2 + 5);
                    vertexBuf.set(color, _vfOffset + vertStep3 + 5);
                  } else if (tiledNode.node.active) {
                    fillByTiledNode(tiledNode.node, color, vertexBuf, left, right, top, bottom, diamondTile);
                  }

                  flipTexture(grid, gid);
                  vertexBuf[_vfOffset + 3] = _uva.x;
                  vertexBuf[_vfOffset + 4] = _uva.y;
                  vertexBuf[_vfOffset + vertStep + 3] = _uvb.x;
                  vertexBuf[_vfOffset + vertStep + 4] = _uvb.y;
                  vertexBuf[_vfOffset + vertStep2 + 3] = _uvc.x;
                  vertexBuf[_vfOffset + vertStep2 + 4] = _uvc.y;
                  vertexBuf[_vfOffset + vertStep3 + 3] = _uvd.x;
                  vertexBuf[_vfOffset + vertStep3 + 4] = _uvd.y;
                  _fillGrids++;

                  _renderData$1.renderData.advance(4, 6);

                  if (_fillGrids >= MaxGridsLimit) {
                    switchRenderData(curTexIdx, grid, comp);
                    curTexIdx = grid.texture;
                  }
                }
              }
            }

            function fillByTiledNode(tiledNode, color, vbuf, left, right, top, bottom, diamondTile) {
              const vertStep = 9;
              const vertStep2 = vertStep * 2;
              const vertStep3 = vertStep * 3;
              tiledNode.updateWorldTransform();
              Mat4.fromRTS(_mat4_temp$5, tiledNode.getRotation(), tiledNode.getPosition(), tiledNode.getScale());
              Vec3.set(_vec3u_temp, -(left + _moveX), -(bottom + _moveY), 0);
              Mat4.transform(_mat4_temp$5, _mat4_temp$5, _vec3u_temp);
              const m = _mat4_temp$5;
              const tx = m.m12;
              const ty = m.m13;
              const a = m.m00;
              const b = m.m01;
              const c = m.m04;
              const d = m.m05;
              const justTranslate = a === 1 && b === 0 && c === 0 && d === 1;

              if (diamondTile) {
                const centerX = (left + right) / 2;
                const centerY = (top + bottom) / 2;

                if (justTranslate) {
                  vbuf[_vfOffset] = centerX + tx;
                  vbuf[_vfOffset + 1] = top + ty;
                  vbuf[_vfOffset + vertStep] = left + tx;
                  vbuf[_vfOffset + vertStep + 1] = centerY + ty;
                  vbuf[_vfOffset + vertStep2] = right + tx;
                  vbuf[_vfOffset + vertStep2 + 1] = centerY + ty;
                  vbuf[_vfOffset + vertStep3] = centerX + tx;
                  vbuf[_vfOffset + vertStep3 + 1] = bottom + ty;
                } else {
                  vbuf[_vfOffset] = centerX * a + top * c + tx;
                  vbuf[_vfOffset + 1] = centerX * b + top * d + ty;
                  vbuf[_vfOffset + vertStep] = left * a + centerY * c + tx;
                  vbuf[_vfOffset + vertStep + 1] = left * b + centerY * d + ty;
                  vbuf[_vfOffset + vertStep2] = right * a + centerY * c + tx;
                  vbuf[_vfOffset + vertStep2 + 1] = right * b + centerY * d + ty;
                  vbuf[_vfOffset + vertStep3] = centerX * a + bottom * c + tx;
                  vbuf[_vfOffset + vertStep3 + 1] = centerX * b + bottom * d + ty;
                }
              } else if (justTranslate) {
                vbuf[_vfOffset] = left + tx;
                vbuf[_vfOffset + 1] = top + ty;
                vbuf[_vfOffset + vertStep] = left + tx;
                vbuf[_vfOffset + vertStep + 1] = bottom + ty;
                vbuf[_vfOffset + vertStep2] = right + tx;
                vbuf[_vfOffset + vertStep2 + 1] = top + ty;
                vbuf[_vfOffset + vertStep3] = right + tx;
                vbuf[_vfOffset + vertStep3 + 1] = bottom + ty;
              } else {
                vbuf[_vfOffset] = left * a + top * c + tx;
                vbuf[_vfOffset + 1] = left * b + top * d + ty;
                vbuf[_vfOffset + vertStep] = left * a + bottom * c + tx;
                vbuf[_vfOffset + vertStep + 1] = left * b + bottom * d + ty;
                vbuf[_vfOffset + vertStep2] = right * a + top * c + tx;
                vbuf[_vfOffset + vertStep2 + 1] = right * b + top * d + ty;
                vbuf[_vfOffset + vertStep3] = right * a + bottom * c + tx;
                vbuf[_vfOffset + vertStep3 + 1] = right * b + bottom * d + ty;
              }

              vbuf.set(color, _vfOffset + 5);
              vbuf.set(color, _vfOffset + vertStep + 5);
              vbuf.set(color, _vfOffset + vertStep2 + 5);
              vbuf.set(color, _vfOffset + vertStep3 + 5);
            }

            const tiledLayerAssembler = exports('tiledLayerAssembler', {
              getAssembler() {
                return simple$1;
              }

            });
            TiledLayer.Assembler = tiledLayerAssembler;

            class TrackEntryListeners {
              constructor() {
                this.start = void 0;
                this.interrupt = void 0;
                this.end = void 0;
                this.dispose = void 0;
                this.complete = void 0;
                this.event = void 0;
              }

              static getListeners(entry) {
                if (!entry.listener) {
                  entry.listener = new TrackEntryListeners();
                }

                return entry.listener;
              }

            }

            var __extends = undefined && undefined.__extends || function () {
              var extendStatics = function (d, b) {
                extendStatics = Object.setPrototypeOf || {
                  __proto__: []
                } instanceof Array && function (d, b) {
                  d.__proto__ = b;
                } || function (d, b) {
                  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                };

                return extendStatics(d, b);
              };

              return function (d, b) {
                extendStatics(d, b);

                function __() {
                  this.constructor = d;
                }

                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
              };
            }();

            var spine;

            (function (spine) {
              var Animation = function () {
                function Animation(name, timelines, duration) {
                  if (name == null) throw new Error("name cannot be null.");
                  if (timelines == null) throw new Error("timelines cannot be null.");
                  this.name = name;
                  this.timelines = timelines;
                  this.timelineIds = [];

                  for (var i = 0; i < timelines.length; i++) this.timelineIds[timelines[i].getPropertyId()] = true;

                  this.duration = duration;
                }

                Animation.prototype.hasTimeline = function (id) {
                  return this.timelineIds[id] == true;
                };

                Animation.prototype.apply = function (skeleton, lastTime, time, loop, events, alpha, blend, direction) {
                  if (skeleton == null) throw new Error("skeleton cannot be null.");

                  if (loop && this.duration != 0) {
                    time %= this.duration;
                    if (lastTime > 0) lastTime %= this.duration;
                  }

                  var timelines = this.timelines;

                  for (var i = 0, n = timelines.length; i < n; i++) timelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);
                };

                Animation.binarySearch = function (values, target, step) {
                  if (step === void 0) {
                    step = 1;
                  }

                  var low = 0;
                  var high = values.length / step - 2;
                  if (high == 0) return step;
                  var current = high >>> 1;

                  while (true) {
                    if (values[(current + 1) * step] <= target) low = current + 1;else high = current;
                    if (low == high) return (low + 1) * step;
                    current = low + high >>> 1;
                  }
                };

                Animation.linearSearch = function (values, target, step) {
                  for (var i = 0, last = values.length - step; i <= last; i += step) if (values[i] > target) return i;

                  return -1;
                };

                return Animation;
              }();

              spine.Animation = Animation;
              var MixBlend;

              (function (MixBlend) {
                MixBlend[MixBlend["setup"] = 0] = "setup";
                MixBlend[MixBlend["first"] = 1] = "first";
                MixBlend[MixBlend["replace"] = 2] = "replace";
                MixBlend[MixBlend["add"] = 3] = "add";
              })(MixBlend = spine.MixBlend || (spine.MixBlend = {}));

              var MixDirection;

              (function (MixDirection) {
                MixDirection[MixDirection["mixIn"] = 0] = "mixIn";
                MixDirection[MixDirection["mixOut"] = 1] = "mixOut";
              })(MixDirection = spine.MixDirection || (spine.MixDirection = {}));

              var TimelineType;

              (function (TimelineType) {
                TimelineType[TimelineType["rotate"] = 0] = "rotate";
                TimelineType[TimelineType["translate"] = 1] = "translate";
                TimelineType[TimelineType["scale"] = 2] = "scale";
                TimelineType[TimelineType["shear"] = 3] = "shear";
                TimelineType[TimelineType["attachment"] = 4] = "attachment";
                TimelineType[TimelineType["color"] = 5] = "color";
                TimelineType[TimelineType["deform"] = 6] = "deform";
                TimelineType[TimelineType["event"] = 7] = "event";
                TimelineType[TimelineType["drawOrder"] = 8] = "drawOrder";
                TimelineType[TimelineType["ikConstraint"] = 9] = "ikConstraint";
                TimelineType[TimelineType["transformConstraint"] = 10] = "transformConstraint";
                TimelineType[TimelineType["pathConstraintPosition"] = 11] = "pathConstraintPosition";
                TimelineType[TimelineType["pathConstraintSpacing"] = 12] = "pathConstraintSpacing";
                TimelineType[TimelineType["pathConstraintMix"] = 13] = "pathConstraintMix";
                TimelineType[TimelineType["twoColor"] = 14] = "twoColor";
              })(TimelineType = spine.TimelineType || (spine.TimelineType = {}));

              var CurveTimeline = function () {
                function CurveTimeline(frameCount) {
                  if (frameCount <= 0) throw new Error("frameCount must be > 0: " + frameCount);
                  this.curves = spine.Utils.newFloatArray((frameCount - 1) * CurveTimeline.BEZIER_SIZE);
                }

                CurveTimeline.prototype.getFrameCount = function () {
                  return this.curves.length / CurveTimeline.BEZIER_SIZE + 1;
                };

                CurveTimeline.prototype.setLinear = function (frameIndex) {
                  this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.LINEAR;
                };

                CurveTimeline.prototype.setStepped = function (frameIndex) {
                  this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.STEPPED;
                };

                CurveTimeline.prototype.getCurveType = function (frameIndex) {
                  var index = frameIndex * CurveTimeline.BEZIER_SIZE;
                  if (index == this.curves.length) return CurveTimeline.LINEAR;
                  var type = this.curves[index];
                  if (type == CurveTimeline.LINEAR) return CurveTimeline.LINEAR;
                  if (type == CurveTimeline.STEPPED) return CurveTimeline.STEPPED;
                  return CurveTimeline.BEZIER;
                };

                CurveTimeline.prototype.setCurve = function (frameIndex, cx1, cy1, cx2, cy2) {
                  var tmpx = (-cx1 * 2 + cx2) * 0.03,
                      tmpy = (-cy1 * 2 + cy2) * 0.03;
                  var dddfx = ((cx1 - cx2) * 3 + 1) * 0.006,
                      dddfy = ((cy1 - cy2) * 3 + 1) * 0.006;
                  var ddfx = tmpx * 2 + dddfx,
                      ddfy = tmpy * 2 + dddfy;
                  var dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667,
                      dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;
                  var i = frameIndex * CurveTimeline.BEZIER_SIZE;
                  var curves = this.curves;
                  curves[i++] = CurveTimeline.BEZIER;
                  var x = dfx,
                      y = dfy;

                  for (var n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {
                    curves[i] = x;
                    curves[i + 1] = y;
                    dfx += ddfx;
                    dfy += ddfy;
                    ddfx += dddfx;
                    ddfy += dddfy;
                    x += dfx;
                    y += dfy;
                  }
                };

                CurveTimeline.prototype.getCurvePercent = function (frameIndex, percent) {
                  percent = spine.MathUtils.clamp(percent, 0, 1);
                  var curves = this.curves;
                  var i = frameIndex * CurveTimeline.BEZIER_SIZE;
                  var type = curves[i];
                  if (type == CurveTimeline.LINEAR) return percent;
                  if (type == CurveTimeline.STEPPED) return 0;
                  i++;
                  var x = 0;

                  for (var start = i, n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {
                    x = curves[i];

                    if (x >= percent) {
                      var prevX = void 0,
                          prevY = void 0;

                      if (i == start) {
                        prevX = 0;
                        prevY = 0;
                      } else {
                        prevX = curves[i - 2];
                        prevY = curves[i - 1];
                      }

                      return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);
                    }
                  }

                  var y = curves[i - 1];
                  return y + (1 - y) * (percent - x) / (1 - x);
                };

                CurveTimeline.LINEAR = 0;
                CurveTimeline.STEPPED = 1;
                CurveTimeline.BEZIER = 2;
                CurveTimeline.BEZIER_SIZE = 10 * 2 - 1;
                return CurveTimeline;
              }();

              spine.CurveTimeline = CurveTimeline;

              var RotateTimeline = function (_super) {
                __extends(RotateTimeline, _super);

                function RotateTimeline(frameCount) {
                  var _this = _super.call(this, frameCount) || this;

                  _this.frames = spine.Utils.newFloatArray(frameCount << 1);
                  return _this;
                }

                RotateTimeline.prototype.getPropertyId = function () {
                  return (TimelineType.rotate << 24) + this.boneIndex;
                };

                RotateTimeline.prototype.setFrame = function (frameIndex, time, degrees) {
                  frameIndex <<= 1;
                  this.frames[frameIndex] = time;
                  this.frames[frameIndex + RotateTimeline.ROTATION] = degrees;
                };

                RotateTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {
                  var frames = this.frames;
                  var bone = skeleton.bones[this.boneIndex];
                  if (!bone.active) return;

                  if (time < frames[0]) {
                    switch (blend) {
                      case MixBlend.setup:
                        bone.rotation = bone.data.rotation;
                        return;

                      case MixBlend.first:
                        var r_1 = bone.data.rotation - bone.rotation;
                        bone.rotation += (r_1 - (16384 - (16384.499999999996 - r_1 / 360 | 0)) * 360) * alpha;
                    }

                    return;
                  }

                  if (time >= frames[frames.length - RotateTimeline.ENTRIES]) {
                    var r_2 = frames[frames.length + RotateTimeline.PREV_ROTATION];

                    switch (blend) {
                      case MixBlend.setup:
                        bone.rotation = bone.data.rotation + r_2 * alpha;
                        break;

                      case MixBlend.first:
                      case MixBlend.replace:
                        r_2 += bone.data.rotation - bone.rotation;
                        r_2 -= (16384 - (16384.499999999996 - r_2 / 360 | 0)) * 360;

                      case MixBlend.add:
                        bone.rotation += r_2 * alpha;
                    }

                    return;
                  }

                  var frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);
                  var prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];
                  var frameTime = frames[frame];
                  var percent = this.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));
                  var r = frames[frame + RotateTimeline.ROTATION] - prevRotation;
                  r = prevRotation + (r - (16384 - (16384.499999999996 - r / 360 | 0)) * 360) * percent;

                  switch (blend) {
                    case MixBlend.setup:
                      bone.rotation = bone.data.rotation + (r - (16384 - (16384.499999999996 - r / 360 | 0)) * 360) * alpha;
                      break;

                    case MixBlend.first:
                    case MixBlend.replace:
                      r += bone.data.rotation - bone.rotation;

                    case MixBlend.add:
                      bone.rotation += (r - (16384 - (16384.499999999996 - r / 360 | 0)) * 360) * alpha;
                  }
                };

                RotateTimeline.ENTRIES = 2;
                RotateTimeline.PREV_TIME = -2;
                RotateTimeline.PREV_ROTATION = -1;
                RotateTimeline.ROTATION = 1;
                return RotateTimeline;
              }(CurveTimeline);

              spine.RotateTimeline = RotateTimeline;

              var TranslateTimeline = function (_super) {
                __extends(TranslateTimeline, _super);

                function TranslateTimeline(frameCount) {
                  var _this = _super.call(this, frameCount) || this;

                  _this.frames = spine.Utils.newFloatArray(frameCount * TranslateTimeline.ENTRIES);
                  return _this;
                }

                TranslateTimeline.prototype.getPropertyId = function () {
                  return (TimelineType.translate << 24) + this.boneIndex;
                };

                TranslateTimeline.prototype.setFrame = function (frameIndex, time, x, y) {
                  frameIndex *= TranslateTimeline.ENTRIES;
                  this.frames[frameIndex] = time;
                  this.frames[frameIndex + TranslateTimeline.X] = x;
                  this.frames[frameIndex + TranslateTimeline.Y] = y;
                };

                TranslateTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {
                  var frames = this.frames;
                  var bone = skeleton.bones[this.boneIndex];
                  if (!bone.active) return;

                  if (time < frames[0]) {
                    switch (blend) {
                      case MixBlend.setup:
                        bone.x = bone.data.x;
                        bone.y = bone.data.y;
                        return;

                      case MixBlend.first:
                        bone.x += (bone.data.x - bone.x) * alpha;
                        bone.y += (bone.data.y - bone.y) * alpha;
                    }

                    return;
                  }

                  var x = 0,
                      y = 0;

                  if (time >= frames[frames.length - TranslateTimeline.ENTRIES]) {
                    x = frames[frames.length + TranslateTimeline.PREV_X];
                    y = frames[frames.length + TranslateTimeline.PREV_Y];
                  } else {
                    var frame = Animation.binarySearch(frames, time, TranslateTimeline.ENTRIES);
                    x = frames[frame + TranslateTimeline.PREV_X];
                    y = frames[frame + TranslateTimeline.PREV_Y];
                    var frameTime = frames[frame];
                    var percent = this.getCurvePercent(frame / TranslateTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TranslateTimeline.PREV_TIME] - frameTime));
                    x += (frames[frame + TranslateTimeline.X] - x) * percent;
                    y += (frames[frame + TranslateTimeline.Y] - y) * percent;
                  }

                  switch (blend) {
                    case MixBlend.setup:
                      bone.x = bone.data.x + x * alpha;
                      bone.y = bone.data.y + y * alpha;
                      break;

                    case MixBlend.first:
                    case MixBlend.replace:
                      bone.x += (bone.data.x + x - bone.x) * alpha;
                      bone.y += (bone.data.y + y - bone.y) * alpha;
                      break;

                    case MixBlend.add:
                      bone.x += x * alpha;
                      bone.y += y * alpha;
                  }
                };

                TranslateTimeline.ENTRIES = 3;
                TranslateTimeline.PREV_TIME = -3;
                TranslateTimeline.PREV_X = -2;
                TranslateTimeline.PREV_Y = -1;
                TranslateTimeline.X = 1;
                TranslateTimeline.Y = 2;
                return TranslateTimeline;
              }(CurveTimeline);

              spine.TranslateTimeline = TranslateTimeline;

              var ScaleTimeline = function (_super) {
                __extends(ScaleTimeline, _super);

                function ScaleTimeline(frameCount) {
                  return _super.call(this, frameCount) || this;
                }

                ScaleTimeline.prototype.getPropertyId = function () {
                  return (TimelineType.scale << 24) + this.boneIndex;
                };

                ScaleTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {
                  var frames = this.frames;
                  var bone = skeleton.bones[this.boneIndex];
                  if (!bone.active) return;

                  if (time < frames[0]) {
                    switch (blend) {
                      case MixBlend.setup:
                        bone.scaleX = bone.data.scaleX;
                        bone.scaleY = bone.data.scaleY;
                        return;

                      case MixBlend.first:
                        bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;
                        bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;
                    }

                    return;
                  }

                  var x = 0,
                      y = 0;

                  if (time >= frames[frames.length - ScaleTimeline.ENTRIES]) {
                    x = frames[frames.length + ScaleTimeline.PREV_X] * bone.data.scaleX;
                    y = frames[frames.length + ScaleTimeline.PREV_Y] * bone.data.scaleY;
                  } else {
                    var frame = Animation.binarySearch(frames, time, ScaleTimeline.ENTRIES);
                    x = frames[frame + ScaleTimeline.PREV_X];
                    y = frames[frame + ScaleTimeline.PREV_Y];
                    var frameTime = frames[frame];
                    var percent = this.getCurvePercent(frame / ScaleTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ScaleTimeline.PREV_TIME] - frameTime));
                    x = (x + (frames[frame + ScaleTimeline.X] - x) * percent) * bone.data.scaleX;
                    y = (y + (frames[frame + ScaleTimeline.Y] - y) * percent) * bone.data.scaleY;
                  }

                  if (alpha == 1) {
                    if (blend == MixBlend.add) {
                      bone.scaleX += x - bone.data.scaleX;
                      bone.scaleY += y - bone.data.scaleY;
                    } else {
                      bone.scaleX = x;
                      bone.scaleY = y;
                    }
                  } else {
                    var bx = 0,
                        by = 0;

                    if (direction == MixDirection.mixOut) {
                      switch (blend) {
                        case MixBlend.setup:
                          bx = bone.data.scaleX;
                          by = bone.data.scaleY;
                          bone.scaleX = bx + (Math.abs(x) * spine.MathUtils.signum(bx) - bx) * alpha;
                          bone.scaleY = by + (Math.abs(y) * spine.MathUtils.signum(by) - by) * alpha;
                          break;

                        case MixBlend.first:
                        case MixBlend.replace:
                          bx = bone.scaleX;
                          by = bone.scaleY;
                          bone.scaleX = bx + (Math.abs(x) * spine.MathUtils.signum(bx) - bx) * alpha;
                          bone.scaleY = by + (Math.abs(y) * spine.MathUtils.signum(by) - by) * alpha;
                          break;

                        case MixBlend.add:
                          bx = bone.scaleX;
                          by = bone.scaleY;
                          bone.scaleX = bx + (Math.abs(x) * spine.MathUtils.signum(bx) - bone.data.scaleX) * alpha;
                          bone.scaleY = by + (Math.abs(y) * spine.MathUtils.signum(by) - bone.data.scaleY) * alpha;
                      }
                    } else {
                      switch (blend) {
                        case MixBlend.setup:
                          bx = Math.abs(bone.data.scaleX) * spine.MathUtils.signum(x);
                          by = Math.abs(bone.data.scaleY) * spine.MathUtils.signum(y);
                          bone.scaleX = bx + (x - bx) * alpha;
                          bone.scaleY = by + (y - by) * alpha;
                          break;

                        case MixBlend.first:
                        case MixBlend.replace:
                          bx = Math.abs(bone.scaleX) * spine.MathUtils.signum(x);
                          by = Math.abs(bone.scaleY) * spine.MathUtils.signum(y);
                          bone.scaleX = bx + (x - bx) * alpha;
                          bone.scaleY = by + (y - by) * alpha;
                          break;

                        case MixBlend.add:
                          bx = spine.MathUtils.signum(x);
                          by = spine.MathUtils.signum(y);
                          bone.scaleX = Math.abs(bone.scaleX) * bx + (x - Math.abs(bone.data.scaleX) * bx) * alpha;
                          bone.scaleY = Math.abs(bone.scaleY) * by + (y - Math.abs(bone.data.scaleY) * by) * alpha;
                      }
                    }
                  }
                };

                return ScaleTimeline;
              }(TranslateTimeline);

              spine.ScaleTimeline = ScaleTimeline;

              var ShearTimeline = function (_super) {
                __extends(ShearTimeline, _super);

                function ShearTimeline(frameCount) {
                  return _super.call(this, frameCount) || this;
                }

                ShearTimeline.prototype.getPropertyId = function () {
                  return (TimelineType.shear << 24) + this.boneIndex;
                };

                ShearTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {
                  var frames = this.frames;
                  var bone = skeleton.bones[this.boneIndex];
                  if (!bone.active) return;

                  if (time < frames[0]) {
                    switch (blend) {
                      case MixBlend.setup:
                        bone.shearX = bone.data.shearX;
                        bone.shearY = bone.data.shearY;
                        return;

                      case MixBlend.first:
                        bone.shearX += (bone.data.shearX - bone.shearX) * alpha;
                        bone.shearY += (bone.data.shearY - bone.shearY) * alpha;
                    }

                    return;
                  }

                  var x = 0,
                      y = 0;

                  if (time >= frames[frames.length - ShearTimeline.ENTRIES]) {
                    x = frames[frames.length + ShearTimeline.PREV_X];
                    y = frames[frames.length + ShearTimeline.PREV_Y];
                  } else {
                    var frame = Animation.binarySearch(frames, time, ShearTimeline.ENTRIES);
                    x = frames[frame + ShearTimeline.PREV_X];
                    y = frames[frame + ShearTimeline.PREV_Y];
                    var frameTime = frames[frame];
                    var percent = this.getCurvePercent(frame / ShearTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ShearTimeline.PREV_TIME] - frameTime));
                    x = x + (frames[frame + ShearTimeline.X] - x) * percent;
                    y = y + (frames[frame + ShearTimeline.Y] - y) * percent;
                  }

                  switch (blend) {
                    case MixBlend.setup:
                      bone.shearX = bone.data.shearX + x * alpha;
                      bone.shearY = bone.data.shearY + y * alpha;
                      break;

                    case MixBlend.first:
                    case MixBlend.replace:
                      bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;
                      bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;
                      break;

                    case MixBlend.add:
                      bone.shearX += x * alpha;
                      bone.shearY += y * alpha;
                  }
                };

                return ShearTimeline;
              }(TranslateTimeline);

              spine.ShearTimeline = ShearTimeline;

              var ColorTimeline = function (_super) {
                __extends(ColorTimeline, _super);

                function ColorTimeline(frameCount) {
                  var _this = _super.call(this, frameCount) || this;

                  _this.frames = spine.Utils.newFloatArray(frameCount * ColorTimeline.ENTRIES);
                  return _this;
                }

                ColorTimeline.prototype.getPropertyId = function () {
                  return (TimelineType.color << 24) + this.slotIndex;
                };

                ColorTimeline.prototype.setFrame = function (frameIndex, time, r, g, b, a) {
                  frameIndex *= ColorTimeline.ENTRIES;
                  this.frames[frameIndex] = time;
                  this.frames[frameIndex + ColorTimeline.R] = r;
                  this.frames[frameIndex + ColorTimeline.G] = g;
                  this.frames[frameIndex + ColorTimeline.B] = b;
                  this.frames[frameIndex + ColorTimeline.A] = a;
                };

                ColorTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {
                  var slot = skeleton.slots[this.slotIndex];
                  if (!slot.bone.active) return;
                  var frames = this.frames;

                  if (time < frames[0]) {
                    switch (blend) {
                      case MixBlend.setup:
                        slot.color.setFromColor(slot.data.color);
                        return;

                      case MixBlend.first:
                        var color = slot.color,
                            setup = slot.data.color;
                        color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);
                    }

                    return;
                  }

                  var r = 0,
                      g = 0,
                      b = 0,
                      a = 0;

                  if (time >= frames[frames.length - ColorTimeline.ENTRIES]) {
                    var i = frames.length;
                    r = frames[i + ColorTimeline.PREV_R];
                    g = frames[i + ColorTimeline.PREV_G];
                    b = frames[i + ColorTimeline.PREV_B];
                    a = frames[i + ColorTimeline.PREV_A];
                  } else {
                    var frame = Animation.binarySearch(frames, time, ColorTimeline.ENTRIES);
                    r = frames[frame + ColorTimeline.PREV_R];
                    g = frames[frame + ColorTimeline.PREV_G];
                    b = frames[frame + ColorTimeline.PREV_B];
                    a = frames[frame + ColorTimeline.PREV_A];
                    var frameTime = frames[frame];
                    var percent = this.getCurvePercent(frame / ColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ColorTimeline.PREV_TIME] - frameTime));
                    r += (frames[frame + ColorTimeline.R] - r) * percent;
                    g += (frames[frame + ColorTimeline.G] - g) * percent;
                    b += (frames[frame + ColorTimeline.B] - b) * percent;
                    a += (frames[frame + ColorTimeline.A] - a) * percent;
                  }

                  if (alpha == 1) slot.color.set(r, g, b, a);else {
                    var color = slot.color;
                    if (blend == MixBlend.setup) color.setFromColor(slot.data.color);
                    color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);
                  }
                };

                ColorTimeline.ENTRIES = 5;
                ColorTimeline.PREV_TIME = -5;
                ColorTimeline.PREV_R = -4;
                ColorTimeline.PREV_G = -3;
                ColorTimeline.PREV_B = -2;
                ColorTimeline.PREV_A = -1;
                ColorTimeline.R = 1;
                ColorTimeline.G = 2;
                ColorTimeline.B = 3;
                ColorTimeline.A = 4;
                return ColorTimeline;
              }(CurveTimeline);

              spine.ColorTimeline = ColorTimeline;

              var TwoColorTimeline = function (_super) {
                __extends(TwoColorTimeline, _super);

                function TwoColorTimeline(frameCount) {
                  var _this = _super.call(this, frameCount) || this;

                  _this.frames = spine.Utils.newFloatArray(frameCount * TwoColorTimeline.ENTRIES);
                  return _this;
                }

                TwoColorTimeline.prototype.getPropertyId = function () {
                  return (TimelineType.twoColor << 24) + this.slotIndex;
                };

                TwoColorTimeline.prototype.setFrame = function (frameIndex, time, r, g, b, a, r2, g2, b2) {
                  frameIndex *= TwoColorTimeline.ENTRIES;
                  this.frames[frameIndex] = time;
                  this.frames[frameIndex + TwoColorTimeline.R] = r;
                  this.frames[frameIndex + TwoColorTimeline.G] = g;
                  this.frames[frameIndex + TwoColorTimeline.B] = b;
                  this.frames[frameIndex + TwoColorTimeline.A] = a;
                  this.frames[frameIndex + TwoColorTimeline.R2] = r2;
                  this.frames[frameIndex + TwoColorTimeline.G2] = g2;
                  this.frames[frameIndex + TwoColorTimeline.B2] = b2;
                };

                TwoColorTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {
                  var slot = skeleton.slots[this.slotIndex];
                  if (!slot.bone.active) return;
                  var frames = this.frames;

                  if (time < frames[0]) {
                    switch (blend) {
                      case MixBlend.setup:
                        slot.color.setFromColor(slot.data.color);
                        slot.darkColor.setFromColor(slot.data.darkColor);
                        return;

                      case MixBlend.first:
                        var light = slot.color,
                            dark = slot.darkColor,
                            setupLight = slot.data.color,
                            setupDark = slot.data.darkColor;
                        light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);
                        dark.add((setupDark.r - dark.r) * alpha, (setupDark.g - dark.g) * alpha, (setupDark.b - dark.b) * alpha, 0);
                    }

                    return;
                  }

                  var r = 0,
                      g = 0,
                      b = 0,
                      a = 0,
                      r2 = 0,
                      g2 = 0,
                      b2 = 0;

                  if (time >= frames[frames.length - TwoColorTimeline.ENTRIES]) {
                    var i = frames.length;
                    r = frames[i + TwoColorTimeline.PREV_R];
                    g = frames[i + TwoColorTimeline.PREV_G];
                    b = frames[i + TwoColorTimeline.PREV_B];
                    a = frames[i + TwoColorTimeline.PREV_A];
                    r2 = frames[i + TwoColorTimeline.PREV_R2];
                    g2 = frames[i + TwoColorTimeline.PREV_G2];
                    b2 = frames[i + TwoColorTimeline.PREV_B2];
                  } else {
                    var frame = Animation.binarySearch(frames, time, TwoColorTimeline.ENTRIES);
                    r = frames[frame + TwoColorTimeline.PREV_R];
                    g = frames[frame + TwoColorTimeline.PREV_G];
                    b = frames[frame + TwoColorTimeline.PREV_B];
                    a = frames[frame + TwoColorTimeline.PREV_A];
                    r2 = frames[frame + TwoColorTimeline.PREV_R2];
                    g2 = frames[frame + TwoColorTimeline.PREV_G2];
                    b2 = frames[frame + TwoColorTimeline.PREV_B2];
                    var frameTime = frames[frame];
                    var percent = this.getCurvePercent(frame / TwoColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TwoColorTimeline.PREV_TIME] - frameTime));
                    r += (frames[frame + TwoColorTimeline.R] - r) * percent;
                    g += (frames[frame + TwoColorTimeline.G] - g) * percent;
                    b += (frames[frame + TwoColorTimeline.B] - b) * percent;
                    a += (frames[frame + TwoColorTimeline.A] - a) * percent;
                    r2 += (frames[frame + TwoColorTimeline.R2] - r2) * percent;
                    g2 += (frames[frame + TwoColorTimeline.G2] - g2) * percent;
                    b2 += (frames[frame + TwoColorTimeline.B2] - b2) * percent;
                  }

                  if (alpha == 1) {
                    slot.color.set(r, g, b, a);
                    slot.darkColor.set(r2, g2, b2, 1);
                  } else {
                    var light = slot.color,
                        dark = slot.darkColor;

                    if (blend == MixBlend.setup) {
                      light.setFromColor(slot.data.color);
                      dark.setFromColor(slot.data.darkColor);
                    }

                    light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);
                    dark.add((r2 - dark.r) * alpha, (g2 - dark.g) * alpha, (b2 - dark.b) * alpha, 0);
                  }
                };

                TwoColorTimeline.ENTRIES = 8;
                TwoColorTimeline.PREV_TIME = -8;
                TwoColorTimeline.PREV_R = -7;
                TwoColorTimeline.PREV_G = -6;
                TwoColorTimeline.PREV_B = -5;
                TwoColorTimeline.PREV_A = -4;
                TwoColorTimeline.PREV_R2 = -3;
                TwoColorTimeline.PREV_G2 = -2;
                TwoColorTimeline.PREV_B2 = -1;
                TwoColorTimeline.R = 1;
                TwoColorTimeline.G = 2;
                TwoColorTimeline.B = 3;
                TwoColorTimeline.A = 4;
                TwoColorTimeline.R2 = 5;
                TwoColorTimeline.G2 = 6;
                TwoColorTimeline.B2 = 7;
                return TwoColorTimeline;
              }(CurveTimeline);

              spine.TwoColorTimeline = TwoColorTimeline;

              var AttachmentTimeline = function () {
                function AttachmentTimeline(frameCount) {
                  this.frames = spine.Utils.newFloatArray(frameCount);
                  this.attachmentNames = new Array(frameCount);
                }

                AttachmentTimeline.prototype.getPropertyId = function () {
                  return (TimelineType.attachment << 24) + this.slotIndex;
                };

                AttachmentTimeline.prototype.getFrameCount = function () {
                  return this.frames.length;
                };

                AttachmentTimeline.prototype.setFrame = function (frameIndex, time, attachmentName) {
                  this.frames[frameIndex] = time;
                  this.attachmentNames[frameIndex] = attachmentName;
                };

                AttachmentTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {
                  var slot = skeleton.slots[this.slotIndex];
                  if (!slot.bone.active) return;

                  if (direction == MixDirection.mixOut && blend == MixBlend.setup) {
                    var attachmentName_1 = slot.data.attachmentName;
                    slot.setAttachment(attachmentName_1 == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName_1));
                    return;
                  }

                  var frames = this.frames;

                  if (time < frames[0]) {
                    if (blend == MixBlend.setup || blend == MixBlend.first) {
                      var attachmentName_2 = slot.data.attachmentName;
                      slot.setAttachment(attachmentName_2 == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName_2));
                    }

                    return;
                  }

                  var frameIndex = 0;
                  if (time >= frames[frames.length - 1]) frameIndex = frames.length - 1;else frameIndex = Animation.binarySearch(frames, time, 1) - 1;
                  var attachmentName = this.attachmentNames[frameIndex];
                  skeleton.slots[this.slotIndex].setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));
                };

                return AttachmentTimeline;
              }();

              spine.AttachmentTimeline = AttachmentTimeline;
              var zeros = null;

              var DeformTimeline = function (_super) {
                __extends(DeformTimeline, _super);

                function DeformTimeline(frameCount) {
                  var _this = _super.call(this, frameCount) || this;

                  _this.frames = spine.Utils.newFloatArray(frameCount);
                  _this.frameVertices = new Array(frameCount);
                  if (zeros == null) zeros = spine.Utils.newFloatArray(64);
                  return _this;
                }

                DeformTimeline.prototype.getPropertyId = function () {
                  return (TimelineType.deform << 27) + +this.attachment.id + this.slotIndex;
                };

                DeformTimeline.prototype.setFrame = function (frameIndex, time, vertices) {
                  this.frames[frameIndex] = time;
                  this.frameVertices[frameIndex] = vertices;
                };

                DeformTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
                  var slot = skeleton.slots[this.slotIndex];
                  if (!slot.bone.active) return;
                  var slotAttachment = slot.getAttachment();
                  if (!(slotAttachment instanceof spine.VertexAttachment) || !(slotAttachment.deformAttachment == this.attachment)) return;
                  var deformArray = slot.deform;
                  if (deformArray.length == 0) blend = MixBlend.setup;
                  var frameVertices = this.frameVertices;
                  var vertexCount = frameVertices[0].length;
                  var frames = this.frames;

                  if (time < frames[0]) {
                    var vertexAttachment = slotAttachment;

                    switch (blend) {
                      case MixBlend.setup:
                        deformArray.length = 0;
                        return;

                      case MixBlend.first:
                        if (alpha == 1) {
                          deformArray.length = 0;
                          break;
                        }

                        var deform_1 = spine.Utils.setArraySize(deformArray, vertexCount);

                        if (vertexAttachment.bones == null) {
                          var setupVertices = vertexAttachment.vertices;

                          for (var i = 0; i < vertexCount; i++) deform_1[i] += (setupVertices[i] - deform_1[i]) * alpha;
                        } else {
                          alpha = 1 - alpha;

                          for (var i = 0; i < vertexCount; i++) deform_1[i] *= alpha;
                        }

                    }

                    return;
                  }

                  var deform = spine.Utils.setArraySize(deformArray, vertexCount);

                  if (time >= frames[frames.length - 1]) {
                    var lastVertices = frameVertices[frames.length - 1];

                    if (alpha == 1) {
                      if (blend == MixBlend.add) {
                        var vertexAttachment = slotAttachment;

                        if (vertexAttachment.bones == null) {
                          var setupVertices = vertexAttachment.vertices;

                          for (var i_1 = 0; i_1 < vertexCount; i_1++) {
                            deform[i_1] += lastVertices[i_1] - setupVertices[i_1];
                          }
                        } else {
                          for (var i_2 = 0; i_2 < vertexCount; i_2++) deform[i_2] += lastVertices[i_2];
                        }
                      } else {
                        spine.Utils.arrayCopy(lastVertices, 0, deform, 0, vertexCount);
                      }
                    } else {
                      switch (blend) {
                        case MixBlend.setup:
                          {
                            var vertexAttachment_1 = slotAttachment;

                            if (vertexAttachment_1.bones == null) {
                              var setupVertices = vertexAttachment_1.vertices;

                              for (var i_3 = 0; i_3 < vertexCount; i_3++) {
                                var setup = setupVertices[i_3];
                                deform[i_3] = setup + (lastVertices[i_3] - setup) * alpha;
                              }
                            } else {
                              for (var i_4 = 0; i_4 < vertexCount; i_4++) deform[i_4] = lastVertices[i_4] * alpha;
                            }

                            break;
                          }

                        case MixBlend.first:
                        case MixBlend.replace:
                          for (var i_5 = 0; i_5 < vertexCount; i_5++) deform[i_5] += (lastVertices[i_5] - deform[i_5]) * alpha;

                        case MixBlend.add:
                          var vertexAttachment = slotAttachment;

                          if (vertexAttachment.bones == null) {
                            var setupVertices = vertexAttachment.vertices;

                            for (var i_6 = 0; i_6 < vertexCount; i_6++) {
                              deform[i_6] += (lastVertices[i_6] - setupVertices[i_6]) * alpha;
                            }
                          } else {
                            for (var i_7 = 0; i_7 < vertexCount; i_7++) deform[i_7] += lastVertices[i_7] * alpha;
                          }

                      }
                    }

                    return;
                  }

                  var frame = Animation.binarySearch(frames, time);
                  var prevVertices = frameVertices[frame - 1];
                  var nextVertices = frameVertices[frame];
                  var frameTime = frames[frame];
                  var percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));

                  if (alpha == 1) {
                    if (blend == MixBlend.add) {
                      var vertexAttachment = slotAttachment;

                      if (vertexAttachment.bones == null) {
                        var setupVertices = vertexAttachment.vertices;

                        for (var i_8 = 0; i_8 < vertexCount; i_8++) {
                          var prev = prevVertices[i_8];
                          deform[i_8] += prev + (nextVertices[i_8] - prev) * percent - setupVertices[i_8];
                        }
                      } else {
                        for (var i_9 = 0; i_9 < vertexCount; i_9++) {
                          var prev = prevVertices[i_9];
                          deform[i_9] += prev + (nextVertices[i_9] - prev) * percent;
                        }
                      }
                    } else {
                      for (var i_10 = 0; i_10 < vertexCount; i_10++) {
                        var prev = prevVertices[i_10];
                        deform[i_10] = prev + (nextVertices[i_10] - prev) * percent;
                      }
                    }
                  } else {
                    switch (blend) {
                      case MixBlend.setup:
                        {
                          var vertexAttachment_2 = slotAttachment;

                          if (vertexAttachment_2.bones == null) {
                            var setupVertices = vertexAttachment_2.vertices;

                            for (var i_11 = 0; i_11 < vertexCount; i_11++) {
                              var prev = prevVertices[i_11],
                                  setup = setupVertices[i_11];
                              deform[i_11] = setup + (prev + (nextVertices[i_11] - prev) * percent - setup) * alpha;
                            }
                          } else {
                            for (var i_12 = 0; i_12 < vertexCount; i_12++) {
                              var prev = prevVertices[i_12];
                              deform[i_12] = (prev + (nextVertices[i_12] - prev) * percent) * alpha;
                            }
                          }

                          break;
                        }

                      case MixBlend.first:
                      case MixBlend.replace:
                        for (var i_13 = 0; i_13 < vertexCount; i_13++) {
                          var prev = prevVertices[i_13];
                          deform[i_13] += (prev + (nextVertices[i_13] - prev) * percent - deform[i_13]) * alpha;
                        }

                        break;

                      case MixBlend.add:
                        var vertexAttachment = slotAttachment;

                        if (vertexAttachment.bones == null) {
                          var setupVertices = vertexAttachment.vertices;

                          for (var i_14 = 0; i_14 < vertexCount; i_14++) {
                            var prev = prevVertices[i_14];
                            deform[i_14] += (prev + (nextVertices[i_14] - prev) * percent - setupVertices[i_14]) * alpha;
                          }
                        } else {
                          for (var i_15 = 0; i_15 < vertexCount; i_15++) {
                            var prev = prevVertices[i_15];
                            deform[i_15] += (prev + (nextVertices[i_15] - prev) * percent) * alpha;
                          }
                        }

                    }
                  }
                };

                return DeformTimeline;
              }(CurveTimeline);

              spine.DeformTimeline = DeformTimeline;

              var EventTimeline = function () {
                function EventTimeline(frameCount) {
                  this.frames = spine.Utils.newFloatArray(frameCount);
                  this.events = new Array(frameCount);
                }

                EventTimeline.prototype.getPropertyId = function () {
                  return TimelineType.event << 24;
                };

                EventTimeline.prototype.getFrameCount = function () {
                  return this.frames.length;
                };

                EventTimeline.prototype.setFrame = function (frameIndex, event) {
                  this.frames[frameIndex] = event.time;
                  this.events[frameIndex] = event;
                };

                EventTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
                  if (firedEvents == null) return;
                  var frames = this.frames;
                  var frameCount = this.frames.length;

                  if (lastTime > time) {
                    this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);
                    lastTime = -1;
                  } else if (lastTime >= frames[frameCount - 1]) return;

                  if (time < frames[0]) return;
                  var frame = 0;
                  if (lastTime < frames[0]) frame = 0;else {
                    frame = Animation.binarySearch(frames, lastTime);
                    var frameTime = frames[frame];

                    while (frame > 0) {
                      if (frames[frame - 1] != frameTime) break;
                      frame--;
                    }
                  }

                  for (; frame < frameCount && time >= frames[frame]; frame++) firedEvents.push(this.events[frame]);
                };

                return EventTimeline;
              }();

              spine.EventTimeline = EventTimeline;

              var DrawOrderTimeline = function () {
                function DrawOrderTimeline(frameCount) {
                  this.frames = spine.Utils.newFloatArray(frameCount);
                  this.drawOrders = new Array(frameCount);
                }

                DrawOrderTimeline.prototype.getPropertyId = function () {
                  return TimelineType.drawOrder << 24;
                };

                DrawOrderTimeline.prototype.getFrameCount = function () {
                  return this.frames.length;
                };

                DrawOrderTimeline.prototype.setFrame = function (frameIndex, time, drawOrder) {
                  this.frames[frameIndex] = time;
                  this.drawOrders[frameIndex] = drawOrder;
                };

                DrawOrderTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
                  var drawOrder = skeleton.drawOrder;
                  var slots = skeleton.slots;

                  if (direction == MixDirection.mixOut && blend == MixBlend.setup) {
                    spine.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
                    return;
                  }

                  var frames = this.frames;

                  if (time < frames[0]) {
                    if (blend == MixBlend.setup || blend == MixBlend.first) spine.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
                    return;
                  }

                  var frame = 0;
                  if (time >= frames[frames.length - 1]) frame = frames.length - 1;else frame = Animation.binarySearch(frames, time) - 1;
                  var drawOrderToSetupIndex = this.drawOrders[frame];
                  if (drawOrderToSetupIndex == null) spine.Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);else {
                    for (var i = 0, n = drawOrderToSetupIndex.length; i < n; i++) drawOrder[i] = slots[drawOrderToSetupIndex[i]];
                  }
                };

                return DrawOrderTimeline;
              }();

              spine.DrawOrderTimeline = DrawOrderTimeline;

              var IkConstraintTimeline = function (_super) {
                __extends(IkConstraintTimeline, _super);

                function IkConstraintTimeline(frameCount) {
                  var _this = _super.call(this, frameCount) || this;

                  _this.frames = spine.Utils.newFloatArray(frameCount * IkConstraintTimeline.ENTRIES);
                  return _this;
                }

                IkConstraintTimeline.prototype.getPropertyId = function () {
                  return (TimelineType.ikConstraint << 24) + this.ikConstraintIndex;
                };

                IkConstraintTimeline.prototype.setFrame = function (frameIndex, time, mix, softness, bendDirection, compress, stretch) {
                  frameIndex *= IkConstraintTimeline.ENTRIES;
                  this.frames[frameIndex] = time;
                  this.frames[frameIndex + IkConstraintTimeline.MIX] = mix;
                  this.frames[frameIndex + IkConstraintTimeline.SOFTNESS] = softness;
                  this.frames[frameIndex + IkConstraintTimeline.BEND_DIRECTION] = bendDirection;
                  this.frames[frameIndex + IkConstraintTimeline.COMPRESS] = compress ? 1 : 0;
                  this.frames[frameIndex + IkConstraintTimeline.STRETCH] = stretch ? 1 : 0;
                };

                IkConstraintTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
                  var frames = this.frames;
                  var constraint = skeleton.ikConstraints[this.ikConstraintIndex];
                  if (!constraint.active) return;

                  if (time < frames[0]) {
                    switch (blend) {
                      case MixBlend.setup:
                        constraint.mix = constraint.data.mix;
                        constraint.softness = constraint.data.softness;
                        constraint.bendDirection = constraint.data.bendDirection;
                        constraint.compress = constraint.data.compress;
                        constraint.stretch = constraint.data.stretch;
                        return;

                      case MixBlend.first:
                        constraint.mix += (constraint.data.mix - constraint.mix) * alpha;
                        constraint.softness += (constraint.data.softness - constraint.softness) * alpha;
                        constraint.bendDirection = constraint.data.bendDirection;
                        constraint.compress = constraint.data.compress;
                        constraint.stretch = constraint.data.stretch;
                    }

                    return;
                  }

                  if (time >= frames[frames.length - IkConstraintTimeline.ENTRIES]) {
                    if (blend == MixBlend.setup) {
                      constraint.mix = constraint.data.mix + (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.data.mix) * alpha;
                      constraint.softness = constraint.data.softness + (frames[frames.length + IkConstraintTimeline.PREV_SOFTNESS] - constraint.data.softness) * alpha;

                      if (direction == MixDirection.mixOut) {
                        constraint.bendDirection = constraint.data.bendDirection;
                        constraint.compress = constraint.data.compress;
                        constraint.stretch = constraint.data.stretch;
                      } else {
                        constraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];
                        constraint.compress = frames[frames.length + IkConstraintTimeline.PREV_COMPRESS] != 0;
                        constraint.stretch = frames[frames.length + IkConstraintTimeline.PREV_STRETCH] != 0;
                      }
                    } else {
                      constraint.mix += (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.mix) * alpha;
                      constraint.softness += (frames[frames.length + IkConstraintTimeline.PREV_SOFTNESS] - constraint.softness) * alpha;

                      if (direction == MixDirection.mixIn) {
                        constraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];
                        constraint.compress = frames[frames.length + IkConstraintTimeline.PREV_COMPRESS] != 0;
                        constraint.stretch = frames[frames.length + IkConstraintTimeline.PREV_STRETCH] != 0;
                      }
                    }

                    return;
                  }

                  var frame = Animation.binarySearch(frames, time, IkConstraintTimeline.ENTRIES);
                  var mix = frames[frame + IkConstraintTimeline.PREV_MIX];
                  var softness = frames[frame + IkConstraintTimeline.PREV_SOFTNESS];
                  var frameTime = frames[frame];
                  var percent = this.getCurvePercent(frame / IkConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + IkConstraintTimeline.PREV_TIME] - frameTime));

                  if (blend == MixBlend.setup) {
                    constraint.mix = constraint.data.mix + (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.data.mix) * alpha;
                    constraint.softness = constraint.data.softness + (softness + (frames[frame + IkConstraintTimeline.SOFTNESS] - softness) * percent - constraint.data.softness) * alpha;

                    if (direction == MixDirection.mixOut) {
                      constraint.bendDirection = constraint.data.bendDirection;
                      constraint.compress = constraint.data.compress;
                      constraint.stretch = constraint.data.stretch;
                    } else {
                      constraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];
                      constraint.compress = frames[frame + IkConstraintTimeline.PREV_COMPRESS] != 0;
                      constraint.stretch = frames[frame + IkConstraintTimeline.PREV_STRETCH] != 0;
                    }
                  } else {
                    constraint.mix += (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.mix) * alpha;
                    constraint.softness += (softness + (frames[frame + IkConstraintTimeline.SOFTNESS] - softness) * percent - constraint.softness) * alpha;

                    if (direction == MixDirection.mixIn) {
                      constraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];
                      constraint.compress = frames[frame + IkConstraintTimeline.PREV_COMPRESS] != 0;
                      constraint.stretch = frames[frame + IkConstraintTimeline.PREV_STRETCH] != 0;
                    }
                  }
                };

                IkConstraintTimeline.ENTRIES = 6;
                IkConstraintTimeline.PREV_TIME = -6;
                IkConstraintTimeline.PREV_MIX = -5;
                IkConstraintTimeline.PREV_SOFTNESS = -4;
                IkConstraintTimeline.PREV_BEND_DIRECTION = -3;
                IkConstraintTimeline.PREV_COMPRESS = -2;
                IkConstraintTimeline.PREV_STRETCH = -1;
                IkConstraintTimeline.MIX = 1;
                IkConstraintTimeline.SOFTNESS = 2;
                IkConstraintTimeline.BEND_DIRECTION = 3;
                IkConstraintTimeline.COMPRESS = 4;
                IkConstraintTimeline.STRETCH = 5;
                return IkConstraintTimeline;
              }(CurveTimeline);

              spine.IkConstraintTimeline = IkConstraintTimeline;

              var TransformConstraintTimeline = function (_super) {
                __extends(TransformConstraintTimeline, _super);

                function TransformConstraintTimeline(frameCount) {
                  var _this = _super.call(this, frameCount) || this;

                  _this.frames = spine.Utils.newFloatArray(frameCount * TransformConstraintTimeline.ENTRIES);
                  return _this;
                }

                TransformConstraintTimeline.prototype.getPropertyId = function () {
                  return (TimelineType.transformConstraint << 24) + this.transformConstraintIndex;
                };

                TransformConstraintTimeline.prototype.setFrame = function (frameIndex, time, rotateMix, translateMix, scaleMix, shearMix) {
                  frameIndex *= TransformConstraintTimeline.ENTRIES;
                  this.frames[frameIndex] = time;
                  this.frames[frameIndex + TransformConstraintTimeline.ROTATE] = rotateMix;
                  this.frames[frameIndex + TransformConstraintTimeline.TRANSLATE] = translateMix;
                  this.frames[frameIndex + TransformConstraintTimeline.SCALE] = scaleMix;
                  this.frames[frameIndex + TransformConstraintTimeline.SHEAR] = shearMix;
                };

                TransformConstraintTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
                  var frames = this.frames;
                  var constraint = skeleton.transformConstraints[this.transformConstraintIndex];
                  if (!constraint.active) return;

                  if (time < frames[0]) {
                    var data = constraint.data;

                    switch (blend) {
                      case MixBlend.setup:
                        constraint.rotateMix = data.rotateMix;
                        constraint.translateMix = data.translateMix;
                        constraint.scaleMix = data.scaleMix;
                        constraint.shearMix = data.shearMix;
                        return;

                      case MixBlend.first:
                        constraint.rotateMix += (data.rotateMix - constraint.rotateMix) * alpha;
                        constraint.translateMix += (data.translateMix - constraint.translateMix) * alpha;
                        constraint.scaleMix += (data.scaleMix - constraint.scaleMix) * alpha;
                        constraint.shearMix += (data.shearMix - constraint.shearMix) * alpha;
                    }

                    return;
                  }

                  var rotate = 0,
                      translate = 0,
                      scale = 0,
                      shear = 0;

                  if (time >= frames[frames.length - TransformConstraintTimeline.ENTRIES]) {
                    var i = frames.length;
                    rotate = frames[i + TransformConstraintTimeline.PREV_ROTATE];
                    translate = frames[i + TransformConstraintTimeline.PREV_TRANSLATE];
                    scale = frames[i + TransformConstraintTimeline.PREV_SCALE];
                    shear = frames[i + TransformConstraintTimeline.PREV_SHEAR];
                  } else {
                    var frame = Animation.binarySearch(frames, time, TransformConstraintTimeline.ENTRIES);
                    rotate = frames[frame + TransformConstraintTimeline.PREV_ROTATE];
                    translate = frames[frame + TransformConstraintTimeline.PREV_TRANSLATE];
                    scale = frames[frame + TransformConstraintTimeline.PREV_SCALE];
                    shear = frames[frame + TransformConstraintTimeline.PREV_SHEAR];
                    var frameTime = frames[frame];
                    var percent = this.getCurvePercent(frame / TransformConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TransformConstraintTimeline.PREV_TIME] - frameTime));
                    rotate += (frames[frame + TransformConstraintTimeline.ROTATE] - rotate) * percent;
                    translate += (frames[frame + TransformConstraintTimeline.TRANSLATE] - translate) * percent;
                    scale += (frames[frame + TransformConstraintTimeline.SCALE] - scale) * percent;
                    shear += (frames[frame + TransformConstraintTimeline.SHEAR] - shear) * percent;
                  }

                  if (blend == MixBlend.setup) {
                    var data = constraint.data;
                    constraint.rotateMix = data.rotateMix + (rotate - data.rotateMix) * alpha;
                    constraint.translateMix = data.translateMix + (translate - data.translateMix) * alpha;
                    constraint.scaleMix = data.scaleMix + (scale - data.scaleMix) * alpha;
                    constraint.shearMix = data.shearMix + (shear - data.shearMix) * alpha;
                  } else {
                    constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;
                    constraint.translateMix += (translate - constraint.translateMix) * alpha;
                    constraint.scaleMix += (scale - constraint.scaleMix) * alpha;
                    constraint.shearMix += (shear - constraint.shearMix) * alpha;
                  }
                };

                TransformConstraintTimeline.ENTRIES = 5;
                TransformConstraintTimeline.PREV_TIME = -5;
                TransformConstraintTimeline.PREV_ROTATE = -4;
                TransformConstraintTimeline.PREV_TRANSLATE = -3;
                TransformConstraintTimeline.PREV_SCALE = -2;
                TransformConstraintTimeline.PREV_SHEAR = -1;
                TransformConstraintTimeline.ROTATE = 1;
                TransformConstraintTimeline.TRANSLATE = 2;
                TransformConstraintTimeline.SCALE = 3;
                TransformConstraintTimeline.SHEAR = 4;
                return TransformConstraintTimeline;
              }(CurveTimeline);

              spine.TransformConstraintTimeline = TransformConstraintTimeline;

              var PathConstraintPositionTimeline = function (_super) {
                __extends(PathConstraintPositionTimeline, _super);

                function PathConstraintPositionTimeline(frameCount) {
                  var _this = _super.call(this, frameCount) || this;

                  _this.frames = spine.Utils.newFloatArray(frameCount * PathConstraintPositionTimeline.ENTRIES);
                  return _this;
                }

                PathConstraintPositionTimeline.prototype.getPropertyId = function () {
                  return (TimelineType.pathConstraintPosition << 24) + this.pathConstraintIndex;
                };

                PathConstraintPositionTimeline.prototype.setFrame = function (frameIndex, time, value) {
                  frameIndex *= PathConstraintPositionTimeline.ENTRIES;
                  this.frames[frameIndex] = time;
                  this.frames[frameIndex + PathConstraintPositionTimeline.VALUE] = value;
                };

                PathConstraintPositionTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
                  var frames = this.frames;
                  var constraint = skeleton.pathConstraints[this.pathConstraintIndex];
                  if (!constraint.active) return;

                  if (time < frames[0]) {
                    switch (blend) {
                      case MixBlend.setup:
                        constraint.position = constraint.data.position;
                        return;

                      case MixBlend.first:
                        constraint.position += (constraint.data.position - constraint.position) * alpha;
                    }

                    return;
                  }

                  var position = 0;
                  if (time >= frames[frames.length - PathConstraintPositionTimeline.ENTRIES]) position = frames[frames.length + PathConstraintPositionTimeline.PREV_VALUE];else {
                    var frame = Animation.binarySearch(frames, time, PathConstraintPositionTimeline.ENTRIES);
                    position = frames[frame + PathConstraintPositionTimeline.PREV_VALUE];
                    var frameTime = frames[frame];
                    var percent = this.getCurvePercent(frame / PathConstraintPositionTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintPositionTimeline.PREV_TIME] - frameTime));
                    position += (frames[frame + PathConstraintPositionTimeline.VALUE] - position) * percent;
                  }
                  if (blend == MixBlend.setup) constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;else constraint.position += (position - constraint.position) * alpha;
                };

                PathConstraintPositionTimeline.ENTRIES = 2;
                PathConstraintPositionTimeline.PREV_TIME = -2;
                PathConstraintPositionTimeline.PREV_VALUE = -1;
                PathConstraintPositionTimeline.VALUE = 1;
                return PathConstraintPositionTimeline;
              }(CurveTimeline);

              spine.PathConstraintPositionTimeline = PathConstraintPositionTimeline;

              var PathConstraintSpacingTimeline = function (_super) {
                __extends(PathConstraintSpacingTimeline, _super);

                function PathConstraintSpacingTimeline(frameCount) {
                  return _super.call(this, frameCount) || this;
                }

                PathConstraintSpacingTimeline.prototype.getPropertyId = function () {
                  return (TimelineType.pathConstraintSpacing << 24) + this.pathConstraintIndex;
                };

                PathConstraintSpacingTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
                  var frames = this.frames;
                  var constraint = skeleton.pathConstraints[this.pathConstraintIndex];
                  if (!constraint.active) return;

                  if (time < frames[0]) {
                    switch (blend) {
                      case MixBlend.setup:
                        constraint.spacing = constraint.data.spacing;
                        return;

                      case MixBlend.first:
                        constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;
                    }

                    return;
                  }

                  var spacing = 0;
                  if (time >= frames[frames.length - PathConstraintSpacingTimeline.ENTRIES]) spacing = frames[frames.length + PathConstraintSpacingTimeline.PREV_VALUE];else {
                    var frame = Animation.binarySearch(frames, time, PathConstraintSpacingTimeline.ENTRIES);
                    spacing = frames[frame + PathConstraintSpacingTimeline.PREV_VALUE];
                    var frameTime = frames[frame];
                    var percent = this.getCurvePercent(frame / PathConstraintSpacingTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline.PREV_TIME] - frameTime));
                    spacing += (frames[frame + PathConstraintSpacingTimeline.VALUE] - spacing) * percent;
                  }
                  if (blend == MixBlend.setup) constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;else constraint.spacing += (spacing - constraint.spacing) * alpha;
                };

                return PathConstraintSpacingTimeline;
              }(PathConstraintPositionTimeline);

              spine.PathConstraintSpacingTimeline = PathConstraintSpacingTimeline;

              var PathConstraintMixTimeline = function (_super) {
                __extends(PathConstraintMixTimeline, _super);

                function PathConstraintMixTimeline(frameCount) {
                  var _this = _super.call(this, frameCount) || this;

                  _this.frames = spine.Utils.newFloatArray(frameCount * PathConstraintMixTimeline.ENTRIES);
                  return _this;
                }

                PathConstraintMixTimeline.prototype.getPropertyId = function () {
                  return (TimelineType.pathConstraintMix << 24) + this.pathConstraintIndex;
                };

                PathConstraintMixTimeline.prototype.setFrame = function (frameIndex, time, rotateMix, translateMix) {
                  frameIndex *= PathConstraintMixTimeline.ENTRIES;
                  this.frames[frameIndex] = time;
                  this.frames[frameIndex + PathConstraintMixTimeline.ROTATE] = rotateMix;
                  this.frames[frameIndex + PathConstraintMixTimeline.TRANSLATE] = translateMix;
                };

                PathConstraintMixTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {
                  var frames = this.frames;
                  var constraint = skeleton.pathConstraints[this.pathConstraintIndex];
                  if (!constraint.active) return;

                  if (time < frames[0]) {
                    switch (blend) {
                      case MixBlend.setup:
                        constraint.rotateMix = constraint.data.rotateMix;
                        constraint.translateMix = constraint.data.translateMix;
                        return;

                      case MixBlend.first:
                        constraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha;
                        constraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha;
                    }

                    return;
                  }

                  var rotate = 0,
                      translate = 0;

                  if (time >= frames[frames.length - PathConstraintMixTimeline.ENTRIES]) {
                    rotate = frames[frames.length + PathConstraintMixTimeline.PREV_ROTATE];
                    translate = frames[frames.length + PathConstraintMixTimeline.PREV_TRANSLATE];
                  } else {
                    var frame = Animation.binarySearch(frames, time, PathConstraintMixTimeline.ENTRIES);
                    rotate = frames[frame + PathConstraintMixTimeline.PREV_ROTATE];
                    translate = frames[frame + PathConstraintMixTimeline.PREV_TRANSLATE];
                    var frameTime = frames[frame];
                    var percent = this.getCurvePercent(frame / PathConstraintMixTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintMixTimeline.PREV_TIME] - frameTime));
                    rotate += (frames[frame + PathConstraintMixTimeline.ROTATE] - rotate) * percent;
                    translate += (frames[frame + PathConstraintMixTimeline.TRANSLATE] - translate) * percent;
                  }

                  if (blend == MixBlend.setup) {
                    constraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha;
                    constraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha;
                  } else {
                    constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;
                    constraint.translateMix += (translate - constraint.translateMix) * alpha;
                  }
                };

                PathConstraintMixTimeline.ENTRIES = 3;
                PathConstraintMixTimeline.PREV_TIME = -3;
                PathConstraintMixTimeline.PREV_ROTATE = -2;
                PathConstraintMixTimeline.PREV_TRANSLATE = -1;
                PathConstraintMixTimeline.ROTATE = 1;
                PathConstraintMixTimeline.TRANSLATE = 2;
                return PathConstraintMixTimeline;
              }(CurveTimeline);

              spine.PathConstraintMixTimeline = PathConstraintMixTimeline;
            })(spine || (spine = {}));

            var spine;

            (function (spine) {
              var AnimationState = function () {
                function AnimationState(data) {
                  this.tracks = new Array();
                  this.timeScale = 1;
                  this.events = new Array();
                  this.listeners = new Array();
                  this.queue = new EventQueue(this);
                  this.propertyIDs = new spine.IntSet();
                  this.animationsChanged = false;
                  this.trackEntryPool = new spine.Pool(function () {
                    return new TrackEntry();
                  });
                  this.data = data;
                }

                AnimationState.prototype.update = function (delta) {
                  delta *= this.timeScale;
                  var tracks = this.tracks;

                  for (var i = 0, n = tracks.length; i < n; i++) {
                    var current = tracks[i];
                    if (current == null) continue;
                    current.animationLast = current.nextAnimationLast;
                    current.trackLast = current.nextTrackLast;
                    var currentDelta = delta * current.timeScale;

                    if (current.delay > 0) {
                      current.delay -= currentDelta;
                      if (current.delay > 0) continue;
                      currentDelta = -current.delay;
                      current.delay = 0;
                    }

                    var next = current.next;

                    if (next != null) {
                      var nextTime = current.trackLast - next.delay;

                      if (nextTime >= 0) {
                        next.delay = 0;
                        next.trackTime += current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;
                        current.trackTime += currentDelta;
                        this.setCurrent(i, next, true);

                        while (next.mixingFrom != null) {
                          next.mixTime += delta;
                          next = next.mixingFrom;
                        }

                        continue;
                      }
                    } else if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {
                      tracks[i] = null;
                      this.queue.end(current);
                      this.disposeNext(current);
                      continue;
                    }

                    if (current.mixingFrom != null && this.updateMixingFrom(current, delta)) {
                      var from = current.mixingFrom;
                      current.mixingFrom = null;
                      if (from != null) from.mixingTo = null;

                      while (from != null) {
                        this.queue.end(from);
                        from = from.mixingFrom;
                      }
                    }

                    current.trackTime += currentDelta;
                  }

                  this.queue.drain();
                };

                AnimationState.prototype.updateMixingFrom = function (to, delta) {
                  var from = to.mixingFrom;
                  if (from == null) return true;
                  var finished = this.updateMixingFrom(from, delta);
                  from.animationLast = from.nextAnimationLast;
                  from.trackLast = from.nextTrackLast;

                  if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {
                    if (from.totalAlpha == 0 || to.mixDuration == 0) {
                      to.mixingFrom = from.mixingFrom;
                      if (from.mixingFrom != null) from.mixingFrom.mixingTo = to;
                      to.interruptAlpha = from.interruptAlpha;
                      this.queue.end(from);
                    }

                    return finished;
                  }

                  from.trackTime += delta * from.timeScale;
                  to.mixTime += delta;
                  return false;
                };

                AnimationState.prototype.apply = function (skeleton) {
                  if (skeleton == null) throw new Error("skeleton cannot be null.");
                  if (this.animationsChanged) this._animationsChanged();
                  var events = this.events;
                  var tracks = this.tracks;
                  var applied = false;

                  for (var i = 0, n = tracks.length; i < n; i++) {
                    var current = tracks[i];
                    if (current == null || current.delay > 0) continue;
                    applied = true;
                    var blend = i == 0 ? spine.MixBlend.first : current.mixBlend;
                    var mix = current.alpha;
                    if (current.mixingFrom != null) mix *= this.applyMixingFrom(current, skeleton, blend);else if (current.trackTime >= current.trackEnd && current.next == null) mix = 0;
                    var animationLast = current.animationLast,
                        animationTime = current.getAnimationTime();
                    var timelineCount = current.animation.timelines.length;
                    var timelines = current.animation.timelines;

                    if (i == 0 && mix == 1 || blend == spine.MixBlend.add) {
                      for (var ii = 0; ii < timelineCount; ii++) {
                        spine.Utils.webkit602BugfixHelper(mix, blend);
                        timelines[ii].apply(skeleton, animationLast, animationTime, events, mix, blend, spine.MixDirection.mixIn);
                      }
                    } else {
                      var timelineMode = current.timelineMode;
                      var firstFrame = current.timelinesRotation.length == 0;
                      if (firstFrame) spine.Utils.setArraySize(current.timelinesRotation, timelineCount << 1, null);
                      var timelinesRotation = current.timelinesRotation;

                      for (var ii = 0; ii < timelineCount; ii++) {
                        var timeline = timelines[ii];
                        var timelineBlend = (timelineMode[ii] & AnimationState.NOT_LAST - 1) == AnimationState.SUBSEQUENT ? blend : spine.MixBlend.setup;

                        if (timeline instanceof spine.RotateTimeline) {
                          this.applyRotateTimeline(timeline, skeleton, animationTime, mix, timelineBlend, timelinesRotation, ii << 1, firstFrame);
                        } else {
                          spine.Utils.webkit602BugfixHelper(mix, blend);
                          timeline.apply(skeleton, animationLast, animationTime, events, mix, timelineBlend, spine.MixDirection.mixIn);
                        }
                      }
                    }

                    this.queueEvents(current, animationTime);
                    events.length = 0;
                    current.nextAnimationLast = animationTime;
                    current.nextTrackLast = current.trackTime;
                  }

                  this.queue.drain();
                  return applied;
                };

                AnimationState.prototype.applyMixingFrom = function (to, skeleton, blend) {
                  var from = to.mixingFrom;
                  if (from.mixingFrom != null) this.applyMixingFrom(from, skeleton, blend);
                  var mix = 0;

                  if (to.mixDuration == 0) {
                    mix = 1;
                    if (blend == spine.MixBlend.first) blend = spine.MixBlend.setup;
                  } else {
                    mix = to.mixTime / to.mixDuration;
                    if (mix > 1) mix = 1;
                    if (blend != spine.MixBlend.first) blend = from.mixBlend;
                  }

                  var events = mix < from.eventThreshold ? this.events : null;
                  var attachments = mix < from.attachmentThreshold,
                      drawOrder = mix < from.drawOrderThreshold;
                  var animationLast = from.animationLast,
                      animationTime = from.getAnimationTime();
                  var timelineCount = from.animation.timelines.length;
                  var timelines = from.animation.timelines;
                  var alphaHold = from.alpha * to.interruptAlpha,
                      alphaMix = alphaHold * (1 - mix);

                  if (blend == spine.MixBlend.add) {
                    for (var i = 0; i < timelineCount; i++) timelines[i].apply(skeleton, animationLast, animationTime, events, alphaMix, blend, spine.MixDirection.mixOut);
                  } else {
                    var timelineMode = from.timelineMode;
                    var timelineHoldMix = from.timelineHoldMix;
                    var firstFrame = from.timelinesRotation.length == 0;
                    if (firstFrame) spine.Utils.setArraySize(from.timelinesRotation, timelineCount << 1, null);
                    var timelinesRotation = from.timelinesRotation;
                    from.totalAlpha = 0;

                    for (var i = 0; i < timelineCount; i++) {
                      var timeline = timelines[i];
                      var direction = spine.MixDirection.mixOut;
                      var timelineBlend = void 0;
                      var alpha = 0;

                      switch (timelineMode[i] & AnimationState.NOT_LAST - 1) {
                        case AnimationState.SUBSEQUENT:
                          timelineBlend = blend;

                          if (!attachments && timeline instanceof spine.AttachmentTimeline) {
                            if ((timelineMode[i] & AnimationState.NOT_LAST) == AnimationState.NOT_LAST) continue;
                            timelineBlend = spine.MixBlend.setup;
                          }

                          if (!drawOrder && timeline instanceof spine.DrawOrderTimeline) continue;
                          alpha = alphaMix;
                          break;

                        case AnimationState.FIRST:
                          timelineBlend = spine.MixBlend.setup;
                          alpha = alphaMix;
                          break;

                        case AnimationState.HOLD:
                          timelineBlend = spine.MixBlend.setup;
                          alpha = alphaHold;
                          break;

                        default:
                          timelineBlend = spine.MixBlend.setup;
                          var holdMix = timelineHoldMix[i];
                          alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);
                          break;
                      }

                      from.totalAlpha += alpha;
                      if (timeline instanceof spine.RotateTimeline) this.applyRotateTimeline(timeline, skeleton, animationTime, alpha, timelineBlend, timelinesRotation, i << 1, firstFrame);else {
                        spine.Utils.webkit602BugfixHelper(alpha, blend);

                        if (timelineBlend == spine.MixBlend.setup) {
                          if (timeline instanceof spine.AttachmentTimeline) {
                            if (attachments || (timelineMode[i] & AnimationState.NOT_LAST) == AnimationState.NOT_LAST) direction = spine.MixDirection.mixIn;
                          } else if (timeline instanceof spine.DrawOrderTimeline) {
                            if (drawOrder) direction = spine.MixDirection.mixIn;
                          }
                        }

                        timeline.apply(skeleton, animationLast, animationTime, events, alpha, timelineBlend, direction);
                      }
                    }
                  }

                  if (to.mixDuration > 0) this.queueEvents(from, animationTime);
                  this.events.length = 0;
                  from.nextAnimationLast = animationTime;
                  from.nextTrackLast = from.trackTime;
                  return mix;
                };

                AnimationState.prototype.applyRotateTimeline = function (timeline, skeleton, time, alpha, blend, timelinesRotation, i, firstFrame) {
                  if (firstFrame) timelinesRotation[i] = 0;

                  if (alpha == 1) {
                    timeline.apply(skeleton, 0, time, null, 1, blend, spine.MixDirection.mixIn);
                    return;
                  }

                  var rotateTimeline = timeline;
                  var frames = rotateTimeline.frames;
                  var bone = skeleton.bones[rotateTimeline.boneIndex];
                  if (!bone.active) return;
                  var r1 = 0,
                      r2 = 0;

                  if (time < frames[0]) {
                    switch (blend) {
                      case spine.MixBlend.setup:
                        bone.rotation = bone.data.rotation;

                      default:
                        return;

                      case spine.MixBlend.first:
                        r1 = bone.rotation;
                        r2 = bone.data.rotation;
                    }
                  } else {
                    r1 = blend == spine.MixBlend.setup ? bone.data.rotation : bone.rotation;
                    if (time >= frames[frames.length - spine.RotateTimeline.ENTRIES]) r2 = bone.data.rotation + frames[frames.length + spine.RotateTimeline.PREV_ROTATION];else {
                      var frame = spine.Animation.binarySearch(frames, time, spine.RotateTimeline.ENTRIES);
                      var prevRotation = frames[frame + spine.RotateTimeline.PREV_ROTATION];
                      var frameTime = frames[frame];
                      var percent = rotateTimeline.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + spine.RotateTimeline.PREV_TIME] - frameTime));
                      r2 = frames[frame + spine.RotateTimeline.ROTATION] - prevRotation;
                      r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;
                      r2 = prevRotation + r2 * percent + bone.data.rotation;
                      r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;
                    }
                  }

                  var total = 0,
                      diff = r2 - r1;
                  diff -= (16384 - (16384.499999999996 - diff / 360 | 0)) * 360;

                  if (diff == 0) {
                    total = timelinesRotation[i];
                  } else {
                    var lastTotal = 0,
                        lastDiff = 0;

                    if (firstFrame) {
                      lastTotal = 0;
                      lastDiff = diff;
                    } else {
                      lastTotal = timelinesRotation[i];
                      lastDiff = timelinesRotation[i + 1];
                    }

                    var current = diff > 0,
                        dir = lastTotal >= 0;

                    if (spine.MathUtils.signum(lastDiff) != spine.MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {
                      if (Math.abs(lastTotal) > 180) lastTotal += 360 * spine.MathUtils.signum(lastTotal);
                      dir = current;
                    }

                    total = diff + lastTotal - lastTotal % 360;
                    if (dir != current) total += 360 * spine.MathUtils.signum(lastTotal);
                    timelinesRotation[i] = total;
                  }

                  timelinesRotation[i + 1] = diff;
                  r1 += total * alpha;
                  bone.rotation = r1 - (16384 - (16384.499999999996 - r1 / 360 | 0)) * 360;
                };

                AnimationState.prototype.queueEvents = function (entry, animationTime) {
                  var animationStart = entry.animationStart,
                      animationEnd = entry.animationEnd;
                  var duration = animationEnd - animationStart;
                  var trackLastWrapped = entry.trackLast % duration;
                  var events = this.events;
                  var i = 0,
                      n = events.length;

                  for (; i < n; i++) {
                    var event_1 = events[i];
                    if (event_1.time < trackLastWrapped) break;
                    if (event_1.time > animationEnd) continue;
                    this.queue.event(entry, event_1);
                  }

                  var complete = false;
                  if (entry.loop) complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;else complete = animationTime >= animationEnd && entry.animationLast < animationEnd;
                  if (complete) this.queue.complete(entry);

                  for (; i < n; i++) {
                    var event_2 = events[i];
                    if (event_2.time < animationStart) continue;
                    this.queue.event(entry, events[i]);
                  }
                };

                AnimationState.prototype.clearTracks = function () {
                  var oldDrainDisabled = this.queue.drainDisabled;
                  this.queue.drainDisabled = true;

                  for (var i = 0, n = this.tracks.length; i < n; i++) this.clearTrack(i);

                  this.tracks.length = 0;
                  this.queue.drainDisabled = oldDrainDisabled;
                  this.queue.drain();
                };

                AnimationState.prototype.clearTrack = function (trackIndex) {
                  if (trackIndex >= this.tracks.length) return;
                  var current = this.tracks[trackIndex];
                  if (current == null) return;
                  this.queue.end(current);
                  this.disposeNext(current);
                  var entry = current;

                  while (true) {
                    var from = entry.mixingFrom;
                    if (from == null) break;
                    this.queue.end(from);
                    entry.mixingFrom = null;
                    entry.mixingTo = null;
                    entry = from;
                  }

                  this.tracks[current.trackIndex] = null;
                  this.queue.drain();
                };

                AnimationState.prototype.setCurrent = function (index, current, interrupt) {
                  var from = this.expandToIndex(index);
                  this.tracks[index] = current;

                  if (from != null) {
                    if (interrupt) this.queue.interrupt(from);
                    current.mixingFrom = from;
                    from.mixingTo = current;
                    current.mixTime = 0;
                    if (from.mixingFrom != null && from.mixDuration > 0) current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);
                    from.timelinesRotation.length = 0;
                  }

                  this.queue.start(current);
                };

                AnimationState.prototype.setAnimation = function (trackIndex, animationName, loop) {
                  var animation = this.data.skeletonData.findAnimation(animationName);
                  if (animation == null) throw new Error("Animation not found: " + animationName);
                  return this.setAnimationWith(trackIndex, animation, loop);
                };

                AnimationState.prototype.setAnimationWith = function (trackIndex, animation, loop) {
                  if (animation == null) throw new Error("animation cannot be null.");
                  var interrupt = true;
                  var current = this.expandToIndex(trackIndex);

                  if (current != null) {
                    if (current.nextTrackLast == -1) {
                      this.tracks[trackIndex] = current.mixingFrom;
                      this.queue.interrupt(current);
                      this.queue.end(current);
                      this.disposeNext(current);
                      current = current.mixingFrom;
                      interrupt = false;
                    } else this.disposeNext(current);
                  }

                  var entry = this.trackEntry(trackIndex, animation, loop, current);
                  this.setCurrent(trackIndex, entry, interrupt);
                  this.queue.drain();
                  return entry;
                };

                AnimationState.prototype.addAnimation = function (trackIndex, animationName, loop, delay) {
                  var animation = this.data.skeletonData.findAnimation(animationName);
                  if (animation == null) throw new Error("Animation not found: " + animationName);
                  return this.addAnimationWith(trackIndex, animation, loop, delay);
                };

                AnimationState.prototype.addAnimationWith = function (trackIndex, animation, loop, delay) {
                  if (animation == null) throw new Error("animation cannot be null.");
                  var last = this.expandToIndex(trackIndex);

                  if (last != null) {
                    while (last.next != null) last = last.next;
                  }

                  var entry = this.trackEntry(trackIndex, animation, loop, last);

                  if (last == null) {
                    this.setCurrent(trackIndex, entry, true);
                    this.queue.drain();
                  } else {
                    last.next = entry;

                    if (delay <= 0) {
                      var duration = last.animationEnd - last.animationStart;

                      if (duration != 0) {
                        if (last.loop) delay += duration * (1 + (last.trackTime / duration | 0));else delay += Math.max(duration, last.trackTime);
                        delay -= this.data.getMix(last.animation, animation);
                      } else delay = last.trackTime;
                    }
                  }

                  entry.delay = delay;
                  return entry;
                };

                AnimationState.prototype.setEmptyAnimation = function (trackIndex, mixDuration) {
                  var entry = this.setAnimationWith(trackIndex, AnimationState.emptyAnimation, false);
                  entry.mixDuration = mixDuration;
                  entry.trackEnd = mixDuration;
                  return entry;
                };

                AnimationState.prototype.addEmptyAnimation = function (trackIndex, mixDuration, delay) {
                  if (delay <= 0) delay -= mixDuration;
                  var entry = this.addAnimationWith(trackIndex, AnimationState.emptyAnimation, false, delay);
                  entry.mixDuration = mixDuration;
                  entry.trackEnd = mixDuration;
                  return entry;
                };

                AnimationState.prototype.setEmptyAnimations = function (mixDuration) {
                  var oldDrainDisabled = this.queue.drainDisabled;
                  this.queue.drainDisabled = true;

                  for (var i = 0, n = this.tracks.length; i < n; i++) {
                    var current = this.tracks[i];
                    if (current != null) this.setEmptyAnimation(current.trackIndex, mixDuration);
                  }

                  this.queue.drainDisabled = oldDrainDisabled;
                  this.queue.drain();
                };

                AnimationState.prototype.expandToIndex = function (index) {
                  if (index < this.tracks.length) return this.tracks[index];
                  spine.Utils.ensureArrayCapacity(this.tracks, index + 1, null);
                  this.tracks.length = index + 1;
                  return null;
                };

                AnimationState.prototype.trackEntry = function (trackIndex, animation, loop, last) {
                  var entry = this.trackEntryPool.obtain();
                  entry.trackIndex = trackIndex;
                  entry.animation = animation;
                  entry.loop = loop;
                  entry.holdPrevious = false;
                  entry.eventThreshold = 0;
                  entry.attachmentThreshold = 0;
                  entry.drawOrderThreshold = 0;
                  entry.animationStart = 0;
                  entry.animationEnd = animation.duration;
                  entry.animationLast = -1;
                  entry.nextAnimationLast = -1;
                  entry.delay = 0;
                  entry.trackTime = 0;
                  entry.trackLast = -1;
                  entry.nextTrackLast = -1;
                  entry.trackEnd = Number.MAX_VALUE;
                  entry.timeScale = 1;
                  entry.alpha = 1;
                  entry.interruptAlpha = 1;
                  entry.mixTime = 0;
                  entry.mixDuration = last == null ? 0 : this.data.getMix(last.animation, animation);
                  return entry;
                };

                AnimationState.prototype.disposeNext = function (entry) {
                  var next = entry.next;

                  while (next != null) {
                    this.queue.dispose(next);
                    next = next.next;
                  }

                  entry.next = null;
                };

                AnimationState.prototype._animationsChanged = function () {
                  this.animationsChanged = false;
                  this.propertyIDs.clear();

                  for (var i = 0, n = this.tracks.length; i < n; i++) {
                    var entry = this.tracks[i];
                    if (entry == null) continue;

                    while (entry.mixingFrom != null) entry = entry.mixingFrom;

                    do {
                      if (entry.mixingFrom == null || entry.mixBlend != spine.MixBlend.add) this.computeHold(entry);
                      entry = entry.mixingTo;
                    } while (entry != null);
                  }

                  this.propertyIDs.clear();

                  for (var i = this.tracks.length - 1; i >= 0; i--) {
                    var entry = this.tracks[i];

                    while (entry != null) {
                      this.computeNotLast(entry);
                      entry = entry.mixingFrom;
                    }
                  }
                };

                AnimationState.prototype.computeHold = function (entry) {
                  var to = entry.mixingTo;
                  var timelines = entry.animation.timelines;
                  var timelinesCount = entry.animation.timelines.length;
                  var timelineMode = spine.Utils.setArraySize(entry.timelineMode, timelinesCount);
                  entry.timelineHoldMix.length = 0;
                  var timelineDipMix = spine.Utils.setArraySize(entry.timelineHoldMix, timelinesCount);
                  var propertyIDs = this.propertyIDs;

                  if (to != null && to.holdPrevious) {
                    for (var i = 0; i < timelinesCount; i++) {
                      propertyIDs.add(timelines[i].getPropertyId());
                      timelineMode[i] = AnimationState.HOLD;
                    }

                    return;
                  }

                  outer: for (var i = 0; i < timelinesCount; i++) {
                    var timeline = timelines[i];
                    var id = timeline.getPropertyId();
                    if (!propertyIDs.add(id)) timelineMode[i] = AnimationState.SUBSEQUENT;else if (to == null || timeline instanceof spine.AttachmentTimeline || timeline instanceof spine.DrawOrderTimeline || timeline instanceof spine.EventTimeline || !to.animation.hasTimeline(id)) {
                      timelineMode[i] = AnimationState.FIRST;
                    } else {
                      for (var next = to.mixingTo; next != null; next = next.mixingTo) {
                        if (next.animation.hasTimeline(id)) continue;

                        if (entry.mixDuration > 0) {
                          timelineMode[i] = AnimationState.HOLD_MIX;
                          timelineDipMix[i] = next;
                          continue outer;
                        }

                        break;
                      }

                      timelineMode[i] = AnimationState.HOLD;
                    }
                  }
                };

                AnimationState.prototype.computeNotLast = function (entry) {
                  var timelines = entry.animation.timelines;
                  var timelinesCount = entry.animation.timelines.length;
                  var timelineMode = entry.timelineMode;
                  var propertyIDs = this.propertyIDs;

                  for (var i = 0; i < timelinesCount; i++) {
                    if (timelines[i] instanceof spine.AttachmentTimeline) {
                      var timeline = timelines[i];
                      if (!propertyIDs.add(timeline.slotIndex)) timelineMode[i] |= AnimationState.NOT_LAST;
                    }
                  }
                };

                AnimationState.prototype.getCurrent = function (trackIndex) {
                  if (trackIndex >= this.tracks.length) return null;
                  return this.tracks[trackIndex];
                };

                AnimationState.prototype.addListener = function (listener) {
                  if (listener == null) throw new Error("listener cannot be null.");
                  this.listeners.push(listener);
                };

                AnimationState.prototype.removeListener = function (listener) {
                  var index = this.listeners.indexOf(listener);
                  if (index >= 0) this.listeners.splice(index, 1);
                };

                AnimationState.prototype.clearListeners = function () {
                  this.listeners.length = 0;
                };

                AnimationState.prototype.clearListenerNotifications = function () {
                  this.queue.clear();
                };

                AnimationState.emptyAnimation = new spine.Animation("<empty>", [], 0);
                AnimationState.SUBSEQUENT = 0;
                AnimationState.FIRST = 1;
                AnimationState.HOLD = 2;
                AnimationState.HOLD_MIX = 3;
                AnimationState.NOT_LAST = 4;
                return AnimationState;
              }();

              spine.AnimationState = AnimationState;

              var TrackEntry = function () {
                function TrackEntry() {
                  this.mixBlend = spine.MixBlend.replace;
                  this.timelineMode = new Array();
                  this.timelineHoldMix = new Array();
                  this.timelinesRotation = new Array();
                }

                TrackEntry.prototype.reset = function () {
                  this.next = null;
                  this.mixingFrom = null;
                  this.mixingTo = null;
                  this.animation = null;
                  this.listener = null;
                  this.timelineMode.length = 0;
                  this.timelineHoldMix.length = 0;
                  this.timelinesRotation.length = 0;
                };

                TrackEntry.prototype.getAnimationTime = function () {
                  if (this.loop) {
                    var duration = this.animationEnd - this.animationStart;
                    if (duration == 0) return this.animationStart;
                    return this.trackTime % duration + this.animationStart;
                  }

                  return Math.min(this.trackTime + this.animationStart, this.animationEnd);
                };

                TrackEntry.prototype.setAnimationLast = function (animationLast) {
                  this.animationLast = animationLast;
                  this.nextAnimationLast = animationLast;
                };

                TrackEntry.prototype.isComplete = function () {
                  return this.trackTime >= this.animationEnd - this.animationStart;
                };

                TrackEntry.prototype.resetRotationDirections = function () {
                  this.timelinesRotation.length = 0;
                };

                return TrackEntry;
              }();

              spine.TrackEntry = TrackEntry;

              var EventQueue = function () {
                function EventQueue(animState) {
                  this.objects = [];
                  this.drainDisabled = false;
                  this.animState = animState;
                }

                EventQueue.prototype.start = function (entry) {
                  this.objects.push(EventType.start);
                  this.objects.push(entry);
                  this.animState.animationsChanged = true;
                };

                EventQueue.prototype.interrupt = function (entry) {
                  this.objects.push(EventType.interrupt);
                  this.objects.push(entry);
                };

                EventQueue.prototype.end = function (entry) {
                  this.objects.push(EventType.end);
                  this.objects.push(entry);
                  this.animState.animationsChanged = true;
                };

                EventQueue.prototype.dispose = function (entry) {
                  this.objects.push(EventType.dispose);
                  this.objects.push(entry);
                };

                EventQueue.prototype.complete = function (entry) {
                  this.objects.push(EventType.complete);
                  this.objects.push(entry);
                };

                EventQueue.prototype.event = function (entry, event) {
                  this.objects.push(EventType.event);
                  this.objects.push(entry);
                  this.objects.push(event);
                };

                EventQueue.prototype.drain = function () {
                  if (this.drainDisabled) return;
                  this.drainDisabled = true;
                  var objects = this.objects;
                  var listeners = this.animState.listeners;

                  for (var i = 0; i < objects.length; i += 2) {
                    var type = objects[i];
                    var entry = objects[i + 1];

                    switch (type) {
                      case EventType.start:
                        if (entry.listener != null && entry.listener.start) entry.listener.start(entry);

                        for (var ii = 0; ii < listeners.length; ii++) if (listeners[ii].start) listeners[ii].start(entry);

                        break;

                      case EventType.interrupt:
                        if (entry.listener != null && entry.listener.interrupt) entry.listener.interrupt(entry);

                        for (var ii = 0; ii < listeners.length; ii++) if (listeners[ii].interrupt) listeners[ii].interrupt(entry);

                        break;

                      case EventType.end:
                        if (entry.listener != null && entry.listener.end) entry.listener.end(entry);

                        for (var ii = 0; ii < listeners.length; ii++) if (listeners[ii].end) listeners[ii].end(entry);

                      case EventType.dispose:
                        if (entry.listener != null && entry.listener.dispose) entry.listener.dispose(entry);

                        for (var ii = 0; ii < listeners.length; ii++) if (listeners[ii].dispose) listeners[ii].dispose(entry);

                        this.animState.trackEntryPool.free(entry);
                        break;

                      case EventType.complete:
                        if (entry.listener != null && entry.listener.complete) entry.listener.complete(entry);

                        for (var ii = 0; ii < listeners.length; ii++) if (listeners[ii].complete) listeners[ii].complete(entry);

                        break;

                      case EventType.event:
                        var event_3 = objects[i++ + 2];
                        if (entry.listener != null && entry.listener.event) entry.listener.event(entry, event_3);

                        for (var ii = 0; ii < listeners.length; ii++) if (listeners[ii].event) listeners[ii].event(entry, event_3);

                        break;
                    }
                  }

                  this.clear();
                  this.drainDisabled = false;
                };

                EventQueue.prototype.clear = function () {
                  this.objects.length = 0;
                };

                return EventQueue;
              }();

              spine.EventQueue = EventQueue;
              var EventType;

              (function (EventType) {
                EventType[EventType["start"] = 0] = "start";
                EventType[EventType["interrupt"] = 1] = "interrupt";
                EventType[EventType["end"] = 2] = "end";
                EventType[EventType["dispose"] = 3] = "dispose";
                EventType[EventType["complete"] = 4] = "complete";
                EventType[EventType["event"] = 5] = "event";
              })(EventType = spine.EventType || (spine.EventType = {}));

              var AnimationStateAdapter = function () {
                function AnimationStateAdapter() {}

                AnimationStateAdapter.prototype.start = function (entry) {};

                AnimationStateAdapter.prototype.interrupt = function (entry) {};

                AnimationStateAdapter.prototype.end = function (entry) {};

                AnimationStateAdapter.prototype.dispose = function (entry) {};

                AnimationStateAdapter.prototype.complete = function (entry) {};

                AnimationStateAdapter.prototype.event = function (entry, event) {};

                return AnimationStateAdapter;
              }();

              spine.AnimationStateAdapter = AnimationStateAdapter;
            })(spine || (spine = {}));

            var spine;

            (function (spine) {
              var AnimationStateData = function () {
                function AnimationStateData(skeletonData) {
                  this.animationToMixTime = {};
                  this.defaultMix = 0;
                  if (skeletonData == null) throw new Error("skeletonData cannot be null.");
                  this.skeletonData = skeletonData;
                }

                AnimationStateData.prototype.setMix = function (fromName, toName, duration) {
                  var from = this.skeletonData.findAnimation(fromName);
                  if (from == null) throw new Error("Animation not found: " + fromName);
                  var to = this.skeletonData.findAnimation(toName);
                  if (to == null) throw new Error("Animation not found: " + toName);
                  this.setMixWith(from, to, duration);
                };

                AnimationStateData.prototype.setMixWith = function (from, to, duration) {
                  if (from == null) throw new Error("from cannot be null.");
                  if (to == null) throw new Error("to cannot be null.");
                  var key = from.name + "." + to.name;
                  this.animationToMixTime[key] = duration;
                };

                AnimationStateData.prototype.getMix = function (from, to) {
                  var key = from.name + "." + to.name;
                  var value = this.animationToMixTime[key];
                  return value === undefined ? this.defaultMix : value;
                };

                return AnimationStateData;
              }();

              spine.AnimationStateData = AnimationStateData;
            })(spine || (spine = {}));

            var spine;

            (function (spine) {
              var AssetManager = function () {
                function AssetManager(textureLoader, pathPrefix) {
                  if (pathPrefix === void 0) {
                    pathPrefix = "";
                  }

                  this.assets = {};
                  this.errors = {};
                  this.toLoad = 0;
                  this.loaded = 0;
                  this.textureLoader = textureLoader;
                  this.pathPrefix = pathPrefix;
                }

                AssetManager.downloadText = function (url, success, error) {
                  var request = new XMLHttpRequest();
                  request.open("GET", url, true);

                  request.onload = function () {
                    if (request.status == 200) {
                      success(request.responseText);
                    } else {
                      error(request.status, request.responseText);
                    }
                  };

                  request.onerror = function () {
                    error(request.status, request.responseText);
                  };

                  request.send();
                };

                AssetManager.downloadBinary = function (url, success, error) {
                  var request = new XMLHttpRequest();
                  request.open("GET", url, true);
                  request.responseType = "arraybuffer";

                  request.onload = function () {
                    if (request.status == 200) {
                      success(new Uint8Array(request.response));
                    } else {
                      error(request.status, request.responseText);
                    }
                  };

                  request.onerror = function () {
                    error(request.status, request.responseText);
                  };

                  request.send();
                };

                AssetManager.prototype.loadBinary = function (path, success, error) {
                  var _this = this;

                  if (success === void 0) {
                    success = null;
                  }

                  if (error === void 0) {
                    error = null;
                  }

                  path = this.pathPrefix + path;
                  this.toLoad++;
                  AssetManager.downloadBinary(path, function (data) {
                    _this.assets[path] = data;
                    if (success) success(path, data);
                    _this.toLoad--;
                    _this.loaded++;
                  }, function (state, responseText) {
                    _this.errors[path] = "Couldn't load binary " + path + ": status " + status + ", " + responseText;
                    if (error) error(path, "Couldn't load binary " + path + ": status " + status + ", " + responseText);
                    _this.toLoad--;
                    _this.loaded++;
                  });
                };

                AssetManager.prototype.loadText = function (path, success, error) {
                  var _this = this;

                  if (success === void 0) {
                    success = null;
                  }

                  if (error === void 0) {
                    error = null;
                  }

                  path = this.pathPrefix + path;
                  this.toLoad++;
                  AssetManager.downloadText(path, function (data) {
                    _this.assets[path] = data;
                    if (success) success(path, data);
                    _this.toLoad--;
                    _this.loaded++;
                  }, function (state, responseText) {
                    _this.errors[path] = "Couldn't load text " + path + ": status " + status + ", " + responseText;
                    if (error) error(path, "Couldn't load text " + path + ": status " + status + ", " + responseText);
                    _this.toLoad--;
                    _this.loaded++;
                  });
                };

                AssetManager.prototype.loadTexture = function (path, success, error) {
                  var _this = this;

                  if (success === void 0) {
                    success = null;
                  }

                  if (error === void 0) {
                    error = null;
                  }

                  path = this.pathPrefix + path;
                  this.toLoad++;
                  var img = new Image();
                  img.crossOrigin = "anonymous";

                  img.onload = function (ev) {
                    var texture = _this.textureLoader(img);

                    _this.assets[path] = texture;
                    _this.toLoad--;
                    _this.loaded++;
                    if (success) success(path, img);
                  };

                  img.onerror = function (ev) {
                    _this.errors[path] = "Couldn't load image " + path;
                    _this.toLoad--;
                    _this.loaded++;
                    if (error) error(path, "Couldn't load image " + path);
                  };

                  img.src = path;
                };

                AssetManager.prototype.loadTextureData = function (path, data, success, error) {
                  var _this = this;

                  if (success === void 0) {
                    success = null;
                  }

                  if (error === void 0) {
                    error = null;
                  }

                  path = this.pathPrefix + path;
                  this.toLoad++;
                  var img = new Image();

                  img.onload = function (ev) {
                    var texture = _this.textureLoader(img);

                    _this.assets[path] = texture;
                    _this.toLoad--;
                    _this.loaded++;
                    if (success) success(path, img);
                  };

                  img.onerror = function (ev) {
                    _this.errors[path] = "Couldn't load image " + path;
                    _this.toLoad--;
                    _this.loaded++;
                    if (error) error(path, "Couldn't load image " + path);
                  };

                  img.src = data;
                };

                AssetManager.prototype.loadTextureAtlas = function (path, success, error) {
                  var _this = this;

                  if (success === void 0) {
                    success = null;
                  }

                  if (error === void 0) {
                    error = null;
                  }

                  var parent = path.lastIndexOf("/") >= 0 ? path.substring(0, path.lastIndexOf("/")) : "";
                  path = this.pathPrefix + path;
                  this.toLoad++;
                  AssetManager.downloadText(path, function (atlasData) {
                    var pagesLoaded = {
                      count: 0
                    };
                    var atlasPages = new Array();

                    try {
                      var atlas = new spine.TextureAtlas(atlasData, function (path) {
                        atlasPages.push(parent + "/" + path);
                        var image = document.createElement("img");
                        image.width = 16;
                        image.height = 16;
                        return new spine.FakeTexture(image);
                      });
                    } catch (e) {
                      var ex = e;
                      _this.errors[path] = "Couldn't load texture atlas " + path + ": " + ex.message;
                      if (error) error(path, "Couldn't load texture atlas " + path + ": " + ex.message);
                      _this.toLoad--;
                      _this.loaded++;
                      return;
                    }

                    var _loop_1 = function (atlasPage) {
                      var pageLoadError = false;

                      _this.loadTexture(atlasPage, function (imagePath, image) {
                        pagesLoaded.count++;

                        if (pagesLoaded.count == atlasPages.length) {
                          if (!pageLoadError) {
                            try {
                              var atlas = new spine.TextureAtlas(atlasData, function (path) {
                                return _this.get(parent + "/" + path);
                              });
                              _this.assets[path] = atlas;
                              if (success) success(path, atlas);
                              _this.toLoad--;
                              _this.loaded++;
                            } catch (e) {
                              var ex = e;
                              _this.errors[path] = "Couldn't load texture atlas " + path + ": " + ex.message;
                              if (error) error(path, "Couldn't load texture atlas " + path + ": " + ex.message);
                              _this.toLoad--;
                              _this.loaded++;
                            }
                          } else {
                            _this.errors[path] = "Couldn't load texture atlas page " + imagePath + "} of atlas " + path;
                            if (error) error(path, "Couldn't load texture atlas page " + imagePath + " of atlas " + path);
                            _this.toLoad--;
                            _this.loaded++;
                          }
                        }
                      }, function (imagePath, errorMessage) {
                        pageLoadError = true;
                        pagesLoaded.count++;

                        if (pagesLoaded.count == atlasPages.length) {
                          _this.errors[path] = "Couldn't load texture atlas page " + imagePath + "} of atlas " + path;
                          if (error) error(path, "Couldn't load texture atlas page " + imagePath + " of atlas " + path);
                          _this.toLoad--;
                          _this.loaded++;
                        }
                      });
                    };

                    for (var _i = 0, atlasPages_1 = atlasPages; _i < atlasPages_1.length; _i++) {
                      var atlasPage = atlasPages_1[_i];

                      _loop_1(atlasPage);
                    }
                  }, function (state, responseText) {
                    _this.errors[path] = "Couldn't load texture atlas " + path + ": status " + status + ", " + responseText;
                    if (error) error(path, "Couldn't load texture atlas " + path + ": status " + status + ", " + responseText);
                    _this.toLoad--;
                    _this.loaded++;
                  });
                };

                AssetManager.prototype.get = function (path) {
                  path = this.pathPrefix + path;
                  return this.assets[path];
                };

                AssetManager.prototype.remove = function (path) {
                  path = this.pathPrefix + path;
                  var asset = this.assets[path];
                  if (asset.dispose) asset.dispose();
                  this.assets[path] = null;
                };

                AssetManager.prototype.removeAll = function () {
                  for (var key in this.assets) {
                    var asset = this.assets[key];
                    if (asset.dispose) asset.dispose();
                  }

                  this.assets = {};
                };

                AssetManager.prototype.isLoadingComplete = function () {
                  return this.toLoad == 0;
                };

                AssetManager.prototype.getToLoad = function () {
                  return this.toLoad;
                };

                AssetManager.prototype.getLoaded = function () {
                  return this.loaded;
                };

                AssetManager.prototype.dispose = function () {
                  this.removeAll();
                };

                AssetManager.prototype.hasErrors = function () {
                  return Object.keys(this.errors).length > 0;
                };

                AssetManager.prototype.getErrors = function () {
                  return this.errors;
                };

                return AssetManager;
              }();

              spine.AssetManager = AssetManager;
            })(spine || (spine = {}));

            var spine;

            (function (spine) {
              var AtlasAttachmentLoader = function () {
                function AtlasAttachmentLoader(atlas) {
                  this.atlas = atlas;
                }

                AtlasAttachmentLoader.prototype.newRegionAttachment = function (skin, name, path) {
                  var region = this.atlas.findRegion(path);

                  if (region == null) {
                    return null;
                  }

                  region.renderObject = region;
                  var attachment = new spine.RegionAttachment(name);
                  attachment.setRegion(region);
                  return attachment;
                };

                AtlasAttachmentLoader.prototype.newMeshAttachment = function (skin, name, path) {
                  var region = this.atlas.findRegion(path);

                  if (region == null) {
                    return null;
                  }

                  region.renderObject = region;
                  var attachment = new spine.MeshAttachment(name);
                  attachment.region = region;
                  return attachment;
                };

                AtlasAttachmentLoader.prototype.newBoundingBoxAttachment = function (skin, name) {
                  return new spine.BoundingBoxAttachment(name);
                };

                AtlasAttachmentLoader.prototype.newPathAttachment = function (skin, name) {
                  return new spine.PathAttachment(name);
                };

                AtlasAttachmentLoader.prototype.newPointAttachment = function (skin, name) {
                  return new spine.PointAttachment(name);
                };

                AtlasAttachmentLoader.prototype.newClippingAttachment = function (skin, name) {
                  return new spine.ClippingAttachment(name);
                };

                return AtlasAttachmentLoader;
              }();

              spine.AtlasAttachmentLoader = AtlasAttachmentLoader;
            })(spine || (spine = {}));

            var spine;

            (function (spine) {
              var BlendMode;

              (function (BlendMode) {
                BlendMode[BlendMode["Normal"] = 0] = "Normal";
                BlendMode[BlendMode["Additive"] = 1] = "Additive";
                BlendMode[BlendMode["Multiply"] = 2] = "Multiply";
                BlendMode[BlendMode["Screen"] = 3] = "Screen";
              })(BlendMode = spine.BlendMode || (spine.BlendMode = {}));
            })(spine || (spine = {}));

            var spine;

            (function (spine) {
              var Bone = function () {
                function Bone(data, skeleton, parent) {
                  this.children = new Array();
                  this.x = 0;
                  this.y = 0;
                  this.rotation = 0;
                  this.scaleX = 0;
                  this.scaleY = 0;
                  this.shearX = 0;
                  this.shearY = 0;
                  this.ax = 0;
                  this.ay = 0;
                  this.arotation = 0;
                  this.ascaleX = 0;
                  this.ascaleY = 0;
                  this.ashearX = 0;
                  this.ashearY = 0;
                  this.appliedValid = false;
                  this.a = 0;
                  this.b = 0;
                  this.c = 0;
                  this.d = 0;
                  this.worldY = 0;
                  this.worldX = 0;
                  this.sorted = false;
                  this.active = false;
                  if (data == null) throw new Error("data cannot be null.");
                  if (skeleton == null) throw new Error("skeleton cannot be null.");
                  this.data = data;
                  this.skeleton = skeleton;
                  this.parent = parent;
                  this.setToSetupPose();
                }

                Bone.prototype.isActive = function () {
                  return this.active;
                };

                Bone.prototype.update = function () {
                  this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
                };

                Bone.prototype.updateWorldTransform = function () {
                  this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
                };

                Bone.prototype.updateWorldTransformWith = function (x, y, rotation, scaleX, scaleY, shearX, shearY) {
                  this.ax = x;
                  this.ay = y;
                  this.arotation = rotation;
                  this.ascaleX = scaleX;
                  this.ascaleY = scaleY;
                  this.ashearX = shearX;
                  this.ashearY = shearY;
                  this.appliedValid = true;
                  var parent = this.parent;

                  if (parent == null) {
                    var skeleton = this.skeleton;
                    var rotationY = rotation + 90 + shearY;
                    var sx = skeleton.scaleX;
                    var sy = skeleton.scaleY;
                    this.a = spine.MathUtils.cosDeg(rotation + shearX) * scaleX * sx;
                    this.b = spine.MathUtils.cosDeg(rotationY) * scaleY * sx;
                    this.c = spine.MathUtils.sinDeg(rotation + shearX) * scaleX * sy;
                    this.d = spine.MathUtils.sinDeg(rotationY) * scaleY * sy;
                    this.worldX = x * sx + skeleton.x;
                    this.worldY = y * sy + skeleton.y;
                    return;
                  }

                  var pa = parent.a,
                      pb = parent.b,
                      pc = parent.c,
                      pd = parent.d;
                  this.worldX = pa * x + pb * y + parent.worldX;
                  this.worldY = pc * x + pd * y + parent.worldY;

                  switch (this.data.transformMode) {
                    case spine.TransformMode.Normal:
                      {
                        var rotationY = rotation + 90 + shearY;
                        var la = spine.MathUtils.cosDeg(rotation + shearX) * scaleX;
                        var lb = spine.MathUtils.cosDeg(rotationY) * scaleY;
                        var lc = spine.MathUtils.sinDeg(rotation + shearX) * scaleX;
                        var ld = spine.MathUtils.sinDeg(rotationY) * scaleY;
                        this.a = pa * la + pb * lc;
                        this.b = pa * lb + pb * ld;
                        this.c = pc * la + pd * lc;
                        this.d = pc * lb + pd * ld;
                        return;
                      }

                    case spine.TransformMode.OnlyTranslation:
                      {
                        var rotationY = rotation + 90 + shearY;
                        this.a = spine.MathUtils.cosDeg(rotation + shearX) * scaleX;
                        this.b = spine.MathUtils.cosDeg(rotationY) * scaleY;
                        this.c = spine.MathUtils.sinDeg(rotation + shearX) * scaleX;
                        this.d = spine.MathUtils.sinDeg(rotationY) * scaleY;
                        break;
                      }

                    case spine.TransformMode.NoRotationOrReflection:
                      {
                        var s = pa * pa + pc * pc;
                        var prx = 0;

                        if (s > 0.0001) {
                          s = Math.abs(pa * pd - pb * pc) / s;
                          pb = pc * s;
                          pd = pa * s;
                          prx = Math.atan2(pc, pa) * spine.MathUtils.radDeg;
                        } else {
                          pa = 0;
                          pc = 0;
                          prx = 90 - Math.atan2(pd, pb) * spine.MathUtils.radDeg;
                        }

                        var rx = rotation + shearX - prx;
                        var ry = rotation + shearY - prx + 90;
                        var la = spine.MathUtils.cosDeg(rx) * scaleX;
                        var lb = spine.MathUtils.cosDeg(ry) * scaleY;
                        var lc = spine.MathUtils.sinDeg(rx) * scaleX;
                        var ld = spine.MathUtils.sinDeg(ry) * scaleY;
                        this.a = pa * la - pb * lc;
                        this.b = pa * lb - pb * ld;
                        this.c = pc * la + pd * lc;
                        this.d = pc * lb + pd * ld;
                        break;
                      }

                    case spine.TransformMode.NoScale:
                    case spine.TransformMode.NoScaleOrReflection:
                      {
                        var cos = spine.MathUtils.cosDeg(rotation);
                        var sin = spine.MathUtils.sinDeg(rotation);
                        var za = (pa * cos + pb * sin) / this.skeleton.scaleX;
                        var zc = (pc * cos + pd * sin) / this.skeleton.scaleY;
                        var s = Math.sqrt(za * za + zc * zc);
                        if (s > 0.00001) s = 1 / s;
                        za *= s;
                        zc *= s;
                        s = Math.sqrt(za * za + zc * zc);
                        if (this.data.transformMode == spine.TransformMode.NoScale && pa * pd - pb * pc < 0 != (this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0)) s = -s;
                        var r = Math.PI / 2 + Math.atan2(zc, za);
                        var zb = Math.cos(r) * s;
                        var zd = Math.sin(r) * s;
                        var la = spine.MathUtils.cosDeg(shearX) * scaleX;
                        var lb = spine.MathUtils.cosDeg(90 + shearY) * scaleY;
                        var lc = spine.MathUtils.sinDeg(shearX) * scaleX;
                        var ld = spine.MathUtils.sinDeg(90 + shearY) * scaleY;
                        this.a = za * la + zb * lc;
                        this.b = za * lb + zb * ld;
                        this.c = zc * la + zd * lc;
                        this.d = zc * lb + zd * ld;
                        break;
                      }
                  }

                  this.a *= this.skeleton.scaleX;
                  this.b *= this.skeleton.scaleX;
                  this.c *= this.skeleton.scaleY;
                  this.d *= this.skeleton.scaleY;
                };

                Bone.prototype.setToSetupPose = function () {
                  var data = this.data;
                  this.x = data.x;
                  this.y = data.y;
                  this.rotation = data.rotation;
                  this.scaleX = data.scaleX;
                  this.scaleY = data.scaleY;
                  this.shearX = data.shearX;
                  this.shearY = data.shearY;
                };

                Bone.prototype.getWorldRotationX = function () {
                  return Math.atan2(this.c, this.a) * spine.MathUtils.radDeg;
                };

                Bone.prototype.getWorldRotationY = function () {
                  return Math.atan2(this.d, this.b) * spine.MathUtils.radDeg;
                };

                Bone.prototype.getWorldScaleX = function () {
                  return Math.sqrt(this.a * this.a + this.c * this.c);
                };

                Bone.prototype.getWorldScaleY = function () {
                  return Math.sqrt(this.b * this.b + this.d * this.d);
                };

                Bone.prototype.updateAppliedTransform = function () {
                  this.appliedValid = true;
                  var parent = this.parent;

                  if (parent == null) {
                    this.ax = this.worldX;
                    this.ay = this.worldY;
                    this.arotation = Math.atan2(this.c, this.a) * spine.MathUtils.radDeg;
                    this.ascaleX = Math.sqrt(this.a * this.a + this.c * this.c);
                    this.ascaleY = Math.sqrt(this.b * this.b + this.d * this.d);
                    this.ashearX = 0;
                    this.ashearY = Math.atan2(this.a * this.b + this.c * this.d, this.a * this.d - this.b * this.c) * spine.MathUtils.radDeg;
                    return;
                  }

                  var pa = parent.a,
                      pb = parent.b,
                      pc = parent.c,
                      pd = parent.d;
                  var pid = 1 / (pa * pd - pb * pc);
                  var dx = this.worldX - parent.worldX,
                      dy = this.worldY - parent.worldY;
                  this.ax = dx * pd * pid - dy * pb * pid;
                  this.ay = dy * pa * pid - dx * pc * pid;
                  var ia = pid * pd;
                  var id = pid * pa;
                  var ib = pid * pb;
                  var ic = pid * pc;
                  var ra = ia * this.a - ib * this.c;
                  var rb = ia * this.b - ib * this.d;
                  var rc = id * this.c - ic * this.a;
                  var rd = id * this.d - ic * this.b;
                  this.ashearX = 0;
                  this.ascaleX = Math.sqrt(ra * ra + rc * rc);

                  if (this.ascaleX > 0.0001) {
                    var det = ra * rd - rb * rc;
                    this.ascaleY = det / this.ascaleX;
                    this.ashearY = Math.atan2(ra * rb + rc * rd, det) * spine.MathUtils.radDeg;
                    this.arotation = Math.atan2(rc, ra) * spine.MathUtils.radDeg;
                  } else {
                    this.ascaleX = 0;
                    this.ascaleY = Math.sqrt(rb * rb + rd * rd);
                    this.ashearY = 0;
                    this.arotation = 90 - Math.atan2(rd, rb) * spine.MathUtils.radDeg;
                  }
                };

                Bone.prototype.worldToLocal = function (world) {
                  var a = this.a,
                      b = this.b,
                      c = this.c,
                      d = this.d;
                  var invDet = 1 / (a * d - b * c);
                  var x = world.x - this.worldX,
                      y = world.y - this.worldY;
                  world.x = x * d * invDet - y * b * invDet;
                  world.y = y * a * invDet - x * c * invDet;
                  return world;
                };

                Bone.prototype.localToWorld = function (local) {
                  var x = local.x,
                      y = local.y;
                  local.x = x * this.a + y * this.b + this.worldX;
                  local.y = x * this.c + y * this.d + this.worldY;
                  return local;
                };

                Bone.prototype.worldToLocalRotation = function (worldRotation) {
                  var sin = spine.MathUtils.sinDeg(worldRotation),
                      cos = spine.MathUtils.cosDeg(worldRotation);
                  return Math.atan2(this.a * sin - this.c * cos, this.d * cos - this.b * sin) * spine.MathUtils.radDeg + this.rotation - this.shearX;
                };

                Bone.prototype.localToWorldRotation = function (localRotation) {
                  localRotation -= this.rotation - this.shearX;
                  var sin = spine.MathUtils.sinDeg(localRotation),
                      cos = spine.MathUtils.cosDeg(localRotation);
                  return Math.atan2(cos * this.c + sin * this.d, cos * this.a + sin * this.b) * spine.MathUtils.radDeg;
                };

                Bone.prototype.rotateWorld = function (degrees) {
                  var a = this.a,
                      b = this.b,
                      c = this.c,
                      d = this.d;
                  var cos = spine.MathUtils.cosDeg(degrees),
                      sin = spine.MathUtils.sinDeg(degrees);
                  this.a = cos * a - sin * c;
                  this.b = cos * b - sin * d;
                  this.c = sin * a + cos * c;
                  this.d = sin * b + cos * d;
                  this.appliedValid = false;
                };

                return Bone;
              }();

              spine.Bone = Bone;
            })(spine || (spine = {}));

            var spine;

            (function (spine) {
              var BoneData = function () {
                function BoneData(index, name, parent) {
                  this.x = 0;
                  this.y = 0;
                  this.rotation = 0;
                  this.scaleX = 1;
                  this.scaleY = 1;
                  this.shearX = 0;
                  this.shearY = 0;
                  this.transformMode = TransformMode.Normal;
                  this.skinRequired = false;
                  this.color = new spine.Color();
                  if (index < 0) throw new Error("index must be >= 0.");
                  if (name == null) throw new Error("name cannot be null.");
                  this.index = index;
                  this.name = name;
                  this.parent = parent;
                }

                return BoneData;
              }();

              spine.BoneData = BoneData;
              var TransformMode;

              (function (TransformMode) {
                TransformMode[TransformMode["Normal"] = 0] = "Normal";
                TransformMode[TransformMode["OnlyTranslation"] = 1] = "OnlyTranslation";
                TransformMode[TransformMode["NoRotationOrReflection"] = 2] = "NoRotationOrReflection";
                TransformMode[TransformMode["NoScale"] = 3] = "NoScale";
                TransformMode[TransformMode["NoScaleOrReflection"] = 4] = "NoScaleOrReflection";
              })(TransformMode = spine.TransformMode || (spine.TransformMode = {}));
            })(spine || (spine = {}));

            var spine;

            (function (spine) {
              var ConstraintData = function () {
                function ConstraintData(name, order, skinRequired) {
                  this.name = name;
                  this.order = order;
                  this.skinRequired = skinRequired;
                }

                return ConstraintData;
              }();

              spine.ConstraintData = ConstraintData;
            })(spine || (spine = {}));

            var spine;

            (function (spine) {
              var Event = function () {
                function Event(time, data) {
                  if (data == null) throw new Error("data cannot be null.");
                  this.time = time;
                  this.data = data;
                }

                return Event;
              }();

              spine.Event = Event;
            })(spine || (spine = {}));

            var spine;

            (function (spine) {
              var EventData = function () {
                function EventData(name) {
                  this.name = name;
                }

                return EventData;
              }();

              spine.EventData = EventData;
            })(spine || (spine = {}));

            var spine;

            (function (spine) {
              var IkConstraint = function () {
                function IkConstraint(data, skeleton) {
                  this.bendDirection = 0;
                  this.compress = false;
                  this.stretch = false;
                  this.mix = 1;
                  this.softness = 0;
                  this.active = false;
                  if (data == null) throw new Error("data cannot be null.");
                  if (skeleton == null) throw new Error("skeleton cannot be null.");
                  this.data = data;
                  this.mix = data.mix;
                  this.softness = data.softness;
                  this.bendDirection = data.bendDirection;
                  this.compress = data.compress;
                  this.stretch = data.stretch;
                  this.bones = new Array();

                  for (var i = 0; i < data.bones.length; i++) this.bones.push(skeleton.findBone(data.bones[i].name));

                  this.target = skeleton.findBone(data.target.name);
                }

                IkConstraint.prototype.isActive = function () {
                  return this.active;
                };

                IkConstraint.prototype.apply = function () {
                  this.update();
                };

                IkConstraint.prototype.update = function () {
                  var target = this.target;
                  var bones = this.bones;

                  switch (bones.length) {
                    case 1:
                      this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);
                      break;

                    case 2:
                      this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.softness, this.mix);
                      break;
                  }
                };

                IkConstraint.prototype.apply1 = function (bone, targetX, targetY, compress, stretch, uniform, alpha) {
                  if (!bone.appliedValid) bone.updateAppliedTransform();
                  var p = bone.parent;
                  var id = 1 / (p.a * p.d - p.b * p.c);
                  var x = targetX - p.worldX,
                      y = targetY - p.worldY;
                  var tx = (x * p.d - y * p.b) * id - bone.ax,
                      ty = (y * p.a - x * p.c) * id - bone.ay;
                  var rotationIK = Math.atan2(ty, tx) * spine.MathUtils.radDeg - bone.ashearX - bone.arotation;
                  if (bone.ascaleX < 0) rotationIK += 180;
                  if (rotationIK > 180) rotationIK -= 360;else if (rotationIK < -180) rotationIK += 360;
                  var sx = bone.ascaleX,
                      sy = bone.ascaleY;

                  if (compress || stretch) {
                    var b = bone.data.length * sx,
                        dd = Math.sqrt(tx * tx + ty * ty);

                    if (compress && dd < b || stretch && dd > b && b > 0.0001) {
                      var s = (dd / b - 1) * alpha + 1;
                      sx *= s;
                      if (uniform) sy *= s;
                    }
                  }

                  bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX, bone.ashearY);
                };

                IkConstraint.prototype.apply2 = function (parent, child, targetX, targetY, bendDir, stretch, softness, alpha) {
                  if (alpha == 0) {
                    child.updateWorldTransform();
                    return;
                  }

                  if (!parent.appliedValid) parent.updateAppliedTransform();
                  if (!child.appliedValid) child.updateAppliedTransform();
                  var px = parent.ax,
                      py = parent.ay,
                      psx = parent.ascaleX,
                      sx = psx,
                      psy = parent.ascaleY,
                      csx = child.ascaleX;
                  var os1 = 0,
                      os2 = 0,
                      s2 = 0;

                  if (psx < 0) {
                    psx = -psx;
                    os1 = 180;
                    s2 = -1;
                  } else {
                    os1 = 0;
                    s2 = 1;
                  }

                  if (psy < 0) {
                    psy = -psy;
                    s2 = -s2;
                  }

                  if (csx < 0) {
                    csx = -csx;
                    os2 = 180;
                  } else os2 = 0;

                  var cx = child.ax,
                      cy = 0,
                      cwx = 0,
                      cwy = 0,
                      a = parent.a,
                      b = parent.b,
                      c = parent.c,
                      d = parent.d;
                  var u = Math.abs(psx - psy) <= 0.0001;

                  if (!u) {
                    cy = 0;
                    cwx = a * cx + parent.worldX;
                    cwy = c * cx + parent.worldY;
                  } else {
                    cy = child.ay;
                    cwx = a * cx + b * cy + parent.worldX;
                    cwy = c * cx + d * cy + parent.worldY;
                  }

                  var pp = parent.parent;
                  a = pp.a;
                  b = pp.b;
                  c = pp.c;
                  d = pp.d;
                  var id = 1 / (a * d - b * c),
                      x = cwx - pp.worldX,
                      y = cwy - pp.worldY;
                  var dx = (x * d - y * b) * id - px,
                      dy = (y * a - x * c) * id - py;
                  var l1 = Math.sqrt(dx * dx + dy * dy),
                      l2 = child.data.length * csx,
                      a1,
                      a2;

                  if (l1 < 0.0001) {
                    this.apply1(parent, targetX, targetY, false, stretch, false, alpha);
                    child.updateWorldTransformWith(cx, cy, 0, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
                    return;
                  }

                  x = targetX - pp.worldX;
                  y = targetY - pp.worldY;
                  var tx = (x * d - y * b) * id - px,
                      ty = (y * a - x * c) * id - py;
                  var dd = tx * tx + ty * ty;

                  if (softness != 0) {
                    softness *= psx * (csx + 1) / 2;
                    var td = Math.sqrt(dd),
                        sd = td - l1 - l2 * psx + softness;

                    if (sd > 0) {
                      var p = Math.min(1, sd / (softness * 2)) - 1;
                      p = (sd - softness * (1 - p * p)) / td;
                      tx -= p * tx;
                      ty -= p * ty;
                      dd = tx * tx + ty * ty;
                    }
                  }

                  outer: if (u) {
                    l2 *= psx;
                    var cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);
                    if (cos < -1) cos = -1;else if (cos > 1) {
                      cos = 1;
                      if (stretch) sx *= (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;
                    }
                    a2 = Math.acos(cos) * bendDir;
                    a = l1 + l2 * cos;
                    b = l2 * Math.sin(a2);
                    a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);
                  } else {
                    a = psx * l2;
                    b = psy * l2;
                    var aa = a * a,
                        bb = b * b,
                        ta = Math.atan2(ty, tx);
                    c = bb * l1 * l1 + aa * dd - aa * bb;
                    var c1 = -2 * bb * l1,
                        c2 = bb - aa;
                    d = c1 * c1 - 4 * c2 * c;

                    if (d >= 0) {
                      var q = Math.sqrt(d);
                      if (c1 < 0) q = -q;
                      q = -(c1 + q) / 2;
                      var r0 = q / c2,
                          r1 = c / q;
                      var r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;

                      if (r * r <= dd) {
                        y = Math.sqrt(dd - r * r) * bendDir;
                        a1 = ta - Math.atan2(y, r);
                        a2 = Math.atan2(y / psy, (r - l1) / psx);
                        break outer;
                      }
                    }

                    var minAngle = spine.MathUtils.PI,
                        minX = l1 - a,
                        minDist = minX * minX,
                        minY = 0;
                    var maxAngle = 0,
                        maxX = l1 + a,
                        maxDist = maxX * maxX,
                        maxY = 0;
                    c = -a * l1 / (aa - bb);

                    if (c >= -1 && c <= 1) {
                      c = Math.acos(c);
                      x = a * Math.cos(c) + l1;
                      y = b * Math.sin(c);
                      d = x * x + y * y;

                      if (d < minDist) {
                        minAngle = c;
                        minDist = d;
                        minX = x;
                        minY = y;
                      }

                      if (d > maxDist) {
                        maxAngle = c;
                        maxDist = d;
                        maxX = x;
                        maxY = y;
                      }
                    }

                    if (dd <= (minDist + maxDist) / 2) {
                      a1 = ta - Math.atan2(minY * bendDir, minX);
                      a2 = minAngle * bendDir;
                    } else {
                      a1 = ta - Math.atan2(maxY * bendDir, maxX);
                      a2 = maxAngle * bendDir;
                    }
                  }

                  var os = Math.atan2(cy, cx) * s2;
                  var rotation = parent.arotation;
                  a1 = (a1 - os) * spine.MathUtils.radDeg + os1 - rotation;
                  if (a1 > 180) a1 -= 360;else if (a1 < -180) a1 += 360;
                  parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, parent.ascaleY, 0, 0);
                  rotation = child.arotation;
                  a2 = ((a2 + os) * spine.MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;
                  if (a2 > 180) a2 -= 360;else if (a2 < -180) a2 += 360;
                  child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
                };

                return IkConstraint;
              }();

              spine.IkConstraint = IkConstraint;
            })(spine || (spine = {}));

            var spine;

            (function (spine) {
              var IkConstraintData = function (_super) {
                __extends(IkConstraintData, _super);

                function IkConstraintData(name) {
                  var _this = _super.call(this, name, 0, false) || this;

                  _this.bones = new Array();
                  _this.bendDirection = 1;
                  _this.compress = false;
                  _this.stretch = false;
                  _this.uniform = false;
                  _this.mix = 1;
                  _this.softness = 0;
                  return _this;
                }

                return IkConstraintData;
              }(spine.ConstraintData);

              spine.IkConstraintData = IkConstraintData;
            })(spine || (spine = {}));

            var spine;

            (function (spine) {
              var PathConstraint = function () {
                function PathConstraint(data, skeleton) {
                  this.position = 0;
                  this.spacing = 0;
                  this.rotateMix = 0;
                  this.translateMix = 0;
                  this.spaces = new Array();
                  this.positions = new Array();
                  this.world = new Array();
                  this.curves = new Array();
                  this.lengths = new Array();
                  this.segments = new Array();
                  this.active = false;
                  if (data == null) throw new Error("data cannot be null.");
                  if (skeleton == null) throw new Error("skeleton cannot be null.");
                  this.data = data;
                  this.bones = new Array();

                  for (var i = 0, n = data.bones.length; i < n; i++) this.bones.push(skeleton.findBone(data.bones[i].name));

                  this.target = skeleton.findSlot(data.target.name);
                  this.position = data.position;
                  this.spacing = data.spacing;
                  this.rotateMix = data.rotateMix;
                  this.translateMix = data.translateMix;
                }

                PathConstraint.prototype.isActive = function () {
                  return this.active;
                };

                PathConstraint.prototype.apply = function () {
                  this.update();
                };

                PathConstraint.prototype.update = function () {
                  var attachment = this.target.getAttachment();
                  if (!(attachment instanceof spine.PathAttachment)) return;
                  var rotateMix = this.rotateMix,
                      translateMix = this.translateMix;
                  var translate = translateMix > 0,
                      rotate = rotateMix > 0;
                  if (!translate && !rotate) return;
                  var data = this.data;
                  var percentSpacing = data.spacingMode == spine.SpacingMode.Percent;
                  var rotateMode = data.rotateMode;
                  var tangents = rotateMode == spine.RotateMode.Tangent,
                      scale = rotateMode == spine.RotateMode.ChainScale;
                  var boneCount = this.bones.length,
                      spacesCount = tangents ? boneCount : boneCount + 1;
                  var bones = this.bones;
                  var spaces = spine.Utils.setArraySize(this.spaces, spacesCount),
                      lengths = null;
                  var spacing = this.spacing;

                  if (scale || !percentSpacing) {
                    if (scale) lengths = spine.Utils.setArraySize(this.lengths, boneCount);
                    var lengthSpacing = data.spacingMode == spine.SpacingMode.Length;

                    for (var i = 0, n = spacesCount - 1; i < n;) {
                      var bone = bones[i];
                      var setupLength = bone.data.length;

                      if (setupLength < PathConstraint.epsilon) {
                        if (scale) lengths[i] = 0;
                        spaces[++i] = 0;
                      } else if (percentSpacing) {
                        if (scale) {
                          var x = setupLength * bone.a,
                              y = setupLength * bone.c;
                          var length_1 = Math.sqrt(x * x + y * y);
                          lengths[i] = length_1;
                        }

                        spaces[++i] = spacing;
                      } else {
                        var x = setupLength * bone.a,
                            y = setupLength * bone.c;
                        var length_2 = Math.sqrt(x * x + y * y);
                        if (scale) lengths[i] = length_2;
                        spaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length_2 / setupLength;
                      }
                    }
                  } else {
                    for (var i = 1; i < spacesCount; i++) spaces[i] = spacing;
                  }

                  var positions = this.computeWorldPositions(attachment, spacesCount, tangents, data.positionMode == spine.PositionMode.Percent, percentSpacing);
                  var boneX = positions[0],
                      boneY = positions[1],
                      offsetRotation = data.offsetRotation;
                  var tip = false;
                  if (offsetRotation == 0) tip = rotateMode == spine.RotateMode.Chain;else {
                    tip = false;
                    var p = this.target.bone;
                    offsetRotation *= p.a * p.d - p.b * p.c > 0 ? spine.MathUtils.degRad : -spine.MathUtils.degRad;
                  }

                  for (var i = 0, p = 3; i < boneCount; i++, p += 3) {
                    var bone = bones[i];
                    bone.worldX += (boneX - bone.worldX) * translateMix;
                    bone.worldY += (boneY - bone.worldY) * translateMix;
                    var x = positions[p],
                        y = positions[p + 1],
                        dx = x - boneX,
                        dy = y - boneY;

                    if (scale) {
                      var length_3 = lengths[i];

                      if (length_3 != 0) {
                        var s = (Math.sqrt(dx * dx + dy * dy) / length_3 - 1) * rotateMix + 1;
                        bone.a *= s;
                        bone.c *= s;
                      }
                    }

                    boneX = x;
                    boneY = y;

                    if (rotate) {
                      var a = bone.a,
                          b = bone.b,
                          c = bone.c,
                          d = bone.d,
                          r = 0,
                          cos = 0,
                          sin = 0;
                      if (tangents) r = positions[p - 1];else if (spaces[i + 1] == 0) r = positions[p + 2];else r = Math.atan2(dy, dx);
                      r -= Math.atan2(c, a);

                      if (tip) {
                        cos = Math.cos(r);
                        sin = Math.sin(r);
                        var length_4 = bone.data.length;
                        boneX += (length_4 * (cos * a - sin * c) - dx) * rotateMix;
                        boneY += (length_4 * (sin * a + cos * c) - dy) * rotateMix;
                      } else {
                        r += offsetRotation;
                      }

                      if (r > spine.MathUtils.PI) r -= spine.MathUtils.PI2;else if (r < -spine.MathUtils.PI) r += spine.MathUtils.PI2;
                      r *= rotateMix;
                      cos = Math.cos(r);
                      sin = Math.sin(r);
                      bone.a = cos * a - sin * c;
                      bone.b = cos * b - sin * d;
                      bone.c = sin * a + cos * c;
                      bone.d = sin * b + cos * d;
                    }

                    bone.appliedValid = false;
                  }
                };

                PathConstraint.prototype.computeWorldPositions = function (path, spacesCount, tangents, percentPosition, percentSpacing) {
                  var target = this.target;
                  var position = this.position;
                  var spaces = this.spaces,
                      out = spine.Utils.setArraySize(this.positions, spacesCount * 3 + 2),
                      world = null;
                  var closed = path.closed;
                  var verticesLength = path.worldVerticesLength,
                      curveCount = verticesLength / 6,
                      prevCurve = PathConstraint.NONE;

                  if (!path.constantSpeed) {
                    var lengths = path.lengths;
                    curveCount -= closed ? 1 : 2;
                    var pathLength_1 = lengths[curveCount];
                    if (percentPosition) position *= pathLength_1;

                    if (percentSpacing) {
                      for (var i = 1; i < spacesCount; i++) spaces[i] *= pathLength_1;
                    }

                    world = spine.Utils.setArraySize(this.world, 8);

                    for (var i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {
                      var space = spaces[i];
                      position += space;
                      var p = position;

                      if (closed) {
                        p %= pathLength_1;
                        if (p < 0) p += pathLength_1;
                        curve = 0;
                      } else if (p < 0) {
                        if (prevCurve != PathConstraint.BEFORE) {
                          prevCurve = PathConstraint.BEFORE;
                          path.computeWorldVertices(target, 2, 4, world, 0, 2);
                        }

                        this.addBeforePosition(p, world, 0, out, o);
                        continue;
                      } else if (p > pathLength_1) {
                        if (prevCurve != PathConstraint.AFTER) {
                          prevCurve = PathConstraint.AFTER;
                          path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);
                        }

                        this.addAfterPosition(p - pathLength_1, world, 0, out, o);
                        continue;
                      }

                      for (;; curve++) {
                        var length_5 = lengths[curve];
                        if (p > length_5) continue;
                        if (curve == 0) p /= length_5;else {
                          var prev = lengths[curve - 1];
                          p = (p - prev) / (length_5 - prev);
                        }
                        break;
                      }

                      if (curve != prevCurve) {
                        prevCurve = curve;

                        if (closed && curve == curveCount) {
                          path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);
                          path.computeWorldVertices(target, 0, 4, world, 4, 2);
                        } else path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);
                      }

                      this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || i > 0 && space == 0);
                    }

                    return out;
                  }

                  if (closed) {
                    verticesLength += 2;
                    world = spine.Utils.setArraySize(this.world, verticesLength);
                    path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);
                    path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);
                    world[verticesLength - 2] = world[0];
                    world[verticesLength - 1] = world[1];
                  } else {
                    curveCount--;
                    verticesLength -= 4;
                    world = spine.Utils.setArraySize(this.world, verticesLength);
                    path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);
                  }

                  var curves = spine.Utils.setArraySize(this.curves, curveCount);
                  var pathLength = 0;
                  var x1 = world[0],
                      y1 = world[1],
                      cx1 = 0,
                      cy1 = 0,
                      cx2 = 0,
                      cy2 = 0,
                      x2 = 0,
                      y2 = 0;
                  var tmpx = 0,
                      tmpy = 0,
                      dddfx = 0,
                      dddfy = 0,
                      ddfx = 0,
                      ddfy = 0,
                      dfx = 0,
                      dfy = 0;

                  for (var i = 0, w = 2; i < curveCount; i++, w += 6) {
                    cx1 = world[w];
                    cy1 = world[w + 1];
                    cx2 = world[w + 2];
                    cy2 = world[w + 3];
                    x2 = world[w + 4];
                    y2 = world[w + 5];
                    tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;
                    tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;
                    dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;
                    dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;
                    ddfx = tmpx * 2 + dddfx;
                    ddfy = tmpy * 2 + dddfy;
                    dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;
                    dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;
                    pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
                    dfx += ddfx;
                    dfy += ddfy;
                    ddfx += dddfx;
                    ddfy += dddfy;
                    pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
                    dfx += ddfx;
                    dfy += ddfy;
                    pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
                    dfx += ddfx + dddfx;
                    dfy += ddfy + dddfy;
                    pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
                    curves[i] = pathLength;
                    x1 = x2;
                    y1 = y2;
                  }

                  if (percentPosition) position *= pathLength;else position *= pathLength / path.lengths[curveCount - 1];

                  if (percentSpacing) {
                    for (var i = 1; i < spacesCount; i++) spaces[i] *= pathLength;
                  }

                  var segments = this.segments;
                  var curveLength = 0;

                  for (var i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {
                    var space = spaces[i];
                    position += space;
                    var p = position;

                    if (closed) {
                      p %= pathLength;
                      if (p < 0) p += pathLength;
                      curve = 0;
                    } else if (p < 0) {
                      this.addBeforePosition(p, world, 0, out, o);
                      continue;
                    } else if (p > pathLength) {
                      this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);
                      continue;
                    }

                    for (;; curve++) {
                      var length_6 = curves[curve];
                      if (p > length_6) continue;
                      if (curve == 0) p /= length_6;else {
                        var prev = curves[curve - 1];
                        p = (p - prev) / (length_6 - prev);
                      }
                      break;
                    }

                    if (curve != prevCurve) {
                      prevCurve = curve;
                      var ii = curve * 6;
                      x1 = world[ii];
                      y1 = world[ii + 1];
                      cx1 = world[ii + 2];
                      cy1 = world[ii + 3];
                      cx2 = world[ii + 4];
                      cy2 = world[ii + 5];
                      x2 = world[ii + 6];
                      y2 = world[ii + 7];
                      tmpx = (x1 - cx1 * 2 + cx2) * 0.03;
                      tmpy = (y1 - cy1 * 2 + cy2) * 0.03;
                      dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;
                      dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;
                      ddfx = tmpx * 2 + dddfx;
                      ddfy = tmpy * 2 + dddfy;
                      dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;
                      dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;
                      curveLength = Math.sqrt(dfx * dfx + dfy * dfy);
                      segments[0] = curveLength;

                      for (ii = 1; ii < 8; ii++) {
                        dfx += ddfx;
                        dfy += ddfy;
                        ddfx += dddfx;
                        ddfy += dddfy;
                        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
                        segments[ii] = curveLength;
                      }

                      dfx += ddfx;
                      dfy += ddfy;
                      curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
                      segments[8] = curveLength;
                      dfx += ddfx + dddfx;
                      dfy += ddfy + dddfy;
                      curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
                      segments[9] = curveLength;
                      segment = 0;
                    }

                    p *= curveLength;

                    for (;; segment++) {
                      var length_7 = segments[segment];
                      if (p > length_7) continue;
                      if (segment == 0) p /= length_7;else {
                        var prev = segments[segment - 1];
                        p = segment + (p - prev) / (length_7 - prev);
                      }
                      break;
                    }

                    this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || i > 0 && space == 0);
                  }

                  return out;
                };

                PathConstraint.prototype.addBeforePosition = function (p, temp, i, out, o) {
                  var x1 = temp[i],
                      y1 = temp[i + 1],
                      dx = temp[i + 2] - x1,
                      dy = temp[i + 3] - y1,
                      r = Math.atan2(dy, dx);
                  out[o] = x1 + p * Math.cos(r);
                  out[o + 1] = y1 + p * Math.sin(r);
                  out[o + 2] = r;
                };

                PathConstraint.prototype.addAfterPosition = function (p, temp, i, out, o) {
                  var x1 = temp[i + 2],
                      y1 = temp[i + 3],
                      dx = x1 - temp[i],
                      dy = y1 - temp[i + 1],
                      r = Math.atan2(dy, dx);
                  out[o] = x1 + p * Math.cos(r);
                  out[o + 1] = y1 + p * Math.sin(r);
                  out[o + 2] = r;
                };

                PathConstraint.prototype.addCurvePosition = function (p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents) {
                  if (p == 0 || isNaN(p)) {
                    out[o] = x1;
                    out[o + 1] = y1;
                    out[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);
                    return;
                  }

                  var tt = p * p,
                      ttt = tt * p,
                      u = 1 - p,
                      uu = u * u,
                      uuu = uu * u;
                  var ut = u * p,
                      ut3 = ut * 3,
                      uut3 = u * ut3,
                      utt3 = ut3 * p;
                  var x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt,
                      y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;
                  out[o] = x;
                  out[o + 1] = y;

                  if (tangents) {
                    if (p < 0.001) out[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);else out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));
                  }
                };

                PathConstraint.NONE = -1;
                PathConstraint.BEFORE = -2;
                PathConstraint.AFTER = -3;
                PathConstraint.epsilon = 0.00001;
                return PathConstraint;
              }();

              spine.PathConstraint = PathConstraint;
            })(spine || (spine = {}));

            var spine;

            (function (spine) {
              var PathConstraintData = function (_super) {
                __extends(PathConstraintData, _super);

                function PathConstraintData(name) {
                  var _this = _super.call(this, name, 0, false) || this;

                  _this.bones = new Array();
                  return _this;
                }

                return PathConstraintData;
              }(spine.ConstraintData);

              spine.PathConstraintData = PathConstraintData;
              var PositionMode;

              (function (PositionMode) {
                PositionMode[PositionMode["Fixed"] = 0] = "Fixed";
                PositionMode[PositionMode["Percent"] = 1] = "Percent";
              })(PositionMode = spine.PositionMode || (spine.PositionMode = {}));

              var SpacingMode;

              (function (SpacingMode) {
                SpacingMode[SpacingMode["Length"] = 0] = "Length";
                SpacingMode[SpacingMode["Fixed"] = 1] = "Fixed";
                SpacingMode[SpacingMode["Percent"] = 2] = "Percent";
              })(SpacingMode = spine.SpacingMode || (spine.SpacingMode = {}));

              var RotateMode;

              (function (RotateMode) {
                RotateMode[RotateMode["Tangent"] = 0] = "Tangent";
                RotateMode[RotateMode["Chain"] = 1] = "Chain";
                RotateMode[RotateMode["ChainScale"] = 2] = "ChainScale";
              })(RotateMode = spine.RotateMode || (spine.RotateMode = {}));
            })(spine || (spine = {}));

            var spine;

            (function (spine) {
              var Assets = function () {
                function Assets(clientId) {
                  this.toLoad = new Array();
                  this.assets = {};
                  this.clientId = clientId;
                }

                Assets.prototype.loaded = function () {
                  var i = 0;

                  for (var v in this.assets) i++;

                  return i;
                };

                return Assets;
              }();

              var SharedAssetManager = function () {
                function SharedAssetManager(pathPrefix) {
                  if (pathPrefix === void 0) {
                    pathPrefix = "";
                  }

                  this.clientAssets = {};
                  this.queuedAssets = {};
                  this.rawAssets = {};
                  this.errors = {};
                  this.pathPrefix = pathPrefix;
                }

                SharedAssetManager.prototype.queueAsset = function (clientId, textureLoader, path) {
                  var clientAssets = this.clientAssets[clientId];

                  if (clientAssets === null || clientAssets === undefined) {
                    clientAssets = new Assets(clientId);
                    this.clientAssets[clientId] = clientAssets;
                  }

                  if (textureLoader !== null) clientAssets.textureLoader = textureLoader;
                  clientAssets.toLoad.push(path);

                  if (this.queuedAssets[path] === path) {
                    return false;
                  } else {
                    this.queuedAssets[path] = path;
                    return true;
                  }
                };

                SharedAssetManager.prototype.loadText = function (clientId, path) {
                  var _this = this;

                  path = this.pathPrefix + path;
                  if (!this.queueAsset(clientId, null, path)) return;
                  var request = new XMLHttpRequest();

                  request.onreadystatechange = function () {
                    if (request.readyState == XMLHttpRequest.DONE) {
                      if (request.status >= 200 && request.status < 300) {
                        _this.rawAssets[path] = request.responseText;
                      } else {
                        _this.errors[path] = "Couldn't load text " + path + ": status " + request.status + ", " + request.responseText;
                      }
                    }
                  };

                  request.open("GET", path, true);
                  request.send();
                };

                SharedAssetManager.prototype.loadJson = function (clientId, path) {
                  var _this = this;

                  path = this.pathPrefix + path;
                  if (!this.queueAsset(clientId, null, path)) return;
                  var request = new XMLHttpRequest();

                  request.onreadystatechange = function () {
                    if (request.readyState == XMLHttpRequest.DONE) {
                      if (request.status >= 200 && request.status < 300) {
                        _this.rawAssets[path] = JSON.parse(request.responseText);
                      } else {
                        _this.errors[path] = "Couldn't load text " + path + ": status " + request.status + ", " + request.responseText;
                      }
                    }
                  };

                  request.open("GET", path, true);
                  request.send();
                };

                SharedAssetManager.prototype.loadTexture = function (clientId, textureLoader, path) {
                  var _this = this;

                  path = this.pathPrefix + path;
                  if (!this.queueAsset(clientId, textureLoader, path)) return;
                  var img = new Image();
                  img.src = path;
                  img.crossOrigin = "anonymous";

                  img.onload = function (ev) {
                    _this.rawAssets[path] = img;
                  };

                  img.onerror = function (ev) {
                    _this.errors[path] = "Couldn't load image " + path;
                  };
                };

                SharedAssetManager.prototype.get = function (clientId, path) {
                  path = this.pathPrefix + path;
                  var clientAssets = this.clientAssets[clientId];
                  if (clientAssets === null || clientAssets === undefined) return true;
                  return clientAssets.assets[path];
                };

                SharedAssetManager.prototype.updateClientAssets = function (clientAssets) {
                  for (var i = 0; i < clientAssets.toLoad.length; i++) {
                    var path = clientAssets.toLoad[i];
                    var asset = clientAssets.assets[path];

                    if (asset === null || asset === undefined) {
                      var rawAsset = this.rawAssets[path];
                      if (rawAsset === null || rawAsset === undefined) continue;

                      if (rawAsset instanceof HTMLImageElement) {
                        clientAssets.assets[path] = clientAssets.textureLoader(rawAsset);
                      } else {
                        clientAssets.assets[path] = rawAsset;
                      }
                    }
                  }
                };

                SharedAssetManager.prototype.isLoadingComplete = function (clientId) {
                  var clientAssets = this.clientAssets[clientId];
                  if (clientAssets === null || clientAssets === undefined) return true;
                  this.updateClientAssets(clientAssets);
                  return clientAssets.toLoad.length == clientAssets.loaded();
                };

                SharedAssetManager.prototype.dispose = function () {};

                SharedAssetManager.prototype.hasErrors = function () {
                  return Object.keys(this.errors).length > 0;
                };

                SharedAssetManager.prototype.getErrors = function () {
                  return this.errors;
                };

                return SharedAssetManager;
              }();

              spine.SharedAssetManager = SharedAssetManager;
            })(spine || (spine = {}));

            var spine;

            (function (spine) {
              var Skeleton = function () {
                function Skeleton(data) {
                  this._updateCache = new Array();
                  this.updateCacheReset = new Array();
                  this.time = 0;
                  this.scaleX = 1;
                  this.scaleY = 1;
                  this.x = 0;
                  this.y = 0;
                  if (data == null) throw new Error("data cannot be null.");
                  this.data = data;
                  this.bones = new Array();

                  for (var i = 0; i < data.bones.length; i++) {
                    var boneData = data.bones[i];
                    var bone = void 0;
                    if (boneData.parent == null) bone = new spine.Bone(boneData, this, null);else {
                      var parent_1 = this.bones[boneData.parent.index];
                      bone = new spine.Bone(boneData, this, parent_1);
                      parent_1.children.push(bone);
                    }
                    this.bones.push(bone);
                  }

                  this.slots = new Array();
                  this.drawOrder = new Array();

                  for (var i = 0; i < data.slots.length; i++) {
                    var slotData = data.slots[i];
                    var bone = this.bones[slotData.boneData.index];
                    var slot = new spine.Slot(slotData, bone);
                    this.slots.push(slot);
                    this.drawOrder.push(slot);
                  }

                  this.ikConstraints = new Array();

                  for (var i = 0; i < data.ikConstraints.length; i++) {
                    var ikConstraintData = data.ikConstraints[i];
                    this.ikConstraints.push(new spine.IkConstraint(ikConstraintData, this));
                  }

                  this.transformConstraints = new Array();

                  for (var i = 0; i < data.transformConstraints.length; i++) {
                    var transformConstraintData = data.transformConstraints[i];
                    this.transformConstraints.push(new spine.TransformConstraint(transformConstraintData, this));
                  }

                  this.pathConstraints = new Array();

                  for (var i = 0; i < data.pathConstraints.length; i++) {
                    var pathConstraintData = data.pathConstraints[i];
                    this.pathConstraints.push(new spine.PathConstraint(pathConstraintData, this));
                  }

                  this.color = new spine.Color(1, 1, 1, 1);
                  this.updateCache();
                }

                Skeleton.prototype.updateCache = function () {
                  var updateCache = this._updateCache;
                  updateCache.length = 0;
                  this.updateCacheReset.length = 0;
                  var bones = this.bones;

                  for (var i = 0, n = bones.length; i < n; i++) {
                    var bone = bones[i];
                    bone.sorted = bone.data.skinRequired;
                    bone.active = !bone.sorted;
                  }

                  if (this.skin != null) {
                    var skinBones = this.skin.bones;

                    for (var i = 0, n = this.skin.bones.length; i < n; i++) {
                      var bone = this.bones[skinBones[i].index];

                      do {
                        bone.sorted = false;
                        bone.active = true;
                        bone = bone.parent;
                      } while (bone != null);
                    }
                  }

                  var ikConstraints = this.ikConstraints;
                  var transformConstraints = this.transformConstraints;
                  var pathConstraints = this.pathConstraints;
                  var ikCount = ikConstraints.length,
                      transformCount = transformConstraints.length,
                      pathCount = pathConstraints.length;
                  var constraintCount = ikCount + transformCount + pathCount;

                  outer: for (var i = 0; i < constraintCount; i++) {
                    for (var ii = 0; ii < ikCount; ii++) {
                      var constraint = ikConstraints[ii];

                      if (constraint.data.order == i) {
                        this.sortIkConstraint(constraint);
                        continue outer;
                      }
                    }

                    for (var ii = 0; ii < transformCount; ii++) {
                      var constraint = transformConstraints[ii];

                      if (constraint.data.order == i) {
                        this.sortTransformConstraint(constraint);
                        continue outer;
                      }
                    }

                    for (var ii = 0; ii < pathCount; ii++) {
                      var constraint = pathConstraints[ii];

                      if (constraint.data.order == i) {
                        this.sortPathConstraint(constraint);
                        continue outer;
                      }
                    }
                  }

                  for (var i = 0, n = bones.length; i < n; i++) this.sortBone(bones[i]);
                };

                Skeleton.prototype.sortIkConstraint = function (constraint) {
                  constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || this.skin != null && spine.Utils.contains(this.skin.constraints, constraint.data, true));
                  if (!constraint.active) return;
                  var target = constraint.target;
                  this.sortBone(target);
                  var constrained = constraint.bones;
                  var parent = constrained[0];
                  this.sortBone(parent);

                  if (constrained.length > 1) {
                    var child = constrained[constrained.length - 1];
                    if (!(this._updateCache.indexOf(child) > -1)) this.updateCacheReset.push(child);
                  }

                  this._updateCache.push(constraint);

                  this.sortReset(parent.children);
                  constrained[constrained.length - 1].sorted = true;
                };

                Skeleton.prototype.sortPathConstraint = function (constraint) {
                  constraint.active = constraint.target.bone.isActive() && (!constraint.data.skinRequired || this.skin != null && spine.Utils.contains(this.skin.constraints, constraint.data, true));
                  if (!constraint.active) return;
                  var slot = constraint.target;
                  var slotIndex = slot.data.index;
                  var slotBone = slot.bone;
                  if (this.skin != null) this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);
                  if (this.data.defaultSkin != null && this.data.defaultSkin != this.skin) this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);

                  for (var i = 0, n = this.data.skins.length; i < n; i++) this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);

                  var attachment = slot.getAttachment();
                  if (attachment instanceof spine.PathAttachment) this.sortPathConstraintAttachmentWith(attachment, slotBone);
                  var constrained = constraint.bones;
                  var boneCount = constrained.length;

                  for (var i = 0; i < boneCount; i++) this.sortBone(constrained[i]);

                  this._updateCache.push(constraint);

                  for (var i = 0; i < boneCount; i++) this.sortReset(constrained[i].children);

                  for (var i = 0; i < boneCount; i++) constrained[i].sorted = true;
                };

                Skeleton.prototype.sortTransformConstraint = function (constraint) {
                  constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || this.skin != null && spine.Utils.contains(this.skin.constraints, constraint.data, true));
                  if (!constraint.active) return;
                  this.sortBone(constraint.target);
                  var constrained = constraint.bones;
                  var boneCount = constrained.length;

                  if (constraint.data.local) {
                    for (var i = 0; i < boneCount; i++) {
                      var child = constrained[i];
                      this.sortBone(child.parent);
                      if (!(this._updateCache.indexOf(child) > -1)) this.updateCacheReset.push(child);
                    }
                  } else {
                    for (var i = 0; i < boneCount; i++) {
                      this.sortBone(constrained[i]);
                    }
                  }

                  this._updateCache.push(constraint);

                  for (var ii = 0; ii < boneCount; ii++) this.sortReset(constrained[ii].children);

                  for (var ii = 0; ii < boneCount; ii++) constrained[ii].sorted = true;
                };

                Skeleton.prototype.sortPathConstraintAttachment = function (skin, slotIndex, slotBone) {
                  var attachments = skin.attachments[slotIndex];
                  if (!attachments) return;

                  for (var key in attachments) {
                    this.sortPathConstraintAttachmentWith(attachments[key], slotBone);
                  }
                };

                Skeleton.prototype.sortPathConstraintAttachmentWith = function (attachment, slotBone) {
                  if (!(attachment instanceof spine.PathAttachment)) return;
                  var pathBones = attachment.bones;
                  if (pathBones == null) this.sortBone(slotBone);else {
                    var bones = this.bones;
                    var i = 0;

                    while (i < pathBones.length) {
                      var boneCount = pathBones[i++];

                      for (var n = i + boneCount; i < n; i++) {
                        var boneIndex = pathBones[i];
                        this.sortBone(bones[boneIndex]);
                      }
                    }
                  }
                };

                Skeleton.prototype.sortBone = function (bone) {
                  if (bone.sorted) return;
                  var parent = bone.parent;
                  if (parent != null) this.sortBone(parent);
                  bone.sorted = true;

                  this._updateCache.push(bone);
                };

                Skeleton.prototype.sortReset = function (bones) {
                  for (var i = 0, n = bones.length; i < n; i++) {
                    var bone = bones[i];
                    if (!bone.active) continue;
                    if (bone.sorted) this.sortReset(bone.children);
                    bone.sorted = false;
                  }
                };

                Skeleton.prototype.updateWorldTransform = function () {
                  var updateCacheReset = this.updateCacheReset;

                  for (var i = 0, n = updateCacheReset.length; i < n; i++) {
                    var bone = updateCacheReset[i];
                    bone.ax = bone.x;
                    bone.ay = bone.y;
                    bone.arotation = bone.rotation;
                    bone.ascaleX = bone.scaleX;
                    bone.ascaleY = bone.scaleY;
                    bone.ashearX = bone.shearX;
                    bone.ashearY = bone.shearY;
                    bone.appliedValid = true;
                  }

                  var updateCache = this._updateCache;

                  for (var i = 0, n = updateCache.length; i < n; i++) updateCache[i].update();
                };

                Skeleton.prototype.setToSetupPose = function () {
                  this.setBonesToSetupPose();
                  this.setSlotsToSetupPose();
                };

                Skeleton.prototype.setBonesToSetupPose = function () {
                  var bones = this.bones;

                  for (var i = 0, n = bones.length; i < n; i++) bones[i].setToSetupPose();

                  var ikConstraints = this.ikConstraints;

                  for (var i = 0, n = ikConstraints.length; i < n; i++) {
                    var constraint = ikConstraints[i];
                    constraint.mix = constraint.data.mix;
                    constraint.softness = constraint.data.softness;
                    constraint.bendDirection = constraint.data.bendDirection;
                    constraint.compress = constraint.data.compress;
                    constraint.stretch = constraint.data.stretch;
                  }

                  var transformConstraints = this.transformConstraints;

                  for (var i = 0, n = transformConstraints.length; i < n; i++) {
                    var constraint = transformConstraints[i];
                    var data = constraint.data;
                    constraint.rotateMix = data.rotateMix;
                    constraint.translateMix = data.translateMix;
                    constraint.scaleMix = data.scaleMix;
                    constraint.shearMix = data.shearMix;
                  }

                  var pathConstraints = this.pathConstraints;

                  for (var i = 0, n = pathConstraints.length; i < n; i++) {
                    var constraint = pathConstraints[i];
                    var data = constraint.data;
                    constraint.position = data.position;
                    constraint.spacing = data.spacing;
                    constraint.rotateMix = data.rotateMix;
                    constraint.translateMix = data.translateMix;
                  }
                };

                Skeleton.prototype.setSlotsToSetupPose = function () {
                  var slots = this.slots;
                  spine.Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);

                  for (var i = 0, n = slots.length; i < n; i++) slots[i].setToSetupPose();
                };

                Skeleton.prototype.getRootBone = function () {
                  if (this.bones.length == 0) return null;
                  return this.bones[0];
                };

                Skeleton.prototype.findBone = function (boneName) {
                  if (boneName == null) throw new Error("boneName cannot be null.");
                  var bones = this.bones;

                  for (var i = 0, n = bones.length; i < n; i++) {
                    var bone = bones[i];
                    if (bone.data.name == boneName) return bone;
                  }

                  return null;
                };

                Skeleton.prototype.findBoneIndex = function (boneName) {
                  if (boneName == null) throw new Error("boneName cannot be null.");
                  var bones = this.bones;

                  for (var i = 0, n = bones.length; i < n; i++) if (bones[i].data.name == boneName) return i;

                  return -1;
                };

                Skeleton.prototype.findSlot = function (slotName) {
                  if (slotName == null) throw new Error("slotName cannot be null.");
                  var slots = this.slots;

                  for (var i = 0, n = slots.length; i < n; i++) {
                    var slot = slots[i];
                    if (slot.data.name == slotName) return slot;
                  }

                  return null;
                };

                Skeleton.prototype.findSlotIndex = function (slotName) {
                  if (slotName == null) throw new Error("slotName cannot be null.");
                  var slots = this.slots;

                  for (var i = 0, n = slots.length; i < n; i++) if (slots[i].data.name == slotName) return i;

                  return -1;
                };

                Skeleton.prototype.setSkinByName = function (skinName) {
                  var skin = this.data.findSkin(skinName);
                  if (skin == null) throw new Error("Skin not found: " + skinName);
                  this.setSkin(skin);
                };

                Skeleton.prototype.setSkin = function (newSkin) {
                  if (newSkin == this.skin) return;

                  if (newSkin != null) {
                    if (this.skin != null) newSkin.attachAll(this, this.skin);else {
                      var slots = this.slots;

                      for (var i = 0, n = slots.length; i < n; i++) {
                        var slot = slots[i];
                        var name_1 = slot.data.attachmentName;

                        if (name_1 != null) {
                          var attachment = newSkin.getAttachment(i, name_1);
                          if (attachment != null) slot.setAttachment(attachment);
                        }
                      }
                    }
                  }

                  this.skin = newSkin;
                  this.updateCache();
                };

                Skeleton.prototype.getAttachmentByName = function (slotName, attachmentName) {
                  return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);
                };

                Skeleton.prototype.getAttachment = function (slotIndex, attachmentName) {
                  if (attachmentName == null) throw new Error("attachmentName cannot be null.");

                  if (this.skin != null) {
                    var attachment = this.skin.getAttachment(slotIndex, attachmentName);
                    if (attachment != null) return attachment;
                  }

                  if (this.data.defaultSkin != null) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);
                  return null;
                };

                Skeleton.prototype.setAttachment = function (slotName, attachmentName) {
                  if (slotName == null) throw new Error("slotName cannot be null.");
                  var slots = this.slots;

                  for (var i = 0, n = slots.length; i < n; i++) {
                    var slot = slots[i];

                    if (slot.data.name == slotName) {
                      var attachment = null;

                      if (attachmentName != null) {
                        attachment = this.getAttachment(i, attachmentName);
                        if (attachment == null) throw new Error("Attachment not found: " + attachmentName + ", for slot: " + slotName);
                      }

                      slot.setAttachment(attachment);
                      return;
                    }
                  }

                  throw new Error("Slot not found: " + slotName);
                };

                Skeleton.prototype.findIkConstraint = function (constraintName) {
                  if (constraintName == null) throw new Error("constraintName cannot be null.");
                  var ikConstraints = this.ikConstraints;

                  for (var i = 0, n = ikConstraints.length; i < n; i++) {
                    var ikConstraint = ikConstraints[i];
                    if (ikConstraint.data.name == constraintName) return ikConstraint;
                  }

                  return null;
                };

                Skeleton.prototype.findTransformConstraint = function (constraintName) {
                  if (constraintName == null) throw new Error("constraintName cannot be null.");
                  var transformConstraints = this.transformConstraints;

                  for (var i = 0, n = transformConstraints.length; i < n; i++) {
                    var constraint = transformConstraints[i];
                    if (constraint.data.name == constraintName) return constraint;
                  }

                  return null;
                };

                Skeleton.prototype.findPathConstraint = function (constraintName) {
                  if (constraintName == null) throw new Error("constraintName cannot be null.");
                  var pathConstraints = this.pathConstraints;

                  for (var i = 0, n = pathConstraints.length; i < n; i++) {
                    var constraint = pathConstraints[i];
                    if (constraint.data.name == constraintName) return constraint;
                  }

                  return null;
                };

                Skeleton.prototype.getBounds = function (offset, size, temp) {
                  if (temp === void 0) {
                    temp = new Array(2);
                  }

                  if (offset == null) throw new Error("offset cannot be null.");
                  if (size == null) throw new Error("size cannot be null.");
                  var drawOrder = this.drawOrder;
                  var minX = Number.POSITIVE_INFINITY,
                      minY = Number.POSITIVE_INFINITY,
                      maxX = Number.NEGATIVE_INFINITY,
                      maxY = Number.NEGATIVE_INFINITY;

                  for (var i = 0, n = drawOrder.length; i < n; i++) {
                    var slot = drawOrder[i];
                    if (!slot.bone.active) continue;
                    var verticesLength = 0;
                    var vertices = null;
                    var attachment = slot.getAttachment();

                    if (attachment instanceof spine.RegionAttachment) {
                      verticesLength = 8;
                      vertices = spine.Utils.setArraySize(temp, verticesLength, 0);
                      attachment.computeWorldVertices(slot.bone, vertices, 0, 2);
                    } else if (attachment instanceof spine.MeshAttachment) {
                      var mesh = attachment;
                      verticesLength = mesh.worldVerticesLength;
                      vertices = spine.Utils.setArraySize(temp, verticesLength, 0);
                      mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);
                    }

                    if (vertices != null) {
                      for (var ii = 0, nn = vertices.length; ii < nn; ii += 2) {
                        var x = vertices[ii],
                            y = vertices[ii + 1];
                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        maxX = Math.max(maxX, x);
                        maxY = Math.max(maxY, y);
                      }
                    }
                  }

                  offset.set(minX, minY);
                  size.set(maxX - minX, maxY - minY);
                };

                Skeleton.prototype.update = function (delta) {
                  this.time += delta;
                };

                return Skeleton;
              }();

              spine.Skeleton = Skeleton;
            })(spine || (spine = {}));

            var spine;

            (function (spine) {
              var SkeletonBinary = function () {
                function SkeletonBinary(attachmentLoader) {
                  this.scale = 1;
                  this.linkedMeshes = new Array();
                  this.attachmentLoader = attachmentLoader;
                }

                SkeletonBinary.prototype.readSkeletonData = function (binary) {
                  var scale = this.scale;
                  var skeletonData = new spine.SkeletonData();
                  skeletonData.name = "";
                  var input = new BinaryInput(binary);
                  skeletonData.hash = input.readString();
                  skeletonData.version = input.readString();
                  skeletonData.x = input.readFloat();
                  skeletonData.y = input.readFloat();
                  skeletonData.width = input.readFloat();
                  skeletonData.height = input.readFloat();
                  var nonessential = input.readBoolean();

                  if (nonessential) {
                    skeletonData.fps = input.readFloat();
                    skeletonData.imagesPath = input.readString();
                    skeletonData.audioPath = input.readString();
                  }

                  var n = 0;
                  n = input.readInt(true);

                  for (var i = 0; i < n; i++) input.strings.push(input.readString());

                  n = input.readInt(true);

                  for (var i = 0; i < n; i++) {
                    var name_2 = input.readString();
                    var parent_2 = i == 0 ? null : skeletonData.bones[input.readInt(true)];
                    var data = new spine.BoneData(i, name_2, parent_2);
                    data.rotation = input.readFloat();
                    data.x = input.readFloat() * scale;
                    data.y = input.readFloat() * scale;
                    data.scaleX = input.readFloat();
                    data.scaleY = input.readFloat();
                    data.shearX = input.readFloat();
                    data.shearY = input.readFloat();
                    data.length = input.readFloat() * scale;
                    data.transformMode = SkeletonBinary.TransformModeValues[input.readInt(true)];
                    data.skinRequired = input.readBoolean();
                    if (nonessential) spine.Color.rgba8888ToColor(data.color, input.readInt32());
                    skeletonData.bones.push(data);
                  }

                  n = input.readInt(true);

                  for (var i = 0; i < n; i++) {
                    var slotName = input.readString();
                    var boneData = skeletonData.bones[input.readInt(true)];
                    var data = new spine.SlotData(i, slotName, boneData);
                    spine.Color.rgba8888ToColor(data.color, input.readInt32());
                    var darkColor = input.readInt32();
                    if (darkColor != -1) spine.Color.rgb888ToColor(data.darkColor = new spine.Color(), darkColor);
                    data.attachmentName = input.readStringRef();
                    data.blendMode = SkeletonBinary.BlendModeValues[input.readInt(true)];
                    skeletonData.slots.push(data);
                  }

                  n = input.readInt(true);

                  for (var i = 0, nn = void 0; i < n; i++) {
                    var data = new spine.IkConstraintData(input.readString());
                    data.order = input.readInt(true);
                    data.skinRequired = input.readBoolean();
                    nn = input.readInt(true);

                    for (var ii = 0; ii < nn; ii++) data.bones.push(skeletonData.bones[input.readInt(true)]);

                    data.target = skeletonData.bones[input.readInt(true)];
                    data.mix = input.readFloat();
                    data.softness = input.readFloat() * scale;
                    data.bendDirection = input.readByte();
                    data.compress = input.readBoolean();
                    data.stretch = input.readBoolean();
                    data.uniform = input.readBoolean();
                    skeletonData.ikConstraints.push(data);
                  }

                  n = input.readInt(true);

                  for (var i = 0, nn = void 0; i < n; i++) {
                    var data = new spine.TransformConstraintData(input.readString());
                    data.order = input.readInt(true);
                    data.skinRequired = input.readBoolean();
                    nn = input.readInt(true);

                    for (var ii = 0; ii < nn; ii++) data.bones.push(skeletonData.bones[input.readInt(true)]);

                    data.target = skeletonData.bones[input.readInt(true)];
                    data.local = input.readBoolean();
                    data.relative = input.readBoolean();
                    data.offsetRotation = input.readFloat();
                    data.offsetX = input.readFloat() * scale;
                    data.offsetY = input.readFloat() * scale;
                    data.offsetScaleX = input.readFloat();
                    data.offsetScaleY = input.readFloat();
                    data.offsetShearY = input.readFloat();
                    data.rotateMix = input.readFloat();
                    data.translateMix = input.readFloat();
                    data.scaleMix = input.readFloat();
                    data.shearMix = input.readFloat();
                    skeletonData.transformConstraints.push(data);
                  }

                  n = input.readInt(true);

                  for (var i = 0, nn = void 0; i < n; i++) {
                    var data = new spine.PathConstraintData(input.readString());
                    data.order = input.readInt(true);
                    data.skinRequired = input.readBoolean();
                    nn = input.readInt(true);

                    for (var ii = 0; ii < nn; ii++) data.bones.push(skeletonData.bones[input.readInt(true)]);

                    data.target = skeletonData.slots[input.readInt(true)];
                    data.positionMode = SkeletonBinary.PositionModeValues[input.readInt(true)];
                    data.spacingMode = SkeletonBinary.SpacingModeValues[input.readInt(true)];
                    data.rotateMode = SkeletonBinary.RotateModeValues[input.readInt(true)];
                    data.offsetRotation = input.readFloat();
                    data.position = input.readFloat();
                    if (data.positionMode == spine.PositionMode.Fixed) data.position *= scale;
                    data.spacing = input.readFloat();
                    if (data.spacingMode == spine.SpacingMode.Length || data.spacingMode == spine.SpacingMode.Fixed) data.spacing *= scale;
                    data.rotateMix = input.readFloat();
                    data.translateMix = input.readFloat();
                    skeletonData.pathConstraints.push(data);
                  }

                  var defaultSkin = this.readSkin(input, skeletonData, true, nonessential);

                  if (defaultSkin != null) {
                    skeletonData.defaultSkin = defaultSkin;
                    skeletonData.skins.push(defaultSkin);
                  }

                  {
                    var i = skeletonData.skins.length;
                    spine.Utils.setArraySize(skeletonData.skins, n = i + input.readInt(true));

                    for (; i < n; i++) skeletonData.skins[i] = this.readSkin(input, skeletonData, false, nonessential);
                  }
                  n = this.linkedMeshes.length;

                  for (var i = 0; i < n; i++) {
                    var linkedMesh = this.linkedMeshes[i];
                    var skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);
                    if (skin == null) throw new Error("Skin not found: " + linkedMesh.skin);
                    var parent_3 = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);
                    if (parent_3 == null) throw new Error("Parent mesh not found: " + linkedMesh.parent);
                    linkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? parent_3 : linkedMesh.mesh;
                    linkedMesh.mesh.setParentMesh(parent_3);
                    linkedMesh.mesh.updateUVs();
                  }

                  this.linkedMeshes.length = 0;
                  n = input.readInt(true);

                  for (var i = 0; i < n; i++) {
                    var data = new spine.EventData(input.readStringRef());
                    data.intValue = input.readInt(false);
                    data.floatValue = input.readFloat();
                    data.stringValue = input.readString();
                    data.audioPath = input.readString();

                    if (data.audioPath != null) {
                      data.volume = input.readFloat();
                      data.balance = input.readFloat();
                    }

                    skeletonData.events.push(data);
                  }

                  n = input.readInt(true);

                  for (var i = 0; i < n; i++) skeletonData.animations.push(this.readAnimation(input, input.readString(), skeletonData));

                  return skeletonData;
                };

                SkeletonBinary.prototype.readSkin = function (input, skeletonData, defaultSkin, nonessential) {
                  var skin = null;
                  var slotCount = 0;

                  if (defaultSkin) {
                    slotCount = input.readInt(true);
                    if (slotCount == 0) return null;
                    skin = new spine.Skin("default");
                  } else {
                    skin = new spine.Skin(input.readStringRef());
                    skin.bones.length = input.readInt(true);

                    for (var i = 0, n = skin.bones.length; i < n; i++) skin.bones[i] = skeletonData.bones[input.readInt(true)];

                    for (var i = 0, n = input.readInt(true); i < n; i++) skin.constraints.push(skeletonData.ikConstraints[input.readInt(true)]);

                    for (var i = 0, n = input.readInt(true); i < n; i++) skin.constraints.push(skeletonData.transformConstraints[input.readInt(true)]);

                    for (var i = 0, n = input.readInt(true); i < n; i++) skin.constraints.push(skeletonData.pathConstraints[input.readInt(true)]);

                    slotCount = input.readInt(true);
                  }

                  for (var i = 0; i < slotCount; i++) {
                    var slotIndex = input.readInt(true);

                    for (var ii = 0, nn = input.readInt(true); ii < nn; ii++) {
                      var name_3 = input.readStringRef();
                      var attachment = this.readAttachment(input, skeletonData, skin, slotIndex, name_3, nonessential);
                      if (attachment != null) skin.setAttachment(slotIndex, name_3, attachment);
                    }
                  }

                  return skin;
                };

                SkeletonBinary.prototype.readAttachment = function (input, skeletonData, skin, slotIndex, attachmentName, nonessential) {
                  var scale = this.scale;
                  var name = input.readStringRef();
                  if (name == null) name = attachmentName;
                  var typeIndex = input.readByte();
                  var type = SkeletonBinary.AttachmentTypeValues[typeIndex];

                  switch (type) {
                    case spine.AttachmentType.Region:
                      {
                        var path = input.readStringRef();
                        var rotation = input.readFloat();
                        var x = input.readFloat();
                        var y = input.readFloat();
                        var scaleX = input.readFloat();
                        var scaleY = input.readFloat();
                        var width = input.readFloat();
                        var height = input.readFloat();
                        var color = input.readInt32();
                        if (path == null) path = name;
                        var region = this.attachmentLoader.newRegionAttachment(skin, name, path);
                        if (region == null) return null;
                        region.path = path;
                        region.x = x * scale;
                        region.y = y * scale;
                        region.scaleX = scaleX;
                        region.scaleY = scaleY;
                        region.rotation = rotation;
                        region.width = width * scale;
                        region.height = height * scale;
                        spine.Color.rgba8888ToColor(region.color, color);
                        region.updateOffset();
                        return region;
                      }

                    case spine.AttachmentType.BoundingBox:
                      {
                        var vertexCount = input.readInt(true);
                        var vertices = this.readVertices(input, vertexCount);
                        var color = nonessential ? input.readInt32() : 0;
                        var box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);
                        if (box == null) return null;
                        box.worldVerticesLength = vertexCount << 1;
                        box.vertices = vertices.vertices;
                        box.bones = vertices.bones;
                        if (nonessential) spine.Color.rgba8888ToColor(box.color, color);
                        return box;
                      }

                    case spine.AttachmentType.Mesh:
                      {
                        var path = input.readStringRef();
                        var color = input.readInt32();
                        var vertexCount = input.readInt(true);
                        var uvs = this.readFloatArray(input, vertexCount << 1, 1);
                        var triangles = this.readShortArray(input);
                        var vertices = this.readVertices(input, vertexCount);
                        var hullLength = input.readInt(true);
                        var edges = null;
                        var width = 0,
                            height = 0;

                        if (nonessential) {
                          edges = this.readShortArray(input);
                          width = input.readFloat();
                          height = input.readFloat();
                        }

                        if (path == null) path = name;
                        var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);
                        if (mesh == null) return null;
                        mesh.path = path;
                        spine.Color.rgba8888ToColor(mesh.color, color);
                        mesh.bones = vertices.bones;
                        mesh.vertices = vertices.vertices;
                        mesh.worldVerticesLength = vertexCount << 1;
                        mesh.triangles = triangles;
                        mesh.regionUVs = uvs;
                        mesh.updateUVs();
                        mesh.hullLength = hullLength << 1;

                        if (nonessential) {
                          mesh.edges = edges;
                          mesh.width = width * scale;
                          mesh.height = height * scale;
                        }

                        return mesh;
                      }

                    case spine.AttachmentType.LinkedMesh:
                      {
                        var path = input.readStringRef();
                        var color = input.readInt32();
                        var skinName = input.readStringRef();
                        var parent_4 = input.readStringRef();
                        var inheritDeform = input.readBoolean();
                        var width = 0,
                            height = 0;

                        if (nonessential) {
                          width = input.readFloat();
                          height = input.readFloat();
                        }

                        if (path == null) path = name;
                        var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);
                        if (mesh == null) return null;
                        mesh.path = path;
                        spine.Color.rgba8888ToColor(mesh.color, color);

                        if (nonessential) {
                          mesh.width = width * scale;
                          mesh.height = height * scale;
                        }

                        this.linkedMeshes.push(new LinkedMesh(mesh, skinName, slotIndex, parent_4, inheritDeform));
                        return mesh;
                      }

                    case spine.AttachmentType.Path:
                      {
                        var closed_1 = input.readBoolean();
                        var constantSpeed = input.readBoolean();
                        var vertexCount = input.readInt(true);
                        var vertices = this.readVertices(input, vertexCount);
                        var lengths = spine.Utils.newArray(vertexCount / 3, 0);

                        for (var i = 0, n = lengths.length; i < n; i++) lengths[i] = input.readFloat() * scale;

                        var color = nonessential ? input.readInt32() : 0;
                        var path = this.attachmentLoader.newPathAttachment(skin, name);
                        if (path == null) return null;
                        path.closed = closed_1;
                        path.constantSpeed = constantSpeed;
                        path.worldVerticesLength = vertexCount << 1;
                        path.vertices = vertices.vertices;
                        path.bones = vertices.bones;
                        path.lengths = lengths;
                        if (nonessential) spine.Color.rgba8888ToColor(path.color, color);
                        return path;
                      }

                    case spine.AttachmentType.Point:
                      {
                        var rotation = input.readFloat();
                        var x = input.readFloat();
                        var y = input.readFloat();
                        var color = nonessential ? input.readInt32() : 0;
                        var point = this.attachmentLoader.newPointAttachment(skin, name);
                        if (point == null) return null;
                        point.x = x * scale;
                        point.y = y * scale;
                        point.rotation = rotation;
                        if (nonessential) spine.Color.rgba8888ToColor(point.color, color);
                        return point;
                      }

                    case spine.AttachmentType.Clipping:
                      {
                        var endSlotIndex = input.readInt(true);
                        var vertexCount = input.readInt(true);
                        var vertices = this.readVertices(input, vertexCount);
                        var color = nonessential ? input.readInt32() : 0;
                        var clip = this.attachmentLoader.newClippingAttachment(skin, name);
                        if (clip == null) return null;
                        clip.endSlot = skeletonData.slots[endSlotIndex];
                        clip.worldVerticesLength = vertexCount << 1;
                        clip.vertices = vertices.vertices;
                        clip.bones = vertices.bones;
                        if (nonessential) spine.Color.rgba8888ToColor(clip.color, color);
                        return clip;
                      }
                  }

                  return null;
                };

                SkeletonBinary.prototype.readVertices = function (input, vertexCount) {
                  var verticesLength = vertexCount << 1;
                  var vertices = new Vertices();
                  var scale = this.scale;

                  if (!input.readBoolean()) {
                    vertices.vertices = this.readFloatArray(input, verticesLength, scale);
                    return vertices;
                  }

                  var weights = new Array();
                  var bonesArray = new Array();

                  for (var i = 0; i < vertexCount; i++) {
                    var boneCount = input.readInt(true);
                    bonesArray.push(boneCount);

                    for (var ii = 0; ii < boneCount; ii++) {
                      bonesArray.push(input.readInt(true));
                      weights.push(input.readFloat() * scale);
                      weights.push(input.readFloat() * scale);
                      weights.push(input.readFloat());
                    }
                  }

                  vertices.vertices = spine.Utils.toFloatArray(weights);
                  vertices.bones = bonesArray;
                  return vertices;
                };

                SkeletonBinary.prototype.readFloatArray = function (input, n, scale) {
                  var array = new Array(n);

                  if (scale == 1) {
                    for (var i = 0; i < n; i++) array[i] = input.readFloat();
                  } else {
                    for (var i = 0; i < n; i++) array[i] = input.readFloat() * scale;
                  }

                  return array;
                };

                SkeletonBinary.prototype.readShortArray = function (input) {
                  var n = input.readInt(true);
                  var array = new Array(n);

                  for (var i = 0; i < n; i++) array[i] = input.readShort();

                  return array;
                };

                SkeletonBinary.prototype.readAnimation = function (input, name, skeletonData) {
                  var timelines = new Array();
                  var scale = this.scale;
                  var duration = 0;
                  var tempColor1 = new spine.Color();
                  var tempColor2 = new spine.Color();

                  for (var i = 0, n = input.readInt(true); i < n; i++) {
                    var slotIndex = input.readInt(true);

                    for (var ii = 0, nn = input.readInt(true); ii < nn; ii++) {
                      var timelineType = input.readByte();
                      var frameCount = input.readInt(true);

                      switch (timelineType) {
                        case SkeletonBinary.SLOT_ATTACHMENT:
                          {
                            var timeline = new spine.AttachmentTimeline(frameCount);
                            timeline.slotIndex = slotIndex;

                            for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) timeline.setFrame(frameIndex, input.readFloat(), input.readStringRef());

                            timelines.push(timeline);
                            duration = Math.max(duration, timeline.frames[frameCount - 1]);
                            break;
                          }

                        case SkeletonBinary.SLOT_COLOR:
                          {
                            var timeline = new spine.ColorTimeline(frameCount);
                            timeline.slotIndex = slotIndex;

                            for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {
                              var time = input.readFloat();
                              spine.Color.rgba8888ToColor(tempColor1, input.readInt32());
                              timeline.setFrame(frameIndex, time, tempColor1.r, tempColor1.g, tempColor1.b, tempColor1.a);
                              if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);
                            }

                            timelines.push(timeline);
                            duration = Math.max(duration, timeline.frames[(frameCount - 1) * spine.ColorTimeline.ENTRIES]);
                            break;
                          }

                        case SkeletonBinary.SLOT_TWO_COLOR:
                          {
                            var timeline = new spine.TwoColorTimeline(frameCount);
                            timeline.slotIndex = slotIndex;

                            for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {
                              var time = input.readFloat();
                              spine.Color.rgba8888ToColor(tempColor1, input.readInt32());
                              spine.Color.rgb888ToColor(tempColor2, input.readInt32());
                              timeline.setFrame(frameIndex, time, tempColor1.r, tempColor1.g, tempColor1.b, tempColor1.a, tempColor2.r, tempColor2.g, tempColor2.b);
                              if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);
                            }

                            timelines.push(timeline);
                            duration = Math.max(duration, timeline.frames[(frameCount - 1) * spine.TwoColorTimeline.ENTRIES]);
                            break;
                          }
                      }
                    }
                  }

                  for (var i = 0, n = input.readInt(true); i < n; i++) {
                    var boneIndex = input.readInt(true);

                    for (var ii = 0, nn = input.readInt(true); ii < nn; ii++) {
                      var timelineType = input.readByte();
                      var frameCount = input.readInt(true);

                      switch (timelineType) {
                        case SkeletonBinary.BONE_ROTATE:
                          {
                            var timeline = new spine.RotateTimeline(frameCount);
                            timeline.boneIndex = boneIndex;

                            for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {
                              timeline.setFrame(frameIndex, input.readFloat(), input.readFloat());
                              if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);
                            }

                            timelines.push(timeline);
                            duration = Math.max(duration, timeline.frames[(frameCount - 1) * spine.RotateTimeline.ENTRIES]);
                            break;
                          }

                        case SkeletonBinary.BONE_TRANSLATE:
                        case SkeletonBinary.BONE_SCALE:
                        case SkeletonBinary.BONE_SHEAR:
                          {
                            var timeline = void 0;
                            var timelineScale = 1;
                            if (timelineType == SkeletonBinary.BONE_SCALE) timeline = new spine.ScaleTimeline(frameCount);else if (timelineType == SkeletonBinary.BONE_SHEAR) timeline = new spine.ShearTimeline(frameCount);else {
                              timeline = new spine.TranslateTimeline(frameCount);
                              timelineScale = scale;
                            }
                            timeline.boneIndex = boneIndex;

                            for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {
                              timeline.setFrame(frameIndex, input.readFloat(), input.readFloat() * timelineScale, input.readFloat() * timelineScale);
                              if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);
                            }

                            timelines.push(timeline);
                            duration = Math.max(duration, timeline.frames[(frameCount - 1) * spine.TranslateTimeline.ENTRIES]);
                            break;
                          }
                      }
                    }
                  }

                  for (var i = 0, n = input.readInt(true); i < n; i++) {
                    var index = input.readInt(true);
                    var frameCount = input.readInt(true);
                    var timeline = new spine.IkConstraintTimeline(frameCount);
                    timeline.ikConstraintIndex = index;

                    for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {
                      timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat() * scale, input.readByte(), input.readBoolean(), input.readBoolean());
                      if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);
                    }

                    timelines.push(timeline);
                    duration = Math.max(duration, timeline.frames[(frameCount - 1) * spine.IkConstraintTimeline.ENTRIES]);
                  }

                  for (var i = 0, n = input.readInt(true); i < n; i++) {
                    var index = input.readInt(true);
                    var frameCount = input.readInt(true);
                    var timeline = new spine.TransformConstraintTimeline(frameCount);
                    timeline.transformConstraintIndex = index;

                    for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {
                      timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat());
                      if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);
                    }

                    timelines.push(timeline);
                    duration = Math.max(duration, timeline.frames[(frameCount - 1) * spine.TransformConstraintTimeline.ENTRIES]);
                  }

                  for (var i = 0, n = input.readInt(true); i < n; i++) {
                    var index = input.readInt(true);
                    var data = skeletonData.pathConstraints[index];

                    for (var ii = 0, nn = input.readInt(true); ii < nn; ii++) {
                      var timelineType = input.readByte();
                      var frameCount = input.readInt(true);

                      switch (timelineType) {
                        case SkeletonBinary.PATH_POSITION:
                        case SkeletonBinary.PATH_SPACING:
                          {
                            var timeline = void 0;
                            var timelineScale = 1;

                            if (timelineType == SkeletonBinary.PATH_SPACING) {
                              timeline = new spine.PathConstraintSpacingTimeline(frameCount);
                              if (data.spacingMode == spine.SpacingMode.Length || data.spacingMode == spine.SpacingMode.Fixed) timelineScale = scale;
                            } else {
                              timeline = new spine.PathConstraintPositionTimeline(frameCount);
                              if (data.positionMode == spine.PositionMode.Fixed) timelineScale = scale;
                            }

                            timeline.pathConstraintIndex = index;

                            for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {
                              timeline.setFrame(frameIndex, input.readFloat(), input.readFloat() * timelineScale);
                              if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);
                            }

                            timelines.push(timeline);
                            duration = Math.max(duration, timeline.frames[(frameCount - 1) * spine.PathConstraintPositionTimeline.ENTRIES]);
                            break;
                          }

                        case SkeletonBinary.PATH_MIX:
                          {
                            var timeline = new spine.PathConstraintMixTimeline(frameCount);
                            timeline.pathConstraintIndex = index;

                            for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {
                              timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat());
                              if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);
                            }

                            timelines.push(timeline);
                            duration = Math.max(duration, timeline.frames[(frameCount - 1) * spine.PathConstraintMixTimeline.ENTRIES]);
                            break;
                          }
                      }
                    }
                  }

                  for (var i = 0, n = input.readInt(true); i < n; i++) {
                    var skin = skeletonData.skins[input.readInt(true)];

                    for (var ii = 0, nn = input.readInt(true); ii < nn; ii++) {
                      var slotIndex = input.readInt(true);

                      for (var iii = 0, nnn = input.readInt(true); iii < nnn; iii++) {
                        var attachment = skin.getAttachment(slotIndex, input.readStringRef());
                        var weighted = attachment.bones != null;
                        var vertices = attachment.vertices;
                        var deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;
                        var frameCount = input.readInt(true);
                        var timeline = new spine.DeformTimeline(frameCount);
                        timeline.slotIndex = slotIndex;
                        timeline.attachment = attachment;

                        for (var frameIndex = 0; frameIndex < frameCount; frameIndex++) {
                          var time = input.readFloat();
                          var deform = void 0;
                          var end = input.readInt(true);
                          if (end == 0) deform = weighted ? spine.Utils.newFloatArray(deformLength) : vertices;else {
                            deform = spine.Utils.newFloatArray(deformLength);
                            var start = input.readInt(true);
                            end += start;

                            if (scale == 1) {
                              for (var v = start; v < end; v++) deform[v] = input.readFloat();
                            } else {
                              for (var v = start; v < end; v++) deform[v] = input.readFloat() * scale;
                            }

                            if (!weighted) {
                              for (var v = 0, vn = deform.length; v < vn; v++) deform[v] += vertices[v];
                            }
                          }
                          timeline.setFrame(frameIndex, time, deform);
                          if (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);
                        }

                        timelines.push(timeline);
                        duration = Math.max(duration, timeline.frames[frameCount - 1]);
                      }
                    }
                  }

                  var drawOrderCount = input.readInt(true);

                  if (drawOrderCount > 0) {
                    var timeline = new spine.DrawOrderTimeline(drawOrderCount);
                    var slotCount = skeletonData.slots.length;

                    for (var i = 0; i < drawOrderCount; i++) {
                      var time = input.readFloat();
                      var offsetCount = input.readInt(true);
                      var drawOrder = spine.Utils.newArray(slotCount, 0);

                      for (var ii = slotCount - 1; ii >= 0; ii--) drawOrder[ii] = -1;

                      var unchanged = spine.Utils.newArray(slotCount - offsetCount, 0);
                      var originalIndex = 0,
                          unchangedIndex = 0;

                      for (var ii = 0; ii < offsetCount; ii++) {
                        var slotIndex = input.readInt(true);

                        while (originalIndex != slotIndex) unchanged[unchangedIndex++] = originalIndex++;

                        drawOrder[originalIndex + input.readInt(true)] = originalIndex++;
                      }

                      while (originalIndex < slotCount) unchanged[unchangedIndex++] = originalIndex++;

                      for (var ii = slotCount - 1; ii >= 0; ii--) if (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];

                      timeline.setFrame(i, time, drawOrder);
                    }

                    timelines.push(timeline);
                    duration = Math.max(duration, timeline.frames[drawOrderCount - 1]);
                  }

                  var eventCount = input.readInt(true);

                  if (eventCount > 0) {
                    var timeline = new spine.EventTimeline(eventCount);

                    for (var i = 0; i < eventCount; i++) {
                      var time = input.readFloat();
                      var eventData = skeletonData.events[input.readInt(true)];
                      var event_4 = new spine.Event(time, eventData);
                      event_4.intValue = input.readInt(false);
                      event_4.floatValue = input.readFloat();
                      event_4.stringValue = input.readBoolean() ? input.readString() : eventData.stringValue;

                      if (event_4.data.audioPath != null) {
                        event_4.volume = input.readFloat();
                        event_4.balance = input.readFloat();
                      }

                      timeline.setFrame(i, event_4);
                    }

                    timelines.push(timeline);
                    duration = Math.max(duration, timeline.frames[eventCount - 1]);
                  }

                  return new spine.Animation(name, timelines, duration);
                };

                SkeletonBinary.prototype.readCurve = function (input, frameIndex, timeline) {
                  switch (input.readByte()) {
                    case SkeletonBinary.CURVE_STEPPED:
                      timeline.setStepped(frameIndex);
                      break;

                    case SkeletonBinary.CURVE_BEZIER:
                      this.setCurve(timeline, frameIndex, input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat());
                      break;
                  }
                };

                SkeletonBinary.prototype.setCurve = function (timeline, frameIndex, cx1, cy1, cx2, cy2) {
                  timeline.setCurve(frameIndex, cx1, cy1, cx2, cy2);
                };

                SkeletonBinary.AttachmentTypeValues = [0, 1, 2, 3, 4, 5, 6];
                SkeletonBinary.TransformModeValues = [spine.TransformMode.Normal, spine.TransformMode.OnlyTranslation, spine.TransformMode.NoRotationOrReflection, spine.TransformMode.NoScale, spine.TransformMode.NoScaleOrReflection];
                SkeletonBinary.PositionModeValues = [spine.PositionMode.Fixed, spine.PositionMode.Percent];
                SkeletonBinary.SpacingModeValues = [spine.SpacingMode.Length, spine.SpacingMode.Fixed, spine.SpacingMode.Percent];
                SkeletonBinary.RotateModeValues = [spine.RotateMode.Tangent, spine.RotateMode.Chain, spine.RotateMode.ChainScale];
                SkeletonBinary.BlendModeValues = [spine.BlendMode.Normal, spine.BlendMode.Additive, spine.BlendMode.Multiply, spine.BlendMode.Screen];
                SkeletonBinary.BONE_ROTATE = 0;
                SkeletonBinary.BONE_TRANSLATE = 1;
                SkeletonBinary.BONE_SCALE = 2;
                SkeletonBinary.BONE_SHEAR = 3;
                SkeletonBinary.SLOT_ATTACHMENT = 0;
                SkeletonBinary.SLOT_COLOR = 1;
                SkeletonBinary.SLOT_TWO_COLOR = 2;
                SkeletonBinary.PATH_POSITION = 0;
                SkeletonBinary.PATH_SPACING = 1;
                SkeletonBinary.PATH_MIX = 2;
                SkeletonBinary.CURVE_LINEAR = 0;
                SkeletonBinary.CURVE_STEPPED = 1;
                SkeletonBinary.CURVE_BEZIER = 2;
                return SkeletonBinary;
              }();

              spine.SkeletonBinary = SkeletonBinary;

              var BinaryInput = function () {
                function BinaryInput(data, strings, index, buffer) {
                  if (strings === void 0) {
                    strings = new Array();
                  }

                  if (index === void 0) {
                    index = 0;
                  }

                  if (buffer === void 0) {
                    buffer = new DataView(data.buffer);
                  }

                  this.strings = strings;
                  this.index = index;
                  this.buffer = buffer;
                }

                BinaryInput.prototype.readByte = function () {
                  return this.buffer.getInt8(this.index++);
                };

                BinaryInput.prototype.readShort = function () {
                  var value = this.buffer.getInt16(this.index);
                  this.index += 2;
                  return value;
                };

                BinaryInput.prototype.readInt32 = function () {
                  var value = this.buffer.getInt32(this.index);
                  this.index += 4;
                  return value;
                };

                BinaryInput.prototype.readInt = function (optimizePositive) {
                  var b = this.readByte();
                  var result = b & 0x7F;

                  if ((b & 0x80) != 0) {
                    b = this.readByte();
                    result |= (b & 0x7F) << 7;

                    if ((b & 0x80) != 0) {
                      b = this.readByte();
                      result |= (b & 0x7F) << 14;

                      if ((b & 0x80) != 0) {
                        b = this.readByte();
                        result |= (b & 0x7F) << 21;

                        if ((b & 0x80) != 0) {
                          b = this.readByte();
                          result |= (b & 0x7F) << 28;
                        }
                      }
                    }
                  }

                  return optimizePositive ? result : result >>> 1 ^ -(result & 1);
                };

                BinaryInput.prototype.readStringRef = function () {
                  var index = this.readInt(true);
                  return index == 0 ? null : this.strings[index - 1];
                };

                BinaryInput.prototype.readString = function () {
                  var byteCount = this.readInt(true);

                  switch (byteCount) {
                    case 0:
                      return null;

                    case 1:
                      return "";
                  }

                  byteCount--;
                  var chars = "";

                  for (var i = 0; i < byteCount;) {
                    var b = this.readByte();

                    switch (b >> 4) {
                      case 12:
                      case 13:
                        chars += String.fromCharCode((b & 0x1F) << 6 | this.readByte() & 0x3F);
                        i += 2;
                        break;

                      case 14:
                        chars += String.fromCharCode((b & 0x0F) << 12 | (this.readByte() & 0x3F) << 6 | this.readByte() & 0x3F);
                        i += 3;
                        break;

                      default:
                        chars += String.fromCharCode(b);
                        i++;
                    }
                  }

                  return chars;
                };

                BinaryInput.prototype.readFloat = function () {
                  var value = this.buffer.getFloat32(this.index);
                  this.index += 4;
                  return value;
                };

                BinaryInput.prototype.readBoolean = function () {
                  return this.readByte() != 0;
                };

                return BinaryInput;
              }();

              var LinkedMesh = function () {
                function LinkedMesh(mesh, skin, slotIndex, parent, inheritDeform) {
                  this.mesh = mesh;
                  this.skin = skin;
                  this.slotIndex = slotIndex;
                  this.parent = parent;
                  this.inheritDeform = inheritDeform;
                }

                return LinkedMesh;
              }();

              var Vertices = function () {
                function Vertices(bones, vertices) {
                  if (bones === void 0) {
                    bones = null;
                  }

                  if (vertices === void 0) {
                    vertices = null;
                  }

                  this.bones = bones;
                  this.vertices = vertices;
                }

                return Vertices;
              }();
            })(spine || (spine = {}));

            var spine;

            (function (spine) {
              var SkeletonBounds = function () {
                function SkeletonBounds() {
                  this.minX = 0;
                  this.minY = 0;
                  this.maxX = 0;
                  this.maxY = 0;
                  this.boundingBoxes = new Array();
                  this.polygons = new Array();
                  this.polygonPool = new spine.Pool(function () {
                    return spine.Utils.newFloatArray(16);
                  });
                }

                SkeletonBounds.prototype.update = function (skeleton, updateAabb) {
                  if (skeleton == null) throw new Error("skeleton cannot be null.");
                  var boundingBoxes = this.boundingBoxes;
                  var polygons = this.polygons;
                  var polygonPool = this.polygonPool;
                  var slots = skeleton.slots;
                  var slotCount = slots.length;
                  boundingBoxes.length = 0;
                  polygonPool.freeAll(polygons);
                  polygons.length = 0;

                  for (var i = 0; i < slotCount; i++) {
                    var slot = slots[i];
                    if (!slot.bone.active) continue;
                    var attachment = slot.getAttachment();

                    if (attachment instanceof spine.BoundingBoxAttachment) {
                      var boundingBox = attachment;
                      boundingBoxes.push(boundingBox);
                      var polygon = polygonPool.obtain();

                      if (polygon.length != boundingBox.worldVerticesLength) {
                        polygon = spine.Utils.newFloatArray(boundingBox.worldVerticesLength);
                      }

                      polygons.push(polygon);
                      boundingBox.computeWorldVertices(slot, 0, boundingBox.worldVerticesLength, polygon, 0, 2);
                    }
                  }

                  if (updateAabb) {
                    this.aabbCompute();
                  } else {
                    this.minX = Number.POSITIVE_INFINITY;
                    this.minY = Number.POSITIVE_INFINITY;
                    this.maxX = Number.NEGATIVE_INFINITY;
                    this.maxY = Number.NEGATIVE_INFINITY;
                  }
                };

                SkeletonBounds.prototype.aabbCompute = function () {
                  var minX = Number.POSITIVE_INFINITY,
                      minY = Number.POSITIVE_INFINITY,
                      maxX = Number.NEGATIVE_INFINITY,
                      maxY = Number.NEGATIVE_INFINITY;
                  var polygons = this.polygons;

                  for (var i = 0, n = polygons.length; i < n; i++) {
                    var polygon = polygons[i];
                    var vertices = polygon;

                    for (var ii = 0, nn = polygon.length; ii < nn; ii += 2) {
                      var x = vertices[ii];
                      var y = vertices[ii + 1];
                      minX = Math.min(minX, x);
                      minY = Math.min(minY, y);
                      maxX = Math.max(maxX, x);
                      maxY = Math.max(maxY, y);
                    }
                  }

                  this.minX = minX;
                  this.minY = minY;
                  this.maxX = maxX;
                  this.maxY = maxY;
                };

                SkeletonBounds.prototype.aabbContainsPoint = function (x, y) {
                  return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;
                };

                SkeletonBounds.prototype.aabbIntersectsSegment = function (x1, y1, x2, y2) {
                  var minX = this.minX;
                  var minY = this.minY;
                  var maxX = this.maxX;
                  var maxY = this.maxY;
                  if (x1 <= minX && x2 <= minX || y1 <= minY && y2 <= minY || x1 >= maxX && x2 >= maxX || y1 >= maxY && y2 >= maxY) return false;
                  var m = (y2 - y1) / (x2 - x1);
                  var y = m * (minX - x1) + y1;
                  if (y > minY && y < maxY) return true;
                  y = m * (maxX - x1) + y1;
                  if (y > minY && y < maxY) return true;
                  var x = (minY - y1) / m + x1;
                  if (x > minX && x < maxX) return true;
                  x = (maxY - y1) / m + x1;
                  if (x > minX && x < maxX) return true;
                  return false;
                };

                SkeletonBounds.prototype.aabbIntersectsSkeleton = function (bounds) {
                  return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;
                };

                SkeletonBounds.prototype.containsPoint = function (x, y) {
                  var polygons = this.polygons;

                  for (var i = 0, n = polygons.length; i < n; i++) if (this.containsPointPolygon(polygons[i], x, y)) return this.boundingBoxes[i];

                  return null;
                };

                SkeletonBounds.prototype.containsPointPolygon = function (polygon, x, y) {
                  var vertices = polygon;
                  var nn = polygon.length;
                  var prevIndex = nn - 2;
                  var inside = false;

                  for (var ii = 0; ii < nn; ii += 2) {
                    var vertexY = vertices[ii + 1];
                    var prevY = vertices[prevIndex + 1];

                    if (vertexY < y && prevY >= y || prevY < y && vertexY >= y) {
                      var vertexX = vertices[ii];
                      if (vertexX + (y - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x) inside = !inside;
                    }

                    prevIndex = ii;
                  }

                  return inside;
                };

                SkeletonBounds.prototype.intersectsSegment = function (x1, y1, x2, y2) {
                  var polygons = this.polygons;

                  for (var i = 0, n = polygons.length; i < n; i++) if (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2)) return this.boundingBoxes[i];

                  return null;
                };

                SkeletonBounds.prototype.intersectsSegmentPolygon = function (polygon, x1, y1, x2, y2) {
                  var vertices = polygon;
                  var nn = polygon.length;
                  var width12 = x1 - x2,
                      height12 = y1 - y2;
                  var det1 = x1 * y2 - y1 * x2;
                  var x3 = vertices[nn - 2],
                      y3 = vertices[nn - 1];

                  for (var ii = 0; ii < nn; ii += 2) {
                    var x4 = vertices[ii],
                        y4 = vertices[ii + 1];
                    var det2 = x3 * y4 - y3 * x4;
                    var width34 = x3 - x4,
                        height34 = y3 - y4;
                    var det3 = width12 * height34 - height12 * width34;
                    var x = (det1 * width34 - width12 * det2) / det3;

                    if ((x >= x3 && x <= x4 || x >= x4 && x <= x3) && (x >= x1 && x <= x2 || x >= x2 && x <= x1)) {
                      var y = (det1 * height34 - height12 * det2) / det3;
                      if ((y >= y3 && y <= y4 || y >= y4 && y <= y3) && (y >= y1 && y <= y2 || y >= y2 && y <= y1)) return true;
                    }

                    x3 = x4;
                    y3 = y4;
                  }

                  return false;
                };

                SkeletonBounds.prototype.getPolygon = function (boundingBox) {
                  if (boundingBox == null) throw new Error("boundingBox cannot be null.");
                  var index = this.boundingBoxes.indexOf(boundingBox);
                  return index == -1 ? null : this.polygons[index];
                };

                SkeletonBounds.prototype.getWidth = function () {
                  return this.maxX - this.minX;
                };

                SkeletonBounds.prototype.getHeight = function () {
                  return this.maxY - this.minY;
                };

                return SkeletonBounds;
              }();

              spine.SkeletonBounds = SkeletonBounds;
            })(spine || (spine = {}));

            var spine;

            (function (spine) {
              var SkeletonClipping = function () {
                function SkeletonClipping() {
                  this.triangulator = new spine.Triangulator();
                  this.clippingPolygon = new Array();
                  this.clipOutput = new Array();
                  this.clippedVertices = new Array();
                  this.clippedTriangles = new Array();
                  this.scratch = new Array();
                }

                SkeletonClipping.prototype.clipStart = function (slot, clip) {
                  if (this.clipAttachment != null) return 0;
                  this.clipAttachment = clip;
                  var n = clip.worldVerticesLength;
                  var vertices = spine.Utils.setArraySize(this.clippingPolygon, n);
                  clip.computeWorldVertices(slot, 0, n, vertices, 0, 2);
                  var clippingPolygon = this.clippingPolygon;
                  SkeletonClipping.makeClockwise(clippingPolygon);
                  var clippingPolygons = this.clippingPolygons = this.triangulator.decompose(clippingPolygon, this.triangulator.triangulate(clippingPolygon));

                  for (var i = 0, n_1 = clippingPolygons.length; i < n_1; i++) {
                    var polygon = clippingPolygons[i];
                    SkeletonClipping.makeClockwise(polygon);
                    polygon.push(polygon[0]);
                    polygon.push(polygon[1]);
                  }

                  return clippingPolygons.length;
                };

                SkeletonClipping.prototype.clipEndWithSlot = function (slot) {
                  if (this.clipAttachment != null && this.clipAttachment.endSlot == slot.data) this.clipEnd();
                };

                SkeletonClipping.prototype.clipEnd = function () {
                  if (this.clipAttachment == null) return;
                  this.clipAttachment = null;
                  this.clippingPolygons = null;
                  this.clippedVertices.length = 0;
                  this.clippedTriangles.length = 0;
                  this.clippingPolygon.length = 0;
                };

                SkeletonClipping.prototype.isClipping = function () {
                  return this.clipAttachment != null;
                };

                SkeletonClipping.prototype.clipTriangles = function (vertices, verticesLength, triangles, trianglesLength, uvs, light, dark, twoColor, strideFloat, offsetV, offsetI) {
                  if (strideFloat === void 0) {
                    strideFloat = 2;
                  }

                  if (offsetV === void 0) {
                    offsetV = 0;
                  }

                  if (offsetI === void 0) {
                    offsetI = 0;
                  }

                  var clipOutput = this.clipOutput,
                      clippedVertices = this.clippedVertices;
                  var clippedTriangles = this.clippedTriangles;
                  var polygons = this.clippingPolygons;
                  var polygonsCount = this.clippingPolygons.length;
                  var vertexSize = twoColor ? 12 : 8;
                  var index = 0;
                  clippedVertices.length = 0;
                  clippedTriangles.length = 0;

                  outer: for (var i = 0; i < trianglesLength; i += 3) {
                    var vertexOffset = triangles[i] * strideFloat;
                    var x1 = vertices[vertexOffset + offsetV],
                        y1 = vertices[vertexOffset + offsetV + 1];
                    var u1 = uvs[vertexOffset + offsetI],
                        v1 = uvs[vertexOffset + offsetI + 1];
                    vertexOffset = triangles[i + 1] * strideFloat;
                    var x2 = vertices[vertexOffset + offsetV],
                        y2 = vertices[vertexOffset + offsetV + 1];
                    var u2 = uvs[vertexOffset + offsetI],
                        v2 = uvs[vertexOffset + offsetI + 1];
                    vertexOffset = triangles[i + 2] * strideFloat;
                    var x3 = vertices[vertexOffset + offsetV],
                        y3 = vertices[vertexOffset + offsetV + 1];
                    var u3 = uvs[vertexOffset + offsetI],
                        v3 = uvs[vertexOffset + offsetI + 1];

                    for (var p = 0; p < polygonsCount; p++) {
                      var s = clippedVertices.length;

                      if (this.clip(x1, y1, x2, y2, x3, y3, polygons[p], clipOutput)) {
                        var clipOutputLength = clipOutput.length;
                        if (clipOutputLength == 0) continue;
                        var d0 = y2 - y3,
                            d1 = x3 - x2,
                            d2 = x1 - x3,
                            d4 = y3 - y1;
                        var d = 1 / (d0 * d2 + d1 * (y1 - y3));
                        var clipOutputCount = clipOutputLength >> 1;
                        var clipOutputItems = this.clipOutput;
                        var clippedVerticesItems = spine.Utils.setArraySize(clippedVertices, s + clipOutputCount * vertexSize);

                        for (var ii = 0; ii < clipOutputLength; ii += 2) {
                          var x = clipOutputItems[ii],
                              y = clipOutputItems[ii + 1];
                          clippedVerticesItems[s] = x;
                          clippedVerticesItems[s + 1] = y;
                          clippedVerticesItems[s + 2] = light.r;
                          clippedVerticesItems[s + 3] = light.g;
                          clippedVerticesItems[s + 4] = light.b;
                          clippedVerticesItems[s + 5] = light.a;
                          var c0 = x - x3,
                              c1 = y - y3;
                          var a = (d0 * c0 + d1 * c1) * d;
                          var b = (d4 * c0 + d2 * c1) * d;
                          var c = 1 - a - b;
                          clippedVerticesItems[s + 6] = u1 * a + u2 * b + u3 * c;
                          clippedVerticesItems[s + 7] = v1 * a + v2 * b + v3 * c;

                          if (twoColor) {
                            clippedVerticesItems[s + 8] = dark.r;
                            clippedVerticesItems[s + 9] = dark.g;
                            clippedVerticesItems[s + 10] = dark.b;
                            clippedVerticesItems[s + 11] = dark.a;
                          }

                          s += vertexSize;
                        }

                        s = clippedTriangles.length;
                        var clippedTrianglesItems = spine.Utils.setArraySize(clippedTriangles, s + 3 * (clipOutputCount - 2));
                        clipOutputCount--;

                        for (var ii = 1; ii < clipOutputCount; ii++) {
                          clippedTrianglesItems[s] = index;
                          clippedTrianglesItems[s + 1] = index + ii;
                          clippedTrianglesItems[s + 2] = index + ii + 1;
                          s += 3;
                        }

                        index += clipOutputCount + 1;
                      } else {
                        var clippedVerticesItems = spine.Utils.setArraySize(clippedVertices, s + 3 * vertexSize);
                        clippedVerticesItems[s] = x1;
                        clippedVerticesItems[s + 1] = y1;
                        clippedVerticesItems[s + 2] = light.r;
                        clippedVerticesItems[s + 3] = light.g;
                        clippedVerticesItems[s + 4] = light.b;
                        clippedVerticesItems[s + 5] = light.a;

                        if (!twoColor) {
                          clippedVerticesItems[s + 6] = u1;
                          clippedVerticesItems[s + 7] = v1;
                          clippedVerticesItems[s + 8] = x2;
                          clippedVerticesItems[s + 9] = y2;
                          clippedVerticesItems[s + 10] = light.r;
                          clippedVerticesItems[s + 11] = light.g;
                          clippedVerticesItems[s + 12] = light.b;
                          clippedVerticesItems[s + 13] = light.a;
                          clippedVerticesItems[s + 14] = u2;
                          clippedVerticesItems[s + 15] = v2;
                          clippedVerticesItems[s + 16] = x3;
                          clippedVerticesItems[s + 17] = y3;
                          clippedVerticesItems[s + 18] = light.r;
                          clippedVerticesItems[s + 19] = light.g;
                          clippedVerticesItems[s + 20] = light.b;
                          clippedVerticesItems[s + 21] = light.a;
                          clippedVerticesItems[s + 22] = u3;
                          clippedVerticesItems[s + 23] = v3;
                        } else {
                          clippedVerticesItems[s + 6] = u1;
                          clippedVerticesItems[s + 7] = v1;
                          clippedVerticesItems[s + 8] = dark.r;
                          clippedVerticesItems[s + 9] = dark.g;
                          clippedVerticesItems[s + 10] = dark.b;
                          clippedVerticesItems[s + 11] = dark.a;
                          clippedVerticesItems[s + 12] = x2;
                          clippedVerticesItems[s + 13] = y2;
                          clippedVerticesItems[s + 14] = light.r;
                          clippedVerticesItems[s + 15] = light.g;
                          clippedVerticesItems[s + 16] = light.b;
                          clippedVerticesItems[s + 17] = light.a;
                          clippedVerticesItems[s + 18] = u2;
                          clippedVerticesItems[s + 19] = v2;
                          clippedVerticesItems[s + 20] = dark.r;
                          clippedVerticesItems[s + 21] = dark.g;
                          clippedVerticesItems[s + 22] = dark.b;
                          clippedVerticesItems[s + 23] = dark.a;
                          clippedVerticesItems[s + 24] = x3;
                          clippedVerticesItems[s + 25] = y3;
                          clippedVerticesItems[s + 26] = light.r;
                          clippedVerticesItems[s + 27] = light.g;
                          clippedVerticesItems[s + 28] = light.b;
                          clippedVerticesItems[s + 29] = light.a;
                          clippedVerticesItems[s + 30] = u3;
                          clippedVerticesItems[s + 31] = v3;
                          clippedVerticesItems[s + 32] = dark.r;
                          clippedVerticesItems[s + 33] = dark.g;
                          clippedVerticesItems[s + 34] = dark.b;
                          clippedVerticesItems[s + 35] = dark.a;
                        }

                        s = clippedTriangles.length;
                        var clippedTrianglesItems = spine.Utils.setArraySize(clippedTriangles, s + 3);
                        clippedTrianglesItems[s] = index;
                        clippedTrianglesItems[s + 1] = index + 1;
                        clippedTrianglesItems[s + 2] = index + 2;
                        index += 3;
                        continue outer;
                      }
                    }
                  }
                };

                SkeletonClipping.prototype.clip = function (x1, y1, x2, y2, x3, y3, clippingArea, output) {
                  var originalOutput = output;
                  var clipped = false;
                  var input = null;

                  if (clippingArea.length % 4 >= 2) {
                    input = output;
                    output = this.scratch;
                  } else input = this.scratch;

                  input.length = 0;
                  input.push(x1);
                  input.push(y1);
                  input.push(x2);
                  input.push(y2);
                  input.push(x3);
                  input.push(y3);
                  input.push(x1);
                  input.push(y1);
                  output.length = 0;
                  var clippingVertices = clippingArea;
                  var clippingVerticesLast = clippingArea.length - 4;

                  for (var i = 0;; i += 2) {
                    var edgeX = clippingVertices[i],
                        edgeY = clippingVertices[i + 1];
                    var edgeX2 = clippingVertices[i + 2],
                        edgeY2 = clippingVertices[i + 3];
                    var deltaX = edgeX - edgeX2,
                        deltaY = edgeY - edgeY2;
                    var inputVertices = input;
                    var inputVerticesLength = input.length - 2,
                        outputStart = output.length;

                    for (var ii = 0; ii < inputVerticesLength; ii += 2) {
                      var inputX = inputVertices[ii],
                          inputY = inputVertices[ii + 1];
                      var inputX2 = inputVertices[ii + 2],
                          inputY2 = inputVertices[ii + 3];
                      var side2 = deltaX * (inputY2 - edgeY2) - deltaY * (inputX2 - edgeX2) > 0;

                      if (deltaX * (inputY - edgeY2) - deltaY * (inputX - edgeX2) > 0) {
                        if (side2) {
                          output.push(inputX2);
                          output.push(inputY2);
                          continue;
                        }

                        var c0 = inputY2 - inputY,
                            c2 = inputX2 - inputX;
                        var s = c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY);

                        if (Math.abs(s) > 0.000001) {
                          var ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / s;
                          output.push(edgeX + (edgeX2 - edgeX) * ua);
                          output.push(edgeY + (edgeY2 - edgeY) * ua);
                        } else {
                          output.push(edgeX);
                          output.push(edgeY);
                        }
                      } else if (side2) {
                        var c0 = inputY2 - inputY,
                            c2 = inputX2 - inputX;
                        var s = c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY);

                        if (Math.abs(s) > 0.000001) {
                          var ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / s;
                          output.push(edgeX + (edgeX2 - edgeX) * ua);
                          output.push(edgeY + (edgeY2 - edgeY) * ua);
                        } else {
                          output.push(edgeX);
                          output.push(edgeY);
                        }

                        output.push(inputX2);
                        output.push(inputY2);
                      }

                      clipped = true;
                    }

                    if (outputStart == output.length) {
                      originalOutput.length = 0;
                      return true;
                    }

                    output.push(output[0]);
                    output.push(output[1]);
                    if (i == clippingVerticesLast) break;
                    var temp = output;
                    output = input;
                    output.length = 0;
                    input = temp;
                  }

                  if (originalOutput != output) {
                    originalOutput.length = 0;

                    for (var i = 0, n = output.length - 2; i < n; i++) originalOutput[i] = output[i];
                  } else originalOutput.length = originalOutput.length - 2;

                  return clipped;
                };

                SkeletonClipping.makeClockwise = function (polygon) {
                  var vertices = polygon;
                  var verticeslength = polygon.length;
                  var area = vertices[verticeslength - 2] * vertices[1] - vertices[0] * vertices[verticeslength - 1],
                      p1x = 0,
                      p1y = 0,
                      p2x = 0,
                      p2y = 0;

                  for (var i = 0, n = verticeslength - 3; i < n; i += 2) {
                    p1x = vertices[i];
                    p1y = vertices[i + 1];
                    p2x = vertices[i + 2];
                    p2y = vertices[i + 3];
                    area += p1x * p2y - p2x * p1y;
                  }

                  if (area < 0) return;

                  for (var i = 0, lastX = verticeslength - 2, n = verticeslength >> 1; i < n; i += 2) {
                    var x = vertices[i],
                        y = vertices[i + 1];
                    var other = lastX - i;
                    vertices[i] = vertices[other];
                    vertices[i + 1] = vertices[other + 1];
                    vertices[other] = x;
                    vertices[other + 1] = y;
                  }
                };

                return SkeletonClipping;
              }();

              spine.SkeletonClipping = SkeletonClipping;
            })(spine || (spine = {}));

            var spine;

            (function (spine) {
              var SkeletonData = function () {
                function SkeletonData() {
                  this.bones = new Array();
                  this.slots = new Array();
                  this.skins = new Array();
                  this.events = new Array();
                  this.animations = new Array();
                  this.ikConstraints = new Array();
                  this.transformConstraints = new Array();
                  this.pathConstraints = new Array();
                  this.fps = 0;
                }

                SkeletonData.prototype.findBone = function (boneName) {
                  if (boneName == null) throw new Error("boneName cannot be null.");
                  var bones = this.bones;

                  for (var i = 0, n = bones.length; i < n; i++) {
                    var bone = bones[i];
                    if (bone.name == boneName) return bone;
                  }

                  return null;
                };

                SkeletonData.prototype.findBoneIndex = function (boneName) {
                  if (boneName == null) throw new Error("boneName cannot be null.");
                  var bones = this.bones;

                  for (var i = 0, n = bones.length; i < n; i++) if (bones[i].name == boneName) return i;

                  return -1;
                };

                SkeletonData.prototype.findSlot = function (slotName) {
                  if (slotName == null) throw new Error("slotName cannot be null.");
                  var slots = this.slots;

                  for (var i = 0, n = slots.length; i < n; i++) {
                    var slot = slots[i];
                    if (slot.name == slotName) return slot;
                  }

                  return null;
                };

                SkeletonData.prototype.findSlotIndex = function (slotName) {
                  if (slotName == null) throw new Error("slotName cannot be null.");
                  var slots = this.slots;

                  for (var i = 0, n = slots.length; i < n; i++) if (slots[i].name == slotName) return i;

                  return -1;
                };

                SkeletonData.prototype.findSkin = function (skinName) {
                  if (skinName == null) throw new Error("skinName cannot be null.");
                  var skins = this.skins;

                  for (var i = 0, n = skins.length; i < n; i++) {
                    var skin = skins[i];
                    if (skin.name == skinName) return skin;
                  }

                  return null;
                };

                SkeletonData.prototype.findEvent = function (eventDataName) {
                  if (eventDataName == null) throw new Error("eventDataName cannot be null.");
                  var events = this.events;

                  for (var i = 0, n = events.length; i < n; i++) {
                    var event_5 = events[i];
                    if (event_5.name == eventDataName) return event_5;
                  }

                  return null;
                };

                SkeletonData.prototype.findAnimation = function (animationName) {
                  if (animationName == null) throw new Error("animationName cannot be null.");
                  var animations = this.animations;

                  for (var i = 0, n = animations.length; i < n; i++) {
                    var animation = animations[i];
                    if (animation.name == animationName) return animation;
                  }

                  return null;
                };

                SkeletonData.prototype.findIkConstraint = function (constraintName) {
                  if (constraintName == null) throw new Error("constraintName cannot be null.");
                  var ikConstraints = this.ikConstraints;

                  for (var i = 0, n = ikConstraints.length; i < n; i++) {
                    var constraint = ikConstraints[i];
                    if (constraint.name == constraintName) return constraint;
                  }

                  return null;
                };

                SkeletonData.prototype.findTransformConstraint = function (constraintName) {
                  if (constraintName == null) throw new Error("constraintName cannot be null.");
                  var transformConstraints = this.transformConstraints;

                  for (var i = 0, n = transformConstraints.length; i < n; i++) {
                    var constraint = transformConstraints[i];
                    if (constraint.name == constraintName) return constraint;
                  }

                  return null;
                };

                SkeletonData.prototype.findPathConstraint = function (constraintName) {
                  if (constraintName == null) throw new Error("constraintName cannot be null.");
                  var pathConstraints = this.pathConstraints;

                  for (var i = 0, n = pathConstraints.length; i < n; i++) {
                    var constraint = pathConstraints[i];
                    if (constraint.name == constraintName) return constraint;
                  }

                  return null;
                };

                SkeletonData.prototype.findPathConstraintIndex = function (pathConstraintName) {
                  if (pathConstraintName == null) throw new Error("pathConstraintName cannot be null.");
                  var pathConstraints = this.pathConstraints;

                  for (var i = 0, n = pathConstraints.length; i < n; i++) if (pathConstraints[i].name == pathConstraintName) return i;

                  return -1;
                };

                return SkeletonData;
              }();

              spine.SkeletonData = SkeletonData;
            })(spine || (spine = {}));

            var spine;

            (function (spine) {
              var SkeletonJson = function () {
                function SkeletonJson(attachmentLoader) {
                  this.scale = 1;
                  this.linkedMeshes = new Array();
                  this.attachmentLoader = attachmentLoader;
                }

                SkeletonJson.prototype.readSkeletonData = function (json) {
                  var scale = this.scale;
                  var skeletonData = new spine.SkeletonData();
                  var root = typeof json === "string" ? JSON.parse(json) : json;
                  var skeletonMap = root.skeleton;

                  if (skeletonMap != null) {
                    skeletonData.hash = skeletonMap.hash;
                    skeletonData.version = skeletonMap.spine;
                    skeletonData.x = skeletonMap.x;
                    skeletonData.y = skeletonMap.y;
                    skeletonData.width = skeletonMap.width;
                    skeletonData.height = skeletonMap.height;
                    skeletonData.fps = skeletonMap.fps;
                    skeletonData.imagesPath = skeletonMap.images;
                  }

                  if (root.bones) {
                    for (var i = 0; i < root.bones.length; i++) {
                      var boneMap = root.bones[i];
                      var parent_5 = null;
                      var parentName = this.getValue(boneMap, "parent", null);

                      if (parentName != null) {
                        parent_5 = skeletonData.findBone(parentName);
                        if (parent_5 == null) throw new Error("Parent bone not found: " + parentName);
                      }

                      var data = new spine.BoneData(skeletonData.bones.length, boneMap.name, parent_5);
                      data.length = this.getValue(boneMap, "length", 0) * scale;
                      data.x = this.getValue(boneMap, "x", 0) * scale;
                      data.y = this.getValue(boneMap, "y", 0) * scale;
                      data.rotation = this.getValue(boneMap, "rotation", 0);
                      data.scaleX = this.getValue(boneMap, "scaleX", 1);
                      data.scaleY = this.getValue(boneMap, "scaleY", 1);
                      data.shearX = this.getValue(boneMap, "shearX", 0);
                      data.shearY = this.getValue(boneMap, "shearY", 0);
                      data.transformMode = SkeletonJson.transformModeFromString(this.getValue(boneMap, "transform", "normal"));
                      data.skinRequired = this.getValue(boneMap, "skin", false);
                      skeletonData.bones.push(data);
                    }
                  }

                  if (root.slots) {
                    for (var i = 0; i < root.slots.length; i++) {
                      var slotMap = root.slots[i];
                      var slotName = slotMap.name;
                      var boneName = slotMap.bone;
                      var boneData = skeletonData.findBone(boneName);
                      if (boneData == null) throw new Error("Slot bone not found: " + boneName);
                      var data = new spine.SlotData(skeletonData.slots.length, slotName, boneData);
                      var color = this.getValue(slotMap, "color", null);
                      if (color != null) data.color.setFromString(color);
                      var dark = this.getValue(slotMap, "dark", null);

                      if (dark != null) {
                        data.darkColor = new spine.Color(1, 1, 1, 1);
                        data.darkColor.setFromString(dark);
                      }

                      data.attachmentName = this.getValue(slotMap, "attachment", null);
                      data.blendMode = SkeletonJson.blendModeFromString(this.getValue(slotMap, "blend", "normal"));
                      skeletonData.slots.push(data);
                    }
                  }

                  if (root.ik) {
                    for (var i = 0; i < root.ik.length; i++) {
                      var constraintMap = root.ik[i];
                      var data = new spine.IkConstraintData(constraintMap.name);
                      data.order = this.getValue(constraintMap, "order", 0);
                      data.skinRequired = this.getValue(constraintMap, "skin", false);

                      for (var j = 0; j < constraintMap.bones.length; j++) {
                        var boneName = constraintMap.bones[j];
                        var bone = skeletonData.findBone(boneName);
                        if (bone == null) throw new Error("IK bone not found: " + boneName);
                        data.bones.push(bone);
                      }

                      var targetName = constraintMap.target;
                      data.target = skeletonData.findBone(targetName);
                      if (data.target == null) throw new Error("IK target bone not found: " + targetName);
                      data.mix = this.getValue(constraintMap, "mix", 1);
                      data.softness = this.getValue(constraintMap, "softness", 0) * scale;
                      data.bendDirection = this.getValue(constraintMap, "bendPositive", true) ? 1 : -1;
                      data.compress = this.getValue(constraintMap, "compress", false);
                      data.stretch = this.getValue(constraintMap, "stretch", false);
                      data.uniform = this.getValue(constraintMap, "uniform", false);
                      skeletonData.ikConstraints.push(data);
                    }
                  }

                  if (root.transform) {
                    for (var i = 0; i < root.transform.length; i++) {
                      var constraintMap = root.transform[i];
                      var data = new spine.TransformConstraintData(constraintMap.name);
                      data.order = this.getValue(constraintMap, "order", 0);
                      data.skinRequired = this.getValue(constraintMap, "skin", false);

                      for (var j = 0; j < constraintMap.bones.length; j++) {
                        var boneName = constraintMap.bones[j];
                        var bone = skeletonData.findBone(boneName);
                        if (bone == null) throw new Error("Transform constraint bone not found: " + boneName);
                        data.bones.push(bone);
                      }

                      var targetName = constraintMap.target;
                      data.target = skeletonData.findBone(targetName);
                      if (data.target == null) throw new Error("Transform constraint target bone not found: " + targetName);
                      data.local = this.getValue(constraintMap, "local", false);
                      data.relative = this.getValue(constraintMap, "relative", false);
                      data.offsetRotation = this.getValue(constraintMap, "rotation", 0);
                      data.offsetX = this.getValue(constraintMap, "x", 0) * scale;
                      data.offsetY = this.getValue(constraintMap, "y", 0) * scale;
                      data.offsetScaleX = this.getValue(constraintMap, "scaleX", 0);
                      data.offsetScaleY = this.getValue(constraintMap, "scaleY", 0);
                      data.offsetShearY = this.getValue(constraintMap, "shearY", 0);
                      data.rotateMix = this.getValue(constraintMap, "rotateMix", 1);
                      data.translateMix = this.getValue(constraintMap, "translateMix", 1);
                      data.scaleMix = this.getValue(constraintMap, "scaleMix", 1);
                      data.shearMix = this.getValue(constraintMap, "shearMix", 1);
                      skeletonData.transformConstraints.push(data);
                    }
                  }

                  if (root.path) {
                    for (var i = 0; i < root.path.length; i++) {
                      var constraintMap = root.path[i];
                      var data = new spine.PathConstraintData(constraintMap.name);
                      data.order = this.getValue(constraintMap, "order", 0);
                      data.skinRequired = this.getValue(constraintMap, "skin", false);

                      for (var j = 0; j < constraintMap.bones.length; j++) {
                        var boneName = constraintMap.bones[j];
                        var bone = skeletonData.findBone(boneName);
                        if (bone == null) throw new Error("Transform constraint bone not found: " + boneName);
                        data.bones.push(bone);
                      }

                      var targetName = constraintMap.target;
                      data.target = skeletonData.findSlot(targetName);
                      if (data.target == null) throw new Error("Path target slot not found: " + targetName);
                      data.positionMode = SkeletonJson.positionModeFromString(this.getValue(constraintMap, "positionMode", "percent"));
                      data.spacingMode = SkeletonJson.spacingModeFromString(this.getValue(constraintMap, "spacingMode", "length"));
                      data.rotateMode = SkeletonJson.rotateModeFromString(this.getValue(constraintMap, "rotateMode", "tangent"));
                      data.offsetRotation = this.getValue(constraintMap, "rotation", 0);
                      data.position = this.getValue(constraintMap, "position", 0);
                      if (data.positionMode == spine.PositionMode.Fixed) data.position *= scale;
                      data.spacing = this.getValue(constraintMap, "spacing", 0);
                      if (data.spacingMode == spine.SpacingMode.Length || data.spacingMode == spine.SpacingMode.Fixed) data.spacing *= scale;
                      data.rotateMix = this.getValue(constraintMap, "rotateMix", 1);
                      data.translateMix = this.getValue(constraintMap, "translateMix", 1);
                      skeletonData.pathConstraints.push(data);
                    }
                  }

                  if (root.skins) {
                    var skins = root.skins;
                    var isArray = skins instanceof Array;

                    if (!isArray) {
                      var skinArr = [];

                      for (var skinName in skins) {
                        skinArr.push({
                          name: skinName,
                          attachments: skins[skinName]
                        });
                      }

                      skins = skinArr;
                    }

                    for (var i = 0; i < skins.length; i++) {
                      var skinMap = skins[i];
                      var skin = new spine.Skin(skinMap.name);

                      if (skinMap.bones) {
                        for (var ii = 0; ii < skinMap.bones.length; ii++) {
                          var bone = skeletonData.findBone(skinMap.bones[ii]);
                          if (bone == null) throw new Error("Skin bone not found: " + skinMap.bones[i]);
                          skin.bones.push(bone);
                        }
                      }

                      if (skinMap.ik) {
                        for (var ii = 0; ii < skinMap.ik.length; ii++) {
                          var constraint = skeletonData.findIkConstraint(skinMap.ik[ii]);
                          if (constraint == null) throw new Error("Skin IK constraint not found: " + skinMap.ik[i]);
                          skin.constraints.push(constraint);
                        }
                      }

                      if (skinMap.transform) {
                        for (var ii = 0; ii < skinMap.transform.length; ii++) {
                          var constraint = skeletonData.findTransformConstraint(skinMap.transform[ii]);
                          if (constraint == null) throw new Error("Skin transform constraint not found: " + skinMap.transform[i]);
                          skin.constraints.push(constraint);
                        }
                      }

                      if (skinMap.path) {
                        for (var ii = 0; ii < skinMap.path.length; ii++) {
                          var constraint = skeletonData.findPathConstraint(skinMap.path[ii]);
                          if (constraint == null) throw new Error("Skin path constraint not found: " + skinMap.path[i]);
                          skin.constraints.push(constraint);
                        }
                      }

                      for (var slotName in skinMap.attachments) {
                        var slot = skeletonData.findSlot(slotName);
                        if (slot == null) throw new Error("Slot not found: " + slotName);
                        var slotMap = skinMap.attachments[slotName];

                        for (var entryName in slotMap) {
                          var attachment = this.readAttachment(slotMap[entryName], skin, slot.index, entryName, skeletonData);
                          if (attachment != null) skin.setAttachment(slot.index, entryName, attachment);
                        }
                      }

                      skeletonData.skins.push(skin);
                      if (skin.name == "default") skeletonData.defaultSkin = skin;
                    }
                  }

                  for (var i = 0, n = this.linkedMeshes.length; i < n; i++) {
                    var linkedMesh = this.linkedMeshes[i];
                    var skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);
                    if (skin == null) throw new Error("Skin not found: " + linkedMesh.skin);
                    var parent_6 = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);
                    if (parent_6 == null) throw new Error("Parent mesh not found: " + linkedMesh.parent);
                    linkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? parent_6 : linkedMesh.mesh;
                    linkedMesh.mesh.setParentMesh(parent_6);
                    linkedMesh.mesh.updateUVs();
                  }

                  this.linkedMeshes.length = 0;

                  if (root.events) {
                    for (var eventName in root.events) {
                      var eventMap = root.events[eventName];
                      var data = new spine.EventData(eventName);
                      data.intValue = this.getValue(eventMap, "int", 0);
                      data.floatValue = this.getValue(eventMap, "float", 0);
                      data.stringValue = this.getValue(eventMap, "string", "");
                      data.audioPath = this.getValue(eventMap, "audio", null);

                      if (data.audioPath != null) {
                        data.volume = this.getValue(eventMap, "volume", 1);
                        data.balance = this.getValue(eventMap, "balance", 0);
                      }

                      skeletonData.events.push(data);
                    }
                  }

                  if (root.animations) {
                    for (var animationName in root.animations) {
                      var animationMap = root.animations[animationName];
                      this.readAnimation(animationMap, animationName, skeletonData);
                    }
                  }

                  return skeletonData;
                };

                SkeletonJson.prototype.readAttachment = function (map, skin, slotIndex, name, skeletonData) {
                  var scale = this.scale;
                  name = this.getValue(map, "name", name);
                  var type = this.getValue(map, "type", "region");

                  switch (type) {
                    case "region":
                      {
                        var path = this.getValue(map, "path", name);
                        var region = this.attachmentLoader.newRegionAttachment(skin, name, path);
                        if (region == null) return null;
                        region.path = path;
                        region.x = this.getValue(map, "x", 0) * scale;
                        region.y = this.getValue(map, "y", 0) * scale;
                        region.scaleX = this.getValue(map, "scaleX", 1);
                        region.scaleY = this.getValue(map, "scaleY", 1);
                        region.rotation = this.getValue(map, "rotation", 0);
                        region.width = map.width * scale;
                        region.height = map.height * scale;
                        var color = this.getValue(map, "color", null);
                        if (color != null) region.color.setFromString(color);
                        region.updateOffset();
                        return region;
                      }

                    case "boundingbox":
                      {
                        var box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);
                        if (box == null) return null;
                        this.readVertices(map, box, map.vertexCount << 1);
                        var color = this.getValue(map, "color", null);
                        if (color != null) box.color.setFromString(color);
                        return box;
                      }

                    case "mesh":
                    case "linkedmesh":
                      {
                        var path = this.getValue(map, "path", name);
                        var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);
                        if (mesh == null) return null;
                        mesh.path = path;
                        var color = this.getValue(map, "color", null);
                        if (color != null) mesh.color.setFromString(color);
                        mesh.width = this.getValue(map, "width", 0) * scale;
                        mesh.height = this.getValue(map, "height", 0) * scale;
                        var parent_7 = this.getValue(map, "parent", null);

                        if (parent_7 != null) {
                          this.linkedMeshes.push(new LinkedMesh(mesh, this.getValue(map, "skin", null), slotIndex, parent_7, this.getValue(map, "deform", true)));
                          return mesh;
                        }

                        var uvs = map.uvs;
                        this.readVertices(map, mesh, uvs.length);
                        mesh.triangles = map.triangles;
                        mesh.regionUVs = uvs;
                        mesh.updateUVs();
                        mesh.edges = this.getValue(map, "edges", null);
                        mesh.hullLength = this.getValue(map, "hull", 0) * 2;
                        return mesh;
                      }

                    case "path":
                      {
                        var path = this.attachmentLoader.newPathAttachment(skin, name);
                        if (path == null) return null;
                        path.closed = this.getValue(map, "closed", false);
                        path.constantSpeed = this.getValue(map, "constantSpeed", true);
                        var vertexCount = map.vertexCount;
                        this.readVertices(map, path, vertexCount << 1);
                        var lengths = spine.Utils.newArray(vertexCount / 3, 0);

                        for (var i = 0; i < map.lengths.length; i++) lengths[i] = map.lengths[i] * scale;

                        path.lengths = lengths;
                        var color = this.getValue(map, "color", null);
                        if (color != null) path.color.setFromString(color);
                        return path;
                      }

                    case "point":
                      {
                        var point = this.attachmentLoader.newPointAttachment(skin, name);
                        if (point == null) return null;
                        point.x = this.getValue(map, "x", 0) * scale;
                        point.y = this.getValue(map, "y", 0) * scale;
                        point.rotation = this.getValue(map, "rotation", 0);
                        var color = this.getValue(map, "color", null);
                        if (color != null) point.color.setFromString(color);
                        return point;
                      }

                    case "clipping":
                      {
                        var clip = this.attachmentLoader.newClippingAttachment(skin, name);
                        if (clip == null) return null;
                        var end = this.getValue(map, "end", null);

                        if (end != null) {
                          var slot = skeletonData.findSlot(end);
                          if (slot == null) throw new Error("Clipping end slot not found: " + end);
                          clip.endSlot = slot;
                        }

                        var vertexCount = map.vertexCount;
                        this.readVertices(map, clip, vertexCount << 1);
                        var color = this.getValue(map, "color", null);
                        if (color != null) clip.color.setFromString(color);
                        return clip;
                      }
                  }

                  return null;
                };

                SkeletonJson.prototype.readVertices = function (map, attachment, verticesLength) {
                  var scale = this.scale;
                  attachment.worldVerticesLength = verticesLength;
                  var vertices = map.vertices;

                  if (verticesLength == vertices.length) {
                    var scaledVertices = spine.Utils.toFloatArray(vertices);

                    if (scale != 1) {
                      for (var i = 0, n = vertices.length; i < n; i++) scaledVertices[i] *= scale;
                    }

                    attachment.vertices = scaledVertices;
                    return;
                  }

                  var weights = new Array();
                  var bones = new Array();

                  for (var i = 0, n = vertices.length; i < n;) {
                    var boneCount = vertices[i++];
                    bones.push(boneCount);

                    for (var nn = i + boneCount * 4; i < nn; i += 4) {
                      bones.push(vertices[i]);
                      weights.push(vertices[i + 1] * scale);
                      weights.push(vertices[i + 2] * scale);
                      weights.push(vertices[i + 3]);
                    }
                  }

                  attachment.bones = bones;
                  attachment.vertices = spine.Utils.toFloatArray(weights);
                };

                SkeletonJson.prototype.readAnimation = function (map, name, skeletonData) {
                  var scale = this.scale;
                  var timelines = new Array();
                  var duration = 0;

                  if (map.slots) {
                    for (var slotName in map.slots) {
                      var slotMap = map.slots[slotName];
                      var slotIndex = skeletonData.findSlotIndex(slotName);
                      if (slotIndex == -1) throw new Error("Slot not found: " + slotName);

                      for (var timelineName in slotMap) {
                        var timelineMap = slotMap[timelineName];

                        if (timelineName == "attachment") {
                          var timeline = new spine.AttachmentTimeline(timelineMap.length);
                          timeline.slotIndex = slotIndex;
                          var frameIndex = 0;

                          for (var i = 0; i < timelineMap.length; i++) {
                            var valueMap = timelineMap[i];
                            timeline.setFrame(frameIndex++, this.getValue(valueMap, "time", 0), valueMap.name);
                          }

                          timelines.push(timeline);
                          duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
                        } else if (timelineName == "color") {
                          var timeline = new spine.ColorTimeline(timelineMap.length);
                          timeline.slotIndex = slotIndex;
                          var frameIndex = 0;

                          for (var i = 0; i < timelineMap.length; i++) {
                            var valueMap = timelineMap[i];
                            var color = new spine.Color();
                            color.setFromString(valueMap.color);
                            timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), color.r, color.g, color.b, color.a);
                            this.readCurve(valueMap, timeline, frameIndex);
                            frameIndex++;
                          }

                          timelines.push(timeline);
                          duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.ColorTimeline.ENTRIES]);
                        } else if (timelineName == "twoColor") {
                          var timeline = new spine.TwoColorTimeline(timelineMap.length);
                          timeline.slotIndex = slotIndex;
                          var frameIndex = 0;

                          for (var i = 0; i < timelineMap.length; i++) {
                            var valueMap = timelineMap[i];
                            var light = new spine.Color();
                            var dark = new spine.Color();
                            light.setFromString(valueMap.light);
                            dark.setFromString(valueMap.dark);
                            timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), light.r, light.g, light.b, light.a, dark.r, dark.g, dark.b);
                            this.readCurve(valueMap, timeline, frameIndex);
                            frameIndex++;
                          }

                          timelines.push(timeline);
                          duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.TwoColorTimeline.ENTRIES]);
                        } else throw new Error("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");
                      }
                    }
                  }

                  if (map.bones) {
                    for (var boneName in map.bones) {
                      var boneMap = map.bones[boneName];
                      var boneIndex = skeletonData.findBoneIndex(boneName);
                      if (boneIndex == -1) throw new Error("Bone not found: " + boneName);

                      for (var timelineName in boneMap) {
                        var timelineMap = boneMap[timelineName];

                        if (timelineName === "rotate") {
                          var timeline = new spine.RotateTimeline(timelineMap.length);
                          timeline.boneIndex = boneIndex;
                          var frameIndex = 0;

                          for (var i = 0; i < timelineMap.length; i++) {
                            var valueMap = timelineMap[i];
                            timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), this.getValue(valueMap, "angle", 0));
                            this.readCurve(valueMap, timeline, frameIndex);
                            frameIndex++;
                          }

                          timelines.push(timeline);
                          duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.RotateTimeline.ENTRIES]);
                        } else if (timelineName === "translate" || timelineName === "scale" || timelineName === "shear") {
                          var timeline = null;
                          var timelineScale = 1,
                              defaultValue = 0;

                          if (timelineName === "scale") {
                            timeline = new spine.ScaleTimeline(timelineMap.length);
                            defaultValue = 1;
                          } else if (timelineName === "shear") timeline = new spine.ShearTimeline(timelineMap.length);else {
                            timeline = new spine.TranslateTimeline(timelineMap.length);
                            timelineScale = scale;
                          }

                          timeline.boneIndex = boneIndex;
                          var frameIndex = 0;

                          for (var i = 0; i < timelineMap.length; i++) {
                            var valueMap = timelineMap[i];
                            var x = this.getValue(valueMap, "x", defaultValue),
                                y = this.getValue(valueMap, "y", defaultValue);
                            timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), x * timelineScale, y * timelineScale);
                            this.readCurve(valueMap, timeline, frameIndex);
                            frameIndex++;
                          }

                          timelines.push(timeline);
                          duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.TranslateTimeline.ENTRIES]);
                        } else throw new Error("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");
                      }
                    }
                  }

                  if (map.ik) {
                    for (var constraintName in map.ik) {
                      var constraintMap = map.ik[constraintName];
                      var constraint = skeletonData.findIkConstraint(constraintName);
                      var timeline = new spine.IkConstraintTimeline(constraintMap.length);
                      timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);
                      var frameIndex = 0;

                      for (var i = 0; i < constraintMap.length; i++) {
                        var valueMap = constraintMap[i];
                        timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), this.getValue(valueMap, "mix", 1), this.getValue(valueMap, "softness", 0) * scale, this.getValue(valueMap, "bendPositive", true) ? 1 : -1, this.getValue(valueMap, "compress", false), this.getValue(valueMap, "stretch", false));
                        this.readCurve(valueMap, timeline, frameIndex);
                        frameIndex++;
                      }

                      timelines.push(timeline);
                      duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.IkConstraintTimeline.ENTRIES]);
                    }
                  }

                  if (map.transform) {
                    for (var constraintName in map.transform) {
                      var constraintMap = map.transform[constraintName];
                      var constraint = skeletonData.findTransformConstraint(constraintName);
                      var timeline = new spine.TransformConstraintTimeline(constraintMap.length);
                      timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);
                      var frameIndex = 0;

                      for (var i = 0; i < constraintMap.length; i++) {
                        var valueMap = constraintMap[i];
                        timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), this.getValue(valueMap, "rotateMix", 1), this.getValue(valueMap, "translateMix", 1), this.getValue(valueMap, "scaleMix", 1), this.getValue(valueMap, "shearMix", 1));
                        this.readCurve(valueMap, timeline, frameIndex);
                        frameIndex++;
                      }

                      timelines.push(timeline);
                      duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.TransformConstraintTimeline.ENTRIES]);
                    }
                  }

                  let mapPath = map.path || map.paths;

                  if (mapPath) {
                    for (var constraintName in mapPath) {
                      var constraintMap = mapPath[constraintName];
                      var index = skeletonData.findPathConstraintIndex(constraintName);
                      if (index == -1) throw new Error("Path constraint not found: " + constraintName);
                      var data = skeletonData.pathConstraints[index];

                      for (var timelineName in constraintMap) {
                        var timelineMap = constraintMap[timelineName];

                        if (timelineName === "position" || timelineName === "spacing") {
                          var timeline = null;
                          var timelineScale = 1;

                          if (timelineName === "spacing") {
                            timeline = new spine.PathConstraintSpacingTimeline(timelineMap.length);
                            if (data.spacingMode == spine.SpacingMode.Length || data.spacingMode == spine.SpacingMode.Fixed) timelineScale = scale;
                          } else {
                            timeline = new spine.PathConstraintPositionTimeline(timelineMap.length);
                            if (data.positionMode == spine.PositionMode.Fixed) timelineScale = scale;
                          }

                          timeline.pathConstraintIndex = index;
                          var frameIndex = 0;

                          for (var i = 0; i < timelineMap.length; i++) {
                            var valueMap = timelineMap[i];
                            timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), this.getValue(valueMap, timelineName, 0) * timelineScale);
                            this.readCurve(valueMap, timeline, frameIndex);
                            frameIndex++;
                          }

                          timelines.push(timeline);
                          duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.PathConstraintPositionTimeline.ENTRIES]);
                        } else if (timelineName === "mix") {
                          var timeline = new spine.PathConstraintMixTimeline(timelineMap.length);
                          timeline.pathConstraintIndex = index;
                          var frameIndex = 0;

                          for (var i = 0; i < timelineMap.length; i++) {
                            var valueMap = timelineMap[i];
                            timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), this.getValue(valueMap, "rotateMix", 1), this.getValue(valueMap, "translateMix", 1));
                            this.readCurve(valueMap, timeline, frameIndex);
                            frameIndex++;
                          }

                          timelines.push(timeline);
                          duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.PathConstraintMixTimeline.ENTRIES]);
                        }
                      }
                    }
                  }

                  if (map.deform) {
                    for (var deformName in map.deform) {
                      var deformMap = map.deform[deformName];
                      var skin = skeletonData.findSkin(deformName);
                      if (skin == null) throw new Error("Skin not found: " + deformName);

                      for (var slotName in deformMap) {
                        var slotMap = deformMap[slotName];
                        var slotIndex = skeletonData.findSlotIndex(slotName);
                        if (slotIndex == -1) throw new Error("Slot not found: " + slotMap.name);

                        for (var timelineName in slotMap) {
                          var timelineMap = slotMap[timelineName];
                          var attachment = skin.getAttachment(slotIndex, timelineName);

                          if (attachment == null) {
                            continue;
                          }

                          var weighted = attachment.bones != null;
                          var vertices = attachment.vertices;
                          var deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;
                          var timeline = new spine.DeformTimeline(timelineMap.length);
                          timeline.slotIndex = slotIndex;
                          timeline.attachment = attachment;
                          var frameIndex = 0;

                          for (var j = 0; j < timelineMap.length; j++) {
                            var valueMap = timelineMap[j];
                            var deform = void 0;
                            var verticesValue = this.getValue(valueMap, "vertices", null);
                            if (verticesValue == null) deform = weighted ? spine.Utils.newFloatArray(deformLength) : vertices;else {
                              deform = spine.Utils.newFloatArray(deformLength);
                              var start = this.getValue(valueMap, "offset", 0);
                              spine.Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);

                              if (scale != 1) {
                                for (var i = start, n = i + verticesValue.length; i < n; i++) deform[i] *= scale;
                              }

                              if (!weighted) {
                                for (var i = 0; i < deformLength; i++) deform[i] += vertices[i];
                              }
                            }
                            timeline.setFrame(frameIndex, this.getValue(valueMap, "time", 0), deform);
                            this.readCurve(valueMap, timeline, frameIndex);
                            frameIndex++;
                          }

                          timelines.push(timeline);
                          duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
                        }
                      }
                    }
                  }

                  var drawOrderNode = map.drawOrder;
                  if (drawOrderNode == null) drawOrderNode = map.draworder;

                  if (drawOrderNode != null) {
                    var timeline = new spine.DrawOrderTimeline(drawOrderNode.length);
                    var slotCount = skeletonData.slots.length;
                    var frameIndex = 0;

                    for (var j = 0; j < drawOrderNode.length; j++) {
                      var drawOrderMap = drawOrderNode[j];
                      var drawOrder = null;
                      var offsets = this.getValue(drawOrderMap, "offsets", null);

                      if (offsets != null) {
                        drawOrder = spine.Utils.newArray(slotCount, -1);
                        var unchanged = spine.Utils.newArray(slotCount - offsets.length, 0);
                        var originalIndex = 0,
                            unchangedIndex = 0;

                        for (var i = 0; i < offsets.length; i++) {
                          var offsetMap = offsets[i];
                          var slotIndex = skeletonData.findSlotIndex(offsetMap.slot);
                          if (slotIndex == -1) throw new Error("Slot not found: " + offsetMap.slot);

                          while (originalIndex != slotIndex) unchanged[unchangedIndex++] = originalIndex++;

                          drawOrder[originalIndex + offsetMap.offset] = originalIndex++;
                        }

                        while (originalIndex < slotCount) unchanged[unchangedIndex++] = originalIndex++;

                        for (var i = slotCount - 1; i >= 0; i--) if (drawOrder[i] == -1) drawOrder[i] = unchanged[--unchangedIndex];
                      }

                      timeline.setFrame(frameIndex++, this.getValue(drawOrderMap, "time", 0), drawOrder);
                    }

                    timelines.push(timeline);
                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
                  }

                  if (map.events) {
                    var timeline = new spine.EventTimeline(map.events.length);
                    var frameIndex = 0;

                    for (var i = 0; i < map.events.length; i++) {
                      var eventMap = map.events[i];
                      var eventData = skeletonData.findEvent(eventMap.name);
                      if (eventData == null) throw new Error("Event not found: " + eventMap.name);
                      var event_6 = new spine.Event(spine.Utils.toSinglePrecision(this.getValue(eventMap, "time", 0)), eventData);
                      event_6.intValue = this.getValue(eventMap, "int", eventData.intValue);
                      event_6.floatValue = this.getValue(eventMap, "float", eventData.floatValue);
                      event_6.stringValue = this.getValue(eventMap, "string", eventData.stringValue);

                      if (event_6.data.audioPath != null) {
                        event_6.volume = this.getValue(eventMap, "volume", 1);
                        event_6.balance = this.getValue(eventMap, "balance", 0);
                      }

                      timeline.setFrame(frameIndex++, event_6);
                    }

                    timelines.push(timeline);
                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
                  }

                  if (isNaN(duration)) {
                    throw new Error("Error while parsing animation, duration is NaN");
                  }

                  skeletonData.animations.push(new spine.Animation(name, timelines, duration));
                };

                SkeletonJson.prototype.readCurve = function (map, timeline, frameIndex) {
                  var curve = map.curve;
                  if (!curve) return;

                  if (curve == "stepped") {
                    timeline.setStepped(frameIndex);
                  } else if (Object.prototype.toString.call(curve) === '[object Array]') {
                    timeline.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);
                  } else {
                    timeline.setCurve(frameIndex, curve, this.getValue(map, "c2", 0), this.getValue(map, "c3", 1), this.getValue(map, "c4", 1));
                  }
                };

                SkeletonJson.prototype.getValue = function (map, prop, defaultValue) {
                  return map[prop] !== undefined ? map[prop] : defaultValue;
                };

                SkeletonJson.blendModeFromString = function (str) {
                  str = str.toLowerCase();
                  if (str == "normal") return spine.BlendMode.Normal;
                  if (str == "additive") return spine.BlendMode.Additive;
                  if (str == "multiply") return spine.BlendMode.Multiply;
                  if (str == "screen") return spine.BlendMode.Screen;
                  throw new Error("Unknown blend mode: " + str);
                };

                SkeletonJson.positionModeFromString = function (str) {
                  str = str.toLowerCase();
                  if (str == "fixed") return spine.PositionMode.Fixed;
                  if (str == "percent") return spine.PositionMode.Percent;
                  throw new Error("Unknown position mode: " + str);
                };

                SkeletonJson.spacingModeFromString = function (str) {
                  str = str.toLowerCase();
                  if (str == "length") return spine.SpacingMode.Length;
                  if (str == "fixed") return spine.SpacingMode.Fixed;
                  if (str == "percent") return spine.SpacingMode.Percent;
                  throw new Error("Unknown position mode: " + str);
                };

                SkeletonJson.rotateModeFromString = function (str) {
                  str = str.toLowerCase();
                  if (str == "tangent") return spine.RotateMode.Tangent;
                  if (str == "chain") return spine.RotateMode.Chain;
                  if (str == "chainscale") return spine.RotateMode.ChainScale;
                  throw new Error("Unknown rotate mode: " + str);
                };

                SkeletonJson.transformModeFromString = function (str) {
                  str = str.toLowerCase();
                  if (str == "normal") return spine.TransformMode.Normal;
                  if (str == "onlytranslation") return spine.TransformMode.OnlyTranslation;
                  if (str == "norotationorreflection") return spine.TransformMode.NoRotationOrReflection;
                  if (str == "noscale") return spine.TransformMode.NoScale;
                  if (str == "noscaleorreflection") return spine.TransformMode.NoScaleOrReflection;
                  throw new Error("Unknown transform mode: " + str);
                };

                return SkeletonJson;
              }();

              spine.SkeletonJson = SkeletonJson;

              var LinkedMesh = function () {
                function LinkedMesh(mesh, skin, slotIndex, parent, inheritDeform) {
                  this.mesh = mesh;
                  this.skin = skin;
                  this.slotIndex = slotIndex;
                  this.parent = parent;
                  this.inheritDeform = inheritDeform;
                }

                return LinkedMesh;
              }();
            })(spine || (spine = {}));

            var spine;

            (function (spine) {
              var SkinEntry = function () {
                function SkinEntry(slotIndex, name, attachment) {
                  this.slotIndex = slotIndex;
                  this.name = name;
                  this.attachment = attachment;
                }

                return SkinEntry;
              }();

              spine.SkinEntry = SkinEntry;

              var Skin = function () {
                function Skin(name) {
                  this.attachments = new Array();
                  this.bones = Array();
                  this.constraints = new Array();
                  if (name == null) throw new Error("name cannot be null.");
                  this.name = name;
                }

                Skin.prototype.setAttachment = function (slotIndex, name, attachment) {
                  if (attachment == null) throw new Error("attachment cannot be null.");
                  var attachments = this.attachments;
                  if (slotIndex >= attachments.length) attachments.length = slotIndex + 1;
                  if (!attachments[slotIndex]) attachments[slotIndex] = {};
                  attachments[slotIndex][name] = attachment;
                };

                Skin.prototype.addSkin = function (skin) {
                  for (var i = 0; i < skin.bones.length; i++) {
                    var bone = skin.bones[i];
                    var contained = false;

                    for (var j = 0; j < this.bones.length; j++) {
                      if (this.bones[j] == bone) {
                        contained = true;
                        break;
                      }
                    }

                    if (!contained) this.bones.push(bone);
                  }

                  for (var i = 0; i < skin.constraints.length; i++) {
                    var constraint = skin.constraints[i];
                    var contained = false;

                    for (var j = 0; j < this.constraints.length; j++) {
                      if (this.constraints[j] == constraint) {
                        contained = true;
                        break;
                      }
                    }

                    if (!contained) this.constraints.push(constraint);
                  }

                  var attachments = skin.getAttachments();

                  for (var i = 0; i < attachments.length; i++) {
                    var attachment = attachments[i];
                    this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);
                  }
                };

                Skin.prototype.copySkin = function (skin) {
                  for (var i = 0; i < skin.bones.length; i++) {
                    var bone = skin.bones[i];
                    var contained = false;

                    for (var j = 0; j < this.bones.length; j++) {
                      if (this.bones[j] == bone) {
                        contained = true;
                        break;
                      }
                    }

                    if (!contained) this.bones.push(bone);
                  }

                  for (var i = 0; i < skin.constraints.length; i++) {
                    var constraint = skin.constraints[i];
                    var contained = false;

                    for (var j = 0; j < this.constraints.length; j++) {
                      if (this.constraints[j] == constraint) {
                        contained = true;
                        break;
                      }
                    }

                    if (!contained) this.constraints.push(constraint);
                  }

                  var attachments = skin.getAttachments();

                  for (var i = 0; i < attachments.length; i++) {
                    var attachment = attachments[i];
                    if (attachment.attachment == null) continue;

                    if (attachment.attachment instanceof spine.MeshAttachment) {
                      attachment.attachment = attachment.attachment.newLinkedMesh();
                      this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);
                    } else {
                      attachment.attachment = attachment.attachment.copy();
                      this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);
                    }
                  }
                };

                Skin.prototype.getAttachment = function (slotIndex, name) {
                  var dictionary = this.attachments[slotIndex];
                  return dictionary ? dictionary[name] : null;
                };

                Skin.prototype.removeAttachment = function (slotIndex, name) {
                  var dictionary = this.attachments[slotIndex];
                  if (dictionary) dictionary[name] = null;
                };

                Skin.prototype.getAttachments = function () {
                  var entries = new Array();

                  for (var i = 0; i < this.attachments.length; i++) {
                    var slotAttachments = this.attachments[i];

                    if (slotAttachments) {
                      for (var name_4 in slotAttachments) {
                        var attachment = slotAttachments[name_4];
                        if (attachment) entries.push(new SkinEntry(i, name_4, attachment));
                      }
                    }
                  }

                  return entries;
                };

                Skin.prototype.getAttachmentsForSlot = function (slotIndex, attachments) {
                  var slotAttachments = this.attachments[slotIndex];

                  if (slotAttachments) {
                    for (var name_5 in slotAttachments) {
                      var attachment = slotAttachments[name_5];
                      if (attachment) attachments.push(new SkinEntry(slotIndex, name_5, attachment));
                    }
                  }
                };

                Skin.prototype.clear = function () {
                  this.attachments.length = 0;
                  this.bones.length = 0;
                  this.constraints.length = 0;
                };

                Skin.prototype.attachAll = function (skeleton, oldSkin) {
                  var slotIndex = 0;

                  for (var i = 0; i < skeleton.slots.length; i++) {
                    var slot = skeleton.slots[i];
                    var slotAttachment = slot.getAttachment();

                    if (slotAttachment && slotIndex < oldSkin.attachments.length) {
                      var dictionary = oldSkin.attachments[slotIndex];

                      for (var key in dictionary) {
                        var skinAttachment = dictionary[key];

                        if (slotAttachment == skinAttachment) {
                          var attachment = this.getAttachment(slotIndex, key);
                          if (attachment != null) slot.setAttachment(attachment);
                          break;
                        }
                      }
                    }

                    slotIndex++;
                  }
                };

                return Skin;
              }();

              spine.Skin = Skin;
            })(spine || (spine = {}));

            var spine;

            (function (spine) {
              var Slot = function () {
                function Slot(data, bone) {
                  this.deform = new Array();
                  if (data == null) throw new Error("data cannot be null.");
                  if (bone == null) throw new Error("bone cannot be null.");
                  this.data = data;
                  this.bone = bone;
                  this.color = new spine.Color();
                  this.darkColor = data.darkColor == null ? null : new spine.Color();
                  this.setToSetupPose();
                }

                Slot.prototype.getSkeleton = function () {
                  return this.bone.skeleton;
                };

                Slot.prototype.getAttachment = function () {
                  return this.attachment;
                };

                Slot.prototype.setAttachment = function (attachment) {
                  if (this.attachment == attachment) return;
                  this.attachment = attachment;
                  this.attachmentTime = this.bone.skeleton.time;
                  this.deform.length = 0;
                };

                Slot.prototype.setAttachmentTime = function (time) {
                  this.attachmentTime = this.bone.skeleton.time - time;
                };

                Slot.prototype.getAttachmentTime = function () {
                  return this.bone.skeleton.time - this.attachmentTime;
                };

                Slot.prototype.setToSetupPose = function () {
                  this.color.setFromColor(this.data.color);
                  if (this.darkColor != null) this.darkColor.setFromColor(this.data.darkColor);
                  if (this.data.attachmentName == null) this.attachment = null;else {
                    this.attachment = null;
                    this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));
                  }
                };

                return Slot;
              }();

              spine.Slot = Slot;
            })(spine || (spine = {}));

            var spine;

            (function (spine) {
              var SlotData = function () {
                function SlotData(index, name, boneData) {
                  this.color = new spine.Color(1, 1, 1, 1);
                  if (index < 0) throw new Error("index must be >= 0.");
                  if (name == null) throw new Error("name cannot be null.");
                  if (boneData == null) throw new Error("boneData cannot be null.");
                  this.index = index;
                  this.name = name;
                  this.boneData = boneData;
                }

                return SlotData;
              }();

              spine.SlotData = SlotData;
            })(spine || (spine = {}));

            var spine;

            (function (spine) {
              var Texture = function () {
                function Texture(image) {
                  this._image = image;
                }

                Texture.prototype.getImage = function () {
                  return this._image;
                };

                Texture.filterFromString = function (text) {
                  switch (text.toLowerCase()) {
                    case "nearest":
                      return TextureFilter.Nearest;

                    case "linear":
                      return TextureFilter.Linear;

                    case "mipmap":
                      return TextureFilter.MipMap;

                    case "mipmapnearestnearest":
                      return TextureFilter.MipMapNearestNearest;

                    case "mipmaplinearnearest":
                      return TextureFilter.MipMapLinearNearest;

                    case "mipmapnearestlinear":
                      return TextureFilter.MipMapNearestLinear;

                    case "mipmaplinearlinear":
                      return TextureFilter.MipMapLinearLinear;

                    default:
                      throw new Error("Unknown texture filter " + text);
                  }
                };

                Texture.wrapFromString = function (text) {
                  switch (text.toLowerCase()) {
                    case "mirroredtepeat":
                      return TextureWrap.MirroredRepeat;

                    case "clamptoedge":
                      return TextureWrap.ClampToEdge;

                    case "repeat":
                      return TextureWrap.Repeat;

                    default:
                      throw new Error("Unknown texture wrap " + text);
                  }
                };

                return Texture;
              }();

              spine.Texture = Texture;
              var TextureFilter;

              (function (TextureFilter) {
                TextureFilter[TextureFilter["Nearest"] = 9728] = "Nearest";
                TextureFilter[TextureFilter["Linear"] = 9729] = "Linear";
                TextureFilter[TextureFilter["MipMap"] = 9987] = "MipMap";
                TextureFilter[TextureFilter["MipMapNearestNearest"] = 9984] = "MipMapNearestNearest";
                TextureFilter[TextureFilter["MipMapLinearNearest"] = 9985] = "MipMapLinearNearest";
                TextureFilter[TextureFilter["MipMapNearestLinear"] = 9986] = "MipMapNearestLinear";
                TextureFilter[TextureFilter["MipMapLinearLinear"] = 9987] = "MipMapLinearLinear";
              })(TextureFilter = spine.TextureFilter || (spine.TextureFilter = {}));

              var TextureWrap;

              (function (TextureWrap) {
                TextureWrap[TextureWrap["MirroredRepeat"] = 33648] = "MirroredRepeat";
                TextureWrap[TextureWrap["ClampToEdge"] = 33071] = "ClampToEdge";
                TextureWrap[TextureWrap["Repeat"] = 10497] = "Repeat";
              })(TextureWrap = spine.TextureWrap || (spine.TextureWrap = {}));

              var TextureRegion = function () {
                function TextureRegion() {
                  this.u = 0;
                  this.v = 0;
                  this.u2 = 0;
                  this.v2 = 0;
                  this.width = 0;
                  this.height = 0;
                  this.rotate = false;
                  this.offsetX = 0;
                  this.offsetY = 0;
                  this.originalWidth = 0;
                  this.originalHeight = 0;
                }

                return TextureRegion;
              }();

              spine.TextureRegion = TextureRegion;

              var FakeTexture = function (_super) {
                __extends(FakeTexture, _super);

                function FakeTexture() {
                  return _super !== null && _super.apply(this, arguments) || this;
                }

                FakeTexture.prototype.setFilters = function (minFilter, magFilter) {};

                FakeTexture.prototype.setWraps = function (uWrap, vWrap) {};

                FakeTexture.prototype.dispose = function () {};

                return FakeTexture;
              }(Texture);

              spine.FakeTexture = FakeTexture;
            })(spine || (spine = {}));

            var spine;

            (function (spine) {
              var TextureAtlas = function () {
                function TextureAtlas(atlasText, textureLoader) {
                  this.pages = new Array();
                  this.regions = new Array();
                  this.load(atlasText, textureLoader);
                }

                TextureAtlas.prototype.load = function (atlasText, textureLoader) {
                  if (textureLoader == null) throw new Error("textureLoader cannot be null.");
                  var reader = new TextureAtlasReader(atlasText);
                  var tuple = new Array(4);
                  var page = null;

                  while (true) {
                    var line = reader.readLine();
                    if (line == null) break;
                    line = line.trim();
                    if (line.length == 0) page = null;else if (!page) {
                      page = new TextureAtlasPage();
                      page.name = line;

                      if (reader.readTuple(tuple) == 2) {
                        page.width = parseInt(tuple[0]);
                        page.height = parseInt(tuple[1]);
                        reader.readTuple(tuple);
                      }

                      reader.readTuple(tuple);
                      page.minFilter = spine.Texture.filterFromString(tuple[0]);
                      page.magFilter = spine.Texture.filterFromString(tuple[1]);
                      var direction = reader.readValue();
                      page.uWrap = spine.TextureWrap.ClampToEdge;
                      page.vWrap = spine.TextureWrap.ClampToEdge;
                      if (direction == "x") page.uWrap = spine.TextureWrap.Repeat;else if (direction == "y") page.vWrap = spine.TextureWrap.Repeat;else if (direction == "xy") page.uWrap = page.vWrap = spine.TextureWrap.Repeat;
                      page.texture = textureLoader(line);
                      page.texture.setFilters(page.minFilter, page.magFilter);
                      page.texture.setWraps(page.uWrap, page.vWrap);
                      page.width = page.texture.getImage().width;
                      page.height = page.texture.getImage().height;
                      this.pages.push(page);
                    } else {
                      var region = new TextureAtlasRegion();
                      region.name = line;
                      region.page = page;
                      var rotateValue = reader.readValue();

                      if (rotateValue.toLocaleLowerCase() == "true") {
                        region.degrees = 90;
                      } else if (rotateValue.toLocaleLowerCase() == "false") {
                        region.degrees = 0;
                      } else {
                        region.degrees = parseFloat(rotateValue);
                      }

                      region.rotate = region.degrees == 90;
                      reader.readTuple(tuple);
                      var x = parseInt(tuple[0]);
                      var y = parseInt(tuple[1]);
                      reader.readTuple(tuple);
                      var width = parseInt(tuple[0]);
                      var height = parseInt(tuple[1]);
                      region.u = x / page.width;
                      region.v = y / page.height;

                      if (region.rotate) {
                        region.u2 = (x + height) / page.width;
                        region.v2 = (y + width) / page.height;
                      } else {
                        region.u2 = (x + width) / page.width;
                        region.v2 = (y + height) / page.height;
                      }

                      region.x = x;
                      region.y = y;
                      region.width = Math.abs(width);
                      region.height = Math.abs(height);

                      if (reader.readTuple(tuple) == 4) {
                        if (reader.readTuple(tuple) == 4) {
                          reader.readTuple(tuple);
                        }
                      }

                      region.originalWidth = parseInt(tuple[0]);
                      region.originalHeight = parseInt(tuple[1]);
                      reader.readTuple(tuple);
                      region.offsetX = parseInt(tuple[0]);
                      region.offsetY = parseInt(tuple[1]);
                      region.index = parseInt(reader.readValue());
                      region.texture = page.texture;
                      this.regions.push(region);
                    }
                  }
                };

                TextureAtlas.prototype.findRegion = function (name) {
                  for (var i = 0; i < this.regions.length; i++) {
                    if (this.regions[i].name == name) {
                      return this.regions[i];
                    }
                  }

                  return null;
                };

                TextureAtlas.prototype.dispose = function () {
                  for (var i = 0; i < this.pages.length; i++) {
                    this.pages[i].texture.dispose();
                  }
                };

                return TextureAtlas;
              }();

              spine.TextureAtlas = TextureAtlas;

              var TextureAtlasReader = function () {
                function TextureAtlasReader(text) {
                  this.index = 0;
                  this.lines = text.split(/\r\n|\r|\n/);
                }

                TextureAtlasReader.prototype.readLine = function () {
                  if (this.index >= this.lines.length) return null;
                  return this.lines[this.index++];
                };

                TextureAtlasReader.prototype.readValue = function () {
                  var line = this.readLine();
                  var colon = line.indexOf(":");
                  if (colon == -1) throw new Error("Invalid line: " + line);
                  return line.substring(colon + 1).trim();
                };

                TextureAtlasReader.prototype.readTuple = function (tuple) {
                  var line = this.readLine();
                  var colon = line.indexOf(":");
                  if (colon == -1) throw new Error("Invalid line: " + line);
                  var i = 0,
                      lastMatch = colon + 1;

                  for (; i < 3; i++) {
                    var comma = line.indexOf(",", lastMatch);
                    if (comma == -1) break;
                    tuple[i] = line.substr(lastMatch, comma - lastMatch).trim();
                    lastMatch = comma + 1;
                  }

                  tuple[i] = line.substring(lastMatch).trim();
                  return i + 1;
                };

                return TextureAtlasReader;
              }();

              var TextureAtlasPage = function () {
                function TextureAtlasPage() {}

                return TextureAtlasPage;
              }();

              spine.TextureAtlasPage = TextureAtlasPage;

              var TextureAtlasRegion = function (_super) {
                __extends(TextureAtlasRegion, _super);

                function TextureAtlasRegion() {
                  return _super !== null && _super.apply(this, arguments) || this;
                }

                return TextureAtlasRegion;
              }(spine.TextureRegion);

              spine.TextureAtlasRegion = TextureAtlasRegion;
            })(spine || (spine = {}));

            var spine;

            (function (spine) {
              var TransformConstraint = function () {
                function TransformConstraint(data, skeleton) {
                  this.rotateMix = 0;
                  this.translateMix = 0;
                  this.scaleMix = 0;
                  this.shearMix = 0;
                  this.temp = new spine.Vector2();
                  this.active = false;
                  if (data == null) throw new Error("data cannot be null.");
                  if (skeleton == null) throw new Error("skeleton cannot be null.");
                  this.data = data;
                  this.rotateMix = data.rotateMix;
                  this.translateMix = data.translateMix;
                  this.scaleMix = data.scaleMix;
                  this.shearMix = data.shearMix;
                  this.bones = new Array();

                  for (var i = 0; i < data.bones.length; i++) this.bones.push(skeleton.findBone(data.bones[i].name));

                  this.target = skeleton.findBone(data.target.name);
                }

                TransformConstraint.prototype.isActive = function () {
                  return this.active;
                };

                TransformConstraint.prototype.apply = function () {
                  this.update();
                };

                TransformConstraint.prototype.update = function () {
                  if (this.data.local) {
                    if (this.data.relative) this.applyRelativeLocal();else this.applyAbsoluteLocal();
                  } else {
                    if (this.data.relative) this.applyRelativeWorld();else this.applyAbsoluteWorld();
                  }
                };

                TransformConstraint.prototype.applyAbsoluteWorld = function () {
                  var rotateMix = this.rotateMix,
                      translateMix = this.translateMix,
                      scaleMix = this.scaleMix,
                      shearMix = this.shearMix;
                  var target = this.target;
                  var ta = target.a,
                      tb = target.b,
                      tc = target.c,
                      td = target.d;
                  var degRadReflect = ta * td - tb * tc > 0 ? spine.MathUtils.degRad : -spine.MathUtils.degRad;
                  var offsetRotation = this.data.offsetRotation * degRadReflect;
                  var offsetShearY = this.data.offsetShearY * degRadReflect;
                  var bones = this.bones;

                  for (var i = 0, n = bones.length; i < n; i++) {
                    var bone = bones[i];
                    var modified = false;

                    if (rotateMix != 0) {
                      var a = bone.a,
                          b = bone.b,
                          c = bone.c,
                          d = bone.d;
                      var r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;
                      if (r > spine.MathUtils.PI) r -= spine.MathUtils.PI2;else if (r < -spine.MathUtils.PI) r += spine.MathUtils.PI2;
                      r *= rotateMix;
                      var cos = Math.cos(r),
                          sin = Math.sin(r);
                      bone.a = cos * a - sin * c;
                      bone.b = cos * b - sin * d;
                      bone.c = sin * a + cos * c;
                      bone.d = sin * b + cos * d;
                      modified = true;
                    }

                    if (translateMix != 0) {
                      var temp = this.temp;
                      target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));
                      bone.worldX += (temp.x - bone.worldX) * translateMix;
                      bone.worldY += (temp.y - bone.worldY) * translateMix;
                      modified = true;
                    }

                    if (scaleMix > 0) {
                      var s = Math.sqrt(bone.a * bone.a + bone.c * bone.c);
                      var ts = Math.sqrt(ta * ta + tc * tc);
                      if (s > 0.00001) s = (s + (ts - s + this.data.offsetScaleX) * scaleMix) / s;
                      bone.a *= s;
                      bone.c *= s;
                      s = Math.sqrt(bone.b * bone.b + bone.d * bone.d);
                      ts = Math.sqrt(tb * tb + td * td);
                      if (s > 0.00001) s = (s + (ts - s + this.data.offsetScaleY) * scaleMix) / s;
                      bone.b *= s;
                      bone.d *= s;
                      modified = true;
                    }

                    if (shearMix > 0) {
                      var b = bone.b,
                          d = bone.d;
                      var by = Math.atan2(d, b);
                      var r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(bone.c, bone.a));
                      if (r > spine.MathUtils.PI) r -= spine.MathUtils.PI2;else if (r < -spine.MathUtils.PI) r += spine.MathUtils.PI2;
                      r = by + (r + offsetShearY) * shearMix;
                      var s = Math.sqrt(b * b + d * d);
                      bone.b = Math.cos(r) * s;
                      bone.d = Math.sin(r) * s;
                      modified = true;
                    }

                    if (modified) bone.appliedValid = false;
                  }
                };

                TransformConstraint.prototype.applyRelativeWorld = function () {
                  var rotateMix = this.rotateMix,
                      translateMix = this.translateMix,
                      scaleMix = this.scaleMix,
                      shearMix = this.shearMix;
                  var target = this.target;
                  var ta = target.a,
                      tb = target.b,
                      tc = target.c,
                      td = target.d;
                  var degRadReflect = ta * td - tb * tc > 0 ? spine.MathUtils.degRad : -spine.MathUtils.degRad;
                  var offsetRotation = this.data.offsetRotation * degRadReflect,
                      offsetShearY = this.data.offsetShearY * degRadReflect;
                  var bones = this.bones;

                  for (var i = 0, n = bones.length; i < n; i++) {
                    var bone = bones[i];
                    var modified = false;

                    if (rotateMix != 0) {
                      var a = bone.a,
                          b = bone.b,
                          c = bone.c,
                          d = bone.d;
                      var r = Math.atan2(tc, ta) + offsetRotation;
                      if (r > spine.MathUtils.PI) r -= spine.MathUtils.PI2;else if (r < -spine.MathUtils.PI) r += spine.MathUtils.PI2;
                      r *= rotateMix;
                      var cos = Math.cos(r),
                          sin = Math.sin(r);
                      bone.a = cos * a - sin * c;
                      bone.b = cos * b - sin * d;
                      bone.c = sin * a + cos * c;
                      bone.d = sin * b + cos * d;
                      modified = true;
                    }

                    if (translateMix != 0) {
                      var temp = this.temp;
                      target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));
                      bone.worldX += temp.x * translateMix;
                      bone.worldY += temp.y * translateMix;
                      modified = true;
                    }

                    if (scaleMix > 0) {
                      var s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * scaleMix + 1;
                      bone.a *= s;
                      bone.c *= s;
                      s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * scaleMix + 1;
                      bone.b *= s;
                      bone.d *= s;
                      modified = true;
                    }

                    if (shearMix > 0) {
                      var r = Math.atan2(td, tb) - Math.atan2(tc, ta);
                      if (r > spine.MathUtils.PI) r -= spine.MathUtils.PI2;else if (r < -spine.MathUtils.PI) r += spine.MathUtils.PI2;
                      var b = bone.b,
                          d = bone.d;
                      r = Math.atan2(d, b) + (r - spine.MathUtils.PI / 2 + offsetShearY) * shearMix;
                      var s = Math.sqrt(b * b + d * d);
                      bone.b = Math.cos(r) * s;
                      bone.d = Math.sin(r) * s;
                      modified = true;
                    }

                    if (modified) bone.appliedValid = false;
                  }
                };

                TransformConstraint.prototype.applyAbsoluteLocal = function () {
                  var rotateMix = this.rotateMix,
                      translateMix = this.translateMix,
                      scaleMix = this.scaleMix,
                      shearMix = this.shearMix;
                  var target = this.target;
                  if (!target.appliedValid) target.updateAppliedTransform();
                  var bones = this.bones;

                  for (var i = 0, n = bones.length; i < n; i++) {
                    var bone = bones[i];
                    if (!bone.appliedValid) bone.updateAppliedTransform();
                    var rotation = bone.arotation;

                    if (rotateMix != 0) {
                      var r = target.arotation - rotation + this.data.offsetRotation;
                      r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;
                      rotation += r * rotateMix;
                    }

                    var x = bone.ax,
                        y = bone.ay;

                    if (translateMix != 0) {
                      x += (target.ax - x + this.data.offsetX) * translateMix;
                      y += (target.ay - y + this.data.offsetY) * translateMix;
                    }

                    var scaleX = bone.ascaleX,
                        scaleY = bone.ascaleY;

                    if (scaleMix != 0) {
                      if (scaleX > 0.00001) scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * scaleMix) / scaleX;
                      if (scaleY > 0.00001) scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * scaleMix) / scaleY;
                    }

                    var shearY = bone.ashearY;

                    if (shearMix != 0) {
                      var r = target.ashearY - shearY + this.data.offsetShearY;
                      r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;
                      bone.shearY += r * shearMix;
                    }

                    bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
                  }
                };

                TransformConstraint.prototype.applyRelativeLocal = function () {
                  var rotateMix = this.rotateMix,
                      translateMix = this.translateMix,
                      scaleMix = this.scaleMix,
                      shearMix = this.shearMix;
                  var target = this.target;
                  if (!target.appliedValid) target.updateAppliedTransform();
                  var bones = this.bones;

                  for (var i = 0, n = bones.length; i < n; i++) {
                    var bone = bones[i];
                    if (!bone.appliedValid) bone.updateAppliedTransform();
                    var rotation = bone.arotation;
                    if (rotateMix != 0) rotation += (target.arotation + this.data.offsetRotation) * rotateMix;
                    var x = bone.ax,
                        y = bone.ay;

                    if (translateMix != 0) {
                      x += (target.ax + this.data.offsetX) * translateMix;
                      y += (target.ay + this.data.offsetY) * translateMix;
                    }

                    var scaleX = bone.ascaleX,
                        scaleY = bone.ascaleY;

                    if (scaleMix != 0) {
                      if (scaleX > 0.00001) scaleX *= (target.ascaleX - 1 + this.data.offsetScaleX) * scaleMix + 1;
                      if (scaleY > 0.00001) scaleY *= (target.ascaleY - 1 + this.data.offsetScaleY) * scaleMix + 1;
                    }

                    var shearY = bone.ashearY;
                    if (shearMix != 0) shearY += (target.ashearY + this.data.offsetShearY) * shearMix;
                    bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);
                  }
                };

                return TransformConstraint;
              }();

              spine.TransformConstraint = TransformConstraint;
            })(spine || (spine = {}));

            var spine;

            (function (spine) {
              var TransformConstraintData = function (_super) {
                __extends(TransformConstraintData, _super);

                function TransformConstraintData(name) {
                  var _this = _super.call(this, name, 0, false) || this;

                  _this.bones = new Array();
                  _this.rotateMix = 0;
                  _this.translateMix = 0;
                  _this.scaleMix = 0;
                  _this.shearMix = 0;
                  _this.offsetRotation = 0;
                  _this.offsetX = 0;
                  _this.offsetY = 0;
                  _this.offsetScaleX = 0;
                  _this.offsetScaleY = 0;
                  _this.offsetShearY = 0;
                  _this.relative = false;
                  _this.local = false;
                  return _this;
                }

                return TransformConstraintData;
              }(spine.ConstraintData);

              spine.TransformConstraintData = TransformConstraintData;
            })(spine || (spine = {}));

            var spine;

            (function (spine) {
              var Triangulator = function () {
                function Triangulator() {
                  this.convexPolygons = new Array();
                  this.convexPolygonsIndices = new Array();
                  this.indicesArray = new Array();
                  this.isConcaveArray = new Array();
                  this.triangles = new Array();
                  this.polygonPool = new spine.Pool(function () {
                    return new Array();
                  });
                  this.polygonIndicesPool = new spine.Pool(function () {
                    return new Array();
                  });
                }

                Triangulator.prototype.triangulate = function (verticesArray) {
                  var vertices = verticesArray;
                  var vertexCount = verticesArray.length >> 1;
                  var indices = this.indicesArray;
                  indices.length = 0;

                  for (var i = 0; i < vertexCount; i++) indices[i] = i;

                  var isConcave = this.isConcaveArray;
                  isConcave.length = 0;

                  for (var i = 0, n = vertexCount; i < n; ++i) isConcave[i] = Triangulator.isConcave(i, vertexCount, vertices, indices);

                  var triangles = this.triangles;
                  triangles.length = 0;

                  while (vertexCount > 3) {
                    var previous = vertexCount - 1,
                        i = 0,
                        next = 1;

                    while (true) {
                      outer: if (!isConcave[i]) {
                        var p1 = indices[previous] << 1,
                            p2 = indices[i] << 1,
                            p3 = indices[next] << 1;
                        var p1x = vertices[p1],
                            p1y = vertices[p1 + 1];
                        var p2x = vertices[p2],
                            p2y = vertices[p2 + 1];
                        var p3x = vertices[p3],
                            p3y = vertices[p3 + 1];

                        for (var ii = (next + 1) % vertexCount; ii != previous; ii = (ii + 1) % vertexCount) {
                          if (!isConcave[ii]) continue;
                          var v = indices[ii] << 1;
                          var vx = vertices[v],
                              vy = vertices[v + 1];

                          if (Triangulator.positiveArea(p3x, p3y, p1x, p1y, vx, vy)) {
                            if (Triangulator.positiveArea(p1x, p1y, p2x, p2y, vx, vy)) {
                              if (Triangulator.positiveArea(p2x, p2y, p3x, p3y, vx, vy)) break outer;
                            }
                          }
                        }

                        break;
                      }

                      if (next == 0) {
                        do {
                          if (!isConcave[i]) break;
                          i--;
                        } while (i > 0);

                        break;
                      }

                      previous = i;
                      i = next;
                      next = (next + 1) % vertexCount;
                    }

                    triangles.push(indices[(vertexCount + i - 1) % vertexCount]);
                    triangles.push(indices[i]);
                    triangles.push(indices[(i + 1) % vertexCount]);
                    indices.splice(i, 1);
                    isConcave.splice(i, 1);
                    vertexCount--;
                    var previousIndex = (vertexCount + i - 1) % vertexCount;
                    var nextIndex = i == vertexCount ? 0 : i;
                    isConcave[previousIndex] = Triangulator.isConcave(previousIndex, vertexCount, vertices, indices);
                    isConcave[nextIndex] = Triangulator.isConcave(nextIndex, vertexCount, vertices, indices);
                  }

                  if (vertexCount == 3) {
                    triangles.push(indices[2]);
                    triangles.push(indices[0]);
                    triangles.push(indices[1]);
                  }

                  return triangles;
                };

                Triangulator.prototype.decompose = function (verticesArray, triangles) {
                  var vertices = verticesArray;
                  var convexPolygons = this.convexPolygons;
                  this.polygonPool.freeAll(convexPolygons);
                  convexPolygons.length = 0;
                  var convexPolygonsIndices = this.convexPolygonsIndices;
                  this.polygonIndicesPool.freeAll(convexPolygonsIndices);
                  convexPolygonsIndices.length = 0;
                  var polygonIndices = this.polygonIndicesPool.obtain();
                  polygonIndices.length = 0;
                  var polygon = this.polygonPool.obtain();
                  polygon.length = 0;
                  var fanBaseIndex = -1,
                      lastWinding = 0;

                  for (var i = 0, n = triangles.length; i < n; i += 3) {
                    var t1 = triangles[i] << 1,
                        t2 = triangles[i + 1] << 1,
                        t3 = triangles[i + 2] << 1;
                    var x1 = vertices[t1],
                        y1 = vertices[t1 + 1];
                    var x2 = vertices[t2],
                        y2 = vertices[t2 + 1];
                    var x3 = vertices[t3],
                        y3 = vertices[t3 + 1];
                    var merged = false;

                    if (fanBaseIndex == t1) {
                      var o = polygon.length - 4;
                      var winding1 = Triangulator.winding(polygon[o], polygon[o + 1], polygon[o + 2], polygon[o + 3], x3, y3);
                      var winding2 = Triangulator.winding(x3, y3, polygon[0], polygon[1], polygon[2], polygon[3]);

                      if (winding1 == lastWinding && winding2 == lastWinding) {
                        polygon.push(x3);
                        polygon.push(y3);
                        polygonIndices.push(t3);
                        merged = true;
                      }
                    }

                    if (!merged) {
                      if (polygon.length > 0) {
                        convexPolygons.push(polygon);
                        convexPolygonsIndices.push(polygonIndices);
                      } else {
                        this.polygonPool.free(polygon);
                        this.polygonIndicesPool.free(polygonIndices);
                      }

                      polygon = this.polygonPool.obtain();
                      polygon.length = 0;
                      polygon.push(x1);
                      polygon.push(y1);
                      polygon.push(x2);
                      polygon.push(y2);
                      polygon.push(x3);
                      polygon.push(y3);
                      polygonIndices = this.polygonIndicesPool.obtain();
                      polygonIndices.length = 0;
                      polygonIndices.push(t1);
                      polygonIndices.push(t2);
                      polygonIndices.push(t3);
                      lastWinding = Triangulator.winding(x1, y1, x2, y2, x3, y3);
                      fanBaseIndex = t1;
                    }
                  }

                  if (polygon.length > 0) {
                    convexPolygons.push(polygon);
                    convexPolygonsIndices.push(polygonIndices);
                  }

                  for (var i = 0, n = convexPolygons.length; i < n; i++) {
                    polygonIndices = convexPolygonsIndices[i];
                    if (polygonIndices.length == 0) continue;
                    var firstIndex = polygonIndices[0];
                    var lastIndex = polygonIndices[polygonIndices.length - 1];
                    polygon = convexPolygons[i];
                    var o = polygon.length - 4;
                    var prevPrevX = polygon[o],
                        prevPrevY = polygon[o + 1];
                    var prevX = polygon[o + 2],
                        prevY = polygon[o + 3];
                    var firstX = polygon[0],
                        firstY = polygon[1];
                    var secondX = polygon[2],
                        secondY = polygon[3];
                    var winding = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, firstX, firstY);

                    for (var ii = 0; ii < n; ii++) {
                      if (ii == i) continue;
                      var otherIndices = convexPolygonsIndices[ii];
                      if (otherIndices.length != 3) continue;
                      var otherFirstIndex = otherIndices[0];
                      var otherSecondIndex = otherIndices[1];
                      var otherLastIndex = otherIndices[2];
                      var otherPoly = convexPolygons[ii];
                      var x3 = otherPoly[otherPoly.length - 2],
                          y3 = otherPoly[otherPoly.length - 1];
                      if (otherFirstIndex != firstIndex || otherSecondIndex != lastIndex) continue;
                      var winding1 = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, x3, y3);
                      var winding2 = Triangulator.winding(x3, y3, firstX, firstY, secondX, secondY);

                      if (winding1 == winding && winding2 == winding) {
                        otherPoly.length = 0;
                        otherIndices.length = 0;
                        polygon.push(x3);
                        polygon.push(y3);
                        polygonIndices.push(otherLastIndex);
                        prevPrevX = prevX;
                        prevPrevY = prevY;
                        prevX = x3;
                        prevY = y3;
                        ii = 0;
                      }
                    }
                  }

                  for (var i = convexPolygons.length - 1; i >= 0; i--) {
                    polygon = convexPolygons[i];

                    if (polygon.length == 0) {
                      convexPolygons.splice(i, 1);
                      this.polygonPool.free(polygon);
                      polygonIndices = convexPolygonsIndices[i];
                      convexPolygonsIndices.splice(i, 1);
                      this.polygonIndicesPool.free(polygonIndices);
                    }
                  }

                  return convexPolygons;
                };

                Triangulator.isConcave = function (index, vertexCount, vertices, indices) {
                  var previous = indices[(vertexCount + index - 1) % vertexCount] << 1;
                  var current = indices[index] << 1;
                  var next = indices[(index + 1) % vertexCount] << 1;
                  return !this.positiveArea(vertices[previous], vertices[previous + 1], vertices[current], vertices[current + 1], vertices[next], vertices[next + 1]);
                };

                Triangulator.positiveArea = function (p1x, p1y, p2x, p2y, p3x, p3y) {
                  return p1x * (p3y - p2y) + p2x * (p1y - p3y) + p3x * (p2y - p1y) >= 0;
                };

                Triangulator.winding = function (p1x, p1y, p2x, p2y, p3x, p3y) {
                  var px = p2x - p1x,
                      py = p2y - p1y;
                  return p3x * py - p3y * px + px * p1y - p1x * py >= 0 ? 1 : -1;
                };

                return Triangulator;
              }();

              spine.Triangulator = Triangulator;
            })(spine || (spine = {}));

            var spine;

            (function (spine) {
              var IntSet = function () {
                function IntSet() {
                  this.array = new Array();
                }

                IntSet.prototype.add = function (value) {
                  var contains = this.contains(value);
                  this.array[value | 0] = value | 0;
                  return !contains;
                };

                IntSet.prototype.contains = function (value) {
                  return this.array[value | 0] != undefined;
                };

                IntSet.prototype.remove = function (value) {
                  this.array[value | 0] = undefined;
                };

                IntSet.prototype.clear = function () {
                  this.array.length = 0;
                };

                return IntSet;
              }();

              spine.IntSet = IntSet;

              var Color = function () {
                function Color(r, g, b, a) {
                  if (r === void 0) {
                    r = 0;
                  }

                  if (g === void 0) {
                    g = 0;
                  }

                  if (b === void 0) {
                    b = 0;
                  }

                  if (a === void 0) {
                    a = 0;
                  }

                  this.r = r;
                  this.g = g;
                  this.b = b;
                  this.a = a;
                }

                Color.prototype.set = function (r, g, b, a) {
                  this.r = r;
                  this.g = g;
                  this.b = b;
                  this.a = a;
                  this.clamp();
                  return this;
                };

                Color.prototype.setFromColor = function (c) {
                  this.r = c.r;
                  this.g = c.g;
                  this.b = c.b;
                  this.a = c.a;
                  return this;
                };

                Color.prototype.setFromString = function (hex) {
                  hex = hex.charAt(0) == '#' ? hex.substr(1) : hex;
                  this.r = parseInt(hex.substr(0, 2), 16) / 255.0;
                  this.g = parseInt(hex.substr(2, 2), 16) / 255.0;
                  this.b = parseInt(hex.substr(4, 2), 16) / 255.0;
                  this.a = (hex.length != 8 ? 255 : parseInt(hex.substr(6, 2), 16)) / 255.0;
                  return this;
                };

                Color.prototype.add = function (r, g, b, a) {
                  this.r += r;
                  this.g += g;
                  this.b += b;
                  this.a += a;
                  this.clamp();
                  return this;
                };

                Color.prototype.clamp = function () {
                  if (this.r < 0) this.r = 0;else if (this.r > 1) this.r = 1;
                  if (this.g < 0) this.g = 0;else if (this.g > 1) this.g = 1;
                  if (this.b < 0) this.b = 0;else if (this.b > 1) this.b = 1;
                  if (this.a < 0) this.a = 0;else if (this.a > 1) this.a = 1;
                  return this;
                };

                Color.rgba8888ToColor = function (color, value) {
                  color.r = ((value & 0xff000000) >>> 24) / 255;
                  color.g = ((value & 0x00ff0000) >>> 16) / 255;
                  color.b = ((value & 0x0000ff00) >>> 8) / 255;
                  color.a = (value & 0x000000ff) / 255;
                };

                Color.rgb888ToColor = function (color, value) {
                  color.r = ((value & 0x00ff0000) >>> 16) / 255;
                  color.g = ((value & 0x0000ff00) >>> 8) / 255;
                  color.b = (value & 0x000000ff) / 255;
                };

                Color.WHITE = new Color(1, 1, 1, 1);
                Color.RED = new Color(1, 0, 0, 1);
                Color.GREEN = new Color(0, 1, 0, 1);
                Color.BLUE = new Color(0, 0, 1, 1);
                Color.MAGENTA = new Color(1, 0, 1, 1);
                return Color;
              }();

              spine.Color = Color;

              var MathUtils = function () {
                function MathUtils() {}

                MathUtils.clamp = function (value, min, max) {
                  if (value < min) return min;
                  if (value > max) return max;
                  return value;
                };

                MathUtils.cosDeg = function (degrees) {
                  return Math.cos(degrees * MathUtils.degRad);
                };

                MathUtils.sinDeg = function (degrees) {
                  return Math.sin(degrees * MathUtils.degRad);
                };

                MathUtils.signum = function (value) {
                  return value > 0 ? 1 : value < 0 ? -1 : 0;
                };

                MathUtils.toInt = function (x) {
                  return x > 0 ? Math.floor(x) : Math.ceil(x);
                };

                MathUtils.cbrt = function (x) {
                  var y = Math.pow(Math.abs(x), 1 / 3);
                  return x < 0 ? -y : y;
                };

                MathUtils.randomTriangular = function (min, max) {
                  return MathUtils.randomTriangularWith(min, max, (min + max) * 0.5);
                };

                MathUtils.randomTriangularWith = function (min, max, mode) {
                  var u = Math.random();
                  var d = max - min;
                  if (u <= (mode - min) / d) return min + Math.sqrt(u * d * (mode - min));
                  return max - Math.sqrt((1 - u) * d * (max - mode));
                };

                MathUtils.PI = 3.1415927;
                MathUtils.PI2 = MathUtils.PI * 2;
                MathUtils.radiansToDegrees = 180 / MathUtils.PI;
                MathUtils.radDeg = MathUtils.radiansToDegrees;
                MathUtils.degreesToRadians = MathUtils.PI / 180;
                MathUtils.degRad = MathUtils.degreesToRadians;
                return MathUtils;
              }();

              spine.MathUtils = MathUtils;

              var Interpolation = function () {
                function Interpolation() {}

                Interpolation.prototype.apply = function (start, end, a) {
                  return start + (end - start) * this.applyInternal(a);
                };

                return Interpolation;
              }();

              spine.Interpolation = Interpolation;

              var Pow = function (_super) {
                __extends(Pow, _super);

                function Pow(power) {
                  var _this = _super.call(this) || this;

                  _this.power = 2;
                  _this.power = power;
                  return _this;
                }

                Pow.prototype.applyInternal = function (a) {
                  if (a <= 0.5) return Math.pow(a * 2, this.power) / 2;
                  return Math.pow((a - 1) * 2, this.power) / (this.power % 2 == 0 ? -2 : 2) + 1;
                };

                return Pow;
              }(Interpolation);

              spine.Pow = Pow;

              var PowOut = function (_super) {
                __extends(PowOut, _super);

                function PowOut(power) {
                  return _super.call(this, power) || this;
                }

                PowOut.prototype.applyInternal = function (a) {
                  return Math.pow(a - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1;
                };

                return PowOut;
              }(Pow);

              spine.PowOut = PowOut;

              var Utils = function () {
                function Utils() {}

                Utils.arrayCopy = function (source, sourceStart, dest, destStart, numElements) {
                  for (var i = sourceStart, j = destStart; i < sourceStart + numElements; i++, j++) {
                    dest[j] = source[i];
                  }
                };

                Utils.setArraySize = function (array, size, value) {
                  if (value === void 0) {
                    value = 0;
                  }

                  var oldSize = array.length;
                  if (oldSize == size) return array;
                  array.length = size;

                  if (oldSize < size) {
                    for (var i = oldSize; i < size; i++) array[i] = value;
                  }

                  return array;
                };

                Utils.ensureArrayCapacity = function (array, size, value) {
                  if (value === void 0) {
                    value = 0;
                  }

                  if (array.length >= size) return array;
                  return Utils.setArraySize(array, size, value);
                };

                Utils.newArray = function (size, defaultValue) {
                  var array = new Array(size);

                  for (var i = 0; i < size; i++) array[i] = defaultValue;

                  return array;
                };

                Utils.newFloatArray = function (size) {
                  if (Utils.SUPPORTS_TYPED_ARRAYS) {
                    return new Float32Array(size);
                  } else {
                    var array = new Array(size);

                    for (var i = 0; i < array.length; i++) array[i] = 0;

                    return array;
                  }
                };

                Utils.newShortArray = function (size) {
                  if (Utils.SUPPORTS_TYPED_ARRAYS) {
                    return new Int16Array(size);
                  } else {
                    var array = new Array(size);

                    for (var i = 0; i < array.length; i++) array[i] = 0;

                    return array;
                  }
                };

                Utils.toFloatArray = function (array) {
                  return Utils.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;
                };

                Utils.toSinglePrecision = function (value) {
                  return Utils.SUPPORTS_TYPED_ARRAYS ? Math.fround(value) : value;
                };

                Utils.webkit602BugfixHelper = function (alpha, blend) {};

                Utils.contains = function (array, element, identity) {

                  for (var i = 0; i < array.length; i++) {
                    if (array[i] == element) return true;
                  }

                  return false;
                };

                Utils.SUPPORTS_TYPED_ARRAYS = typeof Float32Array !== "undefined";
                return Utils;
              }();

              spine.Utils = Utils;

              var DebugUtils = function () {
                function DebugUtils() {}

                DebugUtils.logBones = function (skeleton) {
                  for (var i = 0; i < skeleton.bones.length; i++) {
                    var bone = skeleton.bones[i];
                    console.log(bone.data.name + ", " + bone.a + ", " + bone.b + ", " + bone.c + ", " + bone.d + ", " + bone.worldX + ", " + bone.worldY);
                  }
                };

                return DebugUtils;
              }();

              spine.DebugUtils = DebugUtils;

              var Pool = function () {
                function Pool(instantiator) {
                  this.items = new Array();
                  this.instantiator = instantiator;
                }

                Pool.prototype.obtain = function () {
                  return this.items.length > 0 ? this.items.pop() : this.instantiator();
                };

                Pool.prototype.free = function (item) {
                  if (item.reset) item.reset();
                  this.items.push(item);
                };

                Pool.prototype.freeAll = function (items) {
                  for (var i = 0; i < items.length; i++) {
                    if (items[i].reset) items[i].reset();
                    this.items[i] = items[i];
                  }
                };

                Pool.prototype.clear = function () {
                  this.items.length = 0;
                };

                return Pool;
              }();

              spine.Pool = Pool;

              var Vector2 = function () {
                function Vector2(x, y) {
                  if (x === void 0) {
                    x = 0;
                  }

                  if (y === void 0) {
                    y = 0;
                  }

                  this.x = x;
                  this.y = y;
                }

                Vector2.prototype.set = function (x, y) {
                  this.x = x;
                  this.y = y;
                  return this;
                };

                Vector2.prototype.length = function () {
                  var x = this.x;
                  var y = this.y;
                  return Math.sqrt(x * x + y * y);
                };

                Vector2.prototype.normalize = function () {
                  var len = this.length();

                  if (len != 0) {
                    this.x /= len;
                    this.y /= len;
                  }

                  return this;
                };

                return Vector2;
              }();

              spine.Vector2 = Vector2;

              var TimeKeeper = function () {
                function TimeKeeper() {
                  this.maxDelta = 0.064;
                  this.framesPerSecond = 0;
                  this.delta = 0;
                  this.totalTime = 0;
                  this.lastTime = Date.now() / 1000;
                  this.frameCount = 0;
                  this.frameTime = 0;
                }

                TimeKeeper.prototype.update = function () {
                  var now = Date.now() / 1000;
                  this.delta = now - this.lastTime;
                  this.frameTime += this.delta;
                  this.totalTime += this.delta;
                  if (this.delta > this.maxDelta) this.delta = this.maxDelta;
                  this.lastTime = now;
                  this.frameCount++;

                  if (this.frameTime > 1) {
                    this.framesPerSecond = this.frameCount / this.frameTime;
                    this.frameTime = 0;
                    this.frameCount = 0;
                  }
                };

                return TimeKeeper;
              }();

              spine.TimeKeeper = TimeKeeper;

              var WindowedMean = function () {
                function WindowedMean(windowSize) {
                  if (windowSize === void 0) {
                    windowSize = 32;
                  }

                  this.addedValues = 0;
                  this.lastValue = 0;
                  this.mean = 0;
                  this.dirty = true;
                  this.values = new Array(windowSize);
                }

                WindowedMean.prototype.hasEnoughData = function () {
                  return this.addedValues >= this.values.length;
                };

                WindowedMean.prototype.addValue = function (value) {
                  if (this.addedValues < this.values.length) this.addedValues++;
                  this.values[this.lastValue++] = value;
                  if (this.lastValue > this.values.length - 1) this.lastValue = 0;
                  this.dirty = true;
                };

                WindowedMean.prototype.getMean = function () {
                  if (this.hasEnoughData()) {
                    if (this.dirty) {
                      var mean = 0;

                      for (var i = 0; i < this.values.length; i++) {
                        mean += this.values[i];
                      }

                      this.mean = mean / this.values.length;
                      this.dirty = false;
                    }

                    return this.mean;
                  } else {
                    return 0;
                  }
                };

                return WindowedMean;
              }();

              spine.WindowedMean = WindowedMean;
            })(spine || (spine = {}));

            (function () {
              if (!Math.fround) {
                Math.fround = function (array) {
                  return function (x) {
                    return array[0] = x, array[0];
                  };
                }(new Float32Array(1));
              }
            })();

            var spine;

            (function (spine) {
              var Attachment = function () {
                function Attachment(name) {
                  if (name == null) throw new Error("name cannot be null.");
                  this.name = name;
                }

                return Attachment;
              }();

              spine.Attachment = Attachment;

              var VertexAttachment = function (_super) {
                __extends(VertexAttachment, _super);

                function VertexAttachment(name) {
                  var _this = _super.call(this, name) || this;

                  _this.id = (VertexAttachment.nextID++ & 65535) << 11;
                  _this.worldVerticesLength = 0;
                  _this.deformAttachment = _this;
                  return _this;
                }

                VertexAttachment.prototype.computeWorldVertices = function (slot, start, count, worldVertices, offset, stride) {
                  count = offset + (count >> 1) * stride;
                  var skeleton = slot.bone.skeleton;
                  var deformArray = slot.deform;
                  var vertices = this.vertices;
                  var bones = this.bones;

                  if (bones == null) {
                    if (deformArray.length > 0) vertices = deformArray;
                    var bone = slot.bone;
                    var x = bone.worldX;
                    var y = bone.worldY;
                    var a = bone.a,
                        b = bone.b,
                        c = bone.c,
                        d = bone.d;

                    for (var v_1 = start, w = offset; w < count; v_1 += 2, w += stride) {
                      var vx = vertices[v_1],
                          vy = vertices[v_1 + 1];
                      worldVertices[w] = vx * a + vy * b + x;
                      worldVertices[w + 1] = vx * c + vy * d + y;
                    }

                    return;
                  }

                  var v = 0,
                      skip = 0;

                  for (var i = 0; i < start; i += 2) {
                    var n = bones[v];
                    v += n + 1;
                    skip += n;
                  }

                  var skeletonBones = skeleton.bones;

                  if (deformArray.length == 0) {
                    for (var w = offset, b = skip * 3; w < count; w += stride) {
                      var wx = 0,
                          wy = 0;
                      var n = bones[v++];
                      n += v;

                      for (; v < n; v++, b += 3) {
                        var bone = skeletonBones[bones[v]];
                        var vx = vertices[b],
                            vy = vertices[b + 1],
                            weight = vertices[b + 2];
                        wx += (vx * bone.a + vy * bone.b + bone.worldX) * weight;
                        wy += (vx * bone.c + vy * bone.d + bone.worldY) * weight;
                      }

                      worldVertices[w] = wx;
                      worldVertices[w + 1] = wy;
                    }
                  } else {
                    var deform = deformArray;

                    for (var w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {
                      var wx = 0,
                          wy = 0;
                      var n = bones[v++];
                      n += v;

                      for (; v < n; v++, b += 3, f += 2) {
                        var bone = skeletonBones[bones[v]];
                        var vx = vertices[b] + deform[f],
                            vy = vertices[b + 1] + deform[f + 1],
                            weight = vertices[b + 2];
                        wx += (vx * bone.a + vy * bone.b + bone.worldX) * weight;
                        wy += (vx * bone.c + vy * bone.d + bone.worldY) * weight;
                      }

                      worldVertices[w] = wx;
                      worldVertices[w + 1] = wy;
                    }
                  }
                };

                VertexAttachment.prototype.copyTo = function (attachment) {
                  if (this.bones != null) {
                    attachment.bones = new Array(this.bones.length);
                    spine.Utils.arrayCopy(this.bones, 0, attachment.bones, 0, this.bones.length);
                  } else attachment.bones = null;

                  if (this.vertices != null) {
                    attachment.vertices = spine.Utils.newFloatArray(this.vertices.length);
                    spine.Utils.arrayCopy(this.vertices, 0, attachment.vertices, 0, this.vertices.length);
                  } else attachment.vertices = null;

                  attachment.worldVerticesLength = this.worldVerticesLength;
                  attachment.deformAttachment = this.deformAttachment;
                };

                VertexAttachment.nextID = 0;
                return VertexAttachment;
              }(Attachment);

              spine.VertexAttachment = VertexAttachment;
            })(spine || (spine = {}));

            var spine;

            (function (spine) {
              var AttachmentType;

              (function (AttachmentType) {
                AttachmentType[AttachmentType["Region"] = 0] = "Region";
                AttachmentType[AttachmentType["BoundingBox"] = 1] = "BoundingBox";
                AttachmentType[AttachmentType["Mesh"] = 2] = "Mesh";
                AttachmentType[AttachmentType["LinkedMesh"] = 3] = "LinkedMesh";
                AttachmentType[AttachmentType["Path"] = 4] = "Path";
                AttachmentType[AttachmentType["Point"] = 5] = "Point";
                AttachmentType[AttachmentType["Clipping"] = 6] = "Clipping";
              })(AttachmentType = spine.AttachmentType || (spine.AttachmentType = {}));
            })(spine || (spine = {}));

            var spine;

            (function (spine) {
              var BoundingBoxAttachment = function (_super) {
                __extends(BoundingBoxAttachment, _super);

                function BoundingBoxAttachment(name) {
                  var _this = _super.call(this, name) || this;

                  _this.color = new spine.Color(1, 1, 1, 1);
                  return _this;
                }

                BoundingBoxAttachment.prototype.copy = function () {
                  var copy = new BoundingBoxAttachment(name);
                  this.copyTo(copy);
                  copy.color.setFromColor(this.color);
                  return copy;
                };

                return BoundingBoxAttachment;
              }(spine.VertexAttachment);

              spine.BoundingBoxAttachment = BoundingBoxAttachment;
            })(spine || (spine = {}));

            var spine;

            (function (spine) {
              var ClippingAttachment = function (_super) {
                __extends(ClippingAttachment, _super);

                function ClippingAttachment(name) {
                  var _this = _super.call(this, name) || this;

                  _this.color = new spine.Color(0.2275, 0.2275, 0.8078, 1);
                  return _this;
                }

                ClippingAttachment.prototype.copy = function () {
                  var copy = new ClippingAttachment(name);
                  this.copyTo(copy);
                  copy.endSlot = this.endSlot;
                  copy.color.setFromColor(this.color);
                  return copy;
                };

                return ClippingAttachment;
              }(spine.VertexAttachment);

              spine.ClippingAttachment = ClippingAttachment;
            })(spine || (spine = {}));

            var spine;

            (function (spine) {
              var MeshAttachment = function (_super) {
                __extends(MeshAttachment, _super);

                function MeshAttachment(name) {
                  var _this = _super.call(this, name) || this;

                  _this.color = new spine.Color(1, 1, 1, 1);
                  _this.tempColor = new spine.Color(0, 0, 0, 0);
                  return _this;
                }

                MeshAttachment.prototype.updateUVs = function () {
                  var regionUVs = this.regionUVs;
                  if (this.uvs == null || this.uvs.length != regionUVs.length) this.uvs = spine.Utils.newFloatArray(regionUVs.length);
                  var uvs = this.uvs;
                  var n = this.uvs.length;
                  var u = this.region.u,
                      v = this.region.v,
                      width = 0,
                      height = 0;

                  if (this.region instanceof spine.TextureAtlasRegion) {
                    var region = this.region;
                    var textureWidth = region.texture.getImage().width,
                        textureHeight = region.texture.getImage().height;

                    switch (region.degrees) {
                      case 90:
                        u -= (region.originalHeight - region.offsetY - region.height) / textureWidth;
                        v -= (region.originalWidth - region.offsetX - region.width) / textureHeight;
                        width = region.originalHeight / textureWidth;
                        height = region.originalWidth / textureHeight;

                        for (var i = 0; i < n; i += 2) {
                          uvs[i] = u + regionUVs[i + 1] * width;
                          uvs[i + 1] = v + (1 - regionUVs[i]) * height;
                        }

                        return;

                      case 180:
                        u -= (region.originalWidth - region.offsetX - region.width) / textureWidth;
                        v -= region.offsetY / textureHeight;
                        width = region.originalWidth / textureWidth;
                        height = region.originalHeight / textureHeight;

                        for (var i = 0; i < n; i += 2) {
                          uvs[i] = u + (1 - regionUVs[i]) * width;
                          uvs[i + 1] = v + (1 - regionUVs[i + 1]) * height;
                        }

                        return;

                      case 270:
                        u -= region.offsetY / textureWidth;
                        v -= region.offsetX / textureHeight;
                        width = region.originalHeight / textureWidth;
                        height = region.originalWidth / textureHeight;

                        for (var i = 0; i < n; i += 2) {
                          uvs[i] = u + (1 - regionUVs[i + 1]) * width;
                          uvs[i + 1] = v + regionUVs[i] * height;
                        }

                        return;
                    }

                    u -= region.offsetX / textureWidth;
                    v -= (region.originalHeight - region.offsetY - region.height) / textureHeight;
                    width = region.originalWidth / textureWidth;
                    height = region.originalHeight / textureHeight;
                  } else if (this.region == null) {
                    u = v = 0;
                    width = height = 1;
                  } else {
                    width = this.region.u2 - u;
                    height = this.region.v2 - v;
                  }

                  for (var i = 0; i < n; i += 2) {
                    uvs[i] = u + regionUVs[i] * width;
                    uvs[i + 1] = v + regionUVs[i + 1] * height;
                  }
                };

                MeshAttachment.prototype.getParentMesh = function () {
                  return this.parentMesh;
                };

                MeshAttachment.prototype.setParentMesh = function (parentMesh) {
                  this.parentMesh = parentMesh;

                  if (parentMesh != null) {
                    this.bones = parentMesh.bones;
                    this.vertices = parentMesh.vertices;
                    this.worldVerticesLength = parentMesh.worldVerticesLength;
                    this.regionUVs = parentMesh.regionUVs;
                    this.triangles = parentMesh.triangles;
                    this.hullLength = parentMesh.hullLength;
                    this.worldVerticesLength = parentMesh.worldVerticesLength;
                  }
                };

                MeshAttachment.prototype.copy = function () {
                  if (this.parentMesh != null) return this.newLinkedMesh();
                  var copy = new MeshAttachment(this.name);
                  copy.region = this.region;
                  copy.path = this.path;
                  copy.color.setFromColor(this.color);
                  this.copyTo(copy);
                  copy.regionUVs = new Array(this.regionUVs.length);
                  spine.Utils.arrayCopy(this.regionUVs, 0, copy.regionUVs, 0, this.regionUVs.length);
                  copy.uvs = new Array(this.uvs.length);
                  spine.Utils.arrayCopy(this.uvs, 0, copy.uvs, 0, this.uvs.length);
                  copy.triangles = new Array(this.triangles.length);
                  spine.Utils.arrayCopy(this.triangles, 0, copy.triangles, 0, this.triangles.length);
                  copy.hullLength = this.hullLength;

                  if (this.edges != null) {
                    copy.edges = new Array(this.edges.length);
                    spine.Utils.arrayCopy(this.edges, 0, copy.edges, 0, this.edges.length);
                  }

                  copy.width = this.width;
                  copy.height = this.height;
                  return copy;
                };

                MeshAttachment.prototype.newLinkedMesh = function () {
                  var copy = new MeshAttachment(this.name);
                  copy.region = this.region;
                  copy.path = this.path;
                  copy.color.setFromColor(this.color);
                  copy.deformAttachment = this.deformAttachment;
                  copy.setParentMesh(this.parentMesh != null ? this.parentMesh : this);
                  copy.updateUVs();
                  return copy;
                };

                return MeshAttachment;
              }(spine.VertexAttachment);

              spine.MeshAttachment = MeshAttachment;
            })(spine || (spine = {}));

            var spine;

            (function (spine) {
              var PathAttachment = function (_super) {
                __extends(PathAttachment, _super);

                function PathAttachment(name) {
                  var _this = _super.call(this, name) || this;

                  _this.closed = false;
                  _this.constantSpeed = false;
                  _this.color = new spine.Color(1, 1, 1, 1);
                  return _this;
                }

                PathAttachment.prototype.copy = function () {
                  var copy = new PathAttachment(name);
                  this.copyTo(copy);
                  copy.lengths = new Array(this.lengths.length);
                  spine.Utils.arrayCopy(this.lengths, 0, copy.lengths, 0, this.lengths.length);
                  copy.closed = closed;
                  copy.constantSpeed = this.constantSpeed;
                  copy.color.setFromColor(this.color);
                  return copy;
                };

                return PathAttachment;
              }(spine.VertexAttachment);

              spine.PathAttachment = PathAttachment;
            })(spine || (spine = {}));

            var spine;

            (function (spine) {
              var PointAttachment = function (_super) {
                __extends(PointAttachment, _super);

                function PointAttachment(name) {
                  var _this = _super.call(this, name) || this;

                  _this.color = new spine.Color(0.38, 0.94, 0, 1);
                  return _this;
                }

                PointAttachment.prototype.computeWorldPosition = function (bone, point) {
                  point.x = this.x * bone.a + this.y * bone.b + bone.worldX;
                  point.y = this.x * bone.c + this.y * bone.d + bone.worldY;
                  return point;
                };

                PointAttachment.prototype.computeWorldRotation = function (bone) {
                  var cos = spine.MathUtils.cosDeg(this.rotation),
                      sin = spine.MathUtils.sinDeg(this.rotation);
                  var x = cos * bone.a + sin * bone.b;
                  var y = cos * bone.c + sin * bone.d;
                  return Math.atan2(y, x) * spine.MathUtils.radDeg;
                };

                PointAttachment.prototype.copy = function () {
                  var copy = new PointAttachment(name);
                  copy.x = this.x;
                  copy.y = this.y;
                  copy.rotation = this.rotation;
                  copy.color.setFromColor(this.color);
                  return copy;
                };

                return PointAttachment;
              }(spine.VertexAttachment);

              spine.PointAttachment = PointAttachment;
            })(spine || (spine = {}));

            var spine;

            (function (spine) {
              var RegionAttachment = function (_super) {
                __extends(RegionAttachment, _super);

                function RegionAttachment(name) {
                  var _this = _super.call(this, name) || this;

                  _this.x = 0;
                  _this.y = 0;
                  _this.scaleX = 1;
                  _this.scaleY = 1;
                  _this.rotation = 0;
                  _this.width = 0;
                  _this.height = 0;
                  _this.color = new spine.Color(1, 1, 1, 1);
                  _this.offset = spine.Utils.newFloatArray(8);
                  _this.uvs = spine.Utils.newFloatArray(8);
                  _this.tempColor = new spine.Color(1, 1, 1, 1);
                  return _this;
                }

                RegionAttachment.prototype.updateOffset = function () {
                  var regionScaleX = this.width / this.region.originalWidth * this.scaleX;
                  var regionScaleY = this.height / this.region.originalHeight * this.scaleY;
                  var localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;
                  var localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;
                  var localX2 = localX + this.region.width * regionScaleX;
                  var localY2 = localY + this.region.height * regionScaleY;
                  var radians = this.rotation * Math.PI / 180;
                  var cos = Math.cos(radians);
                  var sin = Math.sin(radians);
                  var localXCos = localX * cos + this.x;
                  var localXSin = localX * sin;
                  var localYCos = localY * cos + this.y;
                  var localYSin = localY * sin;
                  var localX2Cos = localX2 * cos + this.x;
                  var localX2Sin = localX2 * sin;
                  var localY2Cos = localY2 * cos + this.y;
                  var localY2Sin = localY2 * sin;
                  var offset = this.offset;
                  offset[RegionAttachment.OX1] = localXCos - localYSin;
                  offset[RegionAttachment.OY1] = localYCos + localXSin;
                  offset[RegionAttachment.OX2] = localXCos - localY2Sin;
                  offset[RegionAttachment.OY2] = localY2Cos + localXSin;
                  offset[RegionAttachment.OX3] = localX2Cos - localY2Sin;
                  offset[RegionAttachment.OY3] = localY2Cos + localX2Sin;
                  offset[RegionAttachment.OX4] = localX2Cos - localYSin;
                  offset[RegionAttachment.OY4] = localYCos + localX2Sin;
                };

                RegionAttachment.prototype.setRegion = function (region) {
                  this.region = region;
                  var uvs = this.uvs;

                  if (region.rotate) {
                    uvs[2] = region.u;
                    uvs[3] = region.v2;
                    uvs[4] = region.u;
                    uvs[5] = region.v;
                    uvs[6] = region.u2;
                    uvs[7] = region.v;
                    uvs[0] = region.u2;
                    uvs[1] = region.v2;
                  } else {
                    uvs[0] = region.u;
                    uvs[1] = region.v2;
                    uvs[2] = region.u;
                    uvs[3] = region.v;
                    uvs[4] = region.u2;
                    uvs[5] = region.v;
                    uvs[6] = region.u2;
                    uvs[7] = region.v2;
                  }
                };

                RegionAttachment.prototype.computeWorldVertices = function (bone, worldVertices, offset, stride) {
                  var vertexOffset = this.offset;
                  var x = bone.worldX,
                      y = bone.worldY;
                  var a = bone.a,
                      b = bone.b,
                      c = bone.c,
                      d = bone.d;
                  var offsetX = 0,
                      offsetY = 0;
                  offsetX = vertexOffset[RegionAttachment.OX1];
                  offsetY = vertexOffset[RegionAttachment.OY1];
                  worldVertices[offset] = offsetX * a + offsetY * b + x;
                  worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
                  offset += stride;
                  offsetX = vertexOffset[RegionAttachment.OX2];
                  offsetY = vertexOffset[RegionAttachment.OY2];
                  worldVertices[offset] = offsetX * a + offsetY * b + x;
                  worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
                  offset += stride;
                  offsetX = vertexOffset[RegionAttachment.OX3];
                  offsetY = vertexOffset[RegionAttachment.OY3];
                  worldVertices[offset] = offsetX * a + offsetY * b + x;
                  worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
                  offset += stride;
                  offsetX = vertexOffset[RegionAttachment.OX4];
                  offsetY = vertexOffset[RegionAttachment.OY4];
                  worldVertices[offset] = offsetX * a + offsetY * b + x;
                  worldVertices[offset + 1] = offsetX * c + offsetY * d + y;
                };

                RegionAttachment.prototype.copy = function () {
                  var copy = new RegionAttachment(name);
                  copy.region = this.region;
                  copy.rendererObject = this.rendererObject;
                  copy.path = this.path;
                  copy.x = this.x;
                  copy.y = this.y;
                  copy.scaleX = this.scaleX;
                  copy.scaleY = this.scaleY;
                  copy.rotation = this.rotation;
                  copy.width = this.width;
                  copy.height = this.height;
                  spine.Utils.arrayCopy(this.uvs, 0, copy.uvs, 0, 8);
                  spine.Utils.arrayCopy(this.offset, 0, copy.offset, 0, 8);
                  copy.color.setFromColor(this.color);
                  return copy;
                };

                RegionAttachment.OX1 = 0;
                RegionAttachment.OY1 = 1;
                RegionAttachment.OX2 = 2;
                RegionAttachment.OY2 = 3;
                RegionAttachment.OX3 = 4;
                RegionAttachment.OY3 = 5;
                RegionAttachment.OX4 = 6;
                RegionAttachment.OY4 = 7;
                RegionAttachment.X1 = 0;
                RegionAttachment.Y1 = 1;
                RegionAttachment.C1R = 2;
                RegionAttachment.C1G = 3;
                RegionAttachment.C1B = 4;
                RegionAttachment.C1A = 5;
                RegionAttachment.U1 = 6;
                RegionAttachment.V1 = 7;
                RegionAttachment.X2 = 8;
                RegionAttachment.Y2 = 9;
                RegionAttachment.C2R = 10;
                RegionAttachment.C2G = 11;
                RegionAttachment.C2B = 12;
                RegionAttachment.C2A = 13;
                RegionAttachment.U2 = 14;
                RegionAttachment.V2 = 15;
                RegionAttachment.X3 = 16;
                RegionAttachment.Y3 = 17;
                RegionAttachment.C3R = 18;
                RegionAttachment.C3G = 19;
                RegionAttachment.C3B = 20;
                RegionAttachment.C3A = 21;
                RegionAttachment.U3 = 22;
                RegionAttachment.V3 = 23;
                RegionAttachment.X4 = 24;
                RegionAttachment.Y4 = 25;
                RegionAttachment.C4R = 26;
                RegionAttachment.C4G = 27;
                RegionAttachment.C4B = 28;
                RegionAttachment.C4A = 29;
                RegionAttachment.U4 = 30;
                RegionAttachment.V4 = 31;
                return RegionAttachment;
              }(spine.Attachment);

              spine.RegionAttachment = RegionAttachment;
            })(spine || (spine = {}));

            var spine;

            (function (spine) {
              var JitterEffect = function () {
                function JitterEffect(jitterX, jitterY) {
                  this.jitterX = 0;
                  this.jitterY = 0;
                  this.jitterX = jitterX;
                  this.jitterY = jitterY;
                }

                JitterEffect.prototype.begin = function (skeleton) {};

                JitterEffect.prototype.transform = function (position, uv, light, dark) {
                  position.x += spine.MathUtils.randomTriangular(-this.jitterX, this.jitterY);
                  position.y += spine.MathUtils.randomTriangular(-this.jitterX, this.jitterY);
                };

                JitterEffect.prototype.end = function () {};

                return JitterEffect;
              }();

              spine.JitterEffect = JitterEffect;
            })(spine || (spine = {}));

            var spine;

            console.log('pptest importing cc 3.6');
            (function (spine) {
              var SwirlEffect = function () {
                function SwirlEffect(radius, interpolation) {
                  this.centerX = 0;
                  this.centerY = 0;
                  this.radius = 0;
                  this.angle = 0;
                  this.worldX = 0;
                  this.worldY = 0;
                  this.radius = radius;
                  this.interpolation = interpolation;
                }

                SwirlEffect.prototype.begin = function (skeleton) {
                  this.worldX = skeleton.x + this.centerX;
                  this.worldY = skeleton.y + this.centerY;
                };

                SwirlEffect.prototype.transform = function (position, uv, light, dark) {
                  var radAngle = this.angle * spine.MathUtils.degreesToRadians;
                  var x = position.x - this.worldX;
                  var y = position.y - this.worldY;
                  var dist = Math.sqrt(x * x + y * y);

                  if (dist < this.radius) {
                    var theta = this.interpolation.apply(0, radAngle, (this.radius - dist) / this.radius);
                    var cos = Math.cos(theta);
                    var sin = Math.sin(theta);
                    position.x = cos * x - sin * y + this.worldX;
                    position.y = sin * x + cos * y + this.worldY;
                  }
                };

                SwirlEffect.prototype.end = function () {};

                SwirlEffect.interpolation = new spine.PowOut(2);
                return SwirlEffect;
              }();

              spine.SwirlEffect = SwirlEffect;
            })(spine || (spine = {}));

            var spine$1 = spine;

            const MaxCacheTime = 30;
            const FrameTime = 1 / 60;
            const _vertices$1 = [];
            const _indices = [];
            let _boneInfoOffset = 0;
            let _indexOffset = 0;
            let _vfOffset$1 = 0;
            let _preTexID = null;
            let _preBlendMode = null;
            let _segVCount = 0;
            let _segICount = 0;
            let _segOffset = 0;
            let _colorOffset = 0;
            let _preFinalColor = null;
            let _preDarkColor = null;
            const PerVertexSize = 6;
            const PerClipVertexSize = 12;
            const ExportVertexSize = 13;
            let _vfCount = 0;
            let _indexCount = 0;

            let _tempr;

            let _tempg;

            let _tempb;

            let _tempa;

            let _finalColor32;

            let _darkColor32;

            const _finalColor = new spine$1.Color(1, 1, 1, 1);

            const _darkColor = new spine$1.Color(1, 1, 1, 1);

            const _quadTriangles = [0, 1, 2, 2, 3, 0];
            class AnimationCache {
              constructor() {
                this.frames = [];
                this.totalTime = 0;
                this.isCompleted = false;
                this._privateMode = false;
                this._inited = false;
                this._invalid = true;
                this._enableCacheAttachedInfo = false;
                this._frameIdx = -1;
                this._skeletonInfo = null;
                this._animationName = null;
                this._tempSegments = null;
                this._tempColors = null;
                this._tempBoneInfos = null;
                this._privateMode = false;
                this._inited = false;
                this._invalid = true;
                this._enableCacheAttachedInfo = false;
                this.frames = [];
                this.totalTime = 0;
                this._frameIdx = -1;
                this.isCompleted = false;
                this._skeletonInfo = null;
                this._animationName = null;
                this._tempSegments = null;
                this._tempColors = null;
                this._tempBoneInfos = null;
              }

              init(skeletonInfo, animationName) {
                this._inited = true;
                this._animationName = animationName;
                this._skeletonInfo = skeletonInfo;
              }

              clear() {
                this._inited = false;

                for (let i = 0, n = this.frames.length; i < n; i++) {
                  const frame = this.frames[i];
                  frame.segments.length = 0;
                }

                this.invalidAllFrame();
              }

              bind(listener) {
                const completeHandle = entry => {
                  if (entry && entry.animation.name === this._animationName) {
                    this.isCompleted = true;
                  }
                };

                listener.complete = completeHandle;
              }

              unbind(listener) {
                listener.complete = null;
              }

              begin() {
                if (!this._invalid) return;
                const skeletonInfo = this._skeletonInfo;
                const preAnimationCache = skeletonInfo === null || skeletonInfo === void 0 ? void 0 : skeletonInfo.curAnimationCache;

                if (preAnimationCache && preAnimationCache !== this) {
                  if (this._privateMode) {
                    preAnimationCache.invalidAllFrame();
                  } else {
                    preAnimationCache.updateToFrame();
                  }
                }

                const skeleton = skeletonInfo === null || skeletonInfo === void 0 ? void 0 : skeletonInfo.skeleton;
                const listener = skeletonInfo === null || skeletonInfo === void 0 ? void 0 : skeletonInfo.listener;
                const state = skeletonInfo === null || skeletonInfo === void 0 ? void 0 : skeletonInfo.state;
                const animation = skeleton === null || skeleton === void 0 ? void 0 : skeleton.data.findAnimation(this._animationName);
                state === null || state === void 0 ? void 0 : state.setAnimationWith(0, animation, false);
                this.bind(listener);
                skeletonInfo.curAnimationCache = this;
                this._frameIdx = -1;
                this.isCompleted = false;
                this.totalTime = 0;
                this._invalid = false;
              }

              end() {
                if (!this.needToUpdate()) {
                  this._skeletonInfo.curAnimationCache = null;
                  this.frames.length = this._frameIdx + 1;
                  this.isCompleted = true;
                  this.unbind(this._skeletonInfo.listener);
                }
              }

              updateToFrame(toFrameIdx) {
                if (!this._inited) return;
                this.begin();
                if (!this.needToUpdate(toFrameIdx)) return;
                const skeletonInfo = this._skeletonInfo;
                const skeleton = skeletonInfo === null || skeletonInfo === void 0 ? void 0 : skeletonInfo.skeleton;
                const clipper = skeletonInfo === null || skeletonInfo === void 0 ? void 0 : skeletonInfo.clipper;
                const state = skeletonInfo === null || skeletonInfo === void 0 ? void 0 : skeletonInfo.state;

                do {
                  skeleton === null || skeleton === void 0 ? void 0 : skeleton.update(FrameTime);
                  state === null || state === void 0 ? void 0 : state.update(FrameTime);
                  state === null || state === void 0 ? void 0 : state.apply(skeleton);
                  skeleton === null || skeleton === void 0 ? void 0 : skeleton.updateWorldTransform();
                  this._frameIdx++;
                  this.updateFrame(skeleton, clipper, this._frameIdx);
                  this.totalTime += FrameTime;
                } while (this.needToUpdate(toFrameIdx));

                this.end();
              }

              isInited() {
                return this._inited;
              }

              isInvalid() {
                return this._invalid;
              }

              invalidAllFrame() {
                this.isCompleted = false;
                this._invalid = true;
              }

              updateAllFrame() {
                this.invalidAllFrame();
                this.updateToFrame();
              }

              enableCacheAttachedInfo() {
                if (!this._enableCacheAttachedInfo) {
                  this._enableCacheAttachedInfo = true;
                  this.invalidAllFrame();
                }
              }

              fillVertices(skeletonColor, attachmentColor, slotColor, clipper, slot) {
                _tempa = slotColor.a * attachmentColor.a * skeletonColor.a * 255;
                _tempr = attachmentColor.r * skeletonColor.r * 255;
                _tempg = attachmentColor.g * skeletonColor.g * 255;
                _tempb = attachmentColor.b * skeletonColor.b * 255;
                _finalColor.r = _tempr * slotColor.r;
                _finalColor.g = _tempg * slotColor.g;
                _finalColor.b = _tempb * slotColor.b;
                _finalColor.a = _tempa;

                if (slot.darkColor == null) {
                  _darkColor.set(0.0, 0, 0, 1.0);
                } else {
                  _darkColor.r = slot.darkColor.r * _tempr;
                  _darkColor.g = slot.darkColor.g * _tempg;
                  _darkColor.b = slot.darkColor.b * _tempb;
                }

                _darkColor.a = 0;
                _finalColor32 = (_finalColor.a << 24 >>> 0) + (_finalColor.b << 16) + (_finalColor.g << 8) + _finalColor.r;
                _darkColor32 = (_darkColor.a << 24 >>> 0) + (_darkColor.b << 16) + (_darkColor.g << 8) + _darkColor.r;

                if (_preFinalColor !== _finalColor32 || _preDarkColor !== _darkColor32) {
                  const colors = this._tempColors;
                  _preFinalColor = _finalColor32;
                  _preDarkColor = _darkColor32;

                  if (_colorOffset > 0) {
                    colors[_colorOffset - 1].vfOffset = _vfOffset$1;
                  }

                  colors[_colorOffset++] = {
                    fr: _finalColor.r,
                    fg: _finalColor.g,
                    fb: _finalColor.b,
                    fa: _finalColor.a,
                    dr: _darkColor.r,
                    dg: _darkColor.g,
                    db: _darkColor.b,
                    da: _darkColor.a,
                    vfOffset: 0
                  };
                }

                if (!clipper.isClipping()) {
                  for (let v = _vfOffset$1, n = _vfOffset$1 + _vfCount; v < n; v += PerVertexSize) {
                    _vertices$1[v + 4] = _finalColor32;
                    _vertices$1[v + 5] = _darkColor32;
                  }
                } else {
                  clipper.clipTriangles(_vertices$1, _vfCount, _indices, _indexCount, _vertices$1, _finalColor, _darkColor, true, PerVertexSize, _vfOffset$1, _vfOffset$1 + 2);
                  const clippedVertices = clipper.clippedVertices;
                  const clippedTriangles = clipper.clippedTriangles;
                  _indexCount = clippedTriangles.length;
                  _vfCount = clippedVertices.length / PerClipVertexSize * PerVertexSize;

                  for (let ii = 0, jj = _indexOffset, nn = clippedTriangles.length; ii < nn;) {
                    _indices[jj++] = clippedTriangles[ii++];
                  }

                  for (let v = 0, n = clippedVertices.length, offset = _vfOffset$1; v < n; v += PerClipVertexSize, offset += PerVertexSize) {
                    _vertices$1[offset] = clippedVertices[v];
                    _vertices$1[offset + 1] = clippedVertices[v + 1];
                    _vertices$1[offset + 2] = clippedVertices[v + 6];
                    _vertices$1[offset + 3] = clippedVertices[v + 7];
                    _vertices$1[offset + 4] = _finalColor32;
                    _vertices$1[offset + 5] = _darkColor32;
                  }
                }
              }

              updateFrame(skeleton, clipper, index) {
                _vfOffset$1 = 0;
                _boneInfoOffset = 0;
                _indexOffset = 0;
                _preTexID = null;
                _preBlendMode = null;
                _segVCount = 0;
                _segICount = 0;
                _segOffset = 0;
                _colorOffset = 0;
                _preFinalColor = null;
                _preDarkColor = null;
                this.frames[index] = this.frames[index] || {
                  segments: [],
                  colors: [],
                  boneInfos: [],
                  vertices: null,
                  uintVert: null,
                  indices: null
                };
                const frame = this.frames[index];
                const segments = this._tempSegments = frame.segments;
                const colors = this._tempColors = frame.colors;
                const boneInfos = this._tempBoneInfos = frame.boneInfos;
                this.traverseSkeleton(skeleton, clipper);

                if (_colorOffset > 0) {
                  colors[_colorOffset - 1].vfOffset = _vfOffset$1;
                }

                colors.length = _colorOffset;
                boneInfos.length = _boneInfoOffset;
                const preSegOffset = _segOffset - 1;

                if (preSegOffset >= 0) {
                  if (_segICount > 0) {
                    const preSegInfo = segments[preSegOffset];
                    preSegInfo.indexCount = _segICount;
                    preSegInfo.vfCount = _segVCount * ExportVertexSize;
                    preSegInfo.vertexCount = _segVCount;
                    segments.length = _segOffset;
                  } else {
                    segments.length = _segOffset - 1;
                  }
                }

                if (segments.length === 0) return;
                let vertices = frame.vertices;
                const copyOutVerticeSize = _vfOffset$1 / PerVertexSize * ExportVertexSize;

                if (!vertices || vertices.length < copyOutVerticeSize) {
                  vertices = frame.vertices = new Float32Array(copyOutVerticeSize);
                }

                for (let i = 0, j = 0; i < copyOutVerticeSize;) {
                  vertices[i] = _vertices$1[j++];
                  vertices[i + 1] = _vertices$1[j++];
                  vertices[i + 3] = _vertices$1[j++];
                  vertices[i + 4] = _vertices$1[j++];

                  this._setVerticeColor(_vertices$1[j++], vertices, i + 5);

                  this._setVerticeColor(_vertices$1[j++], vertices, i + 9);

                  i += ExportVertexSize;
                }

                let indices = frame.indices;

                if (!indices || indices.length < _indexOffset) {
                  indices = frame.indices = new Uint16Array(_indexOffset);
                }

                for (let i = 0; i < _indexOffset; i++) {
                  indices[i] = _indices[i];
                }

                frame.vertices = vertices;
                frame.indices = indices;
              }

              needToUpdate(toFrameIdx) {
                return !this.isCompleted && this.totalTime < MaxCacheTime && (toFrameIdx === undefined || this._frameIdx < toFrameIdx);
              }

              traverseSkeleton(skeleton, clipper) {
                const segments = this._tempSegments;
                const boneInfos = this._tempBoneInfos;
                const skeletonColor = skeleton.color;
                let attachment;
                let attachmentColor;
                let slotColor;
                let uvs;
                let triangles;
                let isRegion;
                let isMesh;
                let isClip;
                let texture;
                let preSegOffset;
                let preSegInfo;
                let blendMode;
                let slot;
                const bones = skeleton.bones;

                if (this._enableCacheAttachedInfo) {
                  for (let i = 0, l = bones.length; i < l; i++, _boneInfoOffset++) {
                    const bone = bones[i];
                    let boneInfo = boneInfos[_boneInfoOffset];

                    if (!boneInfo) {
                      boneInfo = boneInfos[_boneInfoOffset] = {};
                    }

                    boneInfo.a = bone.a;
                    boneInfo.b = bone.b;
                    boneInfo.c = bone.c;
                    boneInfo.d = bone.d;
                    boneInfo.worldX = bone.worldX;
                    boneInfo.worldY = bone.worldY;
                  }
                }

                for (let slotIdx = 0, slotCount = skeleton.drawOrder.length; slotIdx < slotCount; slotIdx++) {
                  slot = skeleton.drawOrder[slotIdx];
                  _vfCount = 0;
                  _indexCount = 0;
                  attachment = slot.getAttachment();

                  if (!attachment) {
                    clipper.clipEndWithSlot(slot);
                    continue;
                  }

                  isRegion = attachment instanceof spine$1.RegionAttachment;
                  isMesh = attachment instanceof spine$1.MeshAttachment;
                  isClip = attachment instanceof spine$1.ClippingAttachment;

                  if (isClip) {
                    clipper.clipStart(slot, attachment);
                    continue;
                  }

                  if (!isRegion && !isMesh) {
                    clipper.clipEndWithSlot(slot);
                    continue;
                  }

                  texture = attachment.region.texture.getRealTexture();

                  if (!texture) {
                    clipper.clipEndWithSlot(slot);
                    continue;
                  }

                  blendMode = slot.data.blendMode;

                  if (_preTexID !== texture.getId() || _preBlendMode !== blendMode) {
                    _preTexID = texture.getId();
                    _preBlendMode = blendMode;
                    preSegOffset = _segOffset - 1;

                    if (preSegOffset >= 0) {
                      if (_segICount > 0) {
                        preSegInfo = segments[preSegOffset];
                        preSegInfo.indexCount = _segICount;
                        preSegInfo.vertexCount = _segVCount;
                        preSegInfo.vfCount = _segVCount * ExportVertexSize;
                      } else {
                        _segOffset--;
                      }
                    }

                    segments[_segOffset] = {
                      tex: texture,
                      blendMode,
                      indexCount: 0,
                      vertexCount: 0,
                      vfCount: 0
                    };
                    _segOffset++;
                    _segICount = 0;
                    _segVCount = 0;
                  }

                  if (isRegion) {
                    triangles = _quadTriangles;
                    _vfCount = 4 * PerVertexSize;
                    _indexCount = 6;
                    attachment.computeWorldVertices(slot.bone, _vertices$1, _vfOffset$1, PerVertexSize);
                  } else if (isMesh) {
                    const meshAttachment = attachment;
                    triangles = meshAttachment.triangles;
                    _vfCount = (meshAttachment.worldVerticesLength >> 1) * PerVertexSize;
                    _indexCount = triangles.length;
                    meshAttachment.computeWorldVertices(slot, 0, meshAttachment.worldVerticesLength, _vertices$1, _vfOffset$1, PerVertexSize);
                  }

                  if (_vfCount === 0 || _indexCount === 0) {
                    clipper.clipEndWithSlot(slot);
                    continue;
                  }

                  for (let ii = 0, jj = _indexOffset, nn = triangles.length; ii < nn;) {
                    _indices[jj++] = triangles[ii++];
                  }

                  uvs = attachment.uvs;

                  for (let v = _vfOffset$1, n = _vfOffset$1 + _vfCount, u = 0; v < n; v += PerVertexSize, u += 2) {
                    _vertices$1[v + 2] = uvs[u];
                    _vertices$1[v + 3] = uvs[u + 1];
                  }

                  attachmentColor = attachment.color;
                  slotColor = slot.color;
                  this.fillVertices(skeletonColor, attachmentColor, slotColor, clipper, slot);

                  if (_indexCount > 0) {
                    for (let ii = _indexOffset, nn = _indexOffset + _indexCount; ii < nn; ii++) {
                      _indices[ii] += _segVCount;
                    }

                    _indexOffset += _indexCount;
                    _vfOffset$1 += _vfCount;
                    _segICount += _indexCount;
                    _segVCount += _vfCount / PerVertexSize;
                  }

                  clipper.clipEndWithSlot(slot);
                }

                clipper.clipEnd();
              }

              _setVerticeColor(colorI32, buffer, offset) {
                buffer[offset] = (colorI32 & 0xff) / 255.0;
                buffer[offset + 1] = (colorI32 >> 8 & 0xff) / 255.0;
                buffer[offset + 2] = (colorI32 >> 16 & 0xff) / 255.0;
                buffer[offset + 3] = (colorI32 >> 24 & 0xff) / 255.0;
              }

            }

            class SkeletonCache {
              constructor() {
                this._privateMode = void 0;
                this._skeletonCache = void 0;
                this._animationPool = void 0;
                this._privateMode = false;
                this._animationPool = {};
                this._skeletonCache = {};
              }

              enablePrivateMode() {
                this._privateMode = true;
              }

              clear() {
                this._animationPool = {};
                this._skeletonCache = {};
              }

              removeSkeleton(uuid) {
                const skeletonInfo = this._skeletonCache[uuid];
                if (!skeletonInfo) return;
                const animationsCache = skeletonInfo.animationsCache;

                for (const aniKey in animationsCache) {
                  const animationCache = animationsCache[aniKey];
                  if (!animationCache) continue;
                  this._animationPool[`${uuid}#${aniKey}`] = animationCache;
                  animationCache.clear();
                }

                delete this._skeletonCache[uuid];
              }

              getSkeletonCache(uuid, skeletonData) {
                let skeletonInfo = this._skeletonCache[uuid];

                if (!skeletonInfo) {
                  const skeleton = new spine$1.Skeleton(skeletonData);
                  const clipper = new spine$1.SkeletonClipping();
                  const stateData = new spine$1.AnimationStateData(skeleton.data);
                  const state = new spine$1.AnimationState(stateData);
                  const listener = new TrackEntryListeners();
                  state.addListener(listener);
                  this._skeletonCache[uuid] = skeletonInfo = {
                    skeleton,
                    clipper,
                    state,
                    listener,
                    animationsCache: {},
                    curAnimationCache: null
                  };
                }

                return skeletonInfo;
              }

              getAnimationCache(uuid, animationName) {
                const skeletonInfo = this._skeletonCache[uuid];
                if (!skeletonInfo) return null;
                const animationsCache = skeletonInfo.animationsCache;
                return animationsCache[animationName];
              }

              invalidAnimationCache(uuid) {
                const skeletonInfo = this._skeletonCache[uuid];
                const skeleton = skeletonInfo && skeletonInfo.skeleton;
                if (!skeleton) return;
                const animationsCache = skeletonInfo.animationsCache;

                for (const aniKey in animationsCache) {
                  const animationCache = animationsCache[aniKey];
                  animationCache.invalidAllFrame();
                }
              }

              initAnimationCache(uuid, animationName) {
                if (!animationName) return null;
                const skeletonInfo = this._skeletonCache[uuid];
                const skeleton = skeletonInfo && skeletonInfo.skeleton;
                if (!skeleton) return null;
                const animation = skeleton.data.findAnimation(animationName);

                if (!animation) {
                  return null;
                }

                const animationsCache = skeletonInfo.animationsCache;
                let animationCache = animationsCache[animationName];

                if (!animationCache) {
                  const poolKey = `${uuid}#${animationName}`;
                  animationCache = this._animationPool[poolKey];

                  if (animationCache) {
                    delete this._animationPool[poolKey];
                  } else {
                    animationCache = new AnimationCache();
                    animationCache._privateMode = this._privateMode;
                  }

                  animationCache.init(skeletonInfo, animationName);
                  animationsCache[animationName] = animationCache;
                }

                return animationCache;
              }

              updateAnimationCache(uuid, animationName) {
                if (animationName) {
                  const animationCache = this.initAnimationCache(uuid, animationName);
                  if (!animationCache) return;
                  animationCache.updateAllFrame();
                } else {
                  const skeletonInfo = this._skeletonCache[uuid];
                  const skeleton = skeletonInfo && skeletonInfo.skeleton;
                  if (!skeleton) return;
                  const animationsCache = skeletonInfo.animationsCache;

                  for (const aniKey in animationsCache) {
                    const animationCache = animationsCache[aniKey];
                    animationCache.updateAllFrame();
                  }
                }
              }

            }

            SkeletonCache.FrameTime = FrameTime;
            SkeletonCache.sharedCache = new SkeletonCache();

            const tempMat4 = new Mat4();
            const nodeScale = new Vec3();
            class AttachUtil {
              constructor() {
                this._inited = false;
                this._skeleton = null;
                this._skeletonNode = null;
                this._skeletonComp = null;
                this._inited = false;
                this._skeleton = null;
                this._skeletonNode = null;
                this._skeletonComp = null;
              }

              init(skeletonComp) {
                this._inited = true;
                this._skeleton = skeletonComp._skeleton;
                this._skeletonNode = skeletonComp.node;
                this._skeletonComp = skeletonComp;
              }

              reset() {
                this._inited = false;
                this._skeleton = null;
                this._skeletonNode = null;
                this._skeletonComp = null;
              }

              _syncAttachedNode() {
                if (!this._inited) return;
                const socketNodes = this._skeletonComp.socketNodes;
                if (socketNodes.size === 0) return;
                let boneInfos = null;

                const isCached = this._skeletonComp.isAnimationCached();

                if (isCached) {
                  boneInfos = this._skeletonComp._curFrame && this._skeletonComp._curFrame.boneInfos;
                } else {
                  boneInfos = this._skeleton.bones;
                }

                if (!boneInfos) return;

                const matrixHandle = (node, bone) => {
                  nodeScale.set(node.scale);
                  const tm = tempMat4;
                  tm.m00 = bone.a;
                  tm.m01 = bone.c;
                  tm.m04 = bone.b;
                  tm.m05 = bone.d;
                  tm.m12 = bone.worldX;
                  tm.m13 = bone.worldY;
                  node.matrix = tempMat4;
                  node.scale = nodeScale;
                };

                for (const boneIdx of socketNodes.keys()) {
                  const boneNode = socketNodes.get(boneIdx);

                  if (!boneNode || !boneNode.isValid) {
                    socketNodes.delete(boneIdx);
                    continue;
                  }

                  const bone = boneInfos[boneIdx];

                  if (!bone) {
                    boneNode.removeFromParent();
                    boneNode.destroy();
                    socketNodes.delete(boneIdx);
                    continue;
                  }

                  matrixHandle(boneNode, bone);
                }
              }

            }

            class SkeletonTexture extends spine$1.Texture {
              constructor(opt) {
                super(opt);
                this.name = 'sp.SkeletonTexture';
                this._texture = null;
                this._material = null;
              }

              setRealTexture(tex) {
                this._texture = tex;
              }

              getRealTexture() {
                return this._texture;
              }

              setFilters(minFilter, magFilter) {
                if (this._texture) {
                  this.getRealTexture().setFilters(convertFilter(minFilter), convertFilter(magFilter));
                }
              }

              setWraps(uWrap, vWrap) {
                if (this._texture) {
                  this.getRealTexture().setWrapMode(convertWraps(uWrap), convertWraps(vWrap));
                }
              }

              dispose() {}

            }
            function convertFilter(filter) {
              switch (filter) {
                case spine$1.TextureFilter.Nearest:
                case spine$1.TextureFilter.MipMapNearestNearest:
                case spine$1.TextureFilter.MipMapLinearNearest:
                  return Filter$1.NEAREST;

                case spine$1.TextureFilter.MipMap:
                case spine$1.TextureFilter.MipMapNearestLinear:
                case spine$1.TextureFilter.MipMapLinearLinear:
                case spine$1.TextureFilter.Linear:
                default:
                  return Filter$1.LINEAR;
              }
            }
            function convertWraps(wrap) {
              switch (wrap) {
                case spine$1.TextureWrap.MirroredRepeat:
                  return WrapMode.MIRRORED_REPEAT;

                case spine$1.TextureWrap.ClampToEdge:
                  return WrapMode.CLAMP_TO_EDGE;

                case spine$1.TextureWrap.Repeat:
                default:
                  return WrapMode.REPEAT;
              }
            }

            var _dec$1u, _dec2$1k, _dec3$14, _class$1v, _class2$1j, _descriptor$1g, _descriptor2$18, _descriptor3$W, _descriptor4$S, _descriptor5$J, _temp$1o;
            let SkeletonData = (_dec$1u = ccclass('sp.SkeletonData'), _dec2$1k = type$1([Texture2D]), _dec3$14 = type$1([CCString]), _dec$1u(_class$1v = (_class2$1j = (_temp$1o = class SkeletonData extends Asset {
              get skeletonJsonStr() {
                if (this._skeletonJson) {
                  return JSON.stringify(this._skeletonJson);
                }

                return '';
              }

              get skeletonJson() {
                return this._skeletonJson;
              }

              set skeletonJson(value) {
                this.reset();

                if (typeof value === 'string') {
                  this._skeletonJson = JSON.parse(value);
                } else {
                  this._skeletonJson = value;
                }

                if (!this._uuid && value.skeleton) {
                  this._uuid = value.skeleton.hash;
                }
              }

              get atlasText() {
                return this._atlasText;
              }

              set atlasText(value) {
                this._atlasText = value;
                this.reset();
              }

              get _nativeAsset() {
                return this._buffer;
              }

              set _nativeAsset(bin) {
                this._buffer = bin;
                this.reset();
              }

              constructor() {
                super();

                _initializerDefineProperty(this, "_skeletonJson", _descriptor$1g, this);

                _initializerDefineProperty(this, "textures", _descriptor2$18, this);

                _initializerDefineProperty(this, "textureNames", _descriptor3$W, this);

                _initializerDefineProperty(this, "scale", _descriptor4$S, this);

                _initializerDefineProperty(this, "_atlasText", _descriptor5$J, this);

                this._buffer = void 0;
                this._skeletonCache = null;
                this._atlasCache = null;
                this._skinsEnum = null;
                this._animsEnum = null;
                this.reset();
              }

              createNode(callback) {
                const node = new Node(this.name);
                const skeleton = node.addComponent('cc.Skeleton');
                skeleton.skeletonData = this;
                return callback(null, node);
              }

              reset() {
                this._skeletonCache = null;
                this._atlasCache = null;
              }

              resetEnums() {
              }

              getRuntimeData(quiet) {
                if (this._skeletonCache) {
                  return this._skeletonCache;
                }

                if (!(this.textures && this.textures.length > 0) && this.textureNames && this.textureNames.length > 0) {
                  if (!quiet) {
                    console.error(`${this.name} no textures found!`);
                  }

                  return null;
                }

                const atlas = this._getAtlas(quiet);

                if (!atlas) {
                  return null;
                }

                const attachmentLoader = new spine$1.AtlasAttachmentLoader(atlas);
                let resData = null;
                let reader = null;

                if (this.skeletonJson) {
                  reader = new spine$1.SkeletonJson(attachmentLoader);
                  resData = this.skeletonJson;
                } else {
                  reader = new spine$1.SkeletonBinary(attachmentLoader);
                  resData = new Uint8Array(this._nativeAsset);
                }

                reader.scale = this.scale;
                this._skeletonCache = reader.readSkeletonData(resData);
                atlas.dispose();
                return this._skeletonCache;
              }

              getSkinsEnum() {
                if (this._skinsEnum) {
                    return this._skinsEnum;
                  }

                const sd = this.getRuntimeData(true);

                if (sd) {
                  const skins = sd.skins;
                  const enumDef = {};

                  for (let i = 0; i < skins.length; i++) {
                    const name = skins[i].name;
                    enumDef[name] = i;
                  }

                  return this._skinsEnum = Enum(enumDef);
                }

                return null;
              }

              getAnimsEnum() {
                if (this._animsEnum && Object.keys(this._animsEnum).length > 1) {
                  return this._animsEnum;
                }

                const sd = this.getRuntimeData(true);

                if (sd) {
                  const enumDef = {
                    '<None>': 0
                  };
                  const anims = sd.animations;

                  for (let i = 0; i < anims.length; i++) {
                    const name = anims[i].name;
                    enumDef[name] = i + 1;
                  }

                  return this._animsEnum = Enum(enumDef);
                }

                return null;
              }

              destroy() {
                SkeletonCache.sharedCache.removeSkeleton(this._uuid);
                return super.destroy();
              }

              _getTexture(line) {
                const names = this.textureNames;

                for (let i = 0; i < names.length; i++) {
                  if (names[i] === line) {
                    const texture = this.textures[i];
                    const tex = new SkeletonTexture({
                      width: texture.width,
                      height: texture.height
                    });
                    tex.setRealTexture(texture);
                    return tex;
                  }
                }

                console.error(`${this.name} no textures found!`);
                return null;
              }

              _getAtlas(quiet) {
                if (this._atlasCache) {
                  return this._atlasCache;
                }

                if (!this.atlasText) {
                  if (!quiet) {
                    console.error(`${this.name} no atlas found!`);
                  }

                  return null;
                }

                return this._atlasCache = new spine$1.TextureAtlas(this.atlasText, this._getTexture.bind(this));
              }

            }, _temp$1o), (_descriptor$1g = _applyDecoratedDescriptor(_class2$1j.prototype, "_skeletonJson", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor2$18 = _applyDecoratedDescriptor(_class2$1j.prototype, "textures", [serializable, _dec2$1k], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor3$W = _applyDecoratedDescriptor(_class2$1j.prototype, "textureNames", [serializable, _dec3$14], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor4$S = _applyDecoratedDescriptor(_class2$1j.prototype, "scale", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            }), _descriptor5$J = _applyDecoratedDescriptor(_class2$1j.prototype, "_atlasText", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            })), _class2$1j)) || _class$1v);
            legacyCC.internal.SpineSkeletonData = SkeletonData;

            class SkeletonSystem extends System {
              constructor() {
                super();
                this._skeletons = new Set();
              }

              static getInstance() {
                if (!SkeletonSystem._instance) {
                  SkeletonSystem._instance = new SkeletonSystem();
                  director.registerSystem(SkeletonSystem.ID, SkeletonSystem._instance, System.Priority.HIGH);
                }

                return SkeletonSystem._instance;
              }

              add(skeleton) {
                if (!skeleton) return;

                if (!this._skeletons.has(skeleton)) {
                  this._skeletons.add(skeleton);
                }
              }

              remove(skeleton) {
                if (!skeleton) return;

                if (this._skeletons.has(skeleton)) {
                  this._skeletons.delete(skeleton);
                }
              }

              postUpdate(dt) {
                if (!this._skeletons) {
                  return;
                }

                this._skeletons.forEach(skeleton => {
                  skeleton.updateAnimation(dt);
                });
              }

            }
            SkeletonSystem.ID = 'SKELETON';
            SkeletonSystem._instance = void 0;

            var _dec$1v, _dec2$1l, _class$1w, _class2$1k, _descriptor$1h, _descriptor2$19, _temp$1p, _dec3$15, _dec4$10, _dec5$V, _dec6$Q, _dec7$O, _dec8$K, _dec9$F, _dec10$C, _dec11$y, _dec12$x, _dec13$u, _dec14$q, _dec15$q, _dec16$p, _dec17$m, _dec18$l, _dec19$l, _dec20$j, _dec21$i, _dec22$h, _dec23$h, _dec24$e, _dec25$e, _dec26$d, _dec27$d, _dec28$c, _dec29$b, _class4$6, _class5$6, _descriptor3$X, _descriptor4$T, _descriptor5$K, _descriptor6$B, _descriptor7$t, _descriptor8$p, _descriptor9$j, _descriptor10$i, _descriptor11$h, _descriptor12$f, _descriptor13$b, _descriptor14$8, _descriptor15$7, _descriptor16$7, _class6$3, _temp2$7;
            const timeScale = 1.0;
            let DefaultSkinsEnum;

            (function (DefaultSkinsEnum) {
              DefaultSkinsEnum[DefaultSkinsEnum["default"] = 0] = "default";
            })(DefaultSkinsEnum || (DefaultSkinsEnum = {}));

            ccenum(DefaultSkinsEnum);
            let DefaultAnimsEnum;

            (function (DefaultAnimsEnum) {
              DefaultAnimsEnum[DefaultAnimsEnum["<None>"] = 0] = "<None>";
            })(DefaultAnimsEnum || (DefaultAnimsEnum = {}));

            ccenum(DefaultAnimsEnum);
            let AnimationCacheMode;

            (function (AnimationCacheMode) {
              AnimationCacheMode[AnimationCacheMode["REALTIME"] = 0] = "REALTIME";
              AnimationCacheMode[AnimationCacheMode["SHARED_CACHE"] = 1] = "SHARED_CACHE";
              AnimationCacheMode[AnimationCacheMode["PRIVATE_CACHE"] = 2] = "PRIVATE_CACHE";
            })(AnimationCacheMode || (AnimationCacheMode = {}));

            ccenum(AnimationCacheMode);

            function setEnumAttr(obj, propName, enumDef) {
              CCClass.Attr.setClassAttr(obj, propName, 'type', 'Enum');
              CCClass.Attr.setClassAttr(obj, propName, 'enumList', Enum.getList(enumDef));
            }

            let SpineMaterialType;

            (function (SpineMaterialType) {
              SpineMaterialType[SpineMaterialType["COLORED_TEXTURED"] = 0] = "COLORED_TEXTURED";
              SpineMaterialType[SpineMaterialType["TWO_COLORED"] = 1] = "TWO_COLORED";
            })(SpineMaterialType || (SpineMaterialType = {}));

            let SpineSocket = (_dec$1v = ccclass('sp.Skeleton.SpineSocket'), _dec2$1l = type$1(Node), _dec$1v(_class$1w = (_class2$1k = (_temp$1p = class SpineSocket {
              constructor(path = '', target = null) {
                _initializerDefineProperty(this, "path", _descriptor$1h, this);

                _initializerDefineProperty(this, "target", _descriptor2$19, this);

                this.path = path;
                this.target = target;
              }

            }, _temp$1p), (_descriptor$1h = _applyDecoratedDescriptor(_class2$1k.prototype, "path", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            }), _descriptor2$19 = _applyDecoratedDescriptor(_class2$1k.prototype, "target", [_dec2$1l, editable, serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            })), _class2$1k)) || _class$1w);
            js.setClassAlias(SpineSocket, 'sp.Skeleton.SpineSocket');
            let Skeleton = (_dec3$15 = ccclass('sp.Skeleton'), _dec4$10 = help(), _dec5$V = menu$1(), _dec6$Q = type$1(Material), _dec7$O = displayOrder(), _dec8$K = displayName(), _dec9$F = type$1(SkeletonData), _dec10$C = displayName(), _dec11$y = type$1(DefaultSkinsEnum), _dec12$x = tooltip(), _dec13$u = displayName(), _dec14$q = type$1(DefaultAnimsEnum), _dec15$q = tooltip(), _dec16$p = displayName(), _dec17$m = tooltip(), _dec18$l = type$1(AnimationCacheMode), _dec19$l = tooltip(), _dec20$j = tooltip(), _dec21$i = tooltip(), _dec22$h = tooltip(), _dec23$h = tooltip(), _dec24$e = tooltip(), _dec25$e = tooltip(), _dec26$d = type$1([SpineSocket]), _dec27$d = tooltip(), _dec28$c = visible(), _dec29$b = visible(), _dec3$15(_class4$6 = _dec4$10(_class4$6 = _dec5$V(_class4$6 = executeInEditMode(_class4$6 = (_class5$6 = (_temp2$7 = _class6$3 = class Skeleton extends Renderable2D {
              get meshRenderDataArray() {
                return this._meshRenderDataArray;
              }

              get customMaterial() {
                return this._customMaterial;
              }

              set customMaterial(val) {
                this._customMaterial = val;

                this._cleanMaterialCache();
              }

              get paused() {
                return this._paused;
              }

              set paused(value) {
                this._paused = value;
              }

              get skeletonData() {
                return this._skeletonData;
              }

              set skeletonData(value) {
                if (value) value.resetEnums();

                if (this._skeletonData !== value) {
                  this._skeletonData = value;
                  this.defaultSkin = '';
                  this.defaultAnimation = '';

                  this._updateSkeletonData();
                }
              }

              get animation() {
                if (this.isAnimationCached()) {
                  return this._animationName;
                }

                const entry = this.getCurrent(0);
                return entry && entry.animation.name || '';
              }

              set animation(value) {
                if (value) {
                  this.setAnimation(0, value, this.loop);
                  this.destroyRenderData();
                  this.markForUpdateRenderData();
                } else if (!this.isAnimationCached()) {
                  this.clearTrack(0);
                  this.setToSetupPose();
                }
              }

              get _defaultSkinIndex() {
                if (this.skeletonData) {
                  const skinsEnum = this.skeletonData.getSkinsEnum();

                  if (skinsEnum) {
                    if (this.defaultSkin === '') {
                      if (skinsEnum.hasOwnProperty(0)) {
                        this._defaultSkinIndex = 0;
                        return 0;
                      }
                    } else {
                      const skinIndex = skinsEnum[this.defaultSkin];

                      if (skinIndex !== undefined) {
                        return skinIndex;
                      }
                    }
                  }
                }

                return 0;
              }

              set _defaultSkinIndex(value) {
                let skinsEnum;

                if (this.skeletonData) {
                  skinsEnum = this.skeletonData.getSkinsEnum();
                }

                if (!skinsEnum) {
                  console.error(`${this.name} skin enums are invalid`);
                  return;
                }

                const skinName = skinsEnum[value];

                if (skinName !== undefined) {
                  this.defaultSkin = skinName;
                  this.setSkin(this.defaultSkin);
                } else {
                  console.error(`${this.name} skin enums are invalid`);
                }
              }

              get _animationIndex() {
                const animationName =  this.animation;

                if (this.skeletonData) {
                  if (animationName) {
                    const animsEnum = this.skeletonData.getAnimsEnum();

                    if (animsEnum) {
                      const animIndex = animsEnum[animationName];

                      if (animIndex !== undefined) {
                        return animIndex;
                      }
                    }
                  } else {
                    this._refreshInspector();
                  }
                }

                return 0;
              }

              set _animationIndex(value) {
                let animsEnum;

                if (this.skeletonData) {
                  animsEnum = this.skeletonData.getAnimsEnum();
                }

                if (!animsEnum) {
                  console.error(`${this.name} animation enums are invalid`);
                  return;
                }

                const animName = animsEnum[value];

                if (animName !== undefined) {
                  this.animation = animName;

                  {
                    this.animation = animName;
                  }
                } else {
                  console.error(`${this.name} animation enums are invalid`);
                }
              }

              get defaultCacheMode() {
                return this._defaultCacheMode;
              }

              set defaultCacheMode(mode) {
                this._defaultCacheMode = mode;
                this.setAnimationCacheMode(this._defaultCacheMode);
              }

              get premultipliedAlpha() {
                return this._premultipliedAlpha;
              }

              set premultipliedAlpha(v) {
                if (v !== this._premultipliedAlpha) {
                  this._premultipliedAlpha = v;
                  this.markForUpdateRenderData();
                }
              }

              get timeScale() {
                return this._timeScale;
              }

              set timeScale(value) {
                if (value !== this._timeScale) {
                  this._timeScale = value;
                }
              }

              get debugSlots() {
                return this._debugSlots;
              }

              set debugSlots(v) {
                if (v !== this._debugSlots) {
                  this._debugSlots = v;

                  this._updateDebugDraw();

                  this.markForUpdateRenderData();
                }
              }

              get debugBones() {
                return this._debugBones;
              }

              set debugBones(v) {
                if (v !== this._debugBones) {
                  this._debugBones = v;

                  this._updateDebugDraw();

                  this.markForUpdateRenderData();
                }
              }

              get debugMesh() {
                return this._debugMesh;
              }

              set debugMesh(value) {
                if (value !== this._debugMesh) {
                  this._debugMesh = value;

                  this._updateDebugDraw();

                  this.markForUpdateRenderData();
                }
              }

              get useTint() {
                return this._useTint;
              }

              set useTint(value) {
                if (value !== this._useTint) {
                  this._useTint = value;

                  this._updateUseTint();

                  this.markForUpdateRenderData();
                }
              }

              get sockets() {
                return this._sockets;
              }

              set sockets(val) {

                this._sockets = val;

                this._updateSocketBindings();

                this.attachUtil._syncAttachedNode();
              }

              get socketNodes() {
                return this._socketNodes;
              }

              constructor() {
                super();
                this._paused = false;

                _initializerDefineProperty(this, "loop", _descriptor3$X, this);

                _initializerDefineProperty(this, "_premultipliedAlpha", _descriptor4$T, this);

                _initializerDefineProperty(this, "_timeScale", _descriptor5$K, this);

                this.enableBatch = false;
                this._frameCache = null;
                this._curFrame = null;
                this._effectDelegate = null;
                this._skeleton = void 0;
                this._clipper = void 0;
                this._debugRenderer = void 0;
                this._startSlotIndex = void 0;
                this._endSlotIndex = void 0;
                this._startEntry = void 0;
                this._endEntry = void 0;
                this.attachUtil = void 0;
                this._materialCache = {};
                this._enumSkins = Enum({});
                this._enumAnimations = Enum({});
                this._accTime = 0;
                this._playCount = 0;
                this._skeletonCache = null;
                this._animationName = '';
                this._animationQueue = [];
                this._headAniInfo = null;
                this._playTimes = 0;
                this._isAniComplete = true;

                _initializerDefineProperty(this, "_useTint", _descriptor6$B, this);

                _initializerDefineProperty(this, "_preCacheMode", _descriptor7$t, this);

                _initializerDefineProperty(this, "_cacheMode", _descriptor8$p, this);

                _initializerDefineProperty(this, "_defaultCacheMode", _descriptor9$j, this);

                _initializerDefineProperty(this, "_debugBones", _descriptor10$i, this);

                _initializerDefineProperty(this, "_debugSlots", _descriptor11$h, this);

                _initializerDefineProperty(this, "_skeletonData", _descriptor12$f, this);

                _initializerDefineProperty(this, "defaultSkin", _descriptor13$b, this);

                _initializerDefineProperty(this, "defaultAnimation", _descriptor14$8, this);

                _initializerDefineProperty(this, "_sockets", _descriptor15$7, this);

                this._meshRenderDataArray = [];

                _initializerDefineProperty(this, "_debugMesh", _descriptor16$7, this);

                this._rootBone = void 0;
                this._state = void 0;
                this._listener = void 0;
                this._socketNodes = new Map();
                this._cachedSockets = new Map();
                this._meshRenderDataArrayIdx = 0;
                this._effectDelegate = null;
                this._skeleton = null;
                this._rootBone = null;
                this._listener = null;
                this._debugRenderer = null;
                this._startSlotIndex = -1;
                this._endSlotIndex = -1;
                this._startEntry = {
                  animation: {
                    name: ''
                  },
                  trackIndex: 0
                };
                this._endEntry = {
                  animation: {
                    name: ''
                  },
                  trackIndex: 0
                };
                this.attachUtil = new AttachUtil();
                setEnumAttr(this, '_defaultSkinIndex', this._enumSkins);
                setEnumAttr(this, '_animationIndex', this._enumAnimations);
              }

              disableRender() {
                this.destroyRenderData();
              }

              setSkeletonData(skeletonData) {
                const uiTrans = this.node._uiProps.uiTransformComp;

                if (skeletonData.width != null && skeletonData.height != null) {
                  uiTrans.setContentSize(skeletonData.width, skeletonData.height);
                }

                {
                  if (this._cacheMode === AnimationCacheMode.SHARED_CACHE) {
                    this._skeletonCache = SkeletonCache.sharedCache;
                  } else if (this._cacheMode === AnimationCacheMode.PRIVATE_CACHE) {
                    this._skeletonCache = new SkeletonCache();

                    this._skeletonCache.enablePrivateMode();
                  }
                }

                if (this.isAnimationCached()) {
                  if (this.debugBones || this.debugSlots) {
                    warn('Debug bones or slots is invalid in cached mode');
                  }

                  const skeletonInfo = this._skeletonCache.getSkeletonCache(this.skeletonData._uuid, skeletonData);

                  this._skeleton = skeletonInfo.skeleton;
                  this._clipper = skeletonInfo.clipper;
                  this._rootBone = this._skeleton.getRootBone();
                } else {
                  this._skeleton = new spine$1.Skeleton(skeletonData);
                  this._clipper = new spine$1.SkeletonClipping();
                  this._rootBone = this._skeleton.getRootBone();
                }

                this.markForUpdateRenderData();
              }

              setSlotsRange(startSlotIndex, endSlotIndex) {
                if (this.isAnimationCached()) {
                  warn('Slots visible range can not be modified in cached mode.');
                } else {
                  this._startSlotIndex = startSlotIndex;
                  this._endSlotIndex = endSlotIndex;
                }
              }

              setAnimationStateData(stateData) {
                if (this.isAnimationCached()) {
                  warn('\'setAnimationStateData\' interface can not be invoked in cached mode.');
                } else {
                  const state = new spine$1.AnimationState(stateData);

                  if (this._listener) {
                    if (this._state) {
                      this._state.removeListener(this._listener);
                    }

                    state.addListener(this._listener);
                  }

                  this._state = state;
                }
              }

              __preload() {
                super.__preload();

                const children = this.node.children;

                for (let i = 0, n = children.length; i < n; i++) {
                  const child = children[i];

                  if (child && child.name === 'DEBUG_DRAW_NODE') {
                    child.destroy();
                  }
                }

                this._updateSkeletonData();

                this._updateDebugDraw();

                this._updateUseTint();

                this._indexBoneSockets();

                this._updateSocketBindings();
              }

              setAnimationCacheMode(cacheMode) {
                if (this._preCacheMode !== cacheMode) {
                  this._cacheMode = cacheMode;

                  this._updateSkeletonData();

                  this._updateUseTint();

                  this._updateSocketBindings();

                  this.markForUpdateRenderData();
                }
              }

              isAnimationCached() {
                return this._cacheMode !== AnimationCacheMode.REALTIME;
              }

              updateAnimation(dt) {
                if (this.paused) return;
                dt *= this._timeScale * timeScale;

                if (this.isAnimationCached()) {
                  if (this._isAniComplete) {
                    if (this._animationQueue.length === 0 && !this._headAniInfo) {
                      const frameCache = this._frameCache;

                      if (frameCache && frameCache.isInvalid()) {
                        frameCache.updateToFrame();
                        const frames = frameCache.frames;
                        this._curFrame = frames[frames.length - 1];
                      }

                      return;
                    }

                    if (!this._headAniInfo) {
                      this._headAniInfo = this._animationQueue.shift();
                    }

                    this._accTime += dt;

                    if (this._accTime > this._headAniInfo.delay) {
                      const aniInfo = this._headAniInfo;
                      this._headAniInfo = null;
                      this.setAnimation(0, aniInfo.animationName, aniInfo.loop);
                    }

                    return;
                  }

                  this._updateCache(dt);
                } else {
                  this._updateRealtime(dt);
                }
              }

              setVertexEffectDelegate(effectDelegate) {
                this._effectDelegate = effectDelegate;
              }

              setToSetupPose() {
                if (this._skeleton) {
                  this._skeleton.setToSetupPose();
                }
              }

              setBonesToSetupPose() {
                if (this._skeleton) {
                  this._skeleton.setBonesToSetupPose();
                }
              }

              setSlotsToSetupPose() {
                if (this._skeleton) {
                  this._skeleton.setSlotsToSetupPose();
                }
              }

              updateAnimationCache(animName) {
                if (!this.isAnimationCached()) return;
                const uuid = this._skeletonData._uuid;

                if (this._skeletonCache) {
                  this._skeletonCache.updateAnimationCache(uuid, animName);
                }
              }

              invalidAnimationCache() {
                if (!this.isAnimationCached()) return;

                if (this._skeletonCache) {
                  this._skeletonCache.invalidAnimationCache(this._skeletonData._uuid);
                }
              }

              findBone(boneName) {
                if (this._skeleton) {
                  return this._skeleton.findBone(boneName);
                }

                return null;
              }

              findSlot(slotName) {
                if (this._skeleton) {
                  return this._skeleton.findSlot(slotName);
                }

                return null;
              }

              setSkin(skinName) {
                if (this._skeleton) {
                  this._skeleton.setSkinByName(skinName);

                  this._skeleton.setSlotsToSetupPose();
                }

                this.invalidAnimationCache();
              }

              getAttachment(slotName, attachmentName) {
                if (this._skeleton) {
                  return this._skeleton.getAttachmentByName(slotName, attachmentName);
                }

                return null;
              }

              setAttachment(slotName, attachmentName) {
                if (this._skeleton) {
                  this._skeleton.setAttachment(slotName, attachmentName);
                }

                this.invalidAnimationCache();
              }

              getTextureAtlas(regionAttachment) {
                return regionAttachment.region;
              }

              setMix(fromAnimation, toAnimation, duration) {
                if (this._state) {
                  this._state.data.setMix(fromAnimation, toAnimation, duration);
                }
              }

              setAnimation(trackIndex, name, loop) {
                this._playTimes = loop ? 0 : 1;
                this._animationName = name;

                if (this.isAnimationCached()) {
                  if (trackIndex !== 0) {
                    warn('Track index can not greater than 0 in cached mode.');
                  }

                  if (!this._skeletonCache) return null;

                  let cache = this._skeletonCache.getAnimationCache(this._skeletonData._uuid, name);

                  if (!cache) {
                    cache = this._skeletonCache.initAnimationCache(this._skeletonData._uuid, name);
                  }

                  if (cache) {
                    this._isAniComplete = false;
                    this._accTime = 0;
                    this._playCount = 0;
                    this._frameCache = cache;

                    if (this._socketNodes.size > 0) {
                      this._frameCache.enableCacheAttachedInfo();
                    }

                    this._frameCache.updateToFrame(0);

                    this._curFrame = this._frameCache.frames[0];
                  }
                } else if (this._skeleton) {
                  const animation = this._skeleton.data.findAnimation(name);

                  if (!animation) {
                    logID(7509, name);
                    return null;
                  }

                  const res = this._state.setAnimationWith(trackIndex, animation, loop);

                  this._state.apply(this._skeleton);

                  return res;
                }

                return null;
              }

              addAnimation(trackIndex, name, loop, delay) {
                delay = delay || 0;

                if (this.isAnimationCached()) {
                  if (trackIndex !== 0) {
                    warn('Track index can not greater than 0 in cached mode.');
                  }

                  this._animationQueue.push({
                    animationName: name,
                    loop,
                    delay
                  });
                } else if (this._skeleton) {
                  var _this$_state;

                  const animation = this._skeleton.data.findAnimation(name);

                  if (!animation) {
                    logID(7510, name);
                    return null;
                  }

                  return (_this$_state = this._state) === null || _this$_state === void 0 ? void 0 : _this$_state.addAnimationWith(trackIndex, animation, loop, delay);
                }

                return null;
              }

              findAnimation(name) {
                if (this._skeleton) {
                  return this._skeleton.data.findAnimation(name);
                }

                return null;
              }

              getCurrent(trackIndex) {
                if (this.isAnimationCached()) {
                  warn('\'getCurrent\' interface can not be invoked in cached mode.');
                } else if (this._state) {
                  return this._state.getCurrent(trackIndex);
                }

                return null;
              }

              clearTracks() {
                if (this.isAnimationCached()) {
                  warn('\'clearTracks\' interface can not be invoked in cached mode.');
                } else if (this._state) {
                  this._state.clearTracks();

                  this.setToSetupPose();
                }
              }

              clearTrack(trackIndex) {
                if (this.isAnimationCached()) {
                  warn('\'clearTrack\' interface can not be invoked in cached mode.');
                } else if (this._state) {
                  this._state.clearTrack(trackIndex);
                }
              }

              setStartListener(listener) {
                this._ensureListener();

                this._listener.start = listener;
              }

              setInterruptListener(listener) {
                this._ensureListener();

                this._listener.interrupt = listener;
              }

              setEndListener(listener) {
                this._ensureListener();

                this._listener.end = listener;
              }

              setDisposeListener(listener) {
                this._ensureListener();

                this._listener.dispose = listener;
              }

              setCompleteListener(listener) {
                this._ensureListener();

                this._listener.complete = listener;
              }

              setEventListener(listener) {
                this._ensureListener();

                this._listener.event = listener;
              }

              setTrackStartListener(entry, listener) {
                TrackEntryListeners.getListeners(entry).start = listener;
              }

              setTrackInterruptListener(entry, listener) {
                TrackEntryListeners.getListeners(entry).interrupt = listener;
              }

              setTrackEndListener(entry, listener) {
                TrackEntryListeners.getListeners(entry).end = listener;
              }

              setTrackDisposeListener(entry, listener) {
                TrackEntryListeners.getListeners(entry).dispose = listener;
              }

              setTrackCompleteListener(entry, listener) {
                TrackEntryListeners.getListeners(entry).complete = function (trackEntry) {
                  const loopCount = Math.floor(trackEntry.trackTime / trackEntry.animationEnd);
                  listener(trackEntry, loopCount);
                };
              }

              setTrackEventListener(entry, listener) {
                TrackEntryListeners.getListeners(entry).event = listener;
              }

              getState() {
                return this._state;
              }

              onEnable() {
                super.onEnable();

                this._flushAssembler();

                SkeletonSystem.getInstance().add(this);
              }

              onDisable() {
                super.onDisable();
                SkeletonSystem.getInstance().remove(this);
              }

              onDestroy() {
                this._cleanMaterialCache();

                this.destroyRenderData();
                super.onDestroy();
              }

              requestMeshRenderData(vertexFloatCnt) {
                if (this._meshRenderDataArray.length > 0 && this._meshRenderDataArray[this._meshRenderDataArray.length - 1].renderData.vertexCount === 0) {
                  return this._meshRenderDataArray[this._meshRenderDataArray.length - 1];
                }

                const renderData = new MeshRenderData(vertexFloatCnt);
                const comb = {
                  renderData
                };
                renderData.material = null;

                this._meshRenderDataArray.push(comb);

                return comb;
              }

              destroyRenderData() {
                if (this._meshRenderDataArray.length > 0) {
                  this._meshRenderDataArray.forEach(rd => {
                    rd.renderData.reset();
                  });

                  this._meshRenderDataArray.length = 0;
                }
              }

              getMaterialForBlendAndTint(src, dst, type) {
                const key = `${type}/${src}/${dst}`;
                let inst = this._materialCache[key];

                if (inst) {
                  return inst;
                }

                let material = this.customMaterial;

                if (material === null) {
                  material = builtinResMgr.get('default-spine-material');
                }

                let useTwoColor = false;

                switch (type) {
                  case SpineMaterialType.TWO_COLORED:
                    useTwoColor = true;
                    break;

                  case SpineMaterialType.COLORED_TEXTURED:
                }

                const matInfo = {
                  parent: material,
                  subModelIdx: 0,
                  owner: this
                };
                inst = new MaterialInstance(matInfo);
                this._materialCache[key] = inst;
                inst.overridePipelineStates({
                  blendState: {
                    blendColor: Color$1.WHITE,
                    targets: [{
                      blendEq: BlendOp.ADD,
                      blendAlphaEq: BlendOp.ADD,
                      blendSrc: src,
                      blendDst: dst,
                      blendSrcAlpha: src,
                      blendDstAlpha: dst
                    }]
                  }
                });
                inst.recompileShaders({
                  TWO_COLORED: useTwoColor
                });
                return inst;
              }

              onRestore() {
                this.updateMaterial();
                this._renderFlag = this._canRender();
                this.markForUpdateRenderData();
              }

              updateMaterial() {
                if (this._customMaterial) {
                  this.setMaterial(this._customMaterial, 0);
                  this._blendHash = -1;
                  return;
                }

                const mat = this._updateBuiltinMaterial();

                this.setMaterial(mat, 0);

                this._updateBlendFunc();

                this._blendHash = -1;
              }

              querySockets() {
                if (!this._skeleton) {
                  return [];
                }

                if (this._cachedSockets.size === 0) {
                  this._indexBoneSockets();
                }

                if (this._cachedSockets.size > 0) {
                  return Array.from(this._cachedSockets.keys()).sort();
                }

                return [];
              }

              _render(ui) {
                if (this._meshRenderDataArray) {
                  for (let i = 0; i < this._meshRenderDataArray.length; i++) {
                    const mat = this.material;
                    this._meshRenderDataArrayIdx = i;
                    const m = this._meshRenderDataArray[i];

                    if (m.renderData.material) {
                      this.material = m.renderData.material;
                    }

                    if (m.texture) {
                      ui.commitComp(this, m.texture, this._assembler, null);
                    }

                    this.material = mat;
                  }
                }
              }

              updateWorldTransform() {
                if (!this.isAnimationCached()) return;

                if (this._skeleton) {
                  this._skeleton.updateWorldTransform();
                }
              }

              _emitCacheCompleteEvent() {
                if (!this._listener) return;
                this._endEntry.animation.name = this._animationName;
                if (this._listener.complete) this._listener.complete(this._endEntry);
                if (this._listener.end) this._listener.end(this._endEntry);
              }

              _updateCache(dt) {
                const frameCache = this._frameCache;

                if (!frameCache.isInited()) {
                  return;
                }

                const frames = frameCache.frames;
                const frameTime = SkeletonCache.FrameTime;

                if (this._accTime === 0 && this._playCount === 0) {
                  this._startEntry.animation.name = this._animationName;
                  if (this._listener && this._listener.start) this._listener.start(this._startEntry);
                }

                this._accTime += dt;
                let frameIdx = Math.floor(this._accTime / frameTime);

                if (!frameCache.isCompleted) {
                  frameCache.updateToFrame(frameIdx);
                }

                if (frameCache.isCompleted && frameIdx >= frames.length) {
                  this._playCount++;

                  if (this._playTimes > 0 && this._playCount >= this._playTimes) {
                    this._curFrame = frames[frames.length - 1];
                    this._accTime = 0;
                    this._playCount = 0;
                    this._isAniComplete = true;

                    this._emitCacheCompleteEvent();

                    this.markForUpdateRenderData();
                    return;
                  }

                  this._accTime = 0;
                  frameIdx = 0;

                  this._emitCacheCompleteEvent();
                }

                this._curFrame = frames[frameIdx];
                this.markForUpdateRenderData();
              }

              _updateRealtime(dt) {
                const skeleton = this._skeleton;
                const state = this._state;

                if (skeleton) {
                  skeleton.update(dt);

                  if (state) {
                    state.update(dt);
                    state.apply(skeleton);
                  }

                  this.markForUpdateRenderData();
                }
              }

              _indexBoneSockets() {
                if (!this._skeleton) {
                  return;
                }

                this._cachedSockets.clear();

                const bones = this._skeleton.bones;

                const getBoneName = bone => {
                  if (bone.parent == null) return bone.data.name || '<Unamed>';
                  return `${getBoneName(bones[bone.parent.data.index])}/${bone.data.name}`;
                };

                for (let i = 0, l = bones.length; i < l; i++) {
                  const bd = bones[i].data;
                  const boneName = getBoneName(bones[i]);

                  this._cachedSockets.set(boneName, bd.index);
                }
              }

              _updateUseTint() {
                this._cleanMaterialCache();

                this.destroyRenderData();
              }

              _updateBatch() {
                this.markForUpdateRenderData();
              }

              _validateRender() {
                const skeletonData = this.skeletonData;

                if (!skeletonData) {
                  this.disableRender();
                }
              }

              _updateAnimEnum() {
                let animEnum;

                if (this.skeletonData) {
                  animEnum = this.skeletonData.getAnimsEnum();
                } else {
                  animEnum = DefaultAnimsEnum;
                }

                this._enumAnimations = Enum({});
                Object.assign(this._enumAnimations, animEnum);
                Enum.update(this._enumAnimations);
                setEnumAttr(this, '_animationIndex', this._enumAnimations);
              }

              _updateSkinEnum() {
                let skinEnum;

                if (this.skeletonData) {
                  skinEnum = this.skeletonData.getSkinsEnum();
                } else {
                  skinEnum = DefaultSkinsEnum;
                }

                this._enumSkins = Enum({});
                Object.assign(this._enumSkins, skinEnum);
                Enum.update(this._enumSkins);
                setEnumAttr(this, '_defaultSkinIndex', this._enumSkins);
              }

              _ensureListener() {
                if (!this._listener) {
                  this._listener = new TrackEntryListeners();

                  if (this._state) {
                    this._state.addListener(this._listener);
                  }
                }
              }

              _updateSkeletonData() {
                if (!this.skeletonData) {
                  this.disableRender();
                  return;
                }

                const data = this.skeletonData.getRuntimeData();

                if (!data) {
                  this.disableRender();
                  return;
                }

                try {
                  this.setSkeletonData(data);

                  if (!this.isAnimationCached()) {
                    this.setAnimationStateData(new spine$1.AnimationStateData(this._skeleton.data));
                  }

                  if (this.defaultSkin) this.setSkin(this.defaultSkin);
                } catch (e) {
                  warn(e);
                }

                this._indexBoneSockets();

                this.attachUtil.init(this);
                this._preCacheMode = this._cacheMode;
                this.animation = this.defaultAnimation;
              }

              _refreshInspector() {
                this._updateAnimEnum();

                this._updateSkinEnum();
              }

              _updateDebugDraw() {
                if (this.debugBones || this.debugSlots || this.debugMesh) {
                  if (!this._debugRenderer) {
                    const debugDrawNode = new Node('DEBUG_DRAW_NODE');
                    debugDrawNode.hideFlags |= CCObject.Flags.DontSave | CCObject.Flags.HideInHierarchy;
                    const debugDraw = debugDrawNode.addComponent(Graphics);
                    debugDraw.lineWidth = 1;
                    debugDraw.strokeColor = new Color$1(255, 0, 0, 255);
                    this._debugRenderer = debugDraw;
                    debugDrawNode.parent = this.node;
                  }

                  if (this.isAnimationCached()) {
                    warn('Debug bones or slots is invalid in cached mode');
                  }
                } else if (this._debugRenderer) {
                  this._debugRenderer.node.destroy();

                  this._debugRenderer = null;
                }
              }

              _flushAssembler() {
                const assembler = Skeleton.Assembler.getAssembler(this);

                if (this._assembler !== assembler) {
                  this._assembler = assembler;
                }

                if (this._meshRenderDataArray.length === 0) {
                  if (this._assembler && this._assembler.createData) {
                    this._assembler.createData(this);

                    this.markForUpdateRenderData();
                    this._colorDirty = true;

                    this._updateColor();
                  }
                }
              }

              _updateSocketBindings() {
                if (!this._skeleton) return;

                this._socketNodes.clear();

                for (let i = 0, l = this._sockets.length; i < l; i++) {
                  const socket = this._sockets[i];

                  if (socket.path && socket.target) {
                    const boneIdx = this._cachedSockets.get(socket.path);

                    if (!boneIdx) {
                      console.error(`Skeleton data does not contain path ${socket.path}`);
                      continue;
                    }

                    this._socketNodes.set(boneIdx, socket.target);
                  }
                }
              }

              _verifySockets(sockets) {
                for (let i = 0, l = sockets.length; i < l; i++) {
                  const target = sockets[i].target;

                  if (target) {
                    if (!target.parent || target.parent !== this.node) {
                      console.error(`Target node ${target.name} is expected to be a direct child of ${this.node.name}`);
                      continue;
                    }
                  }
                }

                const uniqueSocketNode = new Map();
                sockets.forEach(x => {
                  if (x.target) {
                    if (uniqueSocketNode.get(x.target)) {
                      console.error(`Target node ${x.target.name} has existed.`);
                    } else {
                      uniqueSocketNode.set(x.target, true);
                    }
                  }
                });
              }

              _cleanMaterialCache() {
                for (const val in this._materialCache) {
                  this._materialCache[val].destroy();
                }

                this._materialCache = {};
              }

            }, _class6$3.SpineSocket = SpineSocket, _class6$3.AnimationCacheMode = AnimationCacheMode, _temp2$7), (_applyDecoratedDescriptor(_class5$6.prototype, "customMaterial", [override, _dec6$Q, _dec7$O, _dec8$K], Object.getOwnPropertyDescriptor(_class5$6.prototype, "customMaterial"), _class5$6.prototype), _applyDecoratedDescriptor(_class5$6.prototype, "skeletonData", [editable, _dec9$F], Object.getOwnPropertyDescriptor(_class5$6.prototype, "skeletonData"), _class5$6.prototype), _applyDecoratedDescriptor(_class5$6.prototype, "_defaultSkinIndex", [_dec10$C, _dec11$y, _dec12$x], Object.getOwnPropertyDescriptor(_class5$6.prototype, "_defaultSkinIndex"), _class5$6.prototype), _applyDecoratedDescriptor(_class5$6.prototype, "_animationIndex", [_dec13$u, _dec14$q, _dec15$q], Object.getOwnPropertyDescriptor(_class5$6.prototype, "_animationIndex"), _class5$6.prototype), _applyDecoratedDescriptor(_class5$6.prototype, "defaultCacheMode", [_dec16$p, _dec17$m, editable, _dec18$l], Object.getOwnPropertyDescriptor(_class5$6.prototype, "defaultCacheMode"), _class5$6.prototype), _descriptor3$X = _applyDecoratedDescriptor(_class5$6.prototype, "loop", [serializable, _dec19$l], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _descriptor4$T = _applyDecoratedDescriptor(_class5$6.prototype, "_premultipliedAlpha", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return true;
              }
            }), _applyDecoratedDescriptor(_class5$6.prototype, "premultipliedAlpha", [editable, _dec20$j], Object.getOwnPropertyDescriptor(_class5$6.prototype, "premultipliedAlpha"), _class5$6.prototype), _descriptor5$K = _applyDecoratedDescriptor(_class5$6.prototype, "_timeScale", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            }), _applyDecoratedDescriptor(_class5$6.prototype, "timeScale", [_dec21$i, editable], Object.getOwnPropertyDescriptor(_class5$6.prototype, "timeScale"), _class5$6.prototype), _applyDecoratedDescriptor(_class5$6.prototype, "debugSlots", [editable, _dec22$h], Object.getOwnPropertyDescriptor(_class5$6.prototype, "debugSlots"), _class5$6.prototype), _applyDecoratedDescriptor(_class5$6.prototype, "debugBones", [editable, _dec23$h], Object.getOwnPropertyDescriptor(_class5$6.prototype, "debugBones"), _class5$6.prototype), _applyDecoratedDescriptor(_class5$6.prototype, "debugMesh", [editable, _dec24$e], Object.getOwnPropertyDescriptor(_class5$6.prototype, "debugMesh"), _class5$6.prototype), _applyDecoratedDescriptor(_class5$6.prototype, "useTint", [editable, _dec25$e], Object.getOwnPropertyDescriptor(_class5$6.prototype, "useTint"), _class5$6.prototype), _applyDecoratedDescriptor(_class5$6.prototype, "sockets", [_dec26$d, _dec27$d], Object.getOwnPropertyDescriptor(_class5$6.prototype, "sockets"), _class5$6.prototype), _descriptor6$B = _applyDecoratedDescriptor(_class5$6.prototype, "_useTint", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor7$t = _applyDecoratedDescriptor(_class5$6.prototype, "_preCacheMode", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return -1;
              }
            }), _descriptor8$p = _applyDecoratedDescriptor(_class5$6.prototype, "_cacheMode", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return AnimationCacheMode.REALTIME;
              }
            }), _descriptor9$j = _applyDecoratedDescriptor(_class5$6.prototype, "_defaultCacheMode", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return AnimationCacheMode.REALTIME;
              }
            }), _descriptor10$i = _applyDecoratedDescriptor(_class5$6.prototype, "_debugBones", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor11$h = _applyDecoratedDescriptor(_class5$6.prototype, "_debugSlots", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor12$f = _applyDecoratedDescriptor(_class5$6.prototype, "_skeletonData", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor13$b = _applyDecoratedDescriptor(_class5$6.prototype, "defaultSkin", [serializable, _dec28$c], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            }), _descriptor14$8 = _applyDecoratedDescriptor(_class5$6.prototype, "defaultAnimation", [_dec29$b, serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            }), _descriptor15$7 = _applyDecoratedDescriptor(_class5$6.prototype, "_sockets", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            }), _descriptor16$7 = _applyDecoratedDescriptor(_class5$6.prototype, "_debugMesh", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            })), _class5$6)) || _class4$6) || _class4$6) || _class4$6) || _class4$6);
            legacyCC.internal.SpineSkeleton = Skeleton;

            const FLAG_BATCH = 0x10;
            const FLAG_TWO_COLOR = 0x01;
            let _handleVal = 0x00;
            const _quadTriangles$1 = [0, 1, 2, 2, 3, 0];

            const _slotColor = new Color$1(0, 0, 255, 255);

            const _boneColor = new Color$1(255, 0, 0, 255);

            const _originColor = new Color$1(0, 255, 0, 255);

            const _meshColor = new Color$1(255, 255, 0, 255);

            const _finalColor$1 = new spine$1.Color(1, 1, 1, 1);

            const _darkColor$1 = new spine$1.Color(1, 1, 1, 1);

            const _tempPos$2 = new spine$1.Vector2();

            const _tempUv = new spine$1.Vector2();

            let _premultipliedAlpha;

            let _multiplier;

            let _slotRangeStart;

            let _slotRangeEnd;

            let _useTint;

            let _debugSlots;

            let _debugBones;

            let _debugMesh;

            let _nodeR;

            let _nodeG;

            let _nodeB;

            let _nodeA;

            const _finalColor32$1 = new Float32Array(4);

            const _darkColor32$1 = new Float32Array(4);

            const _vec3u_temp$1 = new Vec3();

            let _perVertexSize;

            let _perClipVertexSize;

            let _vertexFloatCount = 0;
            let _vertexCount = 0;
            let _vertexOffset = 0;
            let _vertexFloatOffset = 0;
            let _indexCount$1 = 0;
            let _indexOffset$1 = 0;
            let _vfOffset$2 = 0;

            let _tempr$1;

            let _tempg$1;

            let _tempb$1;

            let _inRange;

            let _mustFlush;

            let _x;

            let _y;

            let _m00;

            let _m04;

            let _m12;

            let _m01;

            let _m05;

            let _m13;

            let _r;

            let _g;

            let _b;

            let _fr;

            let _fg;

            let _fb;

            let _fa;

            let _dr;

            let _dg;

            let _db;

            let _da;

            let _comp$1;

            let _buffer;

            let _node;

            let _needColor;

            let _vertexEffect = null;
            let _currentMaterial = null;
            let _currentTexture = null;

            console.log('pptest importing cc 3.8');
            function _getSlotMaterial(blendMode) {
              let src;
              let dst;

              switch (blendMode) {
                case spine$1.BlendMode.Additive:
                  src = _premultipliedAlpha ? BlendFactor.ONE : BlendFactor.SRC_ALPHA;
                  dst = BlendFactor.ONE;
                  break;

                case spine$1.BlendMode.Multiply:
                  src = BlendFactor.DST_COLOR;
                  dst = BlendFactor.ONE_MINUS_SRC_ALPHA;
                  break;

                case spine$1.BlendMode.Screen:
                  src = BlendFactor.ONE;
                  dst = BlendFactor.ONE_MINUS_SRC_COLOR;
                  break;

                case spine$1.BlendMode.Normal:
                default:
                  src = _premultipliedAlpha ? BlendFactor.ONE : BlendFactor.SRC_ALPHA;
                  dst = BlendFactor.ONE_MINUS_SRC_ALPHA;
                  break;
              }

              return _comp$1.getMaterialForBlendAndTint(src, dst, _useTint ? SpineMaterialType.TWO_COLORED : SpineMaterialType.COLORED_TEXTURED);
            }

            function _handleColor(color) {
              _fa = color.fa * _nodeA;
              _multiplier = _premultipliedAlpha ? _fa / 255 : 1;
              _r = _nodeR * _multiplier;
              _g = _nodeG * _multiplier;
              _b = _nodeB * _multiplier;
              _fr = color.fr * _r;
              _fg = color.fg * _g;
              _fb = color.fb * _b;
              _finalColor32$1[0] = _fr / 255.0;
              _finalColor32$1[1] = _fg / 255.0;
              _finalColor32$1[2] = _fb / 255.0;
              _finalColor32$1[3] = _fa / 255.0;
              _dr = color.dr * _r;
              _dg = color.dg * _g;
              _db = color.db * _b;
              _da = _premultipliedAlpha ? 255 : 0;
              _darkColor32$1[0] = _dr / 255.0;
              _darkColor32$1[1] = _dg / 255.0;
              _darkColor32$1[2] = _db / 255.0;
              _darkColor32$1[3] = _da / 255.0;
            }

            const _tmpColor4 = new Float32Array(4);

            function _spineColorToFloat32Array4(spineColor) {
              _tmpColor4[0] = spineColor.r / 255.0;
              _tmpColor4[1] = spineColor.g / 255.0;
              _tmpColor4[2] = spineColor.b / 255.0;
              _tmpColor4[3] = spineColor.a / 255.0;
              return _tmpColor4;
            }

            function _vfmtFloatSize(useTint) {
              return useTint ? 3 + 2 + 4 + 4 : 3 + 2 + 4;
            }

            const simple$2 = {
              createData() {},

              updateRenderData(comp, ui) {
                _comp$1 = comp;
                const skeleton = comp._skeleton;

                if (!comp.isAnimationCached() && skeleton) {
                  skeleton.updateWorldTransform();
                }

                if (skeleton) {
                  updateComponentRenderData(comp);
                }
              },

              updateColor(comp) {
                if (!comp) return;
                _comp$1 = comp;

                _comp$1.markForUpdateRenderData();
              },

              fillBuffers(comp, renderer) {
                if (!comp || !comp.meshRenderDataArray) return;
                _comp$1 = comp;
                const dataArray = comp.meshRenderDataArray;
                const node = comp.node;
                const data = dataArray[comp._meshRenderDataArrayIdx];
                const renderData = data.renderData;
                let buffer = renderer.acquireBufferBatch(renderData.floatStride === 9 ? vfmtPosUvColor : vfmtPosUvTwoColor);
                let floatOffset = buffer.byteOffset >> 2;
                let indicesOffset = buffer.indicesOffset;
                let vertexOffset = buffer.vertexOffset;
                const isRecreate = buffer.request(renderData.vertexCount, renderData.indicesCount);

                if (!isRecreate) {
                  buffer = renderer.currBufferBatch;
                  floatOffset = 0;
                  indicesOffset = 0;
                  vertexOffset = 0;
                }

                const vBuf = buffer.vData;
                const iBuf = buffer.iData;
                const matrix = node.worldMatrix;
                const srcVBuf = renderData.vData;
                const srcVIdx = renderData.vertexStart;
                const srcIBuf = renderData.iData;
                const strideFloat = renderData.floatStride;
                vBuf.set(srcVBuf.subarray(srcVIdx, srcVIdx + renderData.vertexCount * strideFloat), floatOffset);

                for (let i = 0; i < renderData.vertexCount; i++) {
                  const pOffset = floatOffset + i * strideFloat;

                  _vec3u_temp$1.set(vBuf[pOffset], vBuf[pOffset + 1], vBuf[pOffset + 2]);

                  _vec3u_temp$1.transformMat4(matrix);

                  vBuf[pOffset] = _vec3u_temp$1.x;
                  vBuf[pOffset + 1] = _vec3u_temp$1.y;
                  vBuf[pOffset + 2] = _vec3u_temp$1.z;
                }

                const srcIOffset = renderData.indicesStart;

                for (let i = 0; i < renderData.indicesCount; i += 1) {
                  iBuf[i + indicesOffset] = srcIBuf[i + srcIOffset] + vertexOffset;
                }
              }

            };

            function updateComponentRenderData(comp, ui) {
              if (!comp._skeleton) return;
              const nodeColor = comp.color;
              _nodeR = nodeColor.r / 255;
              _nodeG = nodeColor.g / 255;
              _nodeB = nodeColor.b / 255;
              _nodeA = nodeColor.a / 255;
              _useTint = comp.useTint || comp.isAnimationCached();
              _perVertexSize = _vfmtFloatSize(_useTint);
              _node = comp.node;
              comp.destroyRenderData();
              _buffer = comp.requestMeshRenderData(_perVertexSize);
              _comp$1 = comp;
              _currentMaterial = null;
              _mustFlush = true;
              _premultipliedAlpha = comp.premultipliedAlpha;
              _multiplier = 1.0;
              _handleVal = 0x00;
              _needColor = false;
              _vertexEffect = comp._effectDelegate && comp._effectDelegate._vertexEffect;

              if (nodeColor._val !== 0xffffffff || _premultipliedAlpha) {
                _needColor = true;
              }

              if (_useTint) {
                _handleVal |= FLAG_TWO_COLOR;
              }

              let worldMat;

              if (_comp$1.enableBatch) {
                worldMat = _node.worldMatrix;
                _mustFlush = false;
                _handleVal |= FLAG_BATCH;
              }

              if (comp.isAnimationCached()) {
                cacheTraverse(worldMat);
              } else {
                if (_vertexEffect) _vertexEffect.begin(comp._skeleton);
                realTimeTraverse(worldMat);
                if (_vertexEffect) _vertexEffect.end();
              }

              comp.attachUtil._syncAttachedNode();

              _node = undefined;
              _buffer = undefined;
              _comp$1 = undefined;
              _vertexEffect = null;
            }

            function fillVertices(skeletonColor, attachmentColor, slotColor, clipper, slot) {
              let vbuf = _buffer.renderData.vData;
              let ibuf = _buffer.renderData.iData;
              _finalColor$1.a = slotColor.a * attachmentColor.a * skeletonColor.a * _nodeA * 255;
              _multiplier = _premultipliedAlpha ? _finalColor$1.a : 255;
              _tempr$1 = _nodeR * attachmentColor.r * skeletonColor.r * _multiplier;
              _tempg$1 = _nodeG * attachmentColor.g * skeletonColor.g * _multiplier;
              _tempb$1 = _nodeB * attachmentColor.b * skeletonColor.b * _multiplier;
              _finalColor$1.r = _tempr$1 * slotColor.r;
              _finalColor$1.g = _tempg$1 * slotColor.g;
              _finalColor$1.b = _tempb$1 * slotColor.b;

              if (slot.darkColor == null) {
                _darkColor$1.set(0.0, 0.0, 0.0, 1.0);
              } else {
                _darkColor$1.r = slot.darkColor.r * _tempr$1;
                _darkColor$1.g = slot.darkColor.g * _tempg$1;
                _darkColor$1.b = slot.darkColor.b * _tempb$1;
              }

              _darkColor$1.a = _premultipliedAlpha ? 255 : 0;

              if (!clipper.isClipping()) {
                if (_vertexEffect) {
                  for (let v = _vertexFloatOffset, n = _vertexFloatOffset + _vertexFloatCount; v < n; v += _perVertexSize) {
                    _tempPos$2.x = vbuf[v];
                    _tempPos$2.y = vbuf[v + 1];
                    _tempUv.x = vbuf[v + 3];
                    _tempUv.y = vbuf[v + 4];

                    _vertexEffect.transform(_tempPos$2, _tempUv, _finalColor$1, _darkColor$1);

                    vbuf[v] = _tempPos$2.x;
                    vbuf[v + 1] = _tempPos$2.y;
                    vbuf[v + 3] = _tempUv.x;
                    vbuf[v + 4] = _tempUv.y;
                    vbuf.set(_spineColorToFloat32Array4(_finalColor$1), v + 5);

                    if (_useTint) {
                      vbuf.set(_spineColorToFloat32Array4(_darkColor$1), v + 9);
                    }
                  }
                } else {
                  _finalColor32$1.set(_spineColorToFloat32Array4(_finalColor$1));

                  _darkColor32$1.set(_spineColorToFloat32Array4(_darkColor$1));

                  for (let v = _vertexFloatOffset, n = _vertexFloatOffset + _vertexFloatCount; v < n; v += _perVertexSize) {
                    vbuf.set(_finalColor32$1, v + 5);

                    if (_useTint) {
                      vbuf.set(_darkColor32$1, v + 9);
                    }
                  }
                }
              } else {
                _perClipVertexSize = _useTint ? 12 : 8;
                const vertices = vbuf.subarray(_vertexFloatOffset);
                const uvs = vbuf.subarray(_vertexFloatOffset + 3);
                clipper.clipTriangles(vertices, _vertexFloatCount, ibuf.subarray(_indexOffset$1), _indexCount$1, uvs, _finalColor$1, _darkColor$1, _useTint, _perVertexSize);
                const clippedVertices = new Float32Array(clipper.clippedVertices);
                const clippedTriangles = clipper.clippedTriangles;
                _indexCount$1 = clippedTriangles.length;
                _vertexFloatCount = clippedVertices.length / _perClipVertexSize * _perVertexSize;

                _buffer.renderData.reserve(_vertexFloatCount / _perVertexSize, _indexCount$1);

                _indexOffset$1 = _buffer.renderData.indicesCount;
                _vertexOffset = _buffer.renderData.vertexCount;
                _vertexFloatOffset = _buffer.renderData.vDataOffset;
                vbuf = _buffer.renderData.vData;
                ibuf = _buffer.renderData.iData;

                if (clippedTriangles.length > 0) {
                  ibuf.set(clippedTriangles, _indexOffset$1);
                }

                if (_vertexEffect) {
                  for (let v = 0, n = clippedVertices.length, offset = _vertexFloatOffset; v < n; v += _perClipVertexSize, offset += _perVertexSize) {
                    _tempPos$2.x = clippedVertices[v];
                    _tempPos$2.y = clippedVertices[v + 1];

                    _finalColor$1.set(clippedVertices[v + 2], clippedVertices[v + 3], clippedVertices[v + 4], clippedVertices[v + 5]);

                    _tempUv.x = clippedVertices[v + 6];
                    _tempUv.y = clippedVertices[v + 7];

                    if (_useTint) {
                      _darkColor$1.set(clippedVertices[v + 8], clippedVertices[v + 9], clippedVertices[v + 10], clippedVertices[v + 11]);
                    } else {
                      _darkColor$1.set(0, 0, 0, 0);
                    }

                    _vertexEffect.transform(_tempPos$2, _tempUv, _finalColor$1, _darkColor$1);

                    vbuf[offset] = _tempPos$2.x;
                    vbuf[offset + 1] = _tempPos$2.y;
                    vbuf[offset + 3] = _tempUv.x;
                    vbuf[offset + 4] = _tempUv.y;
                    vbuf.set(_spineColorToFloat32Array4(_finalColor$1), offset + 5);

                    if (_useTint) {
                      vbuf.set(_spineColorToFloat32Array4(_darkColor$1), offset + 9);
                    }
                  }
                } else {
                  for (let v = 0, n = clippedVertices.length, offset = _vertexFloatOffset; v < n; v += _perClipVertexSize, offset += _perVertexSize) {
                    vbuf[offset] = clippedVertices[v];
                    vbuf[offset + 1] = clippedVertices[v + 1];
                    vbuf[offset + 3] = clippedVertices[v + 6];
                    vbuf[offset + 4] = clippedVertices[v + 7];
                    vbuf[offset + 5] = clippedVertices[v + 2] / 255.0;
                    vbuf[offset + 6] = clippedVertices[v + 3] / 255.0;
                    vbuf[offset + 7] = clippedVertices[v + 4] / 255.0;
                    vbuf[offset + 8] = clippedVertices[v + 5] / 255.0;

                    if (_useTint) {
                      vbuf[offset + 9] = clippedVertices[v + 8] / 255.0;
                      vbuf[offset + 10] = clippedVertices[v + 9] / 255.0;
                      vbuf[offset + 11] = clippedVertices[v + 10] / 255.0;
                      vbuf[offset + 12] = clippedVertices[v + 11] / 255.0;
                    }
                  }
                }
              }
            }

            function realTimeTraverse(worldMat) {
              let vbuf;
              let ibuf;
              const locSkeleton = _comp$1._skeleton;
              const skeletonColor = locSkeleton.color;
              const graphics = _comp$1._debugRenderer;
              const clipper = _comp$1._clipper;
              let material = null;
              let attachment;
              let uvs;
              let triangles;
              let isRegion;
              let isMesh;
              let isClip;
              let slot;
              _slotRangeStart = _comp$1._startSlotIndex;
              _slotRangeEnd = _comp$1._endSlotIndex;
              _inRange = false;
              if (_slotRangeStart === -1) _inRange = true;
              _debugSlots = _comp$1.debugSlots;
              _debugBones = _comp$1.debugBones;
              _debugMesh = _comp$1.debugMesh;

              if (graphics && (_debugBones || _debugSlots || _debugMesh)) {
                graphics.clear();
                graphics.lineWidth = 5;
              }

              _perClipVertexSize = 12;
              _vertexFloatCount = 0;
              _vertexOffset = 0;
              _vertexFloatOffset = 0;
              _indexCount$1 = 0;
              _indexOffset$1 = 0;

              for (let slotIdx = 0, slotCount = locSkeleton.drawOrder.length; slotIdx < slotCount; slotIdx++) {
                var _buffer2;

                slot = locSkeleton.drawOrder[slotIdx];

                if (slot === undefined) {
                  continue;
                }

                if (_slotRangeStart >= 0 && _slotRangeStart === slot.data.index) {
                  _inRange = true;
                }

                if (!_inRange) {
                  clipper.clipEndWithSlot(slot);
                  continue;
                }

                if (_slotRangeEnd >= 0 && _slotRangeEnd === slot.data.index) {
                  _inRange = false;
                }

                _vertexFloatCount = 0;
                _indexCount$1 = 0;
                attachment = slot.getAttachment();

                if (!attachment) {
                  clipper.clipEndWithSlot(slot);
                  continue;
                }

                isRegion = attachment instanceof spine$1.RegionAttachment;
                isMesh = attachment instanceof spine$1.MeshAttachment;
                isClip = attachment instanceof spine$1.ClippingAttachment;

                if (isClip) {
                  clipper.clipStart(slot, attachment);
                  continue;
                }

                if (!isRegion && !isMesh) {
                  clipper.clipEndWithSlot(slot);
                  continue;
                }

                const texture = attachment.region.texture.getRealTexture();
                material = _getSlotMaterial(slot.data.blendMode);

                if (!material) {
                  clipper.clipEndWithSlot(slot);
                  continue;
                }

                if (!_currentMaterial) _currentMaterial = material;
                if (!((_buffer2 = _buffer) === null || _buffer2 === void 0 ? void 0 : _buffer2.renderData.material)) _buffer.renderData.material = _currentMaterial;

                if (_mustFlush || material.hash !== _currentMaterial.hash || texture && _currentTexture !== texture) {
                  _mustFlush = false;
                  _buffer = _comp$1.requestMeshRenderData(_perVertexSize);
                  _currentMaterial = material;
                  _currentTexture = texture;
                  _buffer.texture = texture;
                  _buffer.renderData.material = _currentMaterial;
                }

                if (isRegion) {
                  triangles = _quadTriangles$1;
                  _vertexFloatCount = 4 * _perVertexSize;
                  _indexCount$1 = 6;

                  _buffer.renderData.reserve(4, 6);

                  _indexOffset$1 = _buffer.renderData.indicesCount;
                  _vertexOffset = _buffer.renderData.vertexCount;
                  _vertexFloatOffset = _buffer.renderData.vDataOffset;
                  vbuf = _buffer.renderData.vData;
                  ibuf = _buffer.renderData.iData;
                  attachment.computeWorldVertices(slot.bone, vbuf, _vertexFloatOffset, _perVertexSize);

                  if (graphics && _debugSlots) {
                    graphics.strokeColor = _slotColor;
                    graphics.moveTo(vbuf[_vertexFloatOffset], vbuf[_vertexFloatOffset + 1]);

                    for (let ii = _vertexFloatOffset + _perVertexSize, nn = _vertexFloatOffset + _vertexFloatCount; ii < nn; ii += _perVertexSize) {
                      graphics.lineTo(vbuf[ii], vbuf[ii + 1]);
                    }

                    graphics.close();
                    graphics.stroke();
                  }
                } else if (isMesh) {
                  const mattachment = attachment;
                  triangles = mattachment.triangles;
                  _vertexFloatCount = (mattachment.worldVerticesLength >> 1) * _perVertexSize;
                  _indexCount$1 = triangles.length;

                  _buffer.renderData.reserve(mattachment.worldVerticesLength >> 1, _indexCount$1);

                  _indexOffset$1 = _buffer.renderData.indicesCount;
                  _vertexOffset = _buffer.renderData.vertexCount;
                  _vertexFloatOffset = _buffer.renderData.vDataOffset;
                  vbuf = _buffer.renderData.vData;
                  ibuf = _buffer.renderData.iData;
                  mattachment.computeWorldVertices(slot, 0, mattachment.worldVerticesLength, vbuf, _vertexFloatOffset, _perVertexSize);

                  if (graphics && _debugMesh) {
                    graphics.strokeColor = _meshColor;

                    for (let ii = 0, nn = triangles.length; ii < nn; ii += 3) {
                      const v1 = triangles[ii] * _perVertexSize + _vertexFloatOffset;
                      const v2 = triangles[ii + 1] * _perVertexSize + _vertexFloatOffset;
                      const v3 = triangles[ii + 2] * _perVertexSize + _vertexFloatOffset;
                      graphics.moveTo(vbuf[v1], vbuf[v1 + 1]);
                      graphics.lineTo(vbuf[v2], vbuf[v2 + 1]);
                      graphics.lineTo(vbuf[v3], vbuf[v3 + 1]);
                      graphics.close();
                      graphics.stroke();
                    }
                  }
                }

                if (_vertexFloatCount === 0 || _indexCount$1 === 0) {
                  clipper.clipEndWithSlot(slot);
                  continue;
                }

                const meshAttachment = attachment;
                ibuf.set(triangles, _indexOffset$1);
                uvs = meshAttachment.uvs;

                for (let v = _vertexFloatOffset, n = _vertexFloatOffset + _vertexFloatCount, u = 0; v < n; v += _perVertexSize, u += 2) {
                  vbuf[v + 3] = uvs[u];
                  vbuf[v + 4] = uvs[u + 1];
                }

                fillVertices(skeletonColor, meshAttachment.color, slot.color, clipper, slot);
                vbuf = _buffer.renderData.vData;
                ibuf = _buffer.renderData.iData;

                if (_indexCount$1 > 0) {
                  for (let ii = _indexOffset$1, nn = _indexOffset$1 + _indexCount$1; ii < nn; ii++) {
                    ibuf[ii] += _vertexOffset;
                  }

                  if (worldMat) {
                    _m00 = worldMat.m00;
                    _m04 = worldMat.m04;
                    _m12 = worldMat.m12;
                    _m01 = worldMat.m01;
                    _m05 = worldMat.m05;
                    _m13 = worldMat.m13;

                    for (let ii = _vertexFloatOffset, nn = _vertexFloatOffset + _vertexFloatCount; ii < nn; ii += _perVertexSize) {
                      _x = vbuf[ii];
                      _y = vbuf[ii + 1];
                      vbuf[ii] = _x * _m00 + _y * _m04 + _m12;
                      vbuf[ii + 1] = _x * _m01 + _y * _m05 + _m13;
                    }
                  }

                  _buffer.renderData.advance(_vertexFloatCount / _perVertexSize, _indexCount$1);
                }

                clipper.clipEndWithSlot(slot);
              }

              clipper.clipEnd();

              if (graphics && _debugBones) {
                let bone;
                graphics.strokeColor = _boneColor;
                graphics.fillColor = _slotColor;

                for (let i = 0, n = locSkeleton.bones.length; i < n; i++) {
                  bone = locSkeleton.bones[i];
                  const x = bone.data.length * bone.a + bone.worldX;
                  const y = bone.data.length * bone.c + bone.worldY;
                  graphics.moveTo(bone.worldX, bone.worldY);
                  graphics.lineTo(x, y);
                  graphics.stroke();
                  graphics.circle(bone.worldX, bone.worldY, Math.PI * 1.5);
                  graphics.fill();

                  if (i === 0) {
                    graphics.fillColor = _originColor;
                  }
                }
              }
            }

            function cacheTraverse(worldMat) {
              const frame = _comp$1._curFrame;
              if (!frame) return;
              const segments = frame.segments;
              if (segments.length === 0) return;
              _perClipVertexSize = 12;
              let vbuf;
              let ibuf;
              let material = null;
              const vertices = frame.vertices;
              const indices = frame.indices;
              let frameVFOffset = 0;
              let frameIndexOffset = 0;
              let segVFCount = 0;

              if (worldMat) {
                _m00 = worldMat.m00;
                _m01 = worldMat.m01;
                _m04 = worldMat.m04;
                _m05 = worldMat.m05;
                _m12 = worldMat.m12;
                _m13 = worldMat.m13;
              }

              const justTranslate = _m00 === 1 && _m01 === 0 && _m04 === 0 && _m05 === 1;
              const needBatch = _handleVal & FLAG_BATCH;
              const calcTranslate = needBatch && justTranslate;
              let colorOffset = 0;
              const colors = frame.colors;
              let nowColor = colors[colorOffset++];
              let maxVFOffset = nowColor.vfOffset;

              _handleColor(nowColor);

              for (let i = 0, n = segments.length; i < n; i++) {
                const segInfo = segments[i];
                material = _getSlotMaterial(segInfo.blendMode);
                if (!material) continue;
                if (!_currentMaterial) _currentMaterial = material;
                if (!_currentTexture) _currentTexture = segInfo.tex;
                if (_buffer.renderData.material) _buffer.renderData.material = _currentMaterial;

                if (_mustFlush || material.hash !== _currentMaterial.hash || segInfo.tex && segInfo.tex !== _currentTexture) {
                  _mustFlush = false;

                  if (!_buffer.texture) {
                    _buffer.texture = segInfo.tex;
                  }

                  _buffer = _comp$1.requestMeshRenderData(_vfmtFloatSize(_useTint));
                  _currentMaterial = material;
                  _currentTexture = segInfo.tex;
                  _buffer.texture = segInfo.tex;
                  _buffer.renderData.material = _currentMaterial;
                }

                _vertexCount = segInfo.vertexCount;
                _indexCount$1 = segInfo.indexCount;

                _buffer.renderData.reserve(_vertexCount, _indexCount$1);

                _indexOffset$1 = _buffer.renderData.indicesCount;
                _vertexOffset = _buffer.renderData.vertexCount;
                _vfOffset$2 = _buffer.renderData.vDataOffset;
                vbuf = _buffer.renderData.vData;
                ibuf = _buffer.renderData.iData;

                for (let ii = _indexOffset$1, il = _indexOffset$1 + _indexCount$1; ii < il; ii++) {
                  ibuf[ii] = _vertexOffset + indices[frameIndexOffset++];
                }

                segVFCount = segInfo.vfCount;
                const subArray = vertices.subarray(frameVFOffset, frameVFOffset + segVFCount);
                frameVFOffset += segVFCount;
                let floatOffset = _vfOffset$2;
                _perVertexSize = _vfmtFloatSize(_useTint);

                for (let ii = 0; ii < subArray.length;) {
                  vbuf[floatOffset + 0] = subArray[ii + 0];
                  vbuf[floatOffset + 1] = subArray[ii + 1];
                  vbuf[floatOffset + 3] = subArray[ii + 3];
                  vbuf[floatOffset + 4] = subArray[ii + 4];
                  vbuf[floatOffset + 5] = subArray[ii + 5];
                  vbuf[floatOffset + 6] = subArray[ii + 6];
                  vbuf[floatOffset + 7] = subArray[ii + 7];
                  vbuf[floatOffset + 8] = subArray[ii + 8];

                  if (_useTint) {
                    vbuf[floatOffset + 9] = subArray[ii + 9];
                    vbuf[floatOffset + 10] = subArray[ii + 10];
                    vbuf[floatOffset + 11] = subArray[ii + 11];
                    vbuf[floatOffset + 12] = subArray[ii + 12];
                  }

                  floatOffset += _perVertexSize;
                  ii += 13;
                }

                if (calcTranslate) {
                  for (let ii = _vfOffset$2, il = _vfOffset$2 + segVFCount; ii < il; ii += _perVertexSize) {
                    vbuf[ii] += _m12;
                    vbuf[ii + 1] += _m13;
                  }
                } else if (needBatch) {
                  for (let ii = _vfOffset$2, il = _vfOffset$2 + segVFCount; ii < il; ii += _perVertexSize) {
                    _x = vbuf[ii];
                    _y = vbuf[ii + 1];
                    vbuf[ii] = _x * _m00 + _y * _m04 + _m12;
                    vbuf[ii + 1] = _x * _m01 + _y * _m05 + _m13;
                  }
                }

                _buffer.renderData.advance(_vertexCount, _indexCount$1);

                if (!_needColor) continue;
                let frameColorOffset = (frameVFOffset - segVFCount) / 13 * 6;

                for (let ii = _vfOffset$2, iEnd = _vfOffset$2 + segVFCount; ii < iEnd; ii += _perVertexSize, frameColorOffset += 6) {
                  if (frameColorOffset >= maxVFOffset) {
                    nowColor = colors[colorOffset++];

                    _handleColor(nowColor);

                    maxVFOffset = nowColor.vfOffset;
                  }

                  vbuf.set(_finalColor32$1, ii + 5);
                  vbuf.set(_darkColor32$1, ii + 9);
                }
              }
            }

            legacyCC.internal.SpineAssembler = simple$2;

            const simpleSpineAssembler = {
              getAssembler() {
                return simple$2;
              }

            };
            Skeleton.Assembler = simpleSpineAssembler;

            const spine$2 = window.spine;
            const VertexEffectDelegate = spine$2.VertexEffectDelegate;
            let ATTACHMENT_TYPE;

            (function (ATTACHMENT_TYPE) {
              ATTACHMENT_TYPE[ATTACHMENT_TYPE["REGION"] = 0] = "REGION";
              ATTACHMENT_TYPE[ATTACHMENT_TYPE["BOUNDING_BOX"] = 1] = "BOUNDING_BOX";
              ATTACHMENT_TYPE[ATTACHMENT_TYPE["MESH"] = 2] = "MESH";
              ATTACHMENT_TYPE[ATTACHMENT_TYPE["SKINNED_MESH"] = 3] = "SKINNED_MESH";
            })(ATTACHMENT_TYPE || (ATTACHMENT_TYPE = {}));

            ccenum(ATTACHMENT_TYPE);
            let AnimationEventType;

            (function (AnimationEventType) {
              AnimationEventType[AnimationEventType["START"] = 0] = "START";
              AnimationEventType[AnimationEventType["INTERRUPT"] = 1] = "INTERRUPT";
              AnimationEventType[AnimationEventType["END"] = 2] = "END";
              AnimationEventType[AnimationEventType["DISPOSE"] = 3] = "DISPOSE";
              AnimationEventType[AnimationEventType["COMPLETE"] = 4] = "COMPLETE";
              AnimationEventType[AnimationEventType["EVENT"] = 5] = "EVENT";
            })(AnimationEventType || (AnimationEventType = {}));

            ccenum(AnimationEventType);
            legacyCC.internal.SpineAnimationEventType = AnimationEventType;

            var index$2 = /*#__PURE__*/Object.freeze({
                __proto__: null,
                timeScale: timeScale,
                get DefaultSkinsEnum () { return DefaultSkinsEnum; },
                get DefaultAnimsEnum () { return DefaultAnimsEnum; },
                get AnimationCacheMode () { return AnimationCacheMode; },
                get SpineMaterialType () { return SpineMaterialType; },
                SpineSocket: SpineSocket,
                Skeleton: Skeleton,
                SkeletonData: SkeletonData,
                simpleSpineAssembler: simpleSpineAssembler,
                spine: spine$2,
                VertexEffectDelegate: VertexEffectDelegate,
                get ATTACHMENT_TYPE () { return ATTACHMENT_TYPE; },
                get AnimationEventType () { return AnimationEventType; }
            });
            exports('sp', index$2);

            var __extends$1=undefined&&undefined.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b)if(b.hasOwnProperty(p))d[p]=b[p];};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();let dragonBones={};(function(dragonBones){})(dragonBones||(dragonBones={}));(function(dragonBones){var DragonBones=function(){function DragonBones(eventManager){this._clock=new dragonBones.WorldClock();this._events=[];this._objects=[];this._eventManager=null;this._eventManager=eventManager;console.info("DragonBones: "+DragonBones.VERSION+"\nWebsite: http://dragonbones.com/\nSource and Demo: https://github.com/DragonBones/");}DragonBones.prototype.advanceTime=function(passedTime){if(this._objects.length>0){for(var _i=0,_a=this._objects;_i<_a.length;_i++){var object=_a[_i];object.returnToPool();}this._objects.length=0;}this._clock.advanceTime(passedTime);if(this._events.length>0){for(var i=0;i<this._events.length;++i){var eventObject=this._events[i];var armature=eventObject.armature;if(armature._armatureData!==null){armature.eventDispatcher.dispatchDBEvent(eventObject.type,eventObject);if(eventObject.type===dragonBones.EventObject.SOUND_EVENT){this._eventManager.dispatchDBEvent(eventObject.type,eventObject);}}this.bufferObject(eventObject);}this._events.length=0;}};DragonBones.prototype.bufferEvent=function(value){if(this._events.indexOf(value)<0){this._events.push(value);}};DragonBones.prototype.bufferObject=function(object){if(this._objects.indexOf(object)<0){this._objects.push(object);}};Object.defineProperty(DragonBones.prototype,"clock",{get:function(){return this._clock;},enumerable:true,configurable:true});Object.defineProperty(DragonBones.prototype,"eventManager",{get:function(){return this._eventManager;},enumerable:true,configurable:true});DragonBones.VERSION="5.6.300";DragonBones.yDown=false;DragonBones.debug=false;DragonBones.debugDraw=false;DragonBones.webAssembly=false;return DragonBones;}();dragonBones.DragonBones=DragonBones;})(dragonBones||(dragonBones={}));if(!console.warn){console.warn=function(){};}if(!console.assert){console.assert=function(){};}if(!Date.now){Date.now=function now(){return new Date().getTime();};}var __extends$1=function(t,e){function r(){this.constructor=t;}for(var i in e){if(e.hasOwnProperty(i)){t[i]=e[i];}}r.prototype=e.prototype,t.prototype=new r();};(function(dragonBones){var BaseObject=function(){function BaseObject(){this.hashCode=BaseObject._hashCode++;this._isInPool=false;}BaseObject._returnObject=function(object){var classType=String(object.constructor);var maxCount=classType in BaseObject._maxCountMap?BaseObject._maxCountMap[classType]:BaseObject._defaultMaxCount;var pool=BaseObject._poolsMap[classType]=BaseObject._poolsMap[classType]||[];if(pool.length<maxCount){if(!object._isInPool){object._isInPool=true;pool.push(object);}else {console.warn("The object is already in the pool.");}}};BaseObject.toString=function(){throw new Error();};BaseObject.setMaxCount=function(objectConstructor,maxCount){if(maxCount<0||maxCount!==maxCount){maxCount=0;}if(objectConstructor!==null){var classType=String(objectConstructor);var pool=classType in BaseObject._poolsMap?BaseObject._poolsMap[classType]:null;if(pool!==null&&pool.length>maxCount){pool.length=maxCount;}BaseObject._maxCountMap[classType]=maxCount;}else {BaseObject._defaultMaxCount=maxCount;for(var classType in BaseObject._poolsMap){var pool=BaseObject._poolsMap[classType];if(pool.length>maxCount){pool.length=maxCount;}if(classType in BaseObject._maxCountMap){BaseObject._maxCountMap[classType]=maxCount;}}}};BaseObject.clearPool=function(objectConstructor){if(objectConstructor===void 0){objectConstructor=null;}if(objectConstructor!==null){var classType=String(objectConstructor);var pool=classType in BaseObject._poolsMap?BaseObject._poolsMap[classType]:null;if(pool!==null&&pool.length>0){pool.length=0;}}else {for(var k in BaseObject._poolsMap){var pool=BaseObject._poolsMap[k];pool.length=0;}}};BaseObject.borrowObject=function(objectConstructor){var classType=String(objectConstructor);var pool=classType in BaseObject._poolsMap?BaseObject._poolsMap[classType]:null;if(pool!==null&&pool.length>0){var object_1=pool.pop();object_1._isInPool=false;return object_1;}var object=new objectConstructor();object._onClear();return object;};BaseObject.prototype.returnToPool=function(){this._onClear();BaseObject._returnObject(this);};BaseObject._hashCode=0;BaseObject._defaultMaxCount=3000;BaseObject._maxCountMap={};BaseObject._poolsMap={};return BaseObject;}();dragonBones.BaseObject=BaseObject;})(dragonBones||(dragonBones={}));(function(dragonBones){var Matrix=function(){function Matrix(a,b,c,d,tx,ty){if(a===void 0){a=1.0;}if(b===void 0){b=0.0;}if(c===void 0){c=0.0;}if(d===void 0){d=1.0;}if(tx===void 0){tx=0.0;}if(ty===void 0){ty=0.0;}this.a=a;this.b=b;this.c=c;this.d=d;this.tx=tx;this.ty=ty;}Matrix.prototype.toString=function(){return "[object dragonBones.Matrix] a:"+this.a+" b:"+this.b+" c:"+this.c+" d:"+this.d+" tx:"+this.tx+" ty:"+this.ty;};Matrix.prototype.copyFrom=function(value){this.a=value.a;this.b=value.b;this.c=value.c;this.d=value.d;this.tx=value.tx;this.ty=value.ty;return this;};Matrix.prototype.copyFromArray=function(value,offset){if(offset===void 0){offset=0;}this.a=value[offset];this.b=value[offset+1];this.c=value[offset+2];this.d=value[offset+3];this.tx=value[offset+4];this.ty=value[offset+5];return this;};Matrix.prototype.identity=function(){this.a=this.d=1.0;this.b=this.c=0.0;this.tx=this.ty=0.0;return this;};Matrix.prototype.concat=function(value){var aA=this.a*value.a;var bA=0.0;var cA=0.0;var dA=this.d*value.d;var txA=this.tx*value.a+value.tx;var tyA=this.ty*value.d+value.ty;if(this.b!==0.0||this.c!==0.0){aA+=this.b*value.c;bA+=this.b*value.d;cA+=this.c*value.a;dA+=this.c*value.b;}if(value.b!==0.0||value.c!==0.0){bA+=this.a*value.b;cA+=this.d*value.c;txA+=this.ty*value.c;tyA+=this.tx*value.b;}this.a=aA;this.b=bA;this.c=cA;this.d=dA;this.tx=txA;this.ty=tyA;return this;};Matrix.prototype.invert=function(){var aA=this.a;var bA=this.b;var cA=this.c;var dA=this.d;var txA=this.tx;var tyA=this.ty;if(bA===0.0&&cA===0.0){this.b=this.c=0.0;if(aA===0.0||dA===0.0){this.a=this.b=this.tx=this.ty=0.0;}else {aA=this.a=1.0/aA;dA=this.d=1.0/dA;this.tx=-aA*txA;this.ty=-dA*tyA;}return this;}var determinant=aA*dA-bA*cA;if(determinant===0.0){this.a=this.d=1.0;this.b=this.c=0.0;this.tx=this.ty=0.0;return this;}determinant=1.0/determinant;var k=this.a=dA*determinant;bA=this.b=-bA*determinant;cA=this.c=-cA*determinant;dA=this.d=aA*determinant;this.tx=-(k*txA+cA*tyA);this.ty=-(bA*txA+dA*tyA);return this;};Matrix.prototype.transformPoint=function(x,y,result,delta){if(delta===void 0){delta=false;}result.x=this.a*x+this.c*y;result.y=this.b*x+this.d*y;if(!delta){result.x+=this.tx;result.y+=this.ty;}};Matrix.prototype.transformRectangle=function(rectangle,delta){if(delta===void 0){delta=false;}var a=this.a;var b=this.b;var c=this.c;var d=this.d;var tx=delta?0.0:this.tx;var ty=delta?0.0:this.ty;var x=rectangle.x;var y=rectangle.y;var xMax=x+rectangle.width;var yMax=y+rectangle.height;var x0=a*x+c*y+tx;var y0=b*x+d*y+ty;var x1=a*xMax+c*y+tx;var y1=b*xMax+d*y+ty;var x2=a*xMax+c*yMax+tx;var y2=b*xMax+d*yMax+ty;var x3=a*x+c*yMax+tx;var y3=b*x+d*yMax+ty;var tmp=0.0;if(x0>x1){tmp=x0;x0=x1;x1=tmp;}if(x2>x3){tmp=x2;x2=x3;x3=tmp;}rectangle.x=Math.floor(x0<x2?x0:x2);rectangle.width=Math.ceil((x1>x3?x1:x3)-rectangle.x);if(y0>y1){tmp=y0;y0=y1;y1=tmp;}if(y2>y3){tmp=y2;y2=y3;y3=tmp;}rectangle.y=Math.floor(y0<y2?y0:y2);rectangle.height=Math.ceil((y1>y3?y1:y3)-rectangle.y);};return Matrix;}();dragonBones.Matrix=Matrix;})(dragonBones||(dragonBones={}));(function(dragonBones){var Transform=function(){function Transform(x,y,skew,rotation,scaleX,scaleY){if(x===void 0){x=0.0;}if(y===void 0){y=0.0;}if(skew===void 0){skew=0.0;}if(rotation===void 0){rotation=0.0;}if(scaleX===void 0){scaleX=1.0;}if(scaleY===void 0){scaleY=1.0;}this.x=x;this.y=y;this.skew=skew;this.rotation=rotation;this.scaleX=scaleX;this.scaleY=scaleY;}Transform.normalizeRadian=function(value){value=(value+Math.PI)%(Math.PI*2.0);value+=value>0.0?-Math.PI:Math.PI;return value;};Transform.prototype.toString=function(){return "[object dragonBones.Transform] x:"+this.x+" y:"+this.y+" skewX:"+this.skew*180.0/Math.PI+" skewY:"+this.rotation*180.0/Math.PI+" scaleX:"+this.scaleX+" scaleY:"+this.scaleY;};Transform.prototype.copyFrom=function(value){this.x=value.x;this.y=value.y;this.skew=value.skew;this.rotation=value.rotation;this.scaleX=value.scaleX;this.scaleY=value.scaleY;return this;};Transform.prototype.identity=function(){this.x=this.y=0.0;this.skew=this.rotation=0.0;this.scaleX=this.scaleY=1.0;return this;};Transform.prototype.add=function(value){this.x+=value.x;this.y+=value.y;this.skew+=value.skew;this.rotation+=value.rotation;this.scaleX*=value.scaleX;this.scaleY*=value.scaleY;return this;};Transform.prototype.minus=function(value){this.x-=value.x;this.y-=value.y;this.skew-=value.skew;this.rotation-=value.rotation;this.scaleX/=value.scaleX;this.scaleY/=value.scaleY;return this;};Transform.prototype.fromMatrix=function(matrix){var backupScaleX=this.scaleX,backupScaleY=this.scaleY;var PI_Q=Transform.PI_Q;this.x=matrix.tx;this.y=matrix.ty;this.rotation=Math.atan(matrix.b/matrix.a);var skewX=Math.atan(-matrix.c/matrix.d);this.scaleX=this.rotation>-PI_Q&&this.rotation<PI_Q?matrix.a/Math.cos(this.rotation):matrix.b/Math.sin(this.rotation);this.scaleY=skewX>-PI_Q&&skewX<PI_Q?matrix.d/Math.cos(skewX):-matrix.c/Math.sin(skewX);if(backupScaleX>=0.0&&this.scaleX<0.0){this.scaleX=-this.scaleX;this.rotation=this.rotation-Math.PI;}if(backupScaleY>=0.0&&this.scaleY<0.0){this.scaleY=-this.scaleY;skewX=skewX-Math.PI;}this.skew=skewX-this.rotation;return this;};Transform.prototype.toMatrix=function(matrix){if(this.rotation===0.0){matrix.a=1.0;matrix.b=0.0;}else {matrix.a=Math.cos(this.rotation);matrix.b=Math.sin(this.rotation);}if(this.skew===0.0){matrix.c=-matrix.b;matrix.d=matrix.a;}else {matrix.c=-Math.sin(this.skew+this.rotation);matrix.d=Math.cos(this.skew+this.rotation);}if(this.scaleX!==1.0){matrix.a*=this.scaleX;matrix.b*=this.scaleX;}if(this.scaleY!==1.0){matrix.c*=this.scaleY;matrix.d*=this.scaleY;}matrix.tx=this.x;matrix.ty=this.y;return this;};Transform.PI=Math.PI;Transform.PI_D=Math.PI*2.0;Transform.PI_H=Math.PI/2.0;Transform.PI_Q=Math.PI/4.0;Transform.RAD_DEG=180.0/Math.PI;Transform.DEG_RAD=Math.PI/180.0;return Transform;}();dragonBones.Transform=Transform;})(dragonBones||(dragonBones={}));(function(dragonBones){var ColorTransform=function(){function ColorTransform(alphaMultiplier,redMultiplier,greenMultiplier,blueMultiplier,alphaOffset,redOffset,greenOffset,blueOffset){if(alphaMultiplier===void 0){alphaMultiplier=1.0;}if(redMultiplier===void 0){redMultiplier=1.0;}if(greenMultiplier===void 0){greenMultiplier=1.0;}if(blueMultiplier===void 0){blueMultiplier=1.0;}if(alphaOffset===void 0){alphaOffset=0;}if(redOffset===void 0){redOffset=0;}if(greenOffset===void 0){greenOffset=0;}if(blueOffset===void 0){blueOffset=0;}this.alphaMultiplier=alphaMultiplier;this.redMultiplier=redMultiplier;this.greenMultiplier=greenMultiplier;this.blueMultiplier=blueMultiplier;this.alphaOffset=alphaOffset;this.redOffset=redOffset;this.greenOffset=greenOffset;this.blueOffset=blueOffset;}ColorTransform.prototype.copyFrom=function(value){this.alphaMultiplier=value.alphaMultiplier;this.redMultiplier=value.redMultiplier;this.greenMultiplier=value.greenMultiplier;this.blueMultiplier=value.blueMultiplier;this.alphaOffset=value.alphaOffset;this.redOffset=value.redOffset;this.greenOffset=value.greenOffset;this.blueOffset=value.blueOffset;};ColorTransform.prototype.identity=function(){this.alphaMultiplier=this.redMultiplier=this.greenMultiplier=this.blueMultiplier=1.0;this.alphaOffset=this.redOffset=this.greenOffset=this.blueOffset=0;};return ColorTransform;}();dragonBones.ColorTransform=ColorTransform;})(dragonBones||(dragonBones={}));(function(dragonBones){var Point=function(){function Point(x,y){if(x===void 0){x=0.0;}if(y===void 0){y=0.0;}this.x=x;this.y=y;}Point.prototype.copyFrom=function(value){this.x=value.x;this.y=value.y;};Point.prototype.clear=function(){this.x=this.y=0.0;};return Point;}();dragonBones.Point=Point;})(dragonBones||(dragonBones={}));(function(dragonBones){var Rectangle=function(){function Rectangle(x,y,width,height){if(x===void 0){x=0.0;}if(y===void 0){y=0.0;}if(width===void 0){width=0.0;}if(height===void 0){height=0.0;}this.x=x;this.y=y;this.width=width;this.height=height;}Rectangle.prototype.copyFrom=function(value){this.x=value.x;this.y=value.y;this.width=value.width;this.height=value.height;};Rectangle.prototype.clear=function(){this.x=this.y=0.0;this.width=this.height=0.0;};return Rectangle;}();dragonBones.Rectangle=Rectangle;})(dragonBones||(dragonBones={}));(function(dragonBones){var UserData=function(_super){__extends$1(UserData,_super);function UserData(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.ints=[];_this.floats=[];_this.strings=[];return _this;}UserData.toString=function(){return "[class dragonBones.UserData]";};UserData.prototype._onClear=function(){this.ints.length=0;this.floats.length=0;this.strings.length=0;};UserData.prototype.addInt=function(value){this.ints.push(value);};UserData.prototype.addFloat=function(value){this.floats.push(value);};UserData.prototype.addString=function(value){this.strings.push(value);};UserData.prototype.getInt=function(index){if(index===void 0){index=0;}return index>=0&&index<this.ints.length?this.ints[index]:0;};UserData.prototype.getFloat=function(index){if(index===void 0){index=0;}return index>=0&&index<this.floats.length?this.floats[index]:0.0;};UserData.prototype.getString=function(index){if(index===void 0){index=0;}return index>=0&&index<this.strings.length?this.strings[index]:"";};return UserData;}(dragonBones.BaseObject);dragonBones.UserData=UserData;var ActionData=function(_super){__extends$1(ActionData,_super);function ActionData(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.data=null;return _this;}ActionData.toString=function(){return "[class dragonBones.ActionData]";};ActionData.prototype._onClear=function(){if(this.data!==null){this.data.returnToPool();}this.type=0;this.name="";this.bone=null;this.slot=null;this.data=null;};return ActionData;}(dragonBones.BaseObject);dragonBones.ActionData=ActionData;})(dragonBones||(dragonBones={}));(function(dragonBones){var DragonBonesData=function(_super){__extends$1(DragonBonesData,_super);function DragonBonesData(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.frameIndices=[];_this.cachedFrames=[];_this.armatureNames=[];_this.armatures={};_this.userData=null;return _this;}DragonBonesData.toString=function(){return "[class dragonBones.DragonBonesData]";};DragonBonesData.prototype._onClear=function(){for(var k in this.armatures){this.armatures[k].returnToPool();delete this.armatures[k];}if(this.userData!==null){this.userData.returnToPool();}this.autoSearch=false;this.frameRate=0;this.version="";this.name="";this.stage=null;this.frameIndices.length=0;this.cachedFrames.length=0;this.armatureNames.length=0;this.binary=null;this.intArray=null;this.floatArray=null;this.frameIntArray=null;this.frameFloatArray=null;this.frameArray=null;this.timelineArray=null;this.userData=null;};DragonBonesData.prototype.addArmature=function(value){if(value.name in this.armatures){console.warn("Same armature: "+value.name);return;}value.parent=this;this.armatures[value.name]=value;this.armatureNames.push(value.name);};DragonBonesData.prototype.getArmature=function(armatureName){return armatureName in this.armatures?this.armatures[armatureName]:null;};DragonBonesData.prototype.dispose=function(){console.warn("");this.returnToPool();};return DragonBonesData;}(dragonBones.BaseObject);dragonBones.DragonBonesData=DragonBonesData;})(dragonBones||(dragonBones={}));(function(dragonBones){var ArmatureData=function(_super){__extends$1(ArmatureData,_super);function ArmatureData(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.aabb=new dragonBones.Rectangle();_this.animationNames=[];_this.sortedBones=[];_this.sortedSlots=[];_this.defaultActions=[];_this.actions=[];_this.bones={};_this.slots={};_this.constraints={};_this.skins={};_this.animations={};_this.canvas=null;_this.userData=null;return _this;}ArmatureData.toString=function(){return "[class dragonBones.ArmatureData]";};ArmatureData.prototype._onClear=function(){for(var _i=0,_a=this.defaultActions;_i<_a.length;_i++){var action=_a[_i];action.returnToPool();}for(var _b=0,_c=this.actions;_b<_c.length;_b++){var action=_c[_b];action.returnToPool();}for(var k in this.bones){this.bones[k].returnToPool();delete this.bones[k];}for(var k in this.slots){this.slots[k].returnToPool();delete this.slots[k];}for(var k in this.constraints){this.constraints[k].returnToPool();delete this.constraints[k];}for(var k in this.skins){this.skins[k].returnToPool();delete this.skins[k];}for(var k in this.animations){this.animations[k].returnToPool();delete this.animations[k];}if(this.canvas!==null){this.canvas.returnToPool();}if(this.userData!==null){this.userData.returnToPool();}this.type=0;this.frameRate=0;this.cacheFrameRate=0;this.scale=1.0;this.name="";this.aabb.clear();this.animationNames.length=0;this.sortedBones.length=0;this.sortedSlots.length=0;this.defaultActions.length=0;this.actions.length=0;this.defaultSkin=null;this.defaultAnimation=null;this.canvas=null;this.userData=null;this.parent=null;};ArmatureData.prototype.sortBones=function(){var total=this.sortedBones.length;if(total<=0){return;}var sortHelper=this.sortedBones.concat();var index=0;var count=0;this.sortedBones.length=0;while(count<total){var bone=sortHelper[index++];if(index>=total){index=0;}if(this.sortedBones.indexOf(bone)>=0){continue;}var flag=false;for(var k in this.constraints){var constraint=this.constraints[k];if(constraint.root===bone&&this.sortedBones.indexOf(constraint.target)<0){flag=true;break;}}if(flag){continue;}if(bone.parent!==null&&this.sortedBones.indexOf(bone.parent)<0){continue;}this.sortedBones.push(bone);count++;}};ArmatureData.prototype.cacheFrames=function(frameRate){if(this.cacheFrameRate>0){return;}this.cacheFrameRate=frameRate;for(var k in this.animations){this.animations[k].cacheFrames(this.cacheFrameRate);}};ArmatureData.prototype.setCacheFrame=function(globalTransformMatrix,transform){var dataArray=this.parent.cachedFrames;var arrayOffset=dataArray.length;dataArray.length+=10;dataArray[arrayOffset]=globalTransformMatrix.a;dataArray[arrayOffset+1]=globalTransformMatrix.b;dataArray[arrayOffset+2]=globalTransformMatrix.c;dataArray[arrayOffset+3]=globalTransformMatrix.d;dataArray[arrayOffset+4]=globalTransformMatrix.tx;dataArray[arrayOffset+5]=globalTransformMatrix.ty;dataArray[arrayOffset+6]=transform.rotation;dataArray[arrayOffset+7]=transform.skew;dataArray[arrayOffset+8]=transform.scaleX;dataArray[arrayOffset+9]=transform.scaleY;return arrayOffset;};ArmatureData.prototype.getCacheFrame=function(globalTransformMatrix,transform,arrayOffset){var dataArray=this.parent.cachedFrames;globalTransformMatrix.a=dataArray[arrayOffset];globalTransformMatrix.b=dataArray[arrayOffset+1];globalTransformMatrix.c=dataArray[arrayOffset+2];globalTransformMatrix.d=dataArray[arrayOffset+3];globalTransformMatrix.tx=dataArray[arrayOffset+4];globalTransformMatrix.ty=dataArray[arrayOffset+5];transform.rotation=dataArray[arrayOffset+6];transform.skew=dataArray[arrayOffset+7];transform.scaleX=dataArray[arrayOffset+8];transform.scaleY=dataArray[arrayOffset+9];transform.x=globalTransformMatrix.tx;transform.y=globalTransformMatrix.ty;};ArmatureData.prototype.addBone=function(value){if(value.name in this.bones){console.warn("Same bone: "+value.name);return;}this.bones[value.name]=value;this.sortedBones.push(value);};ArmatureData.prototype.addSlot=function(value){if(value.name in this.slots){console.warn("Same slot: "+value.name);return;}this.slots[value.name]=value;this.sortedSlots.push(value);};ArmatureData.prototype.addConstraint=function(value){if(value.name in this.constraints){console.warn("Same constraint: "+value.name);return;}this.constraints[value.name]=value;};ArmatureData.prototype.addSkin=function(value){if(value.name in this.skins){console.warn("Same skin: "+value.name);return;}value.parent=this;this.skins[value.name]=value;if(this.defaultSkin===null){this.defaultSkin=value;}if(value.name==="default"){this.defaultSkin=value;}};ArmatureData.prototype.addAnimation=function(value){if(value.name in this.animations){console.warn("Same animation: "+value.name);return;}value.parent=this;this.animations[value.name]=value;this.animationNames.push(value.name);if(this.defaultAnimation===null){this.defaultAnimation=value;}};ArmatureData.prototype.addAction=function(value,isDefault){if(isDefault){this.defaultActions.push(value);}else {this.actions.push(value);}};ArmatureData.prototype.getBone=function(boneName){return boneName in this.bones?this.bones[boneName]:null;};ArmatureData.prototype.getSlot=function(slotName){return slotName in this.slots?this.slots[slotName]:null;};ArmatureData.prototype.getConstraint=function(constraintName){return constraintName in this.constraints?this.constraints[constraintName]:null;};ArmatureData.prototype.getSkin=function(skinName){return skinName in this.skins?this.skins[skinName]:null;};ArmatureData.prototype.getMesh=function(skinName,slotName,meshName){var skin=this.getSkin(skinName);if(skin===null){return null;}return skin.getDisplay(slotName,meshName);};ArmatureData.prototype.getAnimation=function(animationName){return animationName in this.animations?this.animations[animationName]:null;};return ArmatureData;}(dragonBones.BaseObject);dragonBones.ArmatureData=ArmatureData;var BoneData=function(_super){__extends$1(BoneData,_super);function BoneData(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.transform=new dragonBones.Transform();_this.userData=null;return _this;}BoneData.toString=function(){return "[class dragonBones.BoneData]";};BoneData.prototype._onClear=function(){if(this.userData!==null){this.userData.returnToPool();}this.inheritTranslation=false;this.inheritRotation=false;this.inheritScale=false;this.inheritReflection=false;this.type=0;this.length=0.0;this.name="";this.transform.identity();this.userData=null;this.parent=null;};return BoneData;}(dragonBones.BaseObject);dragonBones.BoneData=BoneData;var SurfaceData=function(_super){__extends$1(SurfaceData,_super);function SurfaceData(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.vertices=[];return _this;}SurfaceData.toString=function(){return "[class dragonBones.SurfaceData]";};SurfaceData.prototype._onClear=function(){_super.prototype._onClear.call(this);this.type=1;this.segmentX=0;this.segmentY=0;this.vertices.length=0;};return SurfaceData;}(BoneData);dragonBones.SurfaceData=SurfaceData;var SlotData=function(_super){__extends$1(SlotData,_super);function SlotData(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.color=null;_this.userData=null;return _this;}SlotData.createColor=function(){return new dragonBones.ColorTransform();};SlotData.toString=function(){return "[class dragonBones.SlotData]";};SlotData.prototype._onClear=function(){if(this.userData!==null){this.userData.returnToPool();}this.blendMode=0;this.displayIndex=0;this.zOrder=0;this.name="";this.color=null;this.userData=null;this.parent=null;};SlotData.DEFAULT_COLOR=new dragonBones.ColorTransform();return SlotData;}(dragonBones.BaseObject);dragonBones.SlotData=SlotData;})(dragonBones||(dragonBones={}));(function(dragonBones){var ConstraintData=function(_super){__extends$1(ConstraintData,_super);function ConstraintData(){return _super!==null&&_super.apply(this,arguments)||this;}ConstraintData.prototype._onClear=function(){this.order=0;this.name="";this.type=0;this.target=null;this.root=null;this.bone=null;};return ConstraintData;}(dragonBones.BaseObject);dragonBones.ConstraintData=ConstraintData;var IKConstraintData=function(_super){__extends$1(IKConstraintData,_super);function IKConstraintData(){return _super!==null&&_super.apply(this,arguments)||this;}IKConstraintData.toString=function(){return "[class dragonBones.IKConstraintData]";};IKConstraintData.prototype._onClear=function(){_super.prototype._onClear.call(this);this.scaleEnabled=false;this.bendPositive=false;this.weight=1.0;};return IKConstraintData;}(ConstraintData);dragonBones.IKConstraintData=IKConstraintData;var PathConstraintData=function(_super){__extends$1(PathConstraintData,_super);function PathConstraintData(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.bones=[];return _this;}PathConstraintData.toString=function(){return "[class dragonBones.PathConstraintData]";};PathConstraintData.prototype._onClear=function(){_super.prototype._onClear.call(this);this.pathSlot=null;this.pathDisplayData=null;this.bones.length=0;this.positionMode=0;this.spacingMode=1;this.rotateMode=1;this.position=0.0;this.spacing=0.0;this.rotateOffset=0.0;this.rotateMix=0.0;this.translateMix=0.0;};PathConstraintData.prototype.AddBone=function(value){this.bones.push(value);};return PathConstraintData;}(ConstraintData);dragonBones.PathConstraintData=PathConstraintData;})(dragonBones||(dragonBones={}));(function(dragonBones){var CanvasData=function(_super){__extends$1(CanvasData,_super);function CanvasData(){return _super!==null&&_super.apply(this,arguments)||this;}CanvasData.toString=function(){return "[class dragonBones.CanvasData]";};CanvasData.prototype._onClear=function(){this.hasBackground=false;this.color=0x000000;this.x=0;this.y=0;this.width=0;this.height=0;};return CanvasData;}(dragonBones.BaseObject);dragonBones.CanvasData=CanvasData;})(dragonBones||(dragonBones={}));(function(dragonBones){var SkinData=function(_super){__extends$1(SkinData,_super);function SkinData(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.displays={};return _this;}SkinData.toString=function(){return "[class dragonBones.SkinData]";};SkinData.prototype._onClear=function(){for(var k in this.displays){var slotDisplays=this.displays[k];for(var _i=0,slotDisplays_1=slotDisplays;_i<slotDisplays_1.length;_i++){var display=slotDisplays_1[_i];if(display!==null){display.returnToPool();}}delete this.displays[k];}this.name="";this.parent=null;};SkinData.prototype.addDisplay=function(slotName,value){if(!(slotName in this.displays)){this.displays[slotName]=[];}if(value!==null){value.parent=this;}var slotDisplays=this.displays[slotName];slotDisplays.push(value);};SkinData.prototype.getDisplay=function(slotName,displayName){var slotDisplays=this.getDisplays(slotName);if(slotDisplays!==null){for(var _i=0,slotDisplays_2=slotDisplays;_i<slotDisplays_2.length;_i++){var display=slotDisplays_2[_i];if(display!==null&&display.name===displayName){return display;}}}return null;};SkinData.prototype.getDisplays=function(slotName){if(!(slotName in this.displays)){return null;}return this.displays[slotName];};return SkinData;}(dragonBones.BaseObject);dragonBones.SkinData=SkinData;})(dragonBones||(dragonBones={}));(function(dragonBones){var VerticesData=function(){function VerticesData(){this.weight=null;}VerticesData.prototype.clear=function(){if(!this.isShared&&this.weight!==null){this.weight.returnToPool();}this.isShared=false;this.inheritDeform=false;this.offset=0;this.data=null;this.weight=null;};VerticesData.prototype.shareFrom=function(value){this.isShared=true;this.offset=value.offset;this.weight=value.weight;};return VerticesData;}();dragonBones.VerticesData=VerticesData;var DisplayData=function(_super){__extends$1(DisplayData,_super);function DisplayData(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.transform=new dragonBones.Transform();return _this;}DisplayData.prototype._onClear=function(){this.name="";this.path="";this.transform.identity();this.parent=null;};return DisplayData;}(dragonBones.BaseObject);dragonBones.DisplayData=DisplayData;var ImageDisplayData=function(_super){__extends$1(ImageDisplayData,_super);function ImageDisplayData(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.pivot=new dragonBones.Point();return _this;}ImageDisplayData.toString=function(){return "[class dragonBones.ImageDisplayData]";};ImageDisplayData.prototype._onClear=function(){_super.prototype._onClear.call(this);this.type=0;this.pivot.clear();this.texture=null;};return ImageDisplayData;}(DisplayData);dragonBones.ImageDisplayData=ImageDisplayData;var ArmatureDisplayData=function(_super){__extends$1(ArmatureDisplayData,_super);function ArmatureDisplayData(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.actions=[];return _this;}ArmatureDisplayData.toString=function(){return "[class dragonBones.ArmatureDisplayData]";};ArmatureDisplayData.prototype._onClear=function(){_super.prototype._onClear.call(this);for(var _i=0,_a=this.actions;_i<_a.length;_i++){var action=_a[_i];action.returnToPool();}this.type=1;this.inheritAnimation=false;this.actions.length=0;this.armature=null;};ArmatureDisplayData.prototype.addAction=function(value){this.actions.push(value);};return ArmatureDisplayData;}(DisplayData);dragonBones.ArmatureDisplayData=ArmatureDisplayData;var MeshDisplayData=function(_super){__extends$1(MeshDisplayData,_super);function MeshDisplayData(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.vertices=new VerticesData();return _this;}MeshDisplayData.toString=function(){return "[class dragonBones.MeshDisplayData]";};MeshDisplayData.prototype._onClear=function(){_super.prototype._onClear.call(this);this.type=2;this.vertices.clear();this.texture=null;};return MeshDisplayData;}(DisplayData);dragonBones.MeshDisplayData=MeshDisplayData;var BoundingBoxDisplayData=function(_super){__extends$1(BoundingBoxDisplayData,_super);function BoundingBoxDisplayData(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.boundingBox=null;return _this;}BoundingBoxDisplayData.toString=function(){return "[class dragonBones.BoundingBoxDisplayData]";};BoundingBoxDisplayData.prototype._onClear=function(){_super.prototype._onClear.call(this);if(this.boundingBox!==null){this.boundingBox.returnToPool();}this.type=3;this.boundingBox=null;};return BoundingBoxDisplayData;}(DisplayData);dragonBones.BoundingBoxDisplayData=BoundingBoxDisplayData;var PathDisplayData=function(_super){__extends$1(PathDisplayData,_super);function PathDisplayData(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.vertices=new VerticesData();_this.curveLengths=[];return _this;}PathDisplayData.toString=function(){return "[class dragonBones.PathDisplayData]";};PathDisplayData.prototype._onClear=function(){_super.prototype._onClear.call(this);this.type=4;this.closed=false;this.constantSpeed=false;this.vertices.clear();this.curveLengths.length=0;};return PathDisplayData;}(DisplayData);dragonBones.PathDisplayData=PathDisplayData;var WeightData=function(_super){__extends$1(WeightData,_super);function WeightData(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.bones=[];return _this;}WeightData.toString=function(){return "[class dragonBones.WeightData]";};WeightData.prototype._onClear=function(){this.count=0;this.offset=0;this.bones.length=0;};WeightData.prototype.addBone=function(value){this.bones.push(value);};return WeightData;}(dragonBones.BaseObject);dragonBones.WeightData=WeightData;})(dragonBones||(dragonBones={}));(function(dragonBones){var BoundingBoxData=function(_super){__extends$1(BoundingBoxData,_super);function BoundingBoxData(){return _super!==null&&_super.apply(this,arguments)||this;}BoundingBoxData.prototype._onClear=function(){this.color=0x000000;this.width=0.0;this.height=0.0;};return BoundingBoxData;}(dragonBones.BaseObject);dragonBones.BoundingBoxData=BoundingBoxData;var RectangleBoundingBoxData=function(_super){__extends$1(RectangleBoundingBoxData,_super);function RectangleBoundingBoxData(){return _super!==null&&_super.apply(this,arguments)||this;}RectangleBoundingBoxData.toString=function(){return "[class dragonBones.RectangleBoundingBoxData]";};RectangleBoundingBoxData._computeOutCode=function(x,y,xMin,yMin,xMax,yMax){var code=0;if(x<xMin){code|=1;}else if(x>xMax){code|=2;}if(y<yMin){code|=4;}else if(y>yMax){code|=8;}return code;};RectangleBoundingBoxData.rectangleIntersectsSegment=function(xA,yA,xB,yB,xMin,yMin,xMax,yMax,intersectionPointA,intersectionPointB,normalRadians){if(intersectionPointA===void 0){intersectionPointA=null;}if(intersectionPointB===void 0){intersectionPointB=null;}if(normalRadians===void 0){normalRadians=null;}var inSideA=xA>xMin&&xA<xMax&&yA>yMin&&yA<yMax;var inSideB=xB>xMin&&xB<xMax&&yB>yMin&&yB<yMax;if(inSideA&&inSideB){return -1;}var intersectionCount=0;var outcode0=RectangleBoundingBoxData._computeOutCode(xA,yA,xMin,yMin,xMax,yMax);var outcode1=RectangleBoundingBoxData._computeOutCode(xB,yB,xMin,yMin,xMax,yMax);while(true){if((outcode0|outcode1)===0){intersectionCount=2;break;}else if((outcode0&outcode1)!==0){break;}var x=0.0;var y=0.0;var normalRadian=0.0;var outcodeOut=outcode0!==0?outcode0:outcode1;if((outcodeOut&4)!==0){x=xA+(xB-xA)*(yMin-yA)/(yB-yA);y=yMin;if(normalRadians!==null){normalRadian=-Math.PI*0.5;}}else if((outcodeOut&8)!==0){x=xA+(xB-xA)*(yMax-yA)/(yB-yA);y=yMax;if(normalRadians!==null){normalRadian=Math.PI*0.5;}}else if((outcodeOut&2)!==0){y=yA+(yB-yA)*(xMax-xA)/(xB-xA);x=xMax;if(normalRadians!==null){normalRadian=0;}}else if((outcodeOut&1)!==0){y=yA+(yB-yA)*(xMin-xA)/(xB-xA);x=xMin;if(normalRadians!==null){normalRadian=Math.PI;}}if(outcodeOut===outcode0){xA=x;yA=y;outcode0=RectangleBoundingBoxData._computeOutCode(xA,yA,xMin,yMin,xMax,yMax);if(normalRadians!==null){normalRadians.x=normalRadian;}}else {xB=x;yB=y;outcode1=RectangleBoundingBoxData._computeOutCode(xB,yB,xMin,yMin,xMax,yMax);if(normalRadians!==null){normalRadians.y=normalRadian;}}}if(intersectionCount){if(inSideA){intersectionCount=2;if(intersectionPointA!==null){intersectionPointA.x=xB;intersectionPointA.y=yB;}if(intersectionPointB!==null){intersectionPointB.x=xB;intersectionPointB.y=xB;}if(normalRadians!==null){normalRadians.x=normalRadians.y+Math.PI;}}else if(inSideB){intersectionCount=1;if(intersectionPointA!==null){intersectionPointA.x=xA;intersectionPointA.y=yA;}if(intersectionPointB!==null){intersectionPointB.x=xA;intersectionPointB.y=yA;}if(normalRadians!==null){normalRadians.y=normalRadians.x+Math.PI;}}else {intersectionCount=3;if(intersectionPointA!==null){intersectionPointA.x=xA;intersectionPointA.y=yA;}if(intersectionPointB!==null){intersectionPointB.x=xB;intersectionPointB.y=yB;}}}return intersectionCount;};RectangleBoundingBoxData.prototype._onClear=function(){_super.prototype._onClear.call(this);this.type=0;};RectangleBoundingBoxData.prototype.containsPoint=function(pX,pY){var widthH=this.width*0.5;if(pX>=-widthH&&pX<=widthH){var heightH=this.height*0.5;if(pY>=-heightH&&pY<=heightH){return true;}}return false;};RectangleBoundingBoxData.prototype.intersectsSegment=function(xA,yA,xB,yB,intersectionPointA,intersectionPointB,normalRadians){if(intersectionPointA===void 0){intersectionPointA=null;}if(intersectionPointB===void 0){intersectionPointB=null;}if(normalRadians===void 0){normalRadians=null;}var widthH=this.width*0.5;var heightH=this.height*0.5;var intersectionCount=RectangleBoundingBoxData.rectangleIntersectsSegment(xA,yA,xB,yB,-widthH,-heightH,widthH,heightH,intersectionPointA,intersectionPointB,normalRadians);return intersectionCount;};return RectangleBoundingBoxData;}(BoundingBoxData);dragonBones.RectangleBoundingBoxData=RectangleBoundingBoxData;var EllipseBoundingBoxData=function(_super){__extends$1(EllipseBoundingBoxData,_super);function EllipseBoundingBoxData(){return _super!==null&&_super.apply(this,arguments)||this;}EllipseBoundingBoxData.toString=function(){return "[class dragonBones.EllipseData]";};EllipseBoundingBoxData.ellipseIntersectsSegment=function(xA,yA,xB,yB,xC,yC,widthH,heightH,intersectionPointA,intersectionPointB,normalRadians){if(intersectionPointA===void 0){intersectionPointA=null;}if(intersectionPointB===void 0){intersectionPointB=null;}if(normalRadians===void 0){normalRadians=null;}var d=widthH/heightH;var dd=d*d;yA*=d;yB*=d;var dX=xB-xA;var dY=yB-yA;var lAB=Math.sqrt(dX*dX+dY*dY);var xD=dX/lAB;var yD=dY/lAB;var a=(xC-xA)*xD+(yC-yA)*yD;var aa=a*a;var ee=xA*xA+yA*yA;var rr=widthH*widthH;var dR=rr-ee+aa;var intersectionCount=0;if(dR>=0.0){var dT=Math.sqrt(dR);var sA=a-dT;var sB=a+dT;var inSideA=sA<0.0?-1:sA<=lAB?0:1;var inSideB=sB<0.0?-1:sB<=lAB?0:1;var sideAB=inSideA*inSideB;if(sideAB<0){return -1;}else if(sideAB===0){if(inSideA===-1){intersectionCount=2;xB=xA+sB*xD;yB=(yA+sB*yD)/d;if(intersectionPointA!==null){intersectionPointA.x=xB;intersectionPointA.y=yB;}if(intersectionPointB!==null){intersectionPointB.x=xB;intersectionPointB.y=yB;}if(normalRadians!==null){normalRadians.x=Math.atan2(yB/rr*dd,xB/rr);normalRadians.y=normalRadians.x+Math.PI;}}else if(inSideB===1){intersectionCount=1;xA=xA+sA*xD;yA=(yA+sA*yD)/d;if(intersectionPointA!==null){intersectionPointA.x=xA;intersectionPointA.y=yA;}if(intersectionPointB!==null){intersectionPointB.x=xA;intersectionPointB.y=yA;}if(normalRadians!==null){normalRadians.x=Math.atan2(yA/rr*dd,xA/rr);normalRadians.y=normalRadians.x+Math.PI;}}else {intersectionCount=3;if(intersectionPointA!==null){intersectionPointA.x=xA+sA*xD;intersectionPointA.y=(yA+sA*yD)/d;if(normalRadians!==null){normalRadians.x=Math.atan2(intersectionPointA.y/rr*dd,intersectionPointA.x/rr);}}if(intersectionPointB!==null){intersectionPointB.x=xA+sB*xD;intersectionPointB.y=(yA+sB*yD)/d;if(normalRadians!==null){normalRadians.y=Math.atan2(intersectionPointB.y/rr*dd,intersectionPointB.x/rr);}}}}}return intersectionCount;};EllipseBoundingBoxData.prototype._onClear=function(){_super.prototype._onClear.call(this);this.type=1;};EllipseBoundingBoxData.prototype.containsPoint=function(pX,pY){var widthH=this.width*0.5;if(pX>=-widthH&&pX<=widthH){var heightH=this.height*0.5;if(pY>=-heightH&&pY<=heightH){pY*=widthH/heightH;return Math.sqrt(pX*pX+pY*pY)<=widthH;}}return false;};EllipseBoundingBoxData.prototype.intersectsSegment=function(xA,yA,xB,yB,intersectionPointA,intersectionPointB,normalRadians){if(intersectionPointA===void 0){intersectionPointA=null;}if(intersectionPointB===void 0){intersectionPointB=null;}if(normalRadians===void 0){normalRadians=null;}var intersectionCount=EllipseBoundingBoxData.ellipseIntersectsSegment(xA,yA,xB,yB,0.0,0.0,this.width*0.5,this.height*0.5,intersectionPointA,intersectionPointB,normalRadians);return intersectionCount;};return EllipseBoundingBoxData;}(BoundingBoxData);dragonBones.EllipseBoundingBoxData=EllipseBoundingBoxData;var PolygonBoundingBoxData=function(_super){__extends$1(PolygonBoundingBoxData,_super);function PolygonBoundingBoxData(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.vertices=[];return _this;}PolygonBoundingBoxData.toString=function(){return "[class dragonBones.PolygonBoundingBoxData]";};PolygonBoundingBoxData.polygonIntersectsSegment=function(xA,yA,xB,yB,vertices,intersectionPointA,intersectionPointB,normalRadians){if(intersectionPointA===void 0){intersectionPointA=null;}if(intersectionPointB===void 0){intersectionPointB=null;}if(normalRadians===void 0){normalRadians=null;}if(xA===xB){xA=xB+0.000001;}if(yA===yB){yA=yB+0.000001;}var count=vertices.length;var dXAB=xA-xB;var dYAB=yA-yB;var llAB=xA*yB-yA*xB;var intersectionCount=0;var xC=vertices[count-2];var yC=vertices[count-1];var dMin=0.0;var dMax=0.0;var xMin=0.0;var yMin=0.0;var xMax=0.0;var yMax=0.0;for(var i=0;i<count;i+=2){var xD=vertices[i];var yD=vertices[i+1];if(xC===xD){xC=xD+0.0001;}if(yC===yD){yC=yD+0.0001;}var dXCD=xC-xD;var dYCD=yC-yD;var llCD=xC*yD-yC*xD;var ll=dXAB*dYCD-dYAB*dXCD;var x=(llAB*dXCD-dXAB*llCD)/ll;if((x>=xC&&x<=xD||x>=xD&&x<=xC)&&(dXAB===0.0||x>=xA&&x<=xB||x>=xB&&x<=xA)){var y=(llAB*dYCD-dYAB*llCD)/ll;if((y>=yC&&y<=yD||y>=yD&&y<=yC)&&(dYAB===0.0||y>=yA&&y<=yB||y>=yB&&y<=yA)){if(intersectionPointB!==null){var d=x-xA;if(d<0.0){d=-d;}if(intersectionCount===0){dMin=d;dMax=d;xMin=x;yMin=y;xMax=x;yMax=y;if(normalRadians!==null){normalRadians.x=Math.atan2(yD-yC,xD-xC)-Math.PI*0.5;normalRadians.y=normalRadians.x;}}else {if(d<dMin){dMin=d;xMin=x;yMin=y;if(normalRadians!==null){normalRadians.x=Math.atan2(yD-yC,xD-xC)-Math.PI*0.5;}}if(d>dMax){dMax=d;xMax=x;yMax=y;if(normalRadians!==null){normalRadians.y=Math.atan2(yD-yC,xD-xC)-Math.PI*0.5;}}}intersectionCount++;}else {xMin=x;yMin=y;xMax=x;yMax=y;intersectionCount++;if(normalRadians!==null){normalRadians.x=Math.atan2(yD-yC,xD-xC)-Math.PI*0.5;normalRadians.y=normalRadians.x;}break;}}}xC=xD;yC=yD;}if(intersectionCount===1){if(intersectionPointA!==null){intersectionPointA.x=xMin;intersectionPointA.y=yMin;}if(intersectionPointB!==null){intersectionPointB.x=xMin;intersectionPointB.y=yMin;}if(normalRadians!==null){normalRadians.y=normalRadians.x+Math.PI;}}else if(intersectionCount>1){intersectionCount++;if(intersectionPointA!==null){intersectionPointA.x=xMin;intersectionPointA.y=yMin;}if(intersectionPointB!==null){intersectionPointB.x=xMax;intersectionPointB.y=yMax;}}return intersectionCount;};PolygonBoundingBoxData.prototype._onClear=function(){_super.prototype._onClear.call(this);this.type=2;this.x=0.0;this.y=0.0;this.vertices.length=0;};PolygonBoundingBoxData.prototype.containsPoint=function(pX,pY){var isInSide=false;if(pX>=this.x&&pX<=this.width&&pY>=this.y&&pY<=this.height){for(var i=0,l=this.vertices.length,iP=l-2;i<l;i+=2){var yA=this.vertices[iP+1];var yB=this.vertices[i+1];if(yB<pY&&yA>=pY||yA<pY&&yB>=pY){var xA=this.vertices[iP];var xB=this.vertices[i];if((pY-yB)*(xA-xB)/(yA-yB)+xB<pX){isInSide=!isInSide;}}iP=i;}}return isInSide;};PolygonBoundingBoxData.prototype.intersectsSegment=function(xA,yA,xB,yB,intersectionPointA,intersectionPointB,normalRadians){if(intersectionPointA===void 0){intersectionPointA=null;}if(intersectionPointB===void 0){intersectionPointB=null;}if(normalRadians===void 0){normalRadians=null;}var intersectionCount=0;if(RectangleBoundingBoxData.rectangleIntersectsSegment(xA,yA,xB,yB,this.x,this.y,this.x+this.width,this.y+this.height,null,null,null)!==0){intersectionCount=PolygonBoundingBoxData.polygonIntersectsSegment(xA,yA,xB,yB,this.vertices,intersectionPointA,intersectionPointB,normalRadians);}return intersectionCount;};return PolygonBoundingBoxData;}(BoundingBoxData);dragonBones.PolygonBoundingBoxData=PolygonBoundingBoxData;})(dragonBones||(dragonBones={}));(function(dragonBones){var AnimationData=function(_super){__extends$1(AnimationData,_super);function AnimationData(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.cachedFrames=[];_this.boneTimelines={};_this.surfaceTimelines={};_this.slotTimelines={};_this.constraintTimelines={};_this.animationTimelines={};_this.boneCachedFrameIndices={};_this.slotCachedFrameIndices={};_this.actionTimeline=null;_this.zOrderTimeline=null;return _this;}AnimationData.toString=function(){return "[class dragonBones.AnimationData]";};AnimationData.prototype._onClear=function(){for(var k in this.boneTimelines){for(var _i=0,_a=this.boneTimelines[k];_i<_a.length;_i++){var timeline=_a[_i];timeline.returnToPool();}delete this.boneTimelines[k];}for(var k in this.surfaceTimelines){for(var _b=0,_c=this.surfaceTimelines[k];_b<_c.length;_b++){var timeline=_c[_b];timeline.returnToPool();}delete this.surfaceTimelines[k];}for(var k in this.slotTimelines){for(var _d=0,_e=this.slotTimelines[k];_d<_e.length;_d++){var timeline=_e[_d];timeline.returnToPool();}delete this.slotTimelines[k];}for(var k in this.constraintTimelines){for(var _f=0,_g=this.constraintTimelines[k];_f<_g.length;_f++){var timeline=_g[_f];timeline.returnToPool();}delete this.constraintTimelines[k];}for(var k in this.animationTimelines){for(var _h=0,_j=this.animationTimelines[k];_h<_j.length;_h++){var timeline=_j[_h];timeline.returnToPool();}delete this.animationTimelines[k];}for(var k in this.boneCachedFrameIndices){delete this.boneCachedFrameIndices[k];}for(var k in this.slotCachedFrameIndices){delete this.slotCachedFrameIndices[k];}if(this.actionTimeline!==null){this.actionTimeline.returnToPool();}if(this.zOrderTimeline!==null){this.zOrderTimeline.returnToPool();}this.frameIntOffset=0;this.frameFloatOffset=0;this.frameOffset=0;this.frameCount=0;this.playTimes=0;this.duration=0.0;this.scale=1.0;this.fadeInTime=0.0;this.cacheFrameRate=0.0;this.name="";this.cachedFrames.length=0;this.actionTimeline=null;this.zOrderTimeline=null;this.parent=null;};AnimationData.prototype.cacheFrames=function(frameRate){if(this.cacheFrameRate>0.0){return;}this.cacheFrameRate=Math.max(Math.ceil(frameRate*this.scale),1.0);var cacheFrameCount=Math.ceil(this.cacheFrameRate*this.duration)+1;this.cachedFrames.length=cacheFrameCount;for(var i=0,l=this.cacheFrames.length;i<l;++i){this.cachedFrames[i]=false;}for(var _i=0,_a=this.parent.sortedBones;_i<_a.length;_i++){var bone=_a[_i];var indices=new Array(cacheFrameCount);for(var i=0,l=indices.length;i<l;++i){indices[i]=-1;}this.boneCachedFrameIndices[bone.name]=indices;}for(var _b=0,_c=this.parent.sortedSlots;_b<_c.length;_b++){var slot=_c[_b];var indices=new Array(cacheFrameCount);for(var i=0,l=indices.length;i<l;++i){indices[i]=-1;}this.slotCachedFrameIndices[slot.name]=indices;}};AnimationData.prototype.addBoneTimeline=function(bone,timeline){var timelines=bone.name in this.boneTimelines?this.boneTimelines[bone.name]:this.boneTimelines[bone.name]=[];if(timelines.indexOf(timeline)<0){timelines.push(timeline);}};AnimationData.prototype.addSurfaceTimeline=function(surface,timeline){var timelines=surface.name in this.surfaceTimelines?this.surfaceTimelines[surface.name]:this.surfaceTimelines[surface.name]=[];if(timelines.indexOf(timeline)<0){timelines.push(timeline);}};AnimationData.prototype.addSlotTimeline=function(slot,timeline){var timelines=slot.name in this.slotTimelines?this.slotTimelines[slot.name]:this.slotTimelines[slot.name]=[];if(timelines.indexOf(timeline)<0){timelines.push(timeline);}};AnimationData.prototype.addConstraintTimeline=function(constraint,timeline){var timelines=constraint.name in this.constraintTimelines?this.constraintTimelines[constraint.name]:this.constraintTimelines[constraint.name]=[];if(timelines.indexOf(timeline)<0){timelines.push(timeline);}};AnimationData.prototype.addAnimationTimeline=function(timelineName,timeline){var timelines=timelineName in this.animationTimelines?this.animationTimelines[timelineName]:this.animationTimelines[timelineName]=[];if(timelines.indexOf(timeline)<0){timelines.push(timeline);}};AnimationData.prototype.getBoneTimelines=function(timelineName){return timelineName in this.boneTimelines?this.boneTimelines[timelineName]:null;};AnimationData.prototype.getSurfaceTimelines=function(timelineName){return timelineName in this.surfaceTimelines?this.surfaceTimelines[timelineName]:null;};AnimationData.prototype.getSlotTimelines=function(timelineName){return timelineName in this.slotTimelines?this.slotTimelines[timelineName]:null;};AnimationData.prototype.getConstraintTimelines=function(timelineName){return timelineName in this.constraintTimelines?this.constraintTimelines[timelineName]:null;};AnimationData.prototype.getAnimationTimelines=function(timelineName){return timelineName in this.animationTimelines?this.animationTimelines[timelineName]:null;};AnimationData.prototype.getBoneCachedFrameIndices=function(boneName){return boneName in this.boneCachedFrameIndices?this.boneCachedFrameIndices[boneName]:null;};AnimationData.prototype.getSlotCachedFrameIndices=function(slotName){return slotName in this.slotCachedFrameIndices?this.slotCachedFrameIndices[slotName]:null;};return AnimationData;}(dragonBones.BaseObject);dragonBones.AnimationData=AnimationData;var TimelineData=function(_super){__extends$1(TimelineData,_super);function TimelineData(){return _super!==null&&_super.apply(this,arguments)||this;}TimelineData.toString=function(){return "[class dragonBones.TimelineData]";};TimelineData.prototype._onClear=function(){this.type=10;this.offset=0;this.frameIndicesOffset=-1;};return TimelineData;}(dragonBones.BaseObject);dragonBones.TimelineData=TimelineData;})(dragonBones||(dragonBones={}));(function(dragonBones){var AnimationConfig=function(_super){__extends$1(AnimationConfig,_super);function AnimationConfig(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.boneMask=[];return _this;}AnimationConfig.toString=function(){return "[class dragonBones.AnimationConfig]";};AnimationConfig.prototype._onClear=function(){this.pauseFadeOut=true;this.fadeOutMode=4;this.fadeOutTweenType=1;this.fadeOutTime=-1.0;this.actionEnabled=true;this.additiveBlending=false;this.displayControl=true;this.pauseFadeIn=true;this.resetToPose=true;this.fadeInTweenType=1;this.playTimes=-1;this.layer=0;this.position=0.0;this.duration=-1.0;this.timeScale=-100.0;this.weight=1.0;this.fadeInTime=-1.0;this.autoFadeOutTime=-1.0;this.name="";this.animation="";this.group="";this.boneMask.length=0;};AnimationConfig.prototype.clear=function(){this._onClear();};AnimationConfig.prototype.copyFrom=function(value){this.pauseFadeOut=value.pauseFadeOut;this.fadeOutMode=value.fadeOutMode;this.autoFadeOutTime=value.autoFadeOutTime;this.fadeOutTweenType=value.fadeOutTweenType;this.actionEnabled=value.actionEnabled;this.additiveBlending=value.additiveBlending;this.displayControl=value.displayControl;this.pauseFadeIn=value.pauseFadeIn;this.resetToPose=value.resetToPose;this.playTimes=value.playTimes;this.layer=value.layer;this.position=value.position;this.duration=value.duration;this.timeScale=value.timeScale;this.fadeInTime=value.fadeInTime;this.fadeOutTime=value.fadeOutTime;this.fadeInTweenType=value.fadeInTweenType;this.weight=value.weight;this.name=value.name;this.animation=value.animation;this.group=value.group;this.boneMask.length=value.boneMask.length;for(var i=0,l=this.boneMask.length;i<l;++i){this.boneMask[i]=value.boneMask[i];}};AnimationConfig.prototype.containsBoneMask=function(boneName){return this.boneMask.length===0||this.boneMask.indexOf(boneName)>=0;};AnimationConfig.prototype.addBoneMask=function(armature,boneName,recursive){if(recursive===void 0){recursive=true;}var currentBone=armature.getBone(boneName);if(currentBone===null){return;}if(this.boneMask.indexOf(boneName)<0){this.boneMask.push(boneName);}if(recursive){for(var _i=0,_a=armature.getBones();_i<_a.length;_i++){var bone=_a[_i];if(this.boneMask.indexOf(bone.name)<0&&currentBone.contains(bone)){this.boneMask.push(bone.name);}}}};AnimationConfig.prototype.removeBoneMask=function(armature,boneName,recursive){if(recursive===void 0){recursive=true;}var index=this.boneMask.indexOf(boneName);if(index>=0){this.boneMask.splice(index,1);}if(recursive){var currentBone=armature.getBone(boneName);if(currentBone!==null){if(this.boneMask.length>0){for(var _i=0,_a=armature.getBones();_i<_a.length;_i++){var bone=_a[_i];var index_1=this.boneMask.indexOf(bone.name);if(index_1>=0&&currentBone.contains(bone)){this.boneMask.splice(index_1,1);}}}else {for(var _b=0,_c=armature.getBones();_b<_c.length;_b++){var bone=_c[_b];if(bone===currentBone){continue;}if(!currentBone.contains(bone)){this.boneMask.push(bone.name);}}}}}};return AnimationConfig;}(dragonBones.BaseObject);dragonBones.AnimationConfig=AnimationConfig;})(dragonBones||(dragonBones={}));(function(dragonBones){var TextureAtlasData=function(_super){__extends$1(TextureAtlasData,_super);function TextureAtlasData(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.textures={};return _this;}TextureAtlasData.prototype._onClear=function(){for(var k in this.textures){this.textures[k].returnToPool();delete this.textures[k];}this.autoSearch=false;this.width=0;this.height=0;this.scale=1.0;this.name="";this.imagePath="";};TextureAtlasData.prototype.copyFrom=function(value){this.autoSearch=value.autoSearch;this.scale=value.scale;this.width=value.width;this.height=value.height;this.name=value.name;this.imagePath=value.imagePath;for(var k in this.textures){this.textures[k].returnToPool();delete this.textures[k];}for(var k in value.textures){var texture=this.createTexture();texture.copyFrom(value.textures[k]);this.textures[k]=texture;}};TextureAtlasData.prototype.addTexture=function(value){if(value.name in this.textures){console.warn("Same texture: "+value.name);return;}value.parent=this;this.textures[value.name]=value;};TextureAtlasData.prototype.getTexture=function(textureName){return textureName in this.textures?this.textures[textureName]:null;};return TextureAtlasData;}(dragonBones.BaseObject);dragonBones.TextureAtlasData=TextureAtlasData;var TextureData=function(_super){__extends$1(TextureData,_super);function TextureData(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.region=new dragonBones.Rectangle();_this.frame=null;return _this;}TextureData.createRectangle=function(){return new dragonBones.Rectangle();};TextureData.prototype._onClear=function(){this.rotated=false;this.name="";this.region.clear();this.parent=null;this.frame=null;};TextureData.prototype.copyFrom=function(value){this.rotated=value.rotated;this.name=value.name;this.region.copyFrom(value.region);this.parent=value.parent;if(this.frame===null&&value.frame!==null){this.frame=TextureData.createRectangle();}else if(this.frame!==null&&value.frame===null){this.frame=null;}if(this.frame!==null&&value.frame!==null){this.frame.copyFrom(value.frame);}};return TextureData;}(dragonBones.BaseObject);dragonBones.TextureData=TextureData;})(dragonBones||(dragonBones={}));(function(dragonBones){var DeformVertices=function(_super){__extends$1(DeformVertices,_super);function DeformVertices(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.vertices=[];_this.bones=[];return _this;}DeformVertices.toString=function(){return "[class dragonBones.DeformVertices]";};DeformVertices.prototype._onClear=function(){this.verticesDirty=false;this.vertices.length=0;this.bones.length=0;this.verticesData=null;};DeformVertices.prototype.init=function(verticesDataValue,armature){this.verticesData=verticesDataValue;if(this.verticesData!==null){var vertexCount=0;if(this.verticesData.weight!==null){vertexCount=this.verticesData.weight.count*2;}else {vertexCount=this.verticesData.data.intArray[this.verticesData.offset+0]*2;}this.verticesDirty=true;this.vertices.length=vertexCount;this.bones.length=0;for(var i=0,l=this.vertices.length;i<l;++i){this.vertices[i]=0.0;}if(this.verticesData.weight!==null){for(var i=0,l=this.verticesData.weight.bones.length;i<l;++i){var bone=armature.getBone(this.verticesData.weight.bones[i].name);this.bones.push(bone);}}}else {this.verticesDirty=false;this.vertices.length=0;this.bones.length=0;this.verticesData=null;}};DeformVertices.prototype.isBonesUpdate=function(){for(var _i=0,_a=this.bones;_i<_a.length;_i++){var bone=_a[_i];if(bone!==null&&bone._childrenTransformDirty){return true;}}return false;};return DeformVertices;}(dragonBones.BaseObject);dragonBones.DeformVertices=DeformVertices;})(dragonBones||(dragonBones={}));(function(dragonBones_1){var Armature=function(_super){__extends$1(Armature,_super);function Armature(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this._bones=[];_this._slots=[];_this._constraints=[];_this._actions=[];_this._animation=null;_this._proxy=null;_this._replaceTextureAtlasData=null;_this._clock=null;return _this;}Armature.toString=function(){return "[class dragonBones.Armature]";};Armature._onSortSlots=function(a,b){return a._zOrder>b._zOrder?1:-1;};Armature.prototype._onClear=function(){if(this._clock!==null){this._clock.remove(this);}for(var _i=0,_a=this._bones;_i<_a.length;_i++){var bone=_a[_i];bone.returnToPool();}for(var _b=0,_c=this._slots;_b<_c.length;_b++){var slot=_c[_b];slot.returnToPool();}for(var _d=0,_e=this._constraints;_d<_e.length;_d++){var constraint=_e[_d];constraint.returnToPool();}for(var _f=0,_g=this._actions;_f<_g.length;_f++){var action=_g[_f];action.returnToPool();}if(this._animation!==null){this._animation.returnToPool();}if(this._proxy!==null){this._proxy.dbClear();}if(this._replaceTextureAtlasData!==null){this._replaceTextureAtlasData.returnToPool();}this.inheritAnimation=true;this.userData=null;this._lockUpdate=false;this._slotsDirty=true;this._zOrderDirty=false;this._flipX=false;this._flipY=false;this._cacheFrameIndex=-1;this._bones.length=0;this._slots.length=0;this._constraints.length=0;this._actions.length=0;this._armatureData=null;this._animation=null;this._proxy=null;this._display=null;this._replaceTextureAtlasData=null;this._replacedTexture=null;this._dragonBones=null;this._clock=null;this._parent=null;};Armature.prototype._sortZOrder=function(slotIndices,offset){var slotDatas=this._armatureData.sortedSlots;var isOriginal=slotIndices===null;if(this._zOrderDirty||!isOriginal){for(var i=0,l=slotDatas.length;i<l;++i){var slotIndex=isOriginal?i:slotIndices[offset+i];if(slotIndex<0||slotIndex>=l){continue;}var slotData=slotDatas[slotIndex];var slot=this.getSlot(slotData.name);if(slot!==null){slot._setZorder(i);}}this._slotsDirty=true;this._zOrderDirty=!isOriginal;}};Armature.prototype._addBone=function(value){if(this._bones.indexOf(value)<0){this._bones.push(value);}};Armature.prototype._addSlot=function(value){if(this._slots.indexOf(value)<0){this._slots.push(value);}};Armature.prototype._addConstraint=function(value){if(this._constraints.indexOf(value)<0){this._constraints.push(value);}};Armature.prototype._bufferAction=function(action,append){if(this._actions.indexOf(action)<0){if(append){this._actions.push(action);}else {this._actions.unshift(action);}}};Armature.prototype.dispose=function(){if(this._armatureData!==null){this._lockUpdate=true;this._dragonBones.bufferObject(this);}};Armature.prototype.init=function(armatureData,proxy,display,dragonBones){if(this._armatureData!==null){return;}this._armatureData=armatureData;this._animation=dragonBones_1.BaseObject.borrowObject(dragonBones_1.Animation);this._proxy=proxy;this._display=display;this._dragonBones=dragonBones;this._proxy.dbInit(this);this._animation.init(this);this._animation.animations=this._armatureData.animations;};Armature.prototype.advanceTime=function(passedTime){if(this._lockUpdate){return;}if(this._armatureData===null){console.warn("The armature has been disposed.");return;}else if(this._armatureData.parent===null){console.warn("The armature data has been disposed.\nPlease make sure dispose armature before call factory.clear().");return;}var prevCacheFrameIndex=this._cacheFrameIndex;this._animation.advanceTime(passedTime);if(this._slotsDirty){this._slotsDirty=false;this._slots.sort(Armature._onSortSlots);}if(this._cacheFrameIndex<0||this._cacheFrameIndex!==prevCacheFrameIndex){var i=0,l=0;for(i=0,l=this._bones.length;i<l;++i){this._bones[i].update(this._cacheFrameIndex);}for(i=0,l=this._slots.length;i<l;++i){this._slots[i].update(this._cacheFrameIndex);}}if(this._actions.length>0){this._lockUpdate=true;for(var _i=0,_a=this._actions;_i<_a.length;_i++){var action=_a[_i];var actionData=action.actionData;if(actionData!==null){if(actionData.type===0){if(action.slot!==null){var childArmature=action.slot.childArmature;if(childArmature!==null){childArmature.animation.fadeIn(actionData.name);}}else if(action.bone!==null){for(var _b=0,_c=this.getSlots();_b<_c.length;_b++){var slot=_c[_b];if(slot.parent===action.bone){var childArmature=slot.childArmature;if(childArmature!==null){childArmature.animation.fadeIn(actionData.name);}}}}else {this._animation.fadeIn(actionData.name);}}}action.returnToPool();}this._actions.length=0;this._lockUpdate=false;}this._proxy.dbUpdate();};Armature.prototype.invalidUpdate=function(boneName,updateSlot){if(boneName===void 0){boneName=null;}if(updateSlot===void 0){updateSlot=false;}if(boneName!==null&&boneName.length>0){var bone=this.getBone(boneName);if(bone!==null){bone.invalidUpdate();if(updateSlot){for(var _i=0,_a=this._slots;_i<_a.length;_i++){var slot=_a[_i];if(slot.parent===bone){slot.invalidUpdate();}}}}}else {for(var _b=0,_c=this._bones;_b<_c.length;_b++){var bone=_c[_b];bone.invalidUpdate();}if(updateSlot){for(var _d=0,_e=this._slots;_d<_e.length;_d++){var slot=_e[_d];slot.invalidUpdate();}}}};Armature.prototype.containsPoint=function(x,y){for(var _i=0,_a=this._slots;_i<_a.length;_i++){var slot=_a[_i];if(slot.containsPoint(x,y)){return slot;}}return null;};Armature.prototype.intersectsSegment=function(xA,yA,xB,yB,intersectionPointA,intersectionPointB,normalRadians){if(intersectionPointA===void 0){intersectionPointA=null;}if(intersectionPointB===void 0){intersectionPointB=null;}if(normalRadians===void 0){normalRadians=null;}var isV=xA===xB;var dMin=0.0;var dMax=0.0;var intXA=0.0;var intYA=0.0;var intXB=0.0;var intYB=0.0;var intAN=0.0;var intBN=0.0;var intSlotA=null;var intSlotB=null;for(var _i=0,_a=this._slots;_i<_a.length;_i++){var slot=_a[_i];var intersectionCount=slot.intersectsSegment(xA,yA,xB,yB,intersectionPointA,intersectionPointB,normalRadians);if(intersectionCount>0){if(intersectionPointA!==null||intersectionPointB!==null){if(intersectionPointA!==null){var d=isV?intersectionPointA.y-yA:intersectionPointA.x-xA;if(d<0.0){d=-d;}if(intSlotA===null||d<dMin){dMin=d;intXA=intersectionPointA.x;intYA=intersectionPointA.y;intSlotA=slot;if(normalRadians){intAN=normalRadians.x;}}}if(intersectionPointB!==null){var d=intersectionPointB.x-xA;if(d<0.0){d=-d;}if(intSlotB===null||d>dMax){dMax=d;intXB=intersectionPointB.x;intYB=intersectionPointB.y;intSlotB=slot;if(normalRadians!==null){intBN=normalRadians.y;}}}}else {intSlotA=slot;break;}}}if(intSlotA!==null&&intersectionPointA!==null){intersectionPointA.x=intXA;intersectionPointA.y=intYA;if(normalRadians!==null){normalRadians.x=intAN;}}if(intSlotB!==null&&intersectionPointB!==null){intersectionPointB.x=intXB;intersectionPointB.y=intYB;if(normalRadians!==null){normalRadians.y=intBN;}}return intSlotA;};Armature.prototype.getBone=function(name){for(var _i=0,_a=this._bones;_i<_a.length;_i++){var bone=_a[_i];if(bone.name===name){return bone;}}return null;};Armature.prototype.getBoneByDisplay=function(display){var slot=this.getSlotByDisplay(display);return slot!==null?slot.parent:null;};Armature.prototype.getSlot=function(name){for(var _i=0,_a=this._slots;_i<_a.length;_i++){var slot=_a[_i];if(slot.name===name){return slot;}}return null;};Armature.prototype.getSlotByDisplay=function(display){if(display!==null){for(var _i=0,_a=this._slots;_i<_a.length;_i++){var slot=_a[_i];if(slot.display===display){return slot;}}}return null;};Armature.prototype.getBones=function(){return this._bones;};Armature.prototype.getSlots=function(){return this._slots;};Object.defineProperty(Armature.prototype,"flipX",{get:function(){return this._flipX;},set:function(value){if(this._flipX===value){return;}this._flipX=value;this.invalidUpdate();},enumerable:true,configurable:true});Object.defineProperty(Armature.prototype,"flipY",{get:function(){return this._flipY;},set:function(value){if(this._flipY===value){return;}this._flipY=value;this.invalidUpdate();},enumerable:true,configurable:true});Object.defineProperty(Armature.prototype,"cacheFrameRate",{get:function(){return this._armatureData.cacheFrameRate;},set:function(value){if(this._armatureData.cacheFrameRate!==value){this._armatureData.cacheFrames(value);for(var _i=0,_a=this._slots;_i<_a.length;_i++){var slot=_a[_i];var childArmature=slot.childArmature;if(childArmature!==null){childArmature.cacheFrameRate=value;}}}},enumerable:true,configurable:true});Object.defineProperty(Armature.prototype,"name",{get:function(){return this._armatureData.name;},enumerable:true,configurable:true});Object.defineProperty(Armature.prototype,"armatureData",{get:function(){return this._armatureData;},enumerable:true,configurable:true});Object.defineProperty(Armature.prototype,"animation",{get:function(){return this._animation;},enumerable:true,configurable:true});Object.defineProperty(Armature.prototype,"proxy",{get:function(){return this._proxy;},enumerable:true,configurable:true});Object.defineProperty(Armature.prototype,"eventDispatcher",{get:function(){return this._proxy;},enumerable:true,configurable:true});Object.defineProperty(Armature.prototype,"display",{get:function(){return this._display;},enumerable:true,configurable:true});Object.defineProperty(Armature.prototype,"replacedTexture",{get:function(){return this._replacedTexture;},set:function(value){if(this._replacedTexture===value){return;}if(this._replaceTextureAtlasData!==null){this._replaceTextureAtlasData.returnToPool();this._replaceTextureAtlasData=null;}this._replacedTexture=value;for(var _i=0,_a=this._slots;_i<_a.length;_i++){var slot=_a[_i];slot.invalidUpdate();slot.update(-1);}},enumerable:true,configurable:true});Object.defineProperty(Armature.prototype,"clock",{get:function(){return this._clock;},set:function(value){if(this._clock===value){return;}if(this._clock!==null){this._clock.remove(this);}this._clock=value;if(this._clock){this._clock.add(this);}for(var _i=0,_a=this._slots;_i<_a.length;_i++){var slot=_a[_i];var childArmature=slot.childArmature;if(childArmature!==null){childArmature.clock=this._clock;}}},enumerable:true,configurable:true});Object.defineProperty(Armature.prototype,"parent",{get:function(){return this._parent;},enumerable:true,configurable:true});Armature.prototype.replaceTexture=function(texture){this.replacedTexture=texture;};Armature.prototype.hasEventListener=function(type){return this._proxy.hasDBEventListener(type);};Armature.prototype.addEventListener=function(type,listener,target){this._proxy.addDBEventListener(type,listener,target);};Armature.prototype.removeEventListener=function(type,listener,target){this._proxy.removeDBEventListener(type,listener,target);};Armature.prototype.enableAnimationCache=function(frameRate){console.warn("Deprecated.");this.cacheFrameRate=frameRate;};Armature.prototype.getDisplay=function(){return this._display;};return Armature;}(dragonBones_1.BaseObject);dragonBones_1.Armature=Armature;})(dragonBones||(dragonBones={}));(function(dragonBones){var TransformObject=function(_super){__extends$1(TransformObject,_super);function TransformObject(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.globalTransformMatrix=new dragonBones.Matrix();_this.global=new dragonBones.Transform();_this.offset=new dragonBones.Transform();return _this;}TransformObject.prototype._onClear=function(){this.globalTransformMatrix.identity();this.global.identity();this.offset.identity();this.origin=null;this.userData=null;this._globalDirty=false;this._armature=null;};TransformObject.prototype.updateGlobalTransform=function(){if(this._globalDirty){this._globalDirty=false;this.global.fromMatrix(this.globalTransformMatrix);}};Object.defineProperty(TransformObject.prototype,"armature",{get:function(){return this._armature;},enumerable:true,configurable:true});TransformObject._helpMatrix=new dragonBones.Matrix();TransformObject._helpTransform=new dragonBones.Transform();TransformObject._helpPoint=new dragonBones.Point();return TransformObject;}(dragonBones.BaseObject);dragonBones.TransformObject=TransformObject;})(dragonBones||(dragonBones={}));(function(dragonBones){var Bone=function(_super){__extends$1(Bone,_super);function Bone(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.animationPose=new dragonBones.Transform();_this._blendState=new dragonBones.BlendState();return _this;}Bone.toString=function(){return "[class dragonBones.Bone]";};Bone.prototype._onClear=function(){_super.prototype._onClear.call(this);this.offsetMode=1;this.animationPose.identity();this._transformDirty=false;this._childrenTransformDirty=false;this._localDirty=true;this._hasConstraint=false;this._visible=true;this._cachedFrameIndex=-1;this._blendState.clear();this._boneData=null;this._parent=null;this._cachedFrameIndices=null;};Bone.prototype._updateGlobalTransformMatrix=function(isCache){var boneData=this._boneData;var global=this.global;var globalTransformMatrix=this.globalTransformMatrix;var origin=this.origin;var offset=this.offset;var animationPose=this.animationPose;var parent=this._parent;var flipX=this._armature.flipX;var flipY=this._armature.flipY===dragonBones.DragonBones.yDown;var inherit=parent!==null;var rotation=0.0;if(this.offsetMode===1){if(origin!==null){global.x=origin.x+offset.x+animationPose.x;global.scaleX=origin.scaleX*offset.scaleX*animationPose.scaleX;global.scaleY=origin.scaleY*offset.scaleY*animationPose.scaleY;if(dragonBones.DragonBones.yDown){global.y=origin.y+offset.y+animationPose.y;global.skew=origin.skew+offset.skew+animationPose.skew;global.rotation=origin.rotation+offset.rotation+animationPose.rotation;}else {global.y=origin.y-offset.y+animationPose.y;global.skew=origin.skew-offset.skew+animationPose.skew;global.rotation=origin.rotation-offset.rotation+animationPose.rotation;}}else {global.copyFrom(offset);if(!dragonBones.DragonBones.yDown){global.y=-global.y;global.skew=-global.skew;global.rotation=-global.rotation;}global.add(animationPose);}}else if(this.offsetMode===0){if(origin!==null){global.copyFrom(origin).add(animationPose);}else {global.copyFrom(animationPose);}}else {inherit=false;global.copyFrom(offset);if(!dragonBones.DragonBones.yDown){global.y=-global.y;global.skew=-global.skew;global.rotation=-global.rotation;}}if(inherit){var parentMatrix=parent._boneData.type===0?parent.globalTransformMatrix:parent._getGlobalTransformMatrix(global.x,global.y);if(boneData.inheritScale){if(!boneData.inheritRotation){parent.updateGlobalTransform();if(flipX&&flipY){rotation=global.rotation-(parent.global.rotation+Math.PI);}else if(flipX){rotation=global.rotation+parent.global.rotation+Math.PI;}else if(flipY){rotation=global.rotation+parent.global.rotation;}else {rotation=global.rotation-parent.global.rotation;}global.rotation=rotation;}global.toMatrix(globalTransformMatrix);globalTransformMatrix.concat(parentMatrix);if(boneData.inheritTranslation){global.x=globalTransformMatrix.tx;global.y=globalTransformMatrix.ty;}else {globalTransformMatrix.tx=global.x;globalTransformMatrix.ty=global.y;}if(isCache){global.fromMatrix(globalTransformMatrix);}else {this._globalDirty=true;}}else {if(boneData.inheritTranslation){var x=global.x;var y=global.y;global.x=parentMatrix.a*x+parentMatrix.c*y+parentMatrix.tx;global.y=parentMatrix.b*x+parentMatrix.d*y+parentMatrix.ty;}else {if(flipX){global.x=-global.x;}if(flipY){global.y=-global.y;}}if(boneData.inheritRotation){parent.updateGlobalTransform();if(parent.global.scaleX<0.0){rotation=global.rotation+parent.global.rotation+Math.PI;}else {rotation=global.rotation+parent.global.rotation;}if(parentMatrix.a*parentMatrix.d-parentMatrix.b*parentMatrix.c<0.0){rotation-=global.rotation*2.0;if(flipX!==flipY||boneData.inheritReflection){global.skew+=Math.PI;}if(!dragonBones.DragonBones.yDown){global.skew=-global.skew;}}global.rotation=rotation;}else if(flipX||flipY){if(flipX&&flipY){rotation=global.rotation+Math.PI;}else {if(flipX){rotation=Math.PI-global.rotation;}else {rotation=-global.rotation;}global.skew+=Math.PI;}global.rotation=rotation;}global.toMatrix(globalTransformMatrix);}}else {if(flipX||flipY){if(flipX){global.x=-global.x;}if(flipY){global.y=-global.y;}if(flipX&&flipY){rotation=global.rotation+Math.PI;}else {if(flipX){rotation=Math.PI-global.rotation;}else {rotation=-global.rotation;}global.skew+=Math.PI;}global.rotation=rotation;}global.toMatrix(globalTransformMatrix);}};Bone.prototype.init=function(boneData,armatureValue){if(this._boneData!==null){return;}this._boneData=boneData;this._armature=armatureValue;if(this._boneData.parent!==null){this._parent=this._armature.getBone(this._boneData.parent.name);}this._armature._addBone(this);this.origin=this._boneData.transform;};Bone.prototype.update=function(cacheFrameIndex){this._blendState.dirty=false;if(cacheFrameIndex>=0&&this._cachedFrameIndices!==null){var cachedFrameIndex=this._cachedFrameIndices[cacheFrameIndex];if(cachedFrameIndex>=0&&this._cachedFrameIndex===cachedFrameIndex){this._transformDirty=false;}else if(cachedFrameIndex>=0){this._transformDirty=true;this._cachedFrameIndex=cachedFrameIndex;}else {if(this._hasConstraint){for(var _i=0,_a=this._armature._constraints;_i<_a.length;_i++){var constraint=_a[_i];if(constraint._root===this){constraint.update();}}}if(this._transformDirty||this._parent!==null&&this._parent._childrenTransformDirty){this._transformDirty=true;this._cachedFrameIndex=-1;}else if(this._cachedFrameIndex>=0){this._transformDirty=false;this._cachedFrameIndices[cacheFrameIndex]=this._cachedFrameIndex;}else {this._transformDirty=true;this._cachedFrameIndex=-1;}}}else {if(this._hasConstraint){for(var _b=0,_c=this._armature._constraints;_b<_c.length;_b++){var constraint=_c[_b];if(constraint._root===this){constraint.update();}}}if(this._transformDirty||this._parent!==null&&this._parent._childrenTransformDirty){cacheFrameIndex=-1;this._transformDirty=true;this._cachedFrameIndex=-1;}}if(this._transformDirty){this._transformDirty=false;this._childrenTransformDirty=true;if(this._cachedFrameIndex<0){var isCache=cacheFrameIndex>=0;if(this._localDirty){this._updateGlobalTransformMatrix(isCache);}if(isCache&&this._cachedFrameIndices!==null){this._cachedFrameIndex=this._cachedFrameIndices[cacheFrameIndex]=this._armature._armatureData.setCacheFrame(this.globalTransformMatrix,this.global);}}else {this._armature._armatureData.getCacheFrame(this.globalTransformMatrix,this.global,this._cachedFrameIndex);}}else if(this._childrenTransformDirty){this._childrenTransformDirty=false;}this._localDirty=true;};Bone.prototype.updateByConstraint=function(){if(this._localDirty){this._localDirty=false;if(this._transformDirty||this._parent!==null&&this._parent._childrenTransformDirty){this._updateGlobalTransformMatrix(true);}this._transformDirty=true;}};Bone.prototype.invalidUpdate=function(){this._transformDirty=true;};Bone.prototype.contains=function(value){if(value===this){return false;}var ancestor=value;while(ancestor!==this&&ancestor!==null){ancestor=ancestor.parent;}return ancestor===this;};Object.defineProperty(Bone.prototype,"boneData",{get:function(){return this._boneData;},enumerable:true,configurable:true});Object.defineProperty(Bone.prototype,"visible",{get:function(){return this._visible;},set:function(value){if(this._visible===value){return;}this._visible=value;for(var _i=0,_a=this._armature.getSlots();_i<_a.length;_i++){var slot=_a[_i];if(slot.parent===this){slot._updateVisible();}}},enumerable:true,configurable:true});Object.defineProperty(Bone.prototype,"name",{get:function(){return this._boneData.name;},enumerable:true,configurable:true});Object.defineProperty(Bone.prototype,"parent",{get:function(){return this._parent;},enumerable:true,configurable:true});Bone.prototype.getBones=function(){console.warn("Deprecated.");var bones=new Array();for(var _i=0,_a=this._armature.getBones();_i<_a.length;_i++){var bone=_a[_i];if(bone.parent===this){bones.push(bone);}}return bones;};Bone.prototype.getSlots=function(){console.warn("Deprecated.");var slots=new Array();for(var _i=0,_a=this._armature.getSlots();_i<_a.length;_i++){var slot=_a[_i];if(slot.parent===this){slots.push(slot);}}return slots;};Object.defineProperty(Bone.prototype,"slot",{get:function(){console.warn("Deprecated.");for(var _i=0,_a=this._armature.getSlots();_i<_a.length;_i++){var slot=_a[_i];if(slot.parent===this){return slot;}}return null;},enumerable:true,configurable:true});return Bone;}(dragonBones.TransformObject);dragonBones.Bone=Bone;})(dragonBones||(dragonBones={}));(function(dragonBones){var Surface=function(_super){__extends$1(Surface,_super);function Surface(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this._vertices=[];_this._deformVertices=[];_this._hullCache=[];_this._matrixCahce=[];return _this;}Surface.toString=function(){return "[class dragonBones.Surface]";};Surface.prototype._onClear=function(){_super.prototype._onClear.call(this);this._dX=0.0;this._dY=0.0;this._k=0.0;this._kX=0.0;this._kY=0.0;this._vertices.length=0;this._deformVertices.length=0;this._matrixCahce.length=0;this._hullCache.length=0;};Surface.prototype._getAffineTransform=function(x,y,lX,lY,aX,aY,bX,bY,cX,cY,transform,matrix,isDown){var dabX=bX-aX;var dabY=bY-aY;var dacX=cX-aX;var dacY=cY-aY;transform.rotation=Math.atan2(dabY,dabX);transform.skew=Math.atan2(dacY,dacX)-Math.PI*0.5-transform.rotation;if(isDown){transform.rotation+=Math.PI;}transform.scaleX=Math.sqrt(dabX*dabX+dabY*dabY)/lX;transform.scaleY=Math.sqrt(dacX*dacX+dacY*dacY)/lY;transform.toMatrix(matrix);transform.x=matrix.tx=aX-(matrix.a*x+matrix.c*y);transform.y=matrix.ty=aY-(matrix.b*x+matrix.d*y);};Surface.prototype._updateVertices=function(){var originalVertices=this._boneData.vertices;var vertices=this._vertices;var animationVertices=this._deformVertices;if(this._parent!==null){if(this._parent._boneData.type===1){for(var i=0,l=originalVertices.length;i<l;i+=2){var x=originalVertices[i]+animationVertices[i];var y=originalVertices[i+1]+animationVertices[i];var matrix=this._parent._getGlobalTransformMatrix(x,y);vertices[i]=matrix.a*x+matrix.c*y+matrix.tx;vertices[i+1]=matrix.b*x+matrix.d*y+matrix.ty;}}else {var parentMatrix=this._parent.globalTransformMatrix;for(var i=0,l=originalVertices.length;i<l;i+=2){var x=originalVertices[i]+animationVertices[i];var y=originalVertices[i+1]+animationVertices[i+1];vertices[i]=parentMatrix.a*x+parentMatrix.c*y+parentMatrix.tx;vertices[i+1]=parentMatrix.b*x+parentMatrix.d*y+parentMatrix.ty;}}}else {for(var i=0,l=originalVertices.length;i<l;i+=2){vertices[i]=originalVertices[i]+animationVertices[i];vertices[i+1]=originalVertices[i+1]+animationVertices[i+1];}}};Surface.prototype._updateGlobalTransformMatrix=function(isCache){var segmentXD=this._boneData.segmentX*2;var lastIndex=this._vertices.length-2;var lA=200.0;var raX=this._vertices[0];var raY=this._vertices[1];var rbX=this._vertices[segmentXD];var rbY=this._vertices[segmentXD+1];var rcX=this._vertices[lastIndex];var rcY=this._vertices[lastIndex+1];var rdX=this._vertices[lastIndex-segmentXD];var rdY=this._vertices[lastIndex-segmentXD+1];var dacX=raX+(rcX-raX)*0.5;var dacY=raY+(rcY-raY)*0.5;var dbdX=rbX+(rdX-rbX)*0.5;var dbdY=rbY+(rdY-rbY)*0.5;var aX=dacX+(dbdX-dacX)*0.5;var aY=dacY+(dbdY-dacY)*0.5;var bX=rbX+(rcX-rbX)*0.5;var bY=rbY+(rcY-rbY)*0.5;var cX=rdX+(rcX-rdX)*0.5;var cY=rdY+(rcY-rdY)*0.5;this._globalDirty=false;this._getAffineTransform(0.0,0.0,lA,lA,aX,aY,bX,bY,cX,cY,this.global,this.globalTransformMatrix,false);};Surface.prototype._getGlobalTransformMatrix=function(x,y){var lB=1000.0;if(x<-lB||lB<x||y<-lB||lB<y){return this.globalTransformMatrix;}var isDown=false;var lA=200.0;var surfaceData=this._boneData;var segmentX=surfaceData.segmentX;var segmentY=surfaceData.segmentY;var segmentXD=surfaceData.segmentX*2;var dX=this._dX;var dY=this._dY;var indexX=Math.floor((x+lA)/dX);var indexY=Math.floor((y+lA)/dY);var matrixIndex=0;var pX=indexX*dX-lA;var pY=indexY*dY-lA;var matrices=this._matrixCahce;var helpMatrix=Surface._helpMatrix;if(x<-lA){if(y<-lA||y>=lA){return this.globalTransformMatrix;}isDown=y>this._kX*(x+lA)+pY;matrixIndex=((segmentX*(segmentY+1)+segmentX*2+segmentY+indexY)*2+(isDown?1:0))*7;if(this._matrixCahce[matrixIndex]>0.0){helpMatrix.copyFromArray(matrices,matrixIndex+1);}else {var vertexIndex=indexY*(segmentXD+2);var ddX=this._hullCache[4];var ddY=this._hullCache[5];var sX=this._hullCache[2]-(segmentY-indexY)*ddX;var sY=this._hullCache[3]-(segmentY-indexY)*ddY;var vertices=this._vertices;if(isDown){this._getAffineTransform(-lA,pY+dY,lB-lA,dY,vertices[vertexIndex+segmentXD+2],vertices[vertexIndex+segmentXD+3],sX+ddX,sY+ddY,vertices[vertexIndex],vertices[vertexIndex+1],Surface._helpTransform,helpMatrix,true);}else {this._getAffineTransform(-lB,pY,lB-lA,dY,sX,sY,vertices[vertexIndex],vertices[vertexIndex+1],sX+ddX,sY+ddY,Surface._helpTransform,helpMatrix,false);}matrices[matrixIndex]=1.0;matrices[matrixIndex+1]=helpMatrix.a;matrices[matrixIndex+2]=helpMatrix.b;matrices[matrixIndex+3]=helpMatrix.c;matrices[matrixIndex+4]=helpMatrix.d;matrices[matrixIndex+5]=helpMatrix.tx;matrices[matrixIndex+6]=helpMatrix.ty;}}else if(x>=lA){if(y<-lA||y>=lA){return this.globalTransformMatrix;}isDown=y>this._kX*(x-lB)+pY;matrixIndex=((segmentX*(segmentY+1)+segmentX+indexY)*2+(isDown?1:0))*7;if(this._matrixCahce[matrixIndex]>0.0){helpMatrix.copyFromArray(matrices,matrixIndex+1);}else {var vertexIndex=(indexY+1)*(segmentXD+2)-2;var ddX=this._hullCache[4];var ddY=this._hullCache[5];var sX=this._hullCache[0]+indexY*ddX;var sY=this._hullCache[1]+indexY*ddY;var vertices=this._vertices;if(isDown){this._getAffineTransform(lB,pY+dY,lB-lA,dY,sX+ddX,sY+ddY,vertices[vertexIndex+segmentXD+2],vertices[vertexIndex+segmentXD+3],sX,sY,Surface._helpTransform,helpMatrix,true);}else {this._getAffineTransform(lA,pY,lB-lA,dY,vertices[vertexIndex],vertices[vertexIndex+1],sX,sY,vertices[vertexIndex+segmentXD+2],vertices[vertexIndex+segmentXD+3],Surface._helpTransform,helpMatrix,false);}matrices[matrixIndex]=1.0;matrices[matrixIndex+1]=helpMatrix.a;matrices[matrixIndex+2]=helpMatrix.b;matrices[matrixIndex+3]=helpMatrix.c;matrices[matrixIndex+4]=helpMatrix.d;matrices[matrixIndex+5]=helpMatrix.tx;matrices[matrixIndex+6]=helpMatrix.ty;}}else if(y<-lA){if(x<-lA||x>=lA){return this.globalTransformMatrix;}isDown=y>this._kY*(x-pX-dX)-lB;matrixIndex=(segmentX*(segmentY+1)+indexX*2+(isDown?1:0))*7;if(this._matrixCahce[matrixIndex]>0.0){helpMatrix.copyFromArray(matrices,matrixIndex+1);}else {var vertexIndex=indexX*2;var ddX=this._hullCache[10];var ddY=this._hullCache[11];var sX=this._hullCache[8]+indexX*ddX;var sY=this._hullCache[9]+indexX*ddY;var vertices=this._vertices;if(isDown){this._getAffineTransform(pX+dX,-lA,dX,lB-lA,vertices[vertexIndex+2],vertices[vertexIndex+3],vertices[vertexIndex],vertices[vertexIndex+1],sX+ddX,sY+ddY,Surface._helpTransform,helpMatrix,true);}else {this._getAffineTransform(pX,-lB,dX,lB-lA,sX,sY,sX+ddX,sY+ddY,vertices[vertexIndex],vertices[vertexIndex+1],Surface._helpTransform,helpMatrix,false);}matrices[matrixIndex]=1.0;matrices[matrixIndex+1]=helpMatrix.a;matrices[matrixIndex+2]=helpMatrix.b;matrices[matrixIndex+3]=helpMatrix.c;matrices[matrixIndex+4]=helpMatrix.d;matrices[matrixIndex+5]=helpMatrix.tx;matrices[matrixIndex+6]=helpMatrix.ty;}}else if(y>=lA){if(x<-lA||x>=lA){return this.globalTransformMatrix;}isDown=y>this._kY*(x-pX-dX)+lA;matrixIndex=((segmentX*(segmentY+1)+segmentX+segmentY+indexY)*2+(isDown?1:0))*7;if(this._matrixCahce[matrixIndex]>0.0){helpMatrix.copyFromArray(matrices,matrixIndex+1);}else {var vertexIndex=segmentY*(segmentXD+2)+indexX*2;var ddX=this._hullCache[10];var ddY=this._hullCache[11];var sX=this._hullCache[6]-(segmentX-indexX)*ddX;var sY=this._hullCache[7]-(segmentX-indexX)*ddY;var vertices=this._vertices;if(isDown){this._getAffineTransform(pX+dX,lB,dX,lB-lA,sX+ddX,sY+ddY,sX,sY,vertices[vertexIndex+2],vertices[vertexIndex+3],Surface._helpTransform,helpMatrix,true);}else {this._getAffineTransform(pX,lA,dX,lB-lA,vertices[vertexIndex],vertices[vertexIndex+1],vertices[vertexIndex+2],vertices[vertexIndex+3],sX,sY,Surface._helpTransform,helpMatrix,false);}matrices[matrixIndex]=1.0;matrices[matrixIndex+1]=helpMatrix.a;matrices[matrixIndex+2]=helpMatrix.b;matrices[matrixIndex+3]=helpMatrix.c;matrices[matrixIndex+4]=helpMatrix.d;matrices[matrixIndex+5]=helpMatrix.tx;matrices[matrixIndex+6]=helpMatrix.ty;}}else {isDown=y>this._k*(x-pX-dX)+pY;matrixIndex=((segmentX*indexY+indexX)*2+(isDown?1:0))*7;if(this._matrixCahce[matrixIndex]>0.0){helpMatrix.copyFromArray(matrices,matrixIndex+1);}else {var vertexIndex=indexX*2+indexY*(segmentXD+2);var vertices=this._vertices;if(isDown){this._getAffineTransform(pX+dX,pY+dY,dX,dY,vertices[vertexIndex+segmentXD+4],vertices[vertexIndex+segmentXD+5],vertices[vertexIndex+segmentXD+2],vertices[vertexIndex+segmentXD+3],vertices[vertexIndex+2],vertices[vertexIndex+3],Surface._helpTransform,helpMatrix,true);}else {this._getAffineTransform(pX,pY,dX,dY,vertices[vertexIndex],vertices[vertexIndex+1],vertices[vertexIndex+2],vertices[vertexIndex+3],vertices[vertexIndex+segmentXD+2],vertices[vertexIndex+segmentXD+3],Surface._helpTransform,helpMatrix,false);}matrices[matrixIndex]=1.0;matrices[matrixIndex+1]=helpMatrix.a;matrices[matrixIndex+2]=helpMatrix.b;matrices[matrixIndex+3]=helpMatrix.c;matrices[matrixIndex+4]=helpMatrix.d;matrices[matrixIndex+5]=helpMatrix.tx;matrices[matrixIndex+6]=helpMatrix.ty;}}return helpMatrix;};Surface.prototype.init=function(surfaceData,armatureValue){if(this._boneData!==null){return;}_super.prototype.init.call(this,surfaceData,armatureValue);var segmentX=surfaceData.segmentX;var segmentY=surfaceData.segmentY;var vertexCount=surfaceData.vertices.length;var lB=1000.0;var lA=200.0;this._dX=lA*2.0/segmentX;this._dY=lA*2.0/segmentY;this._k=-this._dY/this._dX;this._kX=-this._dY/(lB-lA);this._kY=-(lB-lA)/this._dX;this._vertices.length=vertexCount;this._deformVertices.length=vertexCount;this._matrixCahce.length=(segmentX*segmentY+segmentX*2+segmentY*2)*2*7;this._hullCache.length=10;for(var i=0;i<vertexCount;++i){this._deformVertices[i]=0.0;}};Surface.prototype.update=function(cacheFrameIndex){this._blendState.dirty=false;if(cacheFrameIndex>=0&&this._cachedFrameIndices!==null){var cachedFrameIndex=this._cachedFrameIndices[cacheFrameIndex];if(cachedFrameIndex>=0&&this._cachedFrameIndex===cachedFrameIndex){this._transformDirty=false;}else if(cachedFrameIndex>=0){this._transformDirty=true;this._cachedFrameIndex=cachedFrameIndex;}else {if(this._hasConstraint){for(var _i=0,_a=this._armature._constraints;_i<_a.length;_i++){var constraint=_a[_i];if(constraint._root===this){constraint.update();}}}if(this._transformDirty||this._parent!==null&&this._parent._childrenTransformDirty){this._transformDirty=true;this._cachedFrameIndex=-1;}else if(this._cachedFrameIndex>=0){this._transformDirty=false;this._cachedFrameIndices[cacheFrameIndex]=this._cachedFrameIndex;}else {this._transformDirty=true;this._cachedFrameIndex=-1;}}}else {if(this._hasConstraint){for(var _b=0,_c=this._armature._constraints;_b<_c.length;_b++){var constraint=_c[_b];if(constraint._root===this){constraint.update();}}}if(this._transformDirty||this._parent!==null&&this._parent._childrenTransformDirty){cacheFrameIndex=-1;this._transformDirty=true;this._cachedFrameIndex=-1;}}if(this._transformDirty){this._transformDirty=false;this._childrenTransformDirty=true;for(var i=0,l=this._matrixCahce.length;i<l;i+=7){this._matrixCahce[i]=-1.0;}this._updateVertices();if(this._cachedFrameIndex<0){var isCache=cacheFrameIndex>=0;if(this._localDirty){this._updateGlobalTransformMatrix(isCache);}if(isCache&&this._cachedFrameIndices!==null){this._cachedFrameIndex=this._cachedFrameIndices[cacheFrameIndex]=this._armature._armatureData.setCacheFrame(this.globalTransformMatrix,this.global);}}else {this._armature._armatureData.getCacheFrame(this.globalTransformMatrix,this.global,this._cachedFrameIndex);}var lB=1000.0;var lA=200.0;var ddX=2*this.global.x;var ddY=2*this.global.y;var helpPoint=Surface._helpPoint;this.globalTransformMatrix.transformPoint(lB,-lA,helpPoint);this._hullCache[0]=helpPoint.x;this._hullCache[1]=helpPoint.y;this._hullCache[2]=ddX-helpPoint.x;this._hullCache[3]=ddY-helpPoint.y;this.globalTransformMatrix.transformPoint(0.0,this._dY,helpPoint,true);this._hullCache[4]=helpPoint.x;this._hullCache[5]=helpPoint.y;this.globalTransformMatrix.transformPoint(lA,lB,helpPoint);this._hullCache[6]=helpPoint.x;this._hullCache[7]=helpPoint.y;this._hullCache[8]=ddX-helpPoint.x;this._hullCache[9]=ddY-helpPoint.y;this.globalTransformMatrix.transformPoint(this._dX,0.0,helpPoint,true);this._hullCache[10]=helpPoint.x;this._hullCache[11]=helpPoint.y;}else if(this._childrenTransformDirty){this._childrenTransformDirty=false;}this._localDirty=true;};return Surface;}(dragonBones.Bone);dragonBones.Surface=Surface;})(dragonBones||(dragonBones={}));(function(dragonBones){var Slot=function(_super){__extends$1(Slot,_super);function Slot(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this._localMatrix=new dragonBones.Matrix();_this._colorTransform=new dragonBones.ColorTransform();_this._displayDatas=[];_this._displayList=[];_this._deformVertices=null;_this._rawDisplay=null;_this._meshDisplay=null;return _this;}Slot.prototype._onClear=function(){_super.prototype._onClear.call(this);var disposeDisplayList=[];for(var _i=0,_a=this._displayList;_i<_a.length;_i++){var eachDisplay=_a[_i];if(eachDisplay!==null&&eachDisplay!==this._rawDisplay&&eachDisplay!==this._meshDisplay&&disposeDisplayList.indexOf(eachDisplay)<0){disposeDisplayList.push(eachDisplay);}}for(var _b=0,disposeDisplayList_1=disposeDisplayList;_b<disposeDisplayList_1.length;_b++){var eachDisplay=disposeDisplayList_1[_b];if(eachDisplay instanceof dragonBones.Armature){eachDisplay.dispose();}else {this._disposeDisplay(eachDisplay,true);}}if(this._deformVertices!==null){this._deformVertices.returnToPool();}if(this._meshDisplay!==null&&this._meshDisplay!==this._rawDisplay){this._disposeDisplay(this._meshDisplay,false);}if(this._rawDisplay!==null){this._disposeDisplay(this._rawDisplay,false);}this.displayController=null;this._displayDirty=false;this._zOrderDirty=false;this._blendModeDirty=false;this._colorDirty=false;this._transformDirty=false;this._visible=true;this._blendMode=0;this._displayIndex=-1;this._animationDisplayIndex=-1;this._zOrder=0;this._cachedFrameIndex=-1;this._pivotX=0.0;this._pivotY=0.0;this._localMatrix.identity();this._colorTransform.identity();this._displayList.length=0;this._displayDatas.length=0;this._slotData=null;this._rawDisplayDatas=null;this._displayData=null;this._boundingBoxData=null;this._textureData=null;this._deformVertices=null;this._rawDisplay=null;this._meshDisplay=null;this._display=null;this._childArmature=null;this._parent=null;this._cachedFrameIndices=null;};Slot.prototype._getDefaultRawDisplayData=function(displayIndex){var defaultSkin=this._armature._armatureData.defaultSkin;if(defaultSkin!==null){var defaultRawDisplayDatas=defaultSkin.getDisplays(this._slotData.name);if(defaultRawDisplayDatas!==null){return displayIndex<defaultRawDisplayDatas.length?defaultRawDisplayDatas[displayIndex]:null;}}return null;};Slot.prototype._updateDisplayData=function(){var prevDisplayData=this._displayData;var prevVerticesData=this._deformVertices!==null?this._deformVertices.verticesData:null;var prevTextureData=this._textureData;var rawDisplayData=null;var currentVerticesData=null;this._displayData=null;this._boundingBoxData=null;this._textureData=null;if(this._displayIndex>=0){if(this._rawDisplayDatas!==null){rawDisplayData=this._displayIndex<this._rawDisplayDatas.length?this._rawDisplayDatas[this._displayIndex]:null;}if(rawDisplayData===null){rawDisplayData=this._getDefaultRawDisplayData(this._displayIndex);}if(this._displayIndex<this._displayDatas.length){this._displayData=this._displayDatas[this._displayIndex];}}if(this._displayData!==null){if(this._displayData.type===2){currentVerticesData=this._displayData.vertices;}else if(this._displayData.type===4){currentVerticesData=this._displayData.vertices;}else if(rawDisplayData!==null){if(rawDisplayData.type===2){currentVerticesData=rawDisplayData.vertices;}else if(rawDisplayData.type===4){currentVerticesData=rawDisplayData.vertices;}}if(this._displayData.type===3){this._boundingBoxData=this._displayData.boundingBox;}else if(rawDisplayData!==null){if(rawDisplayData.type===3){this._boundingBoxData=rawDisplayData.boundingBox;}}if(this._displayData.type===0){this._textureData=this._displayData.texture;}else if(this._displayData.type===2){this._textureData=this._displayData.texture;}}if(this._displayData!==prevDisplayData||currentVerticesData!==prevVerticesData||this._textureData!==prevTextureData){if(currentVerticesData===null&&this._textureData!==null){var imageDisplayData=this._displayData;var scale=this._textureData.parent.scale*this._armature._armatureData.scale;var frame=this._textureData.frame;this._pivotX=imageDisplayData.pivot.x;this._pivotY=imageDisplayData.pivot.y;var rect=frame!==null?frame:this._textureData.region;var width=rect.width;var height=rect.height;if(this._textureData.rotated&&frame===null){width=rect.height;height=rect.width;}this._pivotX*=width*scale;this._pivotY*=height*scale;if(frame!==null){this._pivotX+=frame.x*scale;this._pivotY+=frame.y*scale;}if(this._displayData!==null&&rawDisplayData!==null&&this._displayData!==rawDisplayData){rawDisplayData.transform.toMatrix(Slot._helpMatrix);Slot._helpMatrix.invert();Slot._helpMatrix.transformPoint(0.0,0.0,Slot._helpPoint);this._pivotX-=Slot._helpPoint.x;this._pivotY-=Slot._helpPoint.y;this._displayData.transform.toMatrix(Slot._helpMatrix);Slot._helpMatrix.invert();Slot._helpMatrix.transformPoint(0.0,0.0,Slot._helpPoint);this._pivotX+=Slot._helpPoint.x;this._pivotY+=Slot._helpPoint.y;}if(!dragonBones.DragonBones.yDown){this._pivotY=(this._textureData.rotated?this._textureData.region.width:this._textureData.region.height)*scale-this._pivotY;}}else {this._pivotX=0.0;this._pivotY=0.0;}if(rawDisplayData!==null){this.origin=rawDisplayData.transform;}else if(this._displayData!==null){this.origin=this._displayData.transform;}else {this.origin=null;}if(currentVerticesData!==prevVerticesData){if(this._deformVertices===null){this._deformVertices=dragonBones.BaseObject.borrowObject(dragonBones.DeformVertices);}this._deformVertices.init(currentVerticesData,this._armature);}else if(this._deformVertices!==null&&this._textureData!==prevTextureData){this._deformVertices.verticesDirty=true;}this._displayDirty=true;this._transformDirty=true;}};Slot.prototype._updateDisplay=function(){var prevDisplay=this._display!==null?this._display:this._rawDisplay;var prevChildArmature=this._childArmature;if(this._displayIndex>=0&&this._displayIndex<this._displayList.length){this._display=this._displayList[this._displayIndex];if(this._display!==null&&this._display instanceof dragonBones.Armature){this._childArmature=this._display;this._display=this._childArmature.display;}else {this._childArmature=null;}}else {this._display=null;this._childArmature=null;}var currentDisplay=this._display!==null?this._display:this._rawDisplay;if(currentDisplay!==prevDisplay){this._onUpdateDisplay();this._replaceDisplay(prevDisplay);this._transformDirty=true;this._visibleDirty=true;this._blendModeDirty=true;this._colorDirty=true;}if(currentDisplay===this._rawDisplay||currentDisplay===this._meshDisplay){this._updateFrame();}if(this._childArmature!==prevChildArmature){if(prevChildArmature!==null){prevChildArmature._parent=null;prevChildArmature.clock=null;if(prevChildArmature.inheritAnimation){prevChildArmature.animation.reset();}}if(this._childArmature!==null){this._childArmature._parent=this;this._childArmature.clock=this._armature.clock;if(this._childArmature.inheritAnimation){if(this._childArmature.cacheFrameRate===0){var cacheFrameRate=this._armature.cacheFrameRate;if(cacheFrameRate!==0){this._childArmature.cacheFrameRate=cacheFrameRate;}}var actions=null;if(this._displayData!==null&&this._displayData.type===1){actions=this._displayData.actions;}else if(this._displayIndex>=0&&this._rawDisplayDatas!==null){var rawDisplayData=this._displayIndex<this._rawDisplayDatas.length?this._rawDisplayDatas[this._displayIndex]:null;if(rawDisplayData===null){rawDisplayData=this._getDefaultRawDisplayData(this._displayIndex);}if(rawDisplayData!==null&&rawDisplayData.type===1){actions=rawDisplayData.actions;}}if(actions!==null&&actions.length>0){for(var _i=0,actions_1=actions;_i<actions_1.length;_i++){var action=actions_1[_i];var eventObject=dragonBones.BaseObject.borrowObject(dragonBones.EventObject);dragonBones.EventObject.actionDataToInstance(action,eventObject,this._armature);eventObject.slot=this;this._armature._bufferAction(eventObject,false);}}else {this._childArmature.animation.play();}}}}};Slot.prototype._updateGlobalTransformMatrix=function(isCache){var parentMatrix=this._parent._boneData.type===0?this._parent.globalTransformMatrix:this._parent._getGlobalTransformMatrix(this.global.x,this.global.y);this.globalTransformMatrix.copyFrom(this._localMatrix);this.globalTransformMatrix.concat(parentMatrix);if(isCache){this.global.fromMatrix(this.globalTransformMatrix);}else {this._globalDirty=true;}};Slot.prototype._setDisplayIndex=function(value,isAnimation){if(isAnimation===void 0){isAnimation=false;}if(isAnimation){if(this._animationDisplayIndex===value){return false;}this._animationDisplayIndex=value;}if(this._displayIndex===value){return false;}this._displayIndex=value;this._displayDirty=true;this._updateDisplayData();return this._displayDirty;};Slot.prototype._setZorder=function(value){if(this._zOrder===value);this._zOrder=value;this._zOrderDirty=true;return this._zOrderDirty;};Slot.prototype._setColor=function(value){this._colorTransform.copyFrom(value);this._colorDirty=true;return this._colorDirty;};Slot.prototype._setDisplayList=function(value){if(value!==null&&value.length>0){if(this._displayList.length!==value.length){this._displayList.length=value.length;}for(var i=0,l=value.length;i<l;++i){var eachDisplay=value[i];if(eachDisplay!==null&&eachDisplay!==this._rawDisplay&&eachDisplay!==this._meshDisplay&&!(eachDisplay instanceof dragonBones.Armature)&&this._displayList.indexOf(eachDisplay)<0){this._initDisplay(eachDisplay,true);}this._displayList[i]=eachDisplay;}}else if(this._displayList.length>0){this._displayList.length=0;}if(this._displayIndex>=0&&this._displayIndex<this._displayList.length){this._displayDirty=this._display!==this._displayList[this._displayIndex];}else {this._displayDirty=this._display!==null;}this._updateDisplayData();return this._displayDirty;};Slot.prototype.init=function(slotData,armatureValue,rawDisplay,meshDisplay){if(this._slotData!==null){return;}this._slotData=slotData;this._isFromCache=false;this._visibleDirty=true;this._blendModeDirty=true;this._colorDirty=true;this._blendMode=this._slotData.blendMode;this._zOrder=this._slotData.zOrder;this._colorTransform.copyFrom(this._slotData.color);this._rawDisplay=rawDisplay;this._meshDisplay=meshDisplay;this._armature=armatureValue;var slotParent=this._armature.getBone(this._slotData.parent.name);if(slotParent!==null){this._parent=slotParent;}this._armature._addSlot(this);this._initDisplay(this._rawDisplay,false);if(this._rawDisplay!==this._meshDisplay){this._initDisplay(this._meshDisplay,false);}this._onUpdateDisplay();this._addDisplay();};Slot.prototype.update=function(cacheFrameIndex){this._isFromCache=false;if(this._displayDirty){this._displayDirty=false;this._updateDisplay();if(this._transformDirty){if(this.origin!==null){this.global.copyFrom(this.origin).add(this.offset).toMatrix(this._localMatrix);}else {this.global.copyFrom(this.offset).toMatrix(this._localMatrix);}}}if(this._zOrderDirty){this._zOrderDirty=false;this._updateZOrder();}if(cacheFrameIndex>=0&&this._cachedFrameIndices!==null){var cachedFrameIndex=this._cachedFrameIndices[cacheFrameIndex];if(cachedFrameIndex>=0&&this._cachedFrameIndex===cachedFrameIndex){this._transformDirty=false;}else if(cachedFrameIndex>=0){this._transformDirty=true;this._cachedFrameIndex=cachedFrameIndex;}else if(this._transformDirty||this._parent._childrenTransformDirty){this._transformDirty=true;this._cachedFrameIndex=-1;}else if(this._cachedFrameIndex>=0){this._transformDirty=false;this._cachedFrameIndices[cacheFrameIndex]=this._cachedFrameIndex;}else {this._transformDirty=true;this._cachedFrameIndex=-1;}}else if(this._transformDirty||this._parent._childrenTransformDirty){cacheFrameIndex=-1;this._transformDirty=true;this._cachedFrameIndex=-1;}if(this._display===null){return;}if(this._visibleDirty){this._visibleDirty=false;this._updateVisible();}if(this._blendModeDirty){this._blendModeDirty=false;this._updateBlendMode();}if(this._colorDirty){this._colorDirty=false;this._updateColor();}if(this._deformVertices!==null&&this._deformVertices.verticesData!==null&&this._display===this._meshDisplay){var isSkinned=this._deformVertices.verticesData.weight!==null;var isSurface=this._parent._boneData.type!==0;if(this._deformVertices.verticesDirty||isSkinned&&this._deformVertices.isBonesUpdate()||isSurface&&this._parent._childrenTransformDirty){this._deformVertices.verticesDirty=false;this._updateMesh();}if(isSkinned||isSurface){return;}}if(this._transformDirty){this._transformDirty=false;if(this._cachedFrameIndex<0){var isCache=cacheFrameIndex>=0;this._updateGlobalTransformMatrix(isCache);if(isCache&&this._cachedFrameIndices!==null){this._cachedFrameIndex=this._cachedFrameIndices[cacheFrameIndex]=this._armature._armatureData.setCacheFrame(this.globalTransformMatrix,this.global);}}else {this._isFromCache=true;this._armature._armatureData.getCacheFrame(this.globalTransformMatrix,this.global,this._cachedFrameIndex);}this._updateTransform();}};Slot.prototype.updateTransformAndMatrix=function(){if(this._transformDirty){this._transformDirty=false;this._updateGlobalTransformMatrix(false);}};Slot.prototype.replaceDisplayData=function(value,displayIndex){if(displayIndex===void 0){displayIndex=-1;}if(displayIndex<0){if(this._displayIndex<0){displayIndex=0;}else {displayIndex=this._displayIndex;}}if(this._displayDatas.length<=displayIndex){this._displayDatas.length=displayIndex+1;for(var i=0,l=this._displayDatas.length;i<l;++i){if(!this._displayDatas[i]){this._displayDatas[i]=null;}}}this._displayDatas[displayIndex]=value;};Slot.prototype.containsPoint=function(x,y){if(this._boundingBoxData===null){return false;}this.updateTransformAndMatrix();Slot._helpMatrix.copyFrom(this.globalTransformMatrix);Slot._helpMatrix.invert();Slot._helpMatrix.transformPoint(x,y,Slot._helpPoint);return this._boundingBoxData.containsPoint(Slot._helpPoint.x,Slot._helpPoint.y);};Slot.prototype.intersectsSegment=function(xA,yA,xB,yB,intersectionPointA,intersectionPointB,normalRadians){if(intersectionPointA===void 0){intersectionPointA=null;}if(intersectionPointB===void 0){intersectionPointB=null;}if(normalRadians===void 0){normalRadians=null;}if(this._boundingBoxData===null){return 0;}this.updateTransformAndMatrix();Slot._helpMatrix.copyFrom(this.globalTransformMatrix);Slot._helpMatrix.invert();Slot._helpMatrix.transformPoint(xA,yA,Slot._helpPoint);xA=Slot._helpPoint.x;yA=Slot._helpPoint.y;Slot._helpMatrix.transformPoint(xB,yB,Slot._helpPoint);xB=Slot._helpPoint.x;yB=Slot._helpPoint.y;var intersectionCount=this._boundingBoxData.intersectsSegment(xA,yA,xB,yB,intersectionPointA,intersectionPointB,normalRadians);if(intersectionCount>0){if(intersectionCount===1||intersectionCount===2){if(intersectionPointA!==null){this.globalTransformMatrix.transformPoint(intersectionPointA.x,intersectionPointA.y,intersectionPointA);if(intersectionPointB!==null){intersectionPointB.x=intersectionPointA.x;intersectionPointB.y=intersectionPointA.y;}}else if(intersectionPointB!==null){this.globalTransformMatrix.transformPoint(intersectionPointB.x,intersectionPointB.y,intersectionPointB);}}else {if(intersectionPointA!==null){this.globalTransformMatrix.transformPoint(intersectionPointA.x,intersectionPointA.y,intersectionPointA);}if(intersectionPointB!==null){this.globalTransformMatrix.transformPoint(intersectionPointB.x,intersectionPointB.y,intersectionPointB);}}if(normalRadians!==null){this.globalTransformMatrix.transformPoint(Math.cos(normalRadians.x),Math.sin(normalRadians.x),Slot._helpPoint,true);normalRadians.x=Math.atan2(Slot._helpPoint.y,Slot._helpPoint.x);this.globalTransformMatrix.transformPoint(Math.cos(normalRadians.y),Math.sin(normalRadians.y),Slot._helpPoint,true);normalRadians.y=Math.atan2(Slot._helpPoint.y,Slot._helpPoint.x);}}return intersectionCount;};Slot.prototype.invalidUpdate=function(){this._displayDirty=true;this._transformDirty=true;};Object.defineProperty(Slot.prototype,"visible",{get:function(){return this._visible;},set:function(value){if(this._visible===value){return;}this._visible=value;this._updateVisible();},enumerable:true,configurable:true});Object.defineProperty(Slot.prototype,"displayIndex",{get:function(){return this._displayIndex;},set:function(value){if(this._setDisplayIndex(value)){this.update(-1);}},enumerable:true,configurable:true});Object.defineProperty(Slot.prototype,"name",{get:function(){return this._slotData.name;},enumerable:true,configurable:true});Object.defineProperty(Slot.prototype,"displayList",{get:function(){return this._displayList.concat();},set:function(value){var backupDisplayList=this._displayList.concat();var disposeDisplayList=new Array();if(this._setDisplayList(value)){this.update(-1);}for(var _i=0,backupDisplayList_1=backupDisplayList;_i<backupDisplayList_1.length;_i++){var eachDisplay=backupDisplayList_1[_i];if(eachDisplay!==null&&eachDisplay!==this._rawDisplay&&eachDisplay!==this._meshDisplay&&this._displayList.indexOf(eachDisplay)<0&&disposeDisplayList.indexOf(eachDisplay)<0){disposeDisplayList.push(eachDisplay);}}for(var _a=0,disposeDisplayList_2=disposeDisplayList;_a<disposeDisplayList_2.length;_a++){var eachDisplay=disposeDisplayList_2[_a];if(eachDisplay instanceof dragonBones.Armature);else {this._disposeDisplay(eachDisplay,true);}}},enumerable:true,configurable:true});Object.defineProperty(Slot.prototype,"slotData",{get:function(){return this._slotData;},enumerable:true,configurable:true});Object.defineProperty(Slot.prototype,"rawDisplayDatas",{get:function(){return this._rawDisplayDatas;},set:function(value){if(this._rawDisplayDatas===value){return;}this._displayDirty=true;this._rawDisplayDatas=value;if(this._rawDisplayDatas!==null){this._displayDatas.length=this._rawDisplayDatas.length;for(var i=0,l=this._displayDatas.length;i<l;++i){var rawDisplayData=this._rawDisplayDatas[i];if(rawDisplayData===null){rawDisplayData=this._getDefaultRawDisplayData(i);}this._displayDatas[i]=rawDisplayData;}}else {this._displayDatas.length=0;}},enumerable:true,configurable:true});Object.defineProperty(Slot.prototype,"displayData",{get:function(){return this._displayData;},enumerable:true,configurable:true});Object.defineProperty(Slot.prototype,"boundingBoxData",{get:function(){return this._boundingBoxData;},enumerable:true,configurable:true});Object.defineProperty(Slot.prototype,"rawDisplay",{get:function(){return this._rawDisplay;},enumerable:true,configurable:true});Object.defineProperty(Slot.prototype,"meshDisplay",{get:function(){return this._meshDisplay;},enumerable:true,configurable:true});Object.defineProperty(Slot.prototype,"display",{get:function(){return this._display;},set:function(value){if(this._display===value){return;}var displayListLength=this._displayList.length;if(this._displayIndex<0&&displayListLength===0){this._displayIndex=0;}if(this._displayIndex<0){return;}else {var replaceDisplayList=this.displayList;if(displayListLength<=this._displayIndex){replaceDisplayList.length=this._displayIndex+1;}replaceDisplayList[this._displayIndex]=value;this.displayList=replaceDisplayList;}},enumerable:true,configurable:true});Object.defineProperty(Slot.prototype,"childArmature",{get:function(){return this._childArmature;},set:function(value){if(this._childArmature===value){return;}this.display=value;},enumerable:true,configurable:true});Object.defineProperty(Slot.prototype,"parent",{get:function(){return this._parent;},enumerable:true,configurable:true});Slot.prototype.getDisplay=function(){return this._display;};Slot.prototype.setDisplay=function(value){this.display=value;};return Slot;}(dragonBones.TransformObject);dragonBones.Slot=Slot;})(dragonBones||(dragonBones={}));(function(dragonBones){var Constraint=function(_super){__extends$1(Constraint,_super);function Constraint(){return _super!==null&&_super.apply(this,arguments)||this;}Constraint.prototype._onClear=function(){this._armature=null;this._target=null;this._root=null;this._bone=null;};Object.defineProperty(Constraint.prototype,"name",{get:function(){return this._constraintData.name;},enumerable:true,configurable:true});Constraint._helpMatrix=new dragonBones.Matrix();Constraint._helpTransform=new dragonBones.Transform();Constraint._helpPoint=new dragonBones.Point();return Constraint;}(dragonBones.BaseObject);dragonBones.Constraint=Constraint;var IKConstraint=function(_super){__extends$1(IKConstraint,_super);function IKConstraint(){return _super!==null&&_super.apply(this,arguments)||this;}IKConstraint.toString=function(){return "[class dragonBones.IKConstraint]";};IKConstraint.prototype._onClear=function(){_super.prototype._onClear.call(this);this._scaleEnabled=false;this._bendPositive=false;this._weight=1.0;this._constraintData=null;};IKConstraint.prototype._computeA=function(){var ikGlobal=this._target.global;var global=this._root.global;var globalTransformMatrix=this._root.globalTransformMatrix;var radian=Math.atan2(ikGlobal.y-global.y,ikGlobal.x-global.x);if(global.scaleX<0.0){radian+=Math.PI;}global.rotation+=dragonBones.Transform.normalizeRadian(radian-global.rotation)*this._weight;global.toMatrix(globalTransformMatrix);};IKConstraint.prototype._computeB=function(){var boneLength=this._bone._boneData.length;var parent=this._root;var ikGlobal=this._target.global;var parentGlobal=parent.global;var global=this._bone.global;var globalTransformMatrix=this._bone.globalTransformMatrix;var x=globalTransformMatrix.a*boneLength;var y=globalTransformMatrix.b*boneLength;var lLL=x*x+y*y;var lL=Math.sqrt(lLL);var dX=global.x-parentGlobal.x;var dY=global.y-parentGlobal.y;var lPP=dX*dX+dY*dY;var lP=Math.sqrt(lPP);var rawRadian=global.rotation;var rawParentRadian=parentGlobal.rotation;var rawRadianA=Math.atan2(dY,dX);dX=ikGlobal.x-parentGlobal.x;dY=ikGlobal.y-parentGlobal.y;var lTT=dX*dX+dY*dY;var lT=Math.sqrt(lTT);var radianA=0.0;if(lL+lP<=lT||lT+lL<=lP||lT+lP<=lL){radianA=Math.atan2(ikGlobal.y-parentGlobal.y,ikGlobal.x-parentGlobal.x);if(lL+lP<=lT);else if(lP<lL){radianA+=Math.PI;}}else {var h=(lPP-lLL+lTT)/(2.0*lTT);var r=Math.sqrt(lPP-h*h*lTT)/lT;var hX=parentGlobal.x+dX*h;var hY=parentGlobal.y+dY*h;var rX=-dY*r;var rY=dX*r;var isPPR=false;var parentParent=parent.parent;if(parentParent!==null){var parentParentMatrix=parentParent.globalTransformMatrix;isPPR=parentParentMatrix.a*parentParentMatrix.d-parentParentMatrix.b*parentParentMatrix.c<0.0;}if(isPPR!==this._bendPositive){global.x=hX-rX;global.y=hY-rY;}else {global.x=hX+rX;global.y=hY+rY;}radianA=Math.atan2(global.y-parentGlobal.y,global.x-parentGlobal.x);}var dR=dragonBones.Transform.normalizeRadian(radianA-rawRadianA);parentGlobal.rotation=rawParentRadian+dR*this._weight;parentGlobal.toMatrix(parent.globalTransformMatrix);var currentRadianA=rawRadianA+dR*this._weight;global.x=parentGlobal.x+Math.cos(currentRadianA)*lP;global.y=parentGlobal.y+Math.sin(currentRadianA)*lP;var radianB=Math.atan2(ikGlobal.y-global.y,ikGlobal.x-global.x);if(global.scaleX<0.0){radianB+=Math.PI;}global.rotation=parentGlobal.rotation+rawRadian-rawParentRadian+dragonBones.Transform.normalizeRadian(radianB-dR-rawRadian)*this._weight;global.toMatrix(globalTransformMatrix);};IKConstraint.prototype.init=function(constraintData,armature){if(this._constraintData!==null){return;}this._constraintData=constraintData;this._armature=armature;this._target=this._armature.getBone(this._constraintData.target.name);this._root=this._armature.getBone(this._constraintData.root.name);this._bone=this._constraintData.bone!==null?this._armature.getBone(this._constraintData.bone.name):null;{var ikConstraintData=this._constraintData;this._scaleEnabled=ikConstraintData.scaleEnabled;this._bendPositive=ikConstraintData.bendPositive;this._weight=ikConstraintData.weight;}this._root._hasConstraint=true;};IKConstraint.prototype.update=function(){this._root.updateByConstraint();if(this._bone!==null){this._bone.updateByConstraint();this._computeB();}else {this._computeA();}};IKConstraint.prototype.invalidUpdate=function(){this._root.invalidUpdate();if(this._bone!==null){this._bone.invalidUpdate();}};return IKConstraint;}(Constraint);dragonBones.IKConstraint=IKConstraint;var PathConstraint=function(_super){__extends$1(PathConstraint,_super);function PathConstraint(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this._bones=[];_this._spaces=[];_this._positions=[];_this._curves=[];_this._boneLengths=[];_this._pathGlobalVertices=[];_this._segments=[10];return _this;}PathConstraint.toString=function(){return "[class dragonBones.PathConstraint]";};PathConstraint.prototype._onClear=function(){_super.prototype._onClear.call(this);this.dirty=false;this.pathOffset=0;this.position=0.0;this.spacing=0.0;this.rotateOffset=0.0;this.rotateMix=1.0;this.translateMix=1.0;this._pathSlot=null;this._bones.length=0;this._spaces.length=0;this._positions.length=0;this._curves.length=0;this._boneLengths.length=0;this._pathGlobalVertices.length=0;};PathConstraint.prototype._updatePathVertices=function(verticesData){var armature=this._armature;var dragonBonesData=armature.armatureData.parent;var scale=armature.armatureData.scale;var intArray=dragonBonesData.intArray;var floatArray=dragonBonesData.floatArray;var pathOffset=verticesData.offset;var pathVertexCount=intArray[pathOffset+0];var pathVertexOffset=intArray[pathOffset+2];this._pathGlobalVertices.length=pathVertexCount*2;var weightData=verticesData.weight;if(weightData===null){var parentBone=this._pathSlot.parent;parentBone.updateByConstraint();var matrix=parentBone.globalTransformMatrix;for(var i=0,iV_1=pathVertexOffset;i<pathVertexCount;i+=2){var vx=floatArray[iV_1++]*scale;var vy=floatArray[iV_1++]*scale;var x=matrix.a*vx+matrix.c*vy+matrix.tx;var y=matrix.b*vx+matrix.d*vy+matrix.ty;this._pathGlobalVertices[i]=x;this._pathGlobalVertices[i+1]=y;}return;}var bones=this._pathSlot._deformVertices.bones;var weightBoneCount=weightData.bones.length;var weightOffset=weightData.offset;var floatOffset=intArray[weightOffset+1];var iV=floatOffset;var iB=weightOffset+2+weightBoneCount;for(var i=0,iW=0;i<pathVertexCount;i++){var vertexBoneCount=intArray[iB++];var xG=0.0,yG=0.0;for(var ii=0,ll=vertexBoneCount;ii<ll;ii++){var boneIndex=intArray[iB++];var bone=bones[boneIndex];if(bone===null){continue;}bone.updateByConstraint();var matrix=bone.globalTransformMatrix;var weight=floatArray[iV++];var vx=floatArray[iV++]*scale;var vy=floatArray[iV++]*scale;xG+=(matrix.a*vx+matrix.c*vy+matrix.tx)*weight;yG+=(matrix.b*vx+matrix.d*vy+matrix.ty)*weight;}this._pathGlobalVertices[iW++]=xG;this._pathGlobalVertices[iW++]=yG;}};PathConstraint.prototype._computeVertices=function(start,count,offset,out){for(var i=offset,iW=start;i<count;i+=2){out[i]=this._pathGlobalVertices[iW++];out[i+1]=this._pathGlobalVertices[iW++];}};PathConstraint.prototype._computeBezierCurve=function(pathDisplayDta,spaceCount,tangents,percentPosition,percentSpacing){var armature=this._armature;var intArray=armature.armatureData.parent.intArray;var vertexCount=intArray[pathDisplayDta.vertices.offset+0];var positions=this._positions;var spaces=this._spaces;var isClosed=pathDisplayDta.closed;var curveVertices=Array();var verticesLength=vertexCount*2;var curveCount=verticesLength/6;var preCurve=-1;var position=this.position;positions.length=spaceCount*3+2;var pathLength=0.0;if(!pathDisplayDta.constantSpeed){var lenghts=pathDisplayDta.curveLengths;curveCount-=isClosed?1:2;pathLength=lenghts[curveCount];if(percentPosition){position*=pathLength;}if(percentSpacing){for(var i=0;i<spaceCount;i++){spaces[i]*=pathLength;}}curveVertices.length=8;for(var i=0,o=0,curve=0;i<spaceCount;i++,o+=3){var space=spaces[i];position+=space;if(isClosed){position%=pathLength;if(position<0){position+=pathLength;}curve=0;}else if(position<0){continue;}else if(position>pathLength){continue;}var percent=0.0;for(;;curve++){var len=lenghts[curve];if(position>len){continue;}if(curve===0){percent=position/len;}else {var preLen=lenghts[curve-1];percent=(position-preLen)/(len-preLen);}break;}if(curve!==preCurve){preCurve=curve;if(isClosed&&curve===curveCount){this._computeVertices(verticesLength-4,4,0,curveVertices);this._computeVertices(0,4,4,curveVertices);}else {this._computeVertices(curve*6+2,8,0,curveVertices);}}this.addCurvePosition(percent,curveVertices[0],curveVertices[1],curveVertices[2],curveVertices[3],curveVertices[4],curveVertices[5],curveVertices[6],curveVertices[7],positions,o,tangents);}return;}if(isClosed){verticesLength+=2;curveVertices.length=vertexCount;this._computeVertices(2,verticesLength-4,0,curveVertices);this._computeVertices(0,2,verticesLength-4,curveVertices);curveVertices[verticesLength-2]=curveVertices[0];curveVertices[verticesLength-1]=curveVertices[1];}else {curveCount--;verticesLength-=4;curveVertices.length=verticesLength;this._computeVertices(2,verticesLength,0,curveVertices);}var curves=new Array(curveCount);pathLength=0;var x1=curveVertices[0],y1=curveVertices[1],cx1=0,cy1=0,cx2=0,cy2=0,x2=0,y2=0;var tmpx,tmpy,dddfx,dddfy,ddfx,ddfy,dfx,dfy;for(var i=0,w=2;i<curveCount;i++,w+=6){cx1=curveVertices[w];cy1=curveVertices[w+1];cx2=curveVertices[w+2];cy2=curveVertices[w+3];x2=curveVertices[w+4];y2=curveVertices[w+5];tmpx=(x1-cx1*2+cx2)*0.1875;tmpy=(y1-cy1*2+cy2)*0.1875;dddfx=((cx1-cx2)*3-x1+x2)*0.09375;dddfy=((cy1-cy2)*3-y1+y2)*0.09375;ddfx=tmpx*2+dddfx;ddfy=tmpy*2+dddfy;dfx=(cx1-x1)*0.75+tmpx+dddfx*0.16666667;dfy=(cy1-y1)*0.75+tmpy+dddfy*0.16666667;pathLength+=Math.sqrt(dfx*dfx+dfy*dfy);dfx+=ddfx;dfy+=ddfy;ddfx+=dddfx;ddfy+=dddfy;pathLength+=Math.sqrt(dfx*dfx+dfy*dfy);dfx+=ddfx;dfy+=ddfy;pathLength+=Math.sqrt(dfx*dfx+dfy*dfy);dfx+=ddfx+dddfx;dfy+=ddfy+dddfy;pathLength+=Math.sqrt(dfx*dfx+dfy*dfy);curves[i]=pathLength;x1=x2;y1=y2;}if(percentPosition){position*=pathLength;}if(percentSpacing){for(var i=0;i<spaceCount;i++){spaces[i]*=pathLength;}}var segments=this._segments;var curveLength=0;for(var i=0,o=0,curve=0,segment=0;i<spaceCount;i++,o+=3){var space=spaces[i];position+=space;var p=position;if(isClosed){p%=pathLength;if(p<0)p+=pathLength;curve=0;}else if(p<0){continue;}else if(p>pathLength){continue;}for(;;curve++){var length_1=curves[curve];if(p>length_1)continue;if(curve===0)p/=length_1;else {var prev=curves[curve-1];p=(p-prev)/(length_1-prev);}break;}if(curve!==preCurve){preCurve=curve;var ii=curve*6;x1=curveVertices[ii];y1=curveVertices[ii+1];cx1=curveVertices[ii+2];cy1=curveVertices[ii+3];cx2=curveVertices[ii+4];cy2=curveVertices[ii+5];x2=curveVertices[ii+6];y2=curveVertices[ii+7];tmpx=(x1-cx1*2+cx2)*0.03;tmpy=(y1-cy1*2+cy2)*0.03;dddfx=((cx1-cx2)*3-x1+x2)*0.006;dddfy=((cy1-cy2)*3-y1+y2)*0.006;ddfx=tmpx*2+dddfx;ddfy=tmpy*2+dddfy;dfx=(cx1-x1)*0.3+tmpx+dddfx*0.16666667;dfy=(cy1-y1)*0.3+tmpy+dddfy*0.16666667;curveLength=Math.sqrt(dfx*dfx+dfy*dfy);segments[0]=curveLength;for(ii=1;ii<8;ii++){dfx+=ddfx;dfy+=ddfy;ddfx+=dddfx;ddfy+=dddfy;curveLength+=Math.sqrt(dfx*dfx+dfy*dfy);segments[ii]=curveLength;}dfx+=ddfx;dfy+=ddfy;curveLength+=Math.sqrt(dfx*dfx+dfy*dfy);segments[8]=curveLength;dfx+=ddfx+dddfx;dfy+=ddfy+dddfy;curveLength+=Math.sqrt(dfx*dfx+dfy*dfy);segments[9]=curveLength;segment=0;}p*=curveLength;for(;;segment++){var length_2=segments[segment];if(p>length_2)continue;if(segment===0)p/=length_2;else {var prev=segments[segment-1];p=segment+(p-prev)/(length_2-prev);}break;}this.addCurvePosition(p*0.1,x1,y1,cx1,cy1,cx2,cy2,x2,y2,positions,o,tangents);}};PathConstraint.prototype.addCurvePosition=function(t,x1,y1,cx1,cy1,cx2,cy2,x2,y2,out,offset,tangents){if(t===0){out[offset]=x1;out[offset+1]=y1;out[offset+2]=0;return;}if(t===1){out[offset]=x2;out[offset+1]=y2;out[offset+2]=0;return;}var mt=1-t;var mt2=mt*mt;var t2=t*t;var a=mt2*mt;var b=mt2*t*3;var c=mt*t2*3;var d=t*t2;var x=a*x1+b*cx1+c*cx2+d*x2;var y=a*y1+b*cy1+c*cy2+d*y2;out[offset]=x;out[offset+1]=y;if(tangents){out[offset+2]=Math.atan2(y-(a*y1+b*cy1+c*cy2),x-(a*x1+b*cx1+c*cx2));}else {out[offset+2]=0;}};PathConstraint.prototype.init=function(constraintData,armature){this._constraintData=constraintData;this._armature=armature;var data=constraintData;this.pathOffset=data.pathDisplayData.vertices.offset;this.position=data.position;this.spacing=data.spacing;this.rotateOffset=data.rotateOffset;this.rotateMix=data.rotateMix;this.translateMix=data.translateMix;this._root=this._armature.getBone(data.root.name);this._target=this._armature.getBone(data.target.name);this._pathSlot=this._armature.getSlot(data.pathSlot.name);for(var i=0,l=data.bones.length;i<l;i++){var bone=this._armature.getBone(data.bones[i].name);if(bone!==null){this._bones.push(bone);}}if(data.rotateMode===2){this._boneLengths.length=this._bones.length;}this._root._hasConstraint=true;};PathConstraint.prototype.update=function(){var pathSlot=this._pathSlot;if(pathSlot._deformVertices===null||pathSlot._deformVertices.verticesData===null||pathSlot._deformVertices.verticesData.offset!==this.pathOffset){return;}var constraintData=this._constraintData;var pathDisplayData=pathSlot._displayData;var isPathVerticeDirty=false;var deformVertices=pathSlot._deformVertices;if(this._root._childrenTransformDirty){this._updatePathVertices(pathDisplayData.vertices);isPathVerticeDirty=true;}else if(deformVertices!==null&&(deformVertices.verticesDirty||deformVertices.isBonesUpdate())){this._updatePathVertices(pathDisplayData.vertices);deformVertices.verticesDirty=false;isPathVerticeDirty=true;}if(!isPathVerticeDirty&&!this.dirty){return;}var positionMode=constraintData.positionMode;var spacingMode=constraintData.spacingMode;var rotateMode=constraintData.rotateMode;var bones=this._bones;var isLengthMode=spacingMode===0;var isChainScaleMode=rotateMode===2;var isTangentMode=rotateMode===0;var boneCount=bones.length;var spacesCount=isTangentMode?boneCount:boneCount+1;var spacing=this.spacing;var spaces=this._spaces;spaces.length=spacesCount;if(isChainScaleMode||isLengthMode){spaces[0]=0;for(var i=0,l=spacesCount-1;i<l;i++){var bone=bones[i];bone.updateByConstraint();var boneLength=bone._boneData.length;var matrix=bone.globalTransformMatrix;var x=boneLength*matrix.a;var y=boneLength*matrix.b;var len=Math.sqrt(x*x+y*y);if(isChainScaleMode){this._boneLengths[i]=len;}spaces[i+1]=(boneLength+spacing)*len/boneLength;}}else {for(var i=0;i<spacesCount;i++){spaces[i]=spacing;}}this._computeBezierCurve(pathDisplayData,spacesCount,isTangentMode,positionMode===1,spacingMode===2);var positions=this._positions;var rotateOffset=this.rotateOffset;var boneX=positions[0],boneY=positions[1];var tip;if(rotateOffset===0){tip=rotateMode===1;}else {tip=false;var bone=pathSlot.parent;if(bone!==null){var matrix=bone.globalTransformMatrix;rotateOffset*=matrix.a*matrix.d-matrix.b*matrix.c>0?dragonBones.Transform.DEG_RAD:-dragonBones.Transform.DEG_RAD;}}var rotateMix=this.rotateMix;var translateMix=this.translateMix;for(var i=0,p=3;i<boneCount;i++,p+=3){var bone=bones[i];bone.updateByConstraint();var matrix=bone.globalTransformMatrix;matrix.tx+=(boneX-matrix.tx)*translateMix;matrix.ty+=(boneY-matrix.ty)*translateMix;var x=positions[p],y=positions[p+1];var dx=x-boneX,dy=y-boneY;if(isChainScaleMode){var lenght=this._boneLengths[i];var s=(Math.sqrt(dx*dx+dy*dy)/lenght-1)*rotateMix+1;matrix.a*=s;matrix.b*=s;}boneX=x;boneY=y;if(rotateMix>0){var a=matrix.a,b=matrix.b,c=matrix.c,d=matrix.d,r=void 0,cos=void 0,sin=void 0;if(isTangentMode){r=positions[p-1];}else {r=Math.atan2(dy,dx);}r-=Math.atan2(b,a);if(tip){cos=Math.cos(r);sin=Math.sin(r);var length_3=bone._boneData.length;boneX+=(length_3*(cos*a-sin*b)-dx)*rotateMix;boneY+=(length_3*(sin*a+cos*b)-dy)*rotateMix;}else {r+=rotateOffset;}if(r>dragonBones.Transform.PI){r-=dragonBones.Transform.PI_D;}else if(r<-dragonBones.Transform.PI){r+=dragonBones.Transform.PI_D;}r*=rotateMix;cos=Math.cos(r);sin=Math.sin(r);matrix.a=cos*a-sin*b;matrix.b=sin*a+cos*b;matrix.c=cos*c-sin*d;matrix.d=sin*c+cos*d;}bone.global.fromMatrix(matrix);}this.dirty=false;};PathConstraint.prototype.invalidUpdate=function(){};return PathConstraint;}(Constraint);dragonBones.PathConstraint=PathConstraint;})(dragonBones||(dragonBones={}));(function(dragonBones){var WorldClock=function(){function WorldClock(time){if(time===void 0){time=0.0;}this.time=0.0;this.timeScale=1.0;this._systemTime=0.0;this._animatebles=[];this._clock=null;this.time=time;this._systemTime=new Date().getTime()*0.001;}WorldClock.prototype.advanceTime=function(passedTime){if(passedTime!==passedTime){passedTime=0.0;}var currentTime=Date.now()*0.001;if(passedTime<0.0){passedTime=currentTime-this._systemTime;}this._systemTime=currentTime;if(this.timeScale!==1.0){passedTime*=this.timeScale;}if(passedTime===0.0){return;}if(passedTime<0.0){this.time-=passedTime;}else {this.time+=passedTime;}var i=0,r=0,l=this._animatebles.length;for(;i<l;++i){var animatable=this._animatebles[i];if(animatable!==null){if(r>0){this._animatebles[i-r]=animatable;this._animatebles[i]=null;}animatable.advanceTime(passedTime);}else {r++;}}if(r>0){l=this._animatebles.length;for(;i<l;++i){var animateble=this._animatebles[i];if(animateble!==null){this._animatebles[i-r]=animateble;}else {r++;}}this._animatebles.length-=r;}};WorldClock.prototype.contains=function(value){if(value===this){return false;}var ancestor=value;while(ancestor!==this&&ancestor!==null){ancestor=ancestor.clock;}return ancestor===this;};WorldClock.prototype.add=function(value){if(this._animatebles.indexOf(value)<0){this._animatebles.push(value);value.clock=this;}};WorldClock.prototype.remove=function(value){var index=this._animatebles.indexOf(value);if(index>=0){this._animatebles[index]=null;value.clock=null;}};WorldClock.prototype.clear=function(){for(var _i=0,_a=this._animatebles;_i<_a.length;_i++){var animatable=_a[_i];if(animatable!==null){animatable.clock=null;}}};Object.defineProperty(WorldClock.prototype,"clock",{get:function(){return this._clock;},set:function(value){if(this._clock===value){return;}if(this._clock!==null){this._clock.remove(this);}this._clock=value;if(this._clock!==null){this._clock.add(this);}},enumerable:true,configurable:true});WorldClock.clock=new WorldClock();return WorldClock;}();dragonBones.WorldClock=WorldClock;})(dragonBones||(dragonBones={}));(function(dragonBones){var Animation=function(_super){__extends$1(Animation,_super);function Animation(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this._animationNames=[];_this._animationStates=[];_this._animations={};_this._animationConfig=null;return _this;}Animation.toString=function(){return "[class dragonBones.Animation]";};Animation.prototype._onClear=function(){for(var _i=0,_a=this._animationStates;_i<_a.length;_i++){var animationState=_a[_i];animationState.returnToPool();}for(var k in this._animations){delete this._animations[k];}if(this._animationConfig!==null){this._animationConfig.returnToPool();}this.timeScale=1.0;this._lockUpdate=false;this._animationDirty=false;this._inheritTimeScale=1.0;this._animationNames.length=0;this._animationStates.length=0;this._armature=null;this._animationConfig=null;this._lastAnimationState=null;};Animation.prototype._fadeOut=function(animationConfig){switch(animationConfig.fadeOutMode){case 1:for(var _i=0,_a=this._animationStates;_i<_a.length;_i++){var animationState=_a[_i];if(animationState._parent!==null){continue;}if(animationState.layer===animationConfig.layer){animationState.fadeOut(animationConfig.fadeOutTime,animationConfig.pauseFadeOut);}}break;case 2:for(var _b=0,_c=this._animationStates;_b<_c.length;_b++){var animationState=_c[_b];if(animationState._parent!==null){continue;}if(animationState.group===animationConfig.group){animationState.fadeOut(animationConfig.fadeOutTime,animationConfig.pauseFadeOut);}}break;case 3:for(var _d=0,_e=this._animationStates;_d<_e.length;_d++){var animationState=_e[_d];if(animationState._parent!==null){continue;}if(animationState.layer===animationConfig.layer&&animationState.group===animationConfig.group){animationState.fadeOut(animationConfig.fadeOutTime,animationConfig.pauseFadeOut);}}break;case 4:for(var _f=0,_g=this._animationStates;_f<_g.length;_f++){var animationState=_g[_f];if(animationState._parent!==null){continue;}animationState.fadeOut(animationConfig.fadeOutTime,animationConfig.pauseFadeOut);}break;}};Animation.prototype.init=function(armature){if(this._armature!==null){return;}this._armature=armature;this._animationConfig=dragonBones.BaseObject.borrowObject(dragonBones.AnimationConfig);};Animation.prototype.advanceTime=function(passedTime){if(passedTime<0.0){passedTime=-passedTime;}if(this._armature.inheritAnimation&&this._armature._parent!==null){this._inheritTimeScale=this._armature._parent._armature.animation._inheritTimeScale*this.timeScale;}else {this._inheritTimeScale=this.timeScale;}if(this._inheritTimeScale!==1.0){passedTime*=this._inheritTimeScale;}var animationStateCount=this._animationStates.length;if(animationStateCount===1){var animationState=this._animationStates[0];if(animationState._fadeState>0&&animationState._subFadeState>0){this._armature._dragonBones.bufferObject(animationState);this._animationStates.length=0;this._lastAnimationState=null;}else {var animationData=animationState._animationData;var cacheFrameRate=animationData.cacheFrameRate;if(this._animationDirty&&cacheFrameRate>0.0){this._animationDirty=false;for(var _i=0,_a=this._armature.getBones();_i<_a.length;_i++){var bone=_a[_i];bone._cachedFrameIndices=animationData.getBoneCachedFrameIndices(bone.name);}for(var _b=0,_c=this._armature.getSlots();_b<_c.length;_b++){var slot=_c[_b];var rawDisplayDatas=slot.rawDisplayDatas;if(rawDisplayDatas!==null&&rawDisplayDatas.length>0){var rawDsplayData=rawDisplayDatas[0];if(rawDsplayData!==null){if(rawDsplayData.parent===this._armature.armatureData.defaultSkin){slot._cachedFrameIndices=animationData.getSlotCachedFrameIndices(slot.name);continue;}}}slot._cachedFrameIndices=null;}}animationState.advanceTime(passedTime,cacheFrameRate);}}else if(animationStateCount>1){for(var i=0,r=0;i<animationStateCount;++i){var animationState=this._animationStates[i];if(animationState._fadeState>0&&animationState._subFadeState>0){r++;this._armature._dragonBones.bufferObject(animationState);this._animationDirty=true;if(this._lastAnimationState===animationState){this._lastAnimationState=null;}}else {if(r>0){this._animationStates[i-r]=animationState;}animationState.advanceTime(passedTime,0.0);}if(i===animationStateCount-1&&r>0){this._animationStates.length-=r;if(this._lastAnimationState===null&&this._animationStates.length>0){this._lastAnimationState=this._animationStates[this._animationStates.length-1];}}}this._armature._cacheFrameIndex=-1;}else {this._armature._cacheFrameIndex=-1;}};Animation.prototype.reset=function(){for(var _i=0,_a=this._animationStates;_i<_a.length;_i++){var animationState=_a[_i];animationState.returnToPool();}this._animationDirty=false;this._animationConfig.clear();this._animationStates.length=0;this._lastAnimationState=null;};Animation.prototype.stop=function(animationName){if(animationName===void 0){animationName=null;}if(animationName!==null){var animationState=this.getState(animationName);if(animationState!==null){animationState.stop();}}else {for(var _i=0,_a=this._animationStates;_i<_a.length;_i++){var animationState=_a[_i];animationState.stop();}}};Animation.prototype.playConfig=function(animationConfig){var animationName=animationConfig.animation;if(!(animationName in this._animations)){console.warn("Non-existent animation.\n","DragonBones name: "+this._armature.armatureData.parent.name,"Armature name: "+this._armature.name,"Animation name: "+animationName);return null;}var animationData=this._animations[animationName];if(animationConfig.fadeOutMode===5){for(var _i=0,_a=this._animationStates;_i<_a.length;_i++){var animationState_1=_a[_i];if(animationState_1._animationData===animationData){return animationState_1;}}}if(this._animationStates.length===0){animationConfig.fadeInTime=0.0;}else if(animationConfig.fadeInTime<0.0){animationConfig.fadeInTime=animationData.fadeInTime;}if(animationConfig.fadeOutTime<0.0){animationConfig.fadeOutTime=animationConfig.fadeInTime;}if(animationConfig.timeScale<=-100.0){animationConfig.timeScale=1.0/animationData.scale;}if(animationData.frameCount>1){if(animationConfig.position<0.0){animationConfig.position%=animationData.duration;animationConfig.position=animationData.duration-animationConfig.position;}else if(animationConfig.position===animationData.duration){animationConfig.position-=0.000001;}else if(animationConfig.position>animationData.duration){animationConfig.position%=animationData.duration;}if(animationConfig.duration>0.0&&animationConfig.position+animationConfig.duration>animationData.duration){animationConfig.duration=animationData.duration-animationConfig.position;}if(animationConfig.playTimes<0){animationConfig.playTimes=animationData.playTimes;}}else {animationConfig.playTimes=1;animationConfig.position=0.0;if(animationConfig.duration>0.0){animationConfig.duration=0.0;}}if(animationConfig.duration===0.0){animationConfig.duration=-1.0;}this._fadeOut(animationConfig);var animationState=dragonBones.BaseObject.borrowObject(dragonBones.AnimationState);animationState.init(this._armature,animationData,animationConfig);this._animationDirty=true;this._armature._cacheFrameIndex=-1;if(this._animationStates.length>0){var added=false;for(var i=0,l=this._animationStates.length;i<l;++i){if(animationState.layer>this._animationStates[i].layer){added=true;this._animationStates.splice(i,0,animationState);break;}else if(i!==l-1&&animationState.layer>this._animationStates[i+1].layer){added=true;this._animationStates.splice(i+1,0,animationState);break;}}if(!added){this._animationStates.push(animationState);}}else {this._animationStates.push(animationState);}for(var _b=0,_c=this._armature.getSlots();_b<_c.length;_b++){var slot=_c[_b];var childArmature=slot.childArmature;if(childArmature!==null&&childArmature.inheritAnimation&&childArmature.animation.hasAnimation(animationName)&&childArmature.animation.getState(animationName)===null){childArmature.animation.fadeIn(animationName);}}var isLocked=false;for(var k in animationData.animationTimelines){if(!this._lockUpdate){isLocked=true;this._lockUpdate=true;}var childAnimatiionState=this.fadeIn(k,animationConfig.fadeInTime,1,animationState.layer,null,0);if(childAnimatiionState!==null){childAnimatiionState.resetToPose=false;childAnimatiionState._parent=animationState;childAnimatiionState.stop();}}if(isLocked){this._lockUpdate=false;}if(!this._lockUpdate){if(animationConfig.fadeInTime<=0.0){this._armature.advanceTime(0.0);}this._lastAnimationState=animationState;}return animationState;};Animation.prototype.play=function(animationName,playTimes){if(animationName===void 0){animationName=null;}if(playTimes===void 0){playTimes=-1;}this._animationConfig.clear();this._animationConfig.resetToPose=true;this._animationConfig.playTimes=playTimes;this._animationConfig.fadeInTime=0.0;this._animationConfig.animation=animationName!==null?animationName:"";if(animationName!==null&&animationName.length>0){this.playConfig(this._animationConfig);}else if(this._lastAnimationState===null){var defaultAnimation=this._armature.armatureData.defaultAnimation;if(defaultAnimation!==null){this._animationConfig.animation=defaultAnimation.name;this.playConfig(this._animationConfig);}}else if(!this._lastAnimationState.isPlaying&&!this._lastAnimationState.isCompleted){this._lastAnimationState.play();}else {this._animationConfig.animation=this._lastAnimationState.name;this.playConfig(this._animationConfig);}return this._lastAnimationState;};Animation.prototype.fadeIn=function(animationName,fadeInTime,playTimes,layer,group,fadeOutMode){if(fadeInTime===void 0){fadeInTime=-1.0;}if(playTimes===void 0){playTimes=-1;}if(layer===void 0){layer=0;}if(group===void 0){group=null;}if(fadeOutMode===void 0){fadeOutMode=3;}this._animationConfig.clear();this._animationConfig.fadeOutMode=fadeOutMode;this._animationConfig.playTimes=playTimes;this._animationConfig.layer=layer;this._animationConfig.fadeInTime=fadeInTime;this._animationConfig.animation=animationName;this._animationConfig.group=group!==null?group:"";return this.playConfig(this._animationConfig);};Animation.prototype.gotoAndPlayByTime=function(animationName,time,playTimes){if(time===void 0){time=0.0;}if(playTimes===void 0){playTimes=-1;}this._animationConfig.clear();this._animationConfig.resetToPose=true;this._animationConfig.playTimes=playTimes;this._animationConfig.position=time;this._animationConfig.fadeInTime=0.0;this._animationConfig.animation=animationName;return this.playConfig(this._animationConfig);};Animation.prototype.gotoAndPlayByFrame=function(animationName,frame,playTimes){if(frame===void 0){frame=0;}if(playTimes===void 0){playTimes=-1;}this._animationConfig.clear();this._animationConfig.resetToPose=true;this._animationConfig.playTimes=playTimes;this._animationConfig.fadeInTime=0.0;this._animationConfig.animation=animationName;var animationData=animationName in this._animations?this._animations[animationName]:null;if(animationData!==null){this._animationConfig.position=animationData.duration*frame/animationData.frameCount;}return this.playConfig(this._animationConfig);};Animation.prototype.gotoAndPlayByProgress=function(animationName,progress,playTimes){if(progress===void 0){progress=0.0;}if(playTimes===void 0){playTimes=-1;}this._animationConfig.clear();this._animationConfig.resetToPose=true;this._animationConfig.playTimes=playTimes;this._animationConfig.fadeInTime=0.0;this._animationConfig.animation=animationName;var animationData=animationName in this._animations?this._animations[animationName]:null;if(animationData!==null){this._animationConfig.position=animationData.duration*(progress>0.0?progress:0.0);}return this.playConfig(this._animationConfig);};Animation.prototype.gotoAndStopByTime=function(animationName,time){if(time===void 0){time=0.0;}var animationState=this.gotoAndPlayByTime(animationName,time,1);if(animationState!==null){animationState.stop();}return animationState;};Animation.prototype.gotoAndStopByFrame=function(animationName,frame){if(frame===void 0){frame=0;}var animationState=this.gotoAndPlayByFrame(animationName,frame,1);if(animationState!==null){animationState.stop();}return animationState;};Animation.prototype.gotoAndStopByProgress=function(animationName,progress){if(progress===void 0){progress=0.0;}var animationState=this.gotoAndPlayByProgress(animationName,progress,1);if(animationState!==null){animationState.stop();}return animationState;};Animation.prototype.getState=function(animationName){var i=this._animationStates.length;while(i--){var animationState=this._animationStates[i];if(animationState.name===animationName){return animationState;}}return null;};Animation.prototype.hasAnimation=function(animationName){return animationName in this._animations;};Animation.prototype.getStates=function(){return this._animationStates;};Object.defineProperty(Animation.prototype,"isPlaying",{get:function(){for(var _i=0,_a=this._animationStates;_i<_a.length;_i++){var animationState=_a[_i];if(animationState.isPlaying){return true;}}return false;},enumerable:true,configurable:true});Object.defineProperty(Animation.prototype,"isCompleted",{get:function(){for(var _i=0,_a=this._animationStates;_i<_a.length;_i++){var animationState=_a[_i];if(!animationState.isCompleted){return false;}}return this._animationStates.length>0;},enumerable:true,configurable:true});Object.defineProperty(Animation.prototype,"lastAnimationName",{get:function(){return this._lastAnimationState!==null?this._lastAnimationState.name:"";},enumerable:true,configurable:true});Object.defineProperty(Animation.prototype,"animationNames",{get:function(){return this._animationNames;},enumerable:true,configurable:true});Object.defineProperty(Animation.prototype,"animations",{get:function(){return this._animations;},set:function(value){if(this._animations===value){return;}this._animationNames.length=0;for(var k in this._animations){delete this._animations[k];}for(var k in value){this._animationNames.push(k);this._animations[k]=value[k];}},enumerable:true,configurable:true});Object.defineProperty(Animation.prototype,"animationConfig",{get:function(){this._animationConfig.clear();return this._animationConfig;},enumerable:true,configurable:true});Object.defineProperty(Animation.prototype,"lastAnimationState",{get:function(){return this._lastAnimationState;},enumerable:true,configurable:true});Animation.prototype.gotoAndPlay=function(animationName,fadeInTime,duration,playTimes,layer,group,fadeOutMode,pauseFadeOut,pauseFadeIn){if(fadeInTime===void 0){fadeInTime=-1;}if(duration===void 0){duration=-1;}if(playTimes===void 0){playTimes=-1;}if(layer===void 0){layer=0;}if(group===void 0){group=null;}if(fadeOutMode===void 0){fadeOutMode=3;}console.warn("Deprecated.");this._animationConfig.clear();this._animationConfig.resetToPose=true;this._animationConfig.fadeOutMode=fadeOutMode;this._animationConfig.playTimes=playTimes;this._animationConfig.layer=layer;this._animationConfig.fadeInTime=fadeInTime;this._animationConfig.animation=animationName;this._animationConfig.group=group!==null?group:"";var animationData=this._animations[animationName];if(animationData&&duration>0.0){this._animationConfig.timeScale=animationData.duration/duration;}return this.playConfig(this._animationConfig);};Animation.prototype.gotoAndStop=function(animationName,time){if(time===void 0){time=0;}console.warn("Deprecated.");return this.gotoAndStopByTime(animationName,time);};Object.defineProperty(Animation.prototype,"animationList",{get:function(){console.warn("Deprecated.");return this._animationNames;},enumerable:true,configurable:true});Object.defineProperty(Animation.prototype,"animationDataList",{get:function(){console.warn("Deprecated.");var list=[];for(var i=0,l=this._animationNames.length;i<l;++i){list.push(this._animations[this._animationNames[i]]);}return list;},enumerable:true,configurable:true});return Animation;}(dragonBones.BaseObject);dragonBones.Animation=Animation;})(dragonBones||(dragonBones={}));(function(dragonBones){var AnimationState=function(_super){__extends$1(AnimationState,_super);function AnimationState(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this._blendState=new BlendState();_this._boneMask=[];_this._boneTimelines=[];_this._surfaceTimelines=[];_this._slotTimelines=[];_this._constraintTimelines=[];_this._animationTimelines=[];_this._poseTimelines=[];_this._bonePoses={};_this._actionTimeline=null;_this._zOrderTimeline=null;_this._parent=null;return _this;}AnimationState.toString=function(){return "[class dragonBones.AnimationState]";};AnimationState.prototype._onClear=function(){for(var _i=0,_a=this._boneTimelines;_i<_a.length;_i++){var timeline=_a[_i];timeline.returnToPool();}for(var _b=0,_c=this._surfaceTimelines;_b<_c.length;_b++){var timeline=_c[_b];timeline.returnToPool();}for(var _d=0,_e=this._slotTimelines;_d<_e.length;_d++){var timeline=_e[_d];timeline.returnToPool();}for(var _f=0,_g=this._constraintTimelines;_f<_g.length;_f++){var timeline=_g[_f];timeline.returnToPool();}for(var _h=0,_j=this._animationTimelines;_h<_j.length;_h++){var timeline=_j[_h];timeline.returnToPool();}for(var k in this._bonePoses){this._bonePoses[k].returnToPool();delete this._bonePoses[k];}if(this._actionTimeline!==null){this._actionTimeline.returnToPool();}if(this._zOrderTimeline!==null){this._zOrderTimeline.returnToPool();}this.actionEnabled=false;this.additiveBlending=false;this.displayControl=false;this.resetToPose=false;this.playTimes=1;this.layer=0;this.timeScale=1.0;this.weight=1.0;this.autoFadeOutTime=0.0;this.fadeTotalTime=0.0;this.name="";this.group="";this._timelineDirty=2;this._playheadState=0;this._fadeState=-1;this._subFadeState=-1;this._position=0.0;this._duration=0.0;this._fadeTime=0.0;this._time=0.0;this._fadeProgress=0.0;this._weightResult=0.0;this._blendState.clear();this._boneMask.length=0;this._boneTimelines.length=0;this._surfaceTimelines.length=0;this._slotTimelines.length=0;this._constraintTimelines.length=0;this._animationTimelines.length=0;this._poseTimelines.length=0;this._animationData=null;this._armature=null;this._actionTimeline=null;this._zOrderTimeline=null;this._parent=null;};AnimationState.prototype._updateTimelines=function(){{for(var _i=0,_a=this._armature._constraints;_i<_a.length;_i++){var constraint=_a[_i];var timelineDatas=this._animationData.getConstraintTimelines(constraint.name);if(timelineDatas!==null){for(var _b=0,timelineDatas_1=timelineDatas;_b<timelineDatas_1.length;_b++){var timelineData=timelineDatas_1[_b];switch(timelineData.type){case 30:{var timeline=dragonBones.BaseObject.borrowObject(dragonBones.IKConstraintTimelineState);timeline.constraint=constraint;timeline.init(this._armature,this,timelineData);this._constraintTimelines.push(timeline);break;}}}}else if(this.resetToPose){var timeline=dragonBones.BaseObject.borrowObject(dragonBones.IKConstraintTimelineState);timeline.constraint=constraint;timeline.init(this._armature,this,null);this._constraintTimelines.push(timeline);this._poseTimelines.push(timeline);}}}{for(var _c=0,_d=this._armature.animation.getStates();_c<_d.length;_c++){var animationState=_d[_c];if(animationState._parent!==this){continue;}var timelineDatas=this._animationData.getAnimationTimelines(animationState.name);if(timelineDatas===null){continue;}for(var _e=0,timelineDatas_2=timelineDatas;_e<timelineDatas_2.length;_e++){var timelineData=timelineDatas_2[_e];switch(timelineData.type){case 40:{var timeline=dragonBones.BaseObject.borrowObject(dragonBones.AnimationTimelineState);timeline.animationState=animationState;timeline.init(this._armature,this,timelineData);this._animationTimelines.push(timeline);break;}}}}}};AnimationState.prototype._updateBoneAndSlotTimelines=function(){{var boneTimelines={};for(var _i=0,_a=this._boneTimelines;_i<_a.length;_i++){var timeline=_a[_i];var timelineName=timeline.bone.name;if(!(timelineName in boneTimelines)){boneTimelines[timelineName]=[];}boneTimelines[timelineName].push(timeline);}for(var _b=0,_c=this._armature.getBones();_b<_c.length;_b++){var bone=_c[_b];var timelineName=bone.name;if(!this.containsBoneMask(timelineName)){continue;}if(timelineName in boneTimelines){delete boneTimelines[timelineName];}else if(bone._boneData.type===0){var timelineDatas=this._animationData.getBoneTimelines(timelineName);var bonePose=timelineName in this._bonePoses?this._bonePoses[timelineName]:this._bonePoses[timelineName]=dragonBones.BaseObject.borrowObject(BonePose);if(timelineDatas!==null){for(var _d=0,timelineDatas_3=timelineDatas;_d<timelineDatas_3.length;_d++){var timelineData=timelineDatas_3[_d];switch(timelineData.type){case 10:{var timeline=dragonBones.BaseObject.borrowObject(dragonBones.BoneAllTimelineState);timeline.bone=bone;timeline.bonePose=bonePose;timeline.init(this._armature,this,timelineData);this._boneTimelines.push(timeline);break;}case 11:{var timeline=dragonBones.BaseObject.borrowObject(dragonBones.BoneTranslateTimelineState);timeline.bone=bone;timeline.bonePose=bonePose;timeline.init(this._armature,this,timelineData);this._boneTimelines.push(timeline);break;}case 12:{var timeline=dragonBones.BaseObject.borrowObject(dragonBones.BoneRotateTimelineState);timeline.bone=bone;timeline.bonePose=bonePose;timeline.init(this._armature,this,timelineData);this._boneTimelines.push(timeline);break;}case 13:{var timeline=dragonBones.BaseObject.borrowObject(dragonBones.BoneScaleTimelineState);timeline.bone=bone;timeline.bonePose=bonePose;timeline.init(this._armature,this,timelineData);this._boneTimelines.push(timeline);break;}}}}else if(this.resetToPose){var timeline=dragonBones.BaseObject.borrowObject(dragonBones.BoneAllTimelineState);timeline.bone=bone;timeline.bonePose=bonePose;timeline.init(this._armature,this,null);this._boneTimelines.push(timeline);this._poseTimelines.push(timeline);}}else if(bone._boneData.type===1){var timelineDatas=this._animationData.getSurfaceTimelines(timelineName);if(timelineDatas!==null){for(var _e=0,timelineDatas_4=timelineDatas;_e<timelineDatas_4.length;_e++){var timelineData=timelineDatas_4[_e];switch(timelineData.type){case 50:{var timeline=dragonBones.BaseObject.borrowObject(dragonBones.SurfaceTimelineState);timeline.surface=bone;timeline.init(this._armature,this,timelineData);this._surfaceTimelines.push(timeline);break;}}}}else if(this.resetToPose){var timeline=dragonBones.BaseObject.borrowObject(dragonBones.SurfaceTimelineState);timeline.surface=bone;timeline.init(this._armature,this,null);this._surfaceTimelines.push(timeline);this._poseTimelines.push(timeline);}}}for(var k in boneTimelines){for(var _f=0,_g=boneTimelines[k];_f<_g.length;_f++){var timeline=_g[_f];this._boneTimelines.splice(this._boneTimelines.indexOf(timeline),1);timeline.returnToPool();}}}{var slotTimelines={};var ffdFlags=[];for(var _h=0,_j=this._slotTimelines;_h<_j.length;_h++){var timeline=_j[_h];var timelineName=timeline.slot.name;if(!(timelineName in slotTimelines)){slotTimelines[timelineName]=[];}slotTimelines[timelineName].push(timeline);}for(var _k=0,_l=this._armature.getSlots();_k<_l.length;_k++){var slot=_l[_k];var boneName=slot.parent.name;if(!this.containsBoneMask(boneName)){continue;}var timelineName=slot.name;var timelineDatas=this._animationData.getSlotTimelines(timelineName);if(timelineName in slotTimelines){delete slotTimelines[timelineName];}else {var displayIndexFlag=false;var colorFlag=false;ffdFlags.length=0;if(timelineDatas!==null){for(var _m=0,timelineDatas_5=timelineDatas;_m<timelineDatas_5.length;_m++){var timelineData=timelineDatas_5[_m];switch(timelineData.type){case 20:{var timeline=dragonBones.BaseObject.borrowObject(dragonBones.SlotDislayTimelineState);timeline.slot=slot;timeline.init(this._armature,this,timelineData);this._slotTimelines.push(timeline);displayIndexFlag=true;break;}case 21:{var timeline=dragonBones.BaseObject.borrowObject(dragonBones.SlotColorTimelineState);timeline.slot=slot;timeline.init(this._armature,this,timelineData);this._slotTimelines.push(timeline);colorFlag=true;break;}case 22:{var timeline=dragonBones.BaseObject.borrowObject(dragonBones.DeformTimelineState);timeline.slot=slot;timeline.init(this._armature,this,timelineData);this._slotTimelines.push(timeline);ffdFlags.push(timeline.vertexOffset);break;}}}}if(this.resetToPose){if(!displayIndexFlag){var timeline=dragonBones.BaseObject.borrowObject(dragonBones.SlotDislayTimelineState);timeline.slot=slot;timeline.init(this._armature,this,null);this._slotTimelines.push(timeline);this._poseTimelines.push(timeline);}if(!colorFlag){var timeline=dragonBones.BaseObject.borrowObject(dragonBones.SlotColorTimelineState);timeline.slot=slot;timeline.init(this._armature,this,null);this._slotTimelines.push(timeline);this._poseTimelines.push(timeline);}if(slot.rawDisplayDatas!==null){for(var _o=0,_p=slot.rawDisplayDatas;_o<_p.length;_o++){var displayData=_p[_o];if(displayData!==null&&displayData.type===2){var meshOffset=displayData.vertices.offset;if(ffdFlags.indexOf(meshOffset)<0){var timeline=dragonBones.BaseObject.borrowObject(dragonBones.DeformTimelineState);timeline.vertexOffset=meshOffset;timeline.slot=slot;timeline.init(this._armature,this,null);this._slotTimelines.push(timeline);this._poseTimelines.push(timeline);}}}}}}}for(var k in slotTimelines){for(var _q=0,_r=slotTimelines[k];_q<_r.length;_q++){var timeline=_r[_q];this._slotTimelines.splice(this._slotTimelines.indexOf(timeline),1);timeline.returnToPool();}}}};AnimationState.prototype._advanceFadeTime=function(passedTime){var isFadeOut=this._fadeState>0;if(this._subFadeState<0){this._subFadeState=0;var eventType=isFadeOut?dragonBones.EventObject.FADE_OUT:dragonBones.EventObject.FADE_IN;if(this._armature.eventDispatcher.hasDBEventListener(eventType)){var eventObject=dragonBones.BaseObject.borrowObject(dragonBones.EventObject);eventObject.type=eventType;eventObject.armature=this._armature;eventObject.animationState=this;this._armature._dragonBones.bufferEvent(eventObject);}}if(passedTime<0.0){passedTime=-passedTime;}this._fadeTime+=passedTime;if(this._fadeTime>=this.fadeTotalTime){this._subFadeState=1;this._fadeProgress=isFadeOut?0.0:1.0;}else if(this._fadeTime>0.0){this._fadeProgress=isFadeOut?1.0-this._fadeTime/this.fadeTotalTime:this._fadeTime/this.fadeTotalTime;}else {this._fadeProgress=isFadeOut?1.0:0.0;}if(this._subFadeState>0){if(!isFadeOut){this._playheadState|=1;this._fadeState=0;}var eventType=isFadeOut?dragonBones.EventObject.FADE_OUT_COMPLETE:dragonBones.EventObject.FADE_IN_COMPLETE;if(this._armature.eventDispatcher.hasDBEventListener(eventType)){var eventObject=dragonBones.BaseObject.borrowObject(dragonBones.EventObject);eventObject.type=eventType;eventObject.armature=this._armature;eventObject.animationState=this;this._armature._dragonBones.bufferEvent(eventObject);}}};AnimationState.prototype.init=function(armature,animationData,animationConfig){if(this._armature!==null){return;}this._armature=armature;this._animationData=animationData;this.resetToPose=animationConfig.resetToPose;this.additiveBlending=animationConfig.additiveBlending;this.displayControl=animationConfig.displayControl;this.actionEnabled=animationConfig.actionEnabled;this.layer=animationConfig.layer;this.playTimes=animationConfig.playTimes;this.timeScale=animationConfig.timeScale;this.fadeTotalTime=animationConfig.fadeInTime;this.autoFadeOutTime=animationConfig.autoFadeOutTime;this.weight=animationConfig.weight;this.name=animationConfig.name.length>0?animationConfig.name:animationConfig.animation;this.group=animationConfig.group;if(animationConfig.pauseFadeIn){this._playheadState=2;}else {this._playheadState=3;}if(animationConfig.duration<0.0){this._position=0.0;this._duration=this._animationData.duration;if(animationConfig.position!==0.0){if(this.timeScale>=0.0){this._time=animationConfig.position;}else {this._time=animationConfig.position-this._duration;}}else {this._time=0.0;}}else {this._position=animationConfig.position;this._duration=animationConfig.duration;this._time=0.0;}if(this.timeScale<0.0&&this._time===0.0){this._time=-0.000001;}if(this.fadeTotalTime<=0.0){this._fadeProgress=0.999999;}if(animationConfig.boneMask.length>0){this._boneMask.length=animationConfig.boneMask.length;for(var i=0,l=this._boneMask.length;i<l;++i){this._boneMask[i]=animationConfig.boneMask[i];}}this._actionTimeline=dragonBones.BaseObject.borrowObject(dragonBones.ActionTimelineState);this._actionTimeline.init(this._armature,this,this._animationData.actionTimeline);this._actionTimeline.currentTime=this._time;if(this._actionTimeline.currentTime<0.0){this._actionTimeline.currentTime=this._duration-this._actionTimeline.currentTime;}if(this._animationData.zOrderTimeline!==null){this._zOrderTimeline=dragonBones.BaseObject.borrowObject(dragonBones.ZOrderTimelineState);this._zOrderTimeline.init(this._armature,this,this._animationData.zOrderTimeline);}};AnimationState.prototype.advanceTime=function(passedTime,cacheFrameRate){this._blendState.dirty=false;if(this._fadeState!==0||this._subFadeState!==0){this._advanceFadeTime(passedTime);}if(this._playheadState===3){if(this.timeScale!==1.0){passedTime*=this.timeScale;}this._time+=passedTime;}if(this._timelineDirty!==0){if(this._timelineDirty===2){this._updateTimelines();}this._timelineDirty=0;this._updateBoneAndSlotTimelines();}if(this.weight===0.0){return;}var isCacheEnabled=this._fadeState===0&&cacheFrameRate>0.0;var isUpdateTimeline=true;var isUpdateBoneTimeline=true;var time=this._time;this._weightResult=this.weight*this._fadeProgress;if(this._parent!==null){this._weightResult*=this._parent._weightResult/this._parent._fadeProgress;}if(this._actionTimeline.playState<=0){this._actionTimeline.update(time);}if(isCacheEnabled){var internval=cacheFrameRate*2.0;this._actionTimeline.currentTime=Math.floor(this._actionTimeline.currentTime*internval)/internval;}if(this._zOrderTimeline!==null&&this._zOrderTimeline.playState<=0){this._zOrderTimeline.update(time);}if(isCacheEnabled){var cacheFrameIndex=Math.floor(this._actionTimeline.currentTime*cacheFrameRate);if(this._armature._cacheFrameIndex===cacheFrameIndex){isUpdateTimeline=false;isUpdateBoneTimeline=false;}else {this._armature._cacheFrameIndex=cacheFrameIndex;if(this._animationData.cachedFrames[cacheFrameIndex]){isUpdateBoneTimeline=false;}else {this._animationData.cachedFrames[cacheFrameIndex]=true;}}}if(isUpdateTimeline){if(isUpdateBoneTimeline){for(var i=0,l=this._boneTimelines.length;i<l;++i){var timeline=this._boneTimelines[i];if(timeline.playState<=0){timeline.update(time);}if(i===l-1||timeline.bone!==this._boneTimelines[i+1].bone){var state=timeline.bone._blendState.update(this._weightResult,this.layer);if(state!==0){timeline.blend(state);}}}}for(var i=0,l=this._surfaceTimelines.length;i<l;++i){var timeline=this._surfaceTimelines[i];var state=timeline.surface._blendState.update(this._weightResult,this.layer);if(timeline.playState<=0){timeline.update(time);}if(state!==0){timeline.blend(state);}}if(this.displayControl){for(var i=0,l=this._slotTimelines.length;i<l;++i){var timeline=this._slotTimelines[i];var displayController=timeline.slot.displayController;if(displayController===null||displayController===this.name||displayController===this.group){if(timeline.playState<=0){timeline.update(time);}}}}for(var i=0,l=this._constraintTimelines.length;i<l;++i){var timeline=this._constraintTimelines[i];if(timeline.playState<=0){timeline.update(time);}}for(var i=0,l=this._animationTimelines.length;i<l;++i){var timeline=this._animationTimelines[i];var state=timeline.animationState._blendState.update(this._weightResult,this.layer);if(timeline.playState<=0){timeline.update(time);}if(state!==0){timeline.blend(state);}}}if(this._fadeState===0){if(this._subFadeState>0){this._subFadeState=0;if(this._poseTimelines.length>0){for(var _i=0,_a=this._poseTimelines;_i<_a.length;_i++){var timeline=_a[_i];if(timeline instanceof dragonBones.BoneTimelineState){this._boneTimelines.splice(this._boneTimelines.indexOf(timeline),1);}else if(timeline instanceof dragonBones.SurfaceTimelineState){this._surfaceTimelines.splice(this._surfaceTimelines.indexOf(timeline),1);}else if(timeline instanceof dragonBones.SlotTimelineState){this._slotTimelines.splice(this._slotTimelines.indexOf(timeline),1);}else if(timeline instanceof dragonBones.ConstraintTimelineState){this._constraintTimelines.splice(this._constraintTimelines.indexOf(timeline),1);}timeline.returnToPool();}this._poseTimelines.length=0;}}if(this._actionTimeline.playState>0){if(this.autoFadeOutTime>=0.0){this.fadeOut(this.autoFadeOutTime);}}}};AnimationState.prototype.play=function(){this._playheadState=3;};AnimationState.prototype.stop=function(){this._playheadState&=1;};AnimationState.prototype.fadeOut=function(fadeOutTime,pausePlayhead){if(pausePlayhead===void 0){pausePlayhead=true;}if(fadeOutTime<0.0){fadeOutTime=0.0;}if(pausePlayhead){this._playheadState&=2;}if(this._fadeState>0){if(fadeOutTime>this.fadeTotalTime-this._fadeTime){return;}}else {this._fadeState=1;this._subFadeState=-1;if(fadeOutTime<=0.0||this._fadeProgress<=0.0){this._fadeProgress=0.000001;}for(var _i=0,_a=this._boneTimelines;_i<_a.length;_i++){var timeline=_a[_i];timeline.fadeOut();}for(var _b=0,_c=this._surfaceTimelines;_b<_c.length;_b++){var timeline=_c[_b];timeline.fadeOut();}for(var _d=0,_e=this._slotTimelines;_d<_e.length;_d++){var timeline=_e[_d];timeline.fadeOut();}for(var _f=0,_g=this._constraintTimelines;_f<_g.length;_f++){var timeline=_g[_f];timeline.fadeOut();}for(var _h=0,_j=this._animationTimelines;_h<_j.length;_h++){var timeline=_j[_h];timeline.animationState.fadeOut(fadeOutTime,pausePlayhead);timeline.fadeOut();}}this.displayControl=false;this.fadeTotalTime=this._fadeProgress>0.000001?fadeOutTime/this._fadeProgress:0.0;this._fadeTime=this.fadeTotalTime*(1.0-this._fadeProgress);};AnimationState.prototype.containsBoneMask=function(boneName){return this._boneMask.length===0||this._boneMask.indexOf(boneName)>=0;};AnimationState.prototype.addBoneMask=function(boneName,recursive){if(recursive===void 0){recursive=true;}var currentBone=this._armature.getBone(boneName);if(currentBone===null){return;}if(this._boneMask.indexOf(boneName)<0){this._boneMask.push(boneName);}if(recursive){for(var _i=0,_a=this._armature.getBones();_i<_a.length;_i++){var bone=_a[_i];if(this._boneMask.indexOf(bone.name)<0&&currentBone.contains(bone)){this._boneMask.push(bone.name);}}}this._timelineDirty=1;};AnimationState.prototype.removeBoneMask=function(boneName,recursive){if(recursive===void 0){recursive=true;}var index=this._boneMask.indexOf(boneName);if(index>=0){this._boneMask.splice(index,1);}if(recursive){var currentBone=this._armature.getBone(boneName);if(currentBone!==null){var bones=this._armature.getBones();if(this._boneMask.length>0){for(var _i=0,bones_1=bones;_i<bones_1.length;_i++){var bone=bones_1[_i];var index_2=this._boneMask.indexOf(bone.name);if(index_2>=0&&currentBone.contains(bone)){this._boneMask.splice(index_2,1);}}}else {for(var _a=0,bones_2=bones;_a<bones_2.length;_a++){var bone=bones_2[_a];if(bone===currentBone){continue;}if(!currentBone.contains(bone)){this._boneMask.push(bone.name);}}}}}this._timelineDirty=1;};AnimationState.prototype.removeAllBoneMask=function(){this._boneMask.length=0;this._timelineDirty=1;};Object.defineProperty(AnimationState.prototype,"isFadeIn",{get:function(){return this._fadeState<0;},enumerable:true,configurable:true});Object.defineProperty(AnimationState.prototype,"isFadeOut",{get:function(){return this._fadeState>0;},enumerable:true,configurable:true});Object.defineProperty(AnimationState.prototype,"isFadeComplete",{get:function(){return this._fadeState===0;},enumerable:true,configurable:true});Object.defineProperty(AnimationState.prototype,"isPlaying",{get:function(){return (this._playheadState&2)!==0&&this._actionTimeline.playState<=0;},enumerable:true,configurable:true});Object.defineProperty(AnimationState.prototype,"isCompleted",{get:function(){return this._actionTimeline.playState>0;},enumerable:true,configurable:true});Object.defineProperty(AnimationState.prototype,"currentPlayTimes",{get:function(){return this._actionTimeline.currentPlayTimes;},enumerable:true,configurable:true});Object.defineProperty(AnimationState.prototype,"totalTime",{get:function(){return this._duration;},enumerable:true,configurable:true});Object.defineProperty(AnimationState.prototype,"currentTime",{get:function(){return this._actionTimeline.currentTime;},set:function(value){var currentPlayTimes=this._actionTimeline.currentPlayTimes-(this._actionTimeline.playState>0?1:0);if(value<0||this._duration<value){value=value%this._duration+currentPlayTimes*this._duration;if(value<0){value+=this._duration;}}if(this.playTimes>0&&currentPlayTimes===this.playTimes-1&&value===this._duration){value=this._duration-0.000001;}if(this._time===value){return;}this._time=value;this._actionTimeline.setCurrentTime(this._time);if(this._zOrderTimeline!==null){this._zOrderTimeline.playState=-1;}for(var _i=0,_a=this._boneTimelines;_i<_a.length;_i++){var timeline=_a[_i];timeline.playState=-1;}for(var _b=0,_c=this._slotTimelines;_b<_c.length;_b++){var timeline=_c[_b];timeline.playState=-1;}},enumerable:true,configurable:true});Object.defineProperty(AnimationState.prototype,"animationData",{get:function(){return this._animationData;},enumerable:true,configurable:true});return AnimationState;}(dragonBones.BaseObject);dragonBones.AnimationState=AnimationState;var BonePose=function(_super){__extends$1(BonePose,_super);function BonePose(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.current=new dragonBones.Transform();_this.delta=new dragonBones.Transform();_this.result=new dragonBones.Transform();return _this;}BonePose.toString=function(){return "[class dragonBones.BonePose]";};BonePose.prototype._onClear=function(){this.current.identity();this.delta.identity();this.result.identity();};return BonePose;}(dragonBones.BaseObject);dragonBones.BonePose=BonePose;var BlendState=function(){function BlendState(){}BlendState.prototype.update=function(weight,p_layer){if(this.dirty){if(this.leftWeight>0.0){if(this.layer!==p_layer){if(this.layerWeight>=this.leftWeight){this.leftWeight=0.0;return 0;}else {this.layer=p_layer;this.leftWeight-=this.layerWeight;this.layerWeight=0.0;}}}else {return 0;}weight*=this.leftWeight;this.layerWeight+=weight;this.blendWeight=weight;return 2;}this.dirty=true;this.layer=p_layer;this.layerWeight=weight;this.leftWeight=1.0;this.blendWeight=weight;return 1;};BlendState.prototype.clear=function(){this.dirty=false;this.layer=0;this.leftWeight=0.0;this.layerWeight=0.0;this.blendWeight=0.0;};return BlendState;}();dragonBones.BlendState=BlendState;})(dragonBones||(dragonBones={}));(function(dragonBones){var TimelineState=function(_super){__extends$1(TimelineState,_super);function TimelineState(){return _super!==null&&_super.apply(this,arguments)||this;}TimelineState.prototype._onClear=function(){this.playState=-1;this.currentPlayTimes=-1;this.currentTime=-1.0;this._tweenState=0;this._frameRate=0;this._frameValueOffset=0;this._frameCount=0;this._frameOffset=0;this._frameIndex=-1;this._frameRateR=0.0;this._position=0.0;this._duration=0.0;this._timeScale=1.0;this._timeOffset=0.0;this._dragonBonesData=null;this._animationData=null;this._timelineData=null;this._armature=null;this._animationState=null;this._actionTimeline=null;this._frameArray=null;this._frameIntArray=null;this._frameFloatArray=null;this._timelineArray=null;this._frameIndices=null;};TimelineState.prototype._setCurrentTime=function(passedTime){var prevState=this.playState;var prevPlayTimes=this.currentPlayTimes;var prevTime=this.currentTime;if(this._actionTimeline!==null&&this._frameCount<=1){this.playState=this._actionTimeline.playState>=0?1:-1;this.currentPlayTimes=1;this.currentTime=this._actionTimeline.currentTime;}else if(this._actionTimeline===null||this._timeScale!==1.0||this._timeOffset!==0.0){var playTimes=this._animationState.playTimes;var totalTime=playTimes*this._duration;passedTime*=this._timeScale;if(this._timeOffset!==0.0){passedTime+=this._timeOffset*this._animationData.duration;}if(playTimes>0&&(passedTime>=totalTime||passedTime<=-totalTime)){if(this.playState<=0&&this._animationState._playheadState===3){this.playState=1;}this.currentPlayTimes=playTimes;if(passedTime<0.0){this.currentTime=0.0;}else {this.currentTime=this._duration+0.000001;}}else {if(this.playState!==0&&this._animationState._playheadState===3){this.playState=0;}if(passedTime<0.0){passedTime=-passedTime;this.currentPlayTimes=Math.floor(passedTime/this._duration);this.currentTime=this._duration-passedTime%this._duration;}else {this.currentPlayTimes=Math.floor(passedTime/this._duration);this.currentTime=passedTime%this._duration;}}this.currentTime+=this._position;}else {this.playState=this._actionTimeline.playState;this.currentPlayTimes=this._actionTimeline.currentPlayTimes;this.currentTime=this._actionTimeline.currentTime;}if(this.currentPlayTimes===prevPlayTimes&&this.currentTime===prevTime){return false;}if(prevState<0&&this.playState!==prevState||this.playState<=0&&this.currentPlayTimes!==prevPlayTimes){this._frameIndex=-1;}return true;};TimelineState.prototype.init=function(armature,animationState,timelineData){this._armature=armature;this._animationState=animationState;this._timelineData=timelineData;this._actionTimeline=this._animationState._actionTimeline;if(this===this._actionTimeline){this._actionTimeline=null;}this._animationData=this._animationState._animationData;this._frameRate=this._animationData.parent.frameRate;this._frameRateR=1.0/this._frameRate;this._position=this._animationState._position;this._duration=this._animationState._duration;this._dragonBonesData=this._animationData.parent.parent;if(this._timelineData!==null){this._frameIntArray=this._dragonBonesData.frameIntArray;this._frameFloatArray=this._dragonBonesData.frameFloatArray;this._frameArray=this._dragonBonesData.frameArray;this._timelineArray=this._dragonBonesData.timelineArray;this._frameIndices=this._dragonBonesData.frameIndices;this._frameCount=this._timelineArray[this._timelineData.offset+2];this._frameValueOffset=this._timelineArray[this._timelineData.offset+4];this._timeScale=100.0/this._timelineArray[this._timelineData.offset+0];this._timeOffset=this._timelineArray[this._timelineData.offset+1]*0.01;}};TimelineState.prototype.fadeOut=function(){};TimelineState.prototype.update=function(passedTime){if(this._setCurrentTime(passedTime)){if(this._frameCount>1){var timelineFrameIndex=Math.floor(this.currentTime*this._frameRate);var frameIndex=this._frameIndices[this._timelineData.frameIndicesOffset+timelineFrameIndex];if(this._frameIndex!==frameIndex){this._frameIndex=frameIndex;this._frameOffset=this._animationData.frameOffset+this._timelineArray[this._timelineData.offset+5+this._frameIndex];this._onArriveAtFrame();}}else if(this._frameIndex<0){this._frameIndex=0;if(this._timelineData!==null){this._frameOffset=this._animationData.frameOffset+this._timelineArray[this._timelineData.offset+5];}this._onArriveAtFrame();}if(this._tweenState!==0){this._onUpdateFrame();}}};return TimelineState;}(dragonBones.BaseObject);dragonBones.TimelineState=TimelineState;var TweenTimelineState=function(_super){__extends$1(TweenTimelineState,_super);function TweenTimelineState(){return _super!==null&&_super.apply(this,arguments)||this;}TweenTimelineState._getEasingValue=function(tweenType,progress,easing){var value=progress;switch(tweenType){case 3:value=Math.pow(progress,2.0);break;case 4:value=1.0-Math.pow(1.0-progress,2.0);break;case 5:value=0.5*(1.0-Math.cos(progress*Math.PI));break;}return (value-progress)*easing+progress;};TweenTimelineState._getEasingCurveValue=function(progress,samples,count,offset){if(progress<=0.0){return 0.0;}else if(progress>=1.0){return 1.0;}var segmentCount=count+1;var valueIndex=Math.floor(progress*segmentCount);var fromValue=valueIndex===0?0.0:samples[offset+valueIndex-1];var toValue=valueIndex===segmentCount-1?10000.0:samples[offset+valueIndex];return (fromValue+(toValue-fromValue)*(progress*segmentCount-valueIndex))*0.0001;};TweenTimelineState.prototype._onClear=function(){_super.prototype._onClear.call(this);this._tweenType=0;this._curveCount=0;this._framePosition=0.0;this._frameDurationR=0.0;this._tweenProgress=0.0;this._tweenEasing=0.0;};TweenTimelineState.prototype._onArriveAtFrame=function(){if(this._frameCount>1&&(this._frameIndex!==this._frameCount-1||this._animationState.playTimes===0||this._animationState.currentPlayTimes<this._animationState.playTimes-1)){this._tweenType=this._frameArray[this._frameOffset+1];this._tweenState=this._tweenType===0?1:2;if(this._tweenType===2){this._curveCount=this._frameArray[this._frameOffset+2];}else if(this._tweenType!==0&&this._tweenType!==1){this._tweenEasing=this._frameArray[this._frameOffset+2]*0.01;}this._framePosition=this._frameArray[this._frameOffset]*this._frameRateR;if(this._frameIndex===this._frameCount-1){this._frameDurationR=1.0/(this._animationData.duration-this._framePosition);}else {var nextFrameOffset=this._animationData.frameOffset+this._timelineArray[this._timelineData.offset+5+this._frameIndex+1];var frameDuration=this._frameArray[nextFrameOffset]*this._frameRateR-this._framePosition;if(frameDuration>0){this._frameDurationR=1.0/frameDuration;}else {this._frameDurationR=0.0;}}}else {this._tweenState=1;}};TweenTimelineState.prototype._onUpdateFrame=function(){if(this._tweenState===2){this._tweenProgress=(this.currentTime-this._framePosition)*this._frameDurationR;if(this._tweenType===2){this._tweenProgress=TweenTimelineState._getEasingCurveValue(this._tweenProgress,this._frameArray,this._curveCount,this._frameOffset+3);}else if(this._tweenType!==1){this._tweenProgress=TweenTimelineState._getEasingValue(this._tweenType,this._tweenProgress,this._tweenEasing);}}else {this._tweenProgress=0.0;}};return TweenTimelineState;}(TimelineState);dragonBones.TweenTimelineState=TweenTimelineState;var BoneTimelineState=function(_super){__extends$1(BoneTimelineState,_super);function BoneTimelineState(){return _super!==null&&_super.apply(this,arguments)||this;}BoneTimelineState.prototype._onClear=function(){_super.prototype._onClear.call(this);this.bone=null;this.bonePose=null;};BoneTimelineState.prototype.blend=function(state){var blendWeight=this.bone._blendState.blendWeight;var animationPose=this.bone.animationPose;var result=this.bonePose.result;if(state===2){animationPose.x+=result.x*blendWeight;animationPose.y+=result.y*blendWeight;animationPose.rotation+=result.rotation*blendWeight;animationPose.skew+=result.skew*blendWeight;animationPose.scaleX+=(result.scaleX-1.0)*blendWeight;animationPose.scaleY+=(result.scaleY-1.0)*blendWeight;}else if(blendWeight!==1.0){animationPose.x=result.x*blendWeight;animationPose.y=result.y*blendWeight;animationPose.rotation=result.rotation*blendWeight;animationPose.skew=result.skew*blendWeight;animationPose.scaleX=(result.scaleX-1.0)*blendWeight+1.0;animationPose.scaleY=(result.scaleY-1.0)*blendWeight+1.0;}else {animationPose.x=result.x;animationPose.y=result.y;animationPose.rotation=result.rotation;animationPose.skew=result.skew;animationPose.scaleX=result.scaleX;animationPose.scaleY=result.scaleY;}if(this._animationState._fadeState!==0||this._animationState._subFadeState!==0){this.bone._transformDirty=true;}};return BoneTimelineState;}(TweenTimelineState);dragonBones.BoneTimelineState=BoneTimelineState;var SlotTimelineState=function(_super){__extends$1(SlotTimelineState,_super);function SlotTimelineState(){return _super!==null&&_super.apply(this,arguments)||this;}SlotTimelineState.prototype._onClear=function(){_super.prototype._onClear.call(this);this.slot=null;};return SlotTimelineState;}(TweenTimelineState);dragonBones.SlotTimelineState=SlotTimelineState;var ConstraintTimelineState=function(_super){__extends$1(ConstraintTimelineState,_super);function ConstraintTimelineState(){return _super!==null&&_super.apply(this,arguments)||this;}ConstraintTimelineState.prototype._onClear=function(){_super.prototype._onClear.call(this);this.constraint=null;};return ConstraintTimelineState;}(TweenTimelineState);dragonBones.ConstraintTimelineState=ConstraintTimelineState;})(dragonBones||(dragonBones={}));(function(dragonBones){var ActionTimelineState=function(_super){__extends$1(ActionTimelineState,_super);function ActionTimelineState(){return _super!==null&&_super.apply(this,arguments)||this;}ActionTimelineState.toString=function(){return "[class dragonBones.ActionTimelineState]";};ActionTimelineState.prototype._onCrossFrame=function(frameIndex){var eventDispatcher=this._armature.eventDispatcher;if(this._animationState.actionEnabled){var frameOffset=this._animationData.frameOffset+this._timelineArray[this._timelineData.offset+5+frameIndex];var actionCount=this._frameArray[frameOffset+1];var actions=this._animationData.parent.actions;for(var i=0;i<actionCount;++i){var actionIndex=this._frameArray[frameOffset+2+i];var action=actions[actionIndex];if(action.type===0){var eventObject=dragonBones.BaseObject.borrowObject(dragonBones.EventObject);eventObject.time=this._frameArray[frameOffset]/this._frameRate;eventObject.animationState=this._animationState;dragonBones.EventObject.actionDataToInstance(action,eventObject,this._armature);this._armature._bufferAction(eventObject,true);}else {var eventType=action.type===10?dragonBones.EventObject.FRAME_EVENT:dragonBones.EventObject.SOUND_EVENT;if(action.type===11||eventDispatcher.hasDBEventListener(eventType)){var eventObject=dragonBones.BaseObject.borrowObject(dragonBones.EventObject);eventObject.time=this._frameArray[frameOffset]/this._frameRate;eventObject.animationState=this._animationState;dragonBones.EventObject.actionDataToInstance(action,eventObject,this._armature);this._armature._dragonBones.bufferEvent(eventObject);}}}}};ActionTimelineState.prototype._onArriveAtFrame=function(){};ActionTimelineState.prototype._onUpdateFrame=function(){};ActionTimelineState.prototype.update=function(passedTime){var prevState=this.playState;var prevPlayTimes=this.currentPlayTimes;var prevTime=this.currentTime;if(this._setCurrentTime(passedTime)){var eventDispatcher=this._armature.eventDispatcher;if(prevState<0){if(this.playState!==prevState){if(this._animationState.displayControl&&this._animationState.resetToPose){this._armature._sortZOrder(null,0);}prevPlayTimes=this.currentPlayTimes;if(eventDispatcher.hasDBEventListener(dragonBones.EventObject.START)){var eventObject=dragonBones.BaseObject.borrowObject(dragonBones.EventObject);eventObject.type=dragonBones.EventObject.START;eventObject.armature=this._armature;eventObject.animationState=this._animationState;this._armature._dragonBones.bufferEvent(eventObject);}}else {return;}}var isReverse=this._animationState.timeScale<0.0;var loopCompleteEvent=null;var completeEvent=null;if(this.currentPlayTimes!==prevPlayTimes){if(eventDispatcher.hasDBEventListener(dragonBones.EventObject.LOOP_COMPLETE)){loopCompleteEvent=dragonBones.BaseObject.borrowObject(dragonBones.EventObject);loopCompleteEvent.type=dragonBones.EventObject.LOOP_COMPLETE;loopCompleteEvent.armature=this._armature;loopCompleteEvent.animationState=this._animationState;}if(this.playState>0){if(eventDispatcher.hasDBEventListener(dragonBones.EventObject.COMPLETE)){completeEvent=dragonBones.BaseObject.borrowObject(dragonBones.EventObject);completeEvent.type=dragonBones.EventObject.COMPLETE;completeEvent.armature=this._armature;completeEvent.animationState=this._animationState;}}}if(this._frameCount>1){var timelineData=this._timelineData;var timelineFrameIndex=Math.floor(this.currentTime*this._frameRate);var frameIndex=this._frameIndices[timelineData.frameIndicesOffset+timelineFrameIndex];if(this._frameIndex!==frameIndex){var crossedFrameIndex=this._frameIndex;this._frameIndex=frameIndex;if(this._timelineArray!==null){this._frameOffset=this._animationData.frameOffset+this._timelineArray[timelineData.offset+5+this._frameIndex];if(isReverse){if(crossedFrameIndex<0){var prevFrameIndex=Math.floor(prevTime*this._frameRate);crossedFrameIndex=this._frameIndices[timelineData.frameIndicesOffset+prevFrameIndex];if(this.currentPlayTimes===prevPlayTimes){if(crossedFrameIndex===frameIndex){crossedFrameIndex=-1;}}}while(crossedFrameIndex>=0){var frameOffset=this._animationData.frameOffset+this._timelineArray[timelineData.offset+5+crossedFrameIndex];var framePosition=this._frameArray[frameOffset]/this._frameRate;if(this._position<=framePosition&&framePosition<=this._position+this._duration){this._onCrossFrame(crossedFrameIndex);}if(loopCompleteEvent!==null&&crossedFrameIndex===0){this._armature._dragonBones.bufferEvent(loopCompleteEvent);loopCompleteEvent=null;}if(crossedFrameIndex>0){crossedFrameIndex--;}else {crossedFrameIndex=this._frameCount-1;}if(crossedFrameIndex===frameIndex){break;}}}else {if(crossedFrameIndex<0){var prevFrameIndex=Math.floor(prevTime*this._frameRate);crossedFrameIndex=this._frameIndices[timelineData.frameIndicesOffset+prevFrameIndex];var frameOffset=this._animationData.frameOffset+this._timelineArray[timelineData.offset+5+crossedFrameIndex];var framePosition=this._frameArray[frameOffset]/this._frameRate;if(this.currentPlayTimes===prevPlayTimes){if(prevTime<=framePosition){if(crossedFrameIndex>0){crossedFrameIndex--;}else {crossedFrameIndex=this._frameCount-1;}}else if(crossedFrameIndex===frameIndex){crossedFrameIndex=-1;}}}while(crossedFrameIndex>=0){if(crossedFrameIndex<this._frameCount-1){crossedFrameIndex++;}else {crossedFrameIndex=0;}var frameOffset=this._animationData.frameOffset+this._timelineArray[timelineData.offset+5+crossedFrameIndex];var framePosition=this._frameArray[frameOffset]/this._frameRate;if(this._position<=framePosition&&framePosition<=this._position+this._duration){this._onCrossFrame(crossedFrameIndex);}if(loopCompleteEvent!==null&&crossedFrameIndex===0){this._armature._dragonBones.bufferEvent(loopCompleteEvent);loopCompleteEvent=null;}if(crossedFrameIndex===frameIndex){break;}}}}}}else if(this._frameIndex<0){this._frameIndex=0;if(this._timelineData!==null){this._frameOffset=this._animationData.frameOffset+this._timelineArray[this._timelineData.offset+5];var framePosition=this._frameArray[this._frameOffset]/this._frameRate;if(this.currentPlayTimes===prevPlayTimes){if(prevTime<=framePosition){this._onCrossFrame(this._frameIndex);}}else if(this._position<=framePosition){if(!isReverse&&loopCompleteEvent!==null){this._armature._dragonBones.bufferEvent(loopCompleteEvent);loopCompleteEvent=null;}this._onCrossFrame(this._frameIndex);}}}if(loopCompleteEvent!==null){this._armature._dragonBones.bufferEvent(loopCompleteEvent);}if(completeEvent!==null){this._armature._dragonBones.bufferEvent(completeEvent);}}};ActionTimelineState.prototype.setCurrentTime=function(value){this._setCurrentTime(value);this._frameIndex=-1;};return ActionTimelineState;}(dragonBones.TimelineState);dragonBones.ActionTimelineState=ActionTimelineState;var ZOrderTimelineState=function(_super){__extends$1(ZOrderTimelineState,_super);function ZOrderTimelineState(){return _super!==null&&_super.apply(this,arguments)||this;}ZOrderTimelineState.toString=function(){return "[class dragonBones.ZOrderTimelineState]";};ZOrderTimelineState.prototype._onArriveAtFrame=function(){if(this.playState>=0){var count=this._frameArray[this._frameOffset+1];if(count>0){this._armature._sortZOrder(this._frameArray,this._frameOffset+2);}else {this._armature._sortZOrder(null,0);}}};ZOrderTimelineState.prototype._onUpdateFrame=function(){};return ZOrderTimelineState;}(dragonBones.TimelineState);dragonBones.ZOrderTimelineState=ZOrderTimelineState;var BoneAllTimelineState=function(_super){__extends$1(BoneAllTimelineState,_super);function BoneAllTimelineState(){return _super!==null&&_super.apply(this,arguments)||this;}BoneAllTimelineState.toString=function(){return "[class dragonBones.BoneAllTimelineState]";};BoneAllTimelineState.prototype._onArriveAtFrame=function(){_super.prototype._onArriveAtFrame.call(this);if(this._timelineData!==null){var valueOffset=this._animationData.frameFloatOffset+this._frameValueOffset+this._frameIndex*6;var scale=this._armature._armatureData.scale;var frameFloatArray=this._frameFloatArray;var current=this.bonePose.current;var delta=this.bonePose.delta;current.x=frameFloatArray[valueOffset++]*scale;current.y=frameFloatArray[valueOffset++]*scale;current.rotation=frameFloatArray[valueOffset++];current.skew=frameFloatArray[valueOffset++];current.scaleX=frameFloatArray[valueOffset++];current.scaleY=frameFloatArray[valueOffset++];if(this._tweenState===2){if(this._frameIndex===this._frameCount-1){valueOffset=this._animationData.frameFloatOffset+this._frameValueOffset;}delta.x=frameFloatArray[valueOffset++]*scale-current.x;delta.y=frameFloatArray[valueOffset++]*scale-current.y;delta.rotation=frameFloatArray[valueOffset++]-current.rotation;delta.skew=frameFloatArray[valueOffset++]-current.skew;delta.scaleX=frameFloatArray[valueOffset++]-current.scaleX;delta.scaleY=frameFloatArray[valueOffset++]-current.scaleY;}else {delta.x=0.0;delta.y=0.0;delta.rotation=0.0;delta.skew=0.0;delta.scaleX=0.0;delta.scaleY=0.0;}}else {var current=this.bonePose.current;var delta=this.bonePose.delta;current.x=0.0;current.y=0.0;current.rotation=0.0;current.skew=0.0;current.scaleX=1.0;current.scaleY=1.0;delta.x=0.0;delta.y=0.0;delta.rotation=0.0;delta.skew=0.0;delta.scaleX=0.0;delta.scaleY=0.0;}};BoneAllTimelineState.prototype._onUpdateFrame=function(){_super.prototype._onUpdateFrame.call(this);var current=this.bonePose.current;var delta=this.bonePose.delta;var result=this.bonePose.result;this.bone._transformDirty=true;if(this._tweenState!==2){this._tweenState=0;}result.x=current.x+delta.x*this._tweenProgress;result.y=current.y+delta.y*this._tweenProgress;result.rotation=current.rotation+delta.rotation*this._tweenProgress;result.skew=current.skew+delta.skew*this._tweenProgress;result.scaleX=current.scaleX+delta.scaleX*this._tweenProgress;result.scaleY=current.scaleY+delta.scaleY*this._tweenProgress;};BoneAllTimelineState.prototype.fadeOut=function(){var result=this.bonePose.result;result.rotation=dragonBones.Transform.normalizeRadian(result.rotation);result.skew=dragonBones.Transform.normalizeRadian(result.skew);};return BoneAllTimelineState;}(dragonBones.BoneTimelineState);dragonBones.BoneAllTimelineState=BoneAllTimelineState;var BoneTranslateTimelineState=function(_super){__extends$1(BoneTranslateTimelineState,_super);function BoneTranslateTimelineState(){return _super!==null&&_super.apply(this,arguments)||this;}BoneTranslateTimelineState.toString=function(){return "[class dragonBones.BoneTranslateTimelineState]";};BoneTranslateTimelineState.prototype._onArriveAtFrame=function(){_super.prototype._onArriveAtFrame.call(this);if(this._timelineData!==null){var valueOffset=this._animationData.frameFloatOffset+this._frameValueOffset+this._frameIndex*2;var scale=this._armature._armatureData.scale;var frameFloatArray=this._frameFloatArray;var current=this.bonePose.current;var delta=this.bonePose.delta;current.x=frameFloatArray[valueOffset++]*scale;current.y=frameFloatArray[valueOffset++]*scale;if(this._tweenState===2){if(this._frameIndex===this._frameCount-1){valueOffset=this._animationData.frameFloatOffset+this._frameValueOffset;}delta.x=frameFloatArray[valueOffset++]*scale-current.x;delta.y=frameFloatArray[valueOffset++]*scale-current.y;}else {delta.x=0.0;delta.y=0.0;}}else {var current=this.bonePose.current;var delta=this.bonePose.delta;current.x=0.0;current.y=0.0;delta.x=0.0;delta.y=0.0;}};BoneTranslateTimelineState.prototype._onUpdateFrame=function(){_super.prototype._onUpdateFrame.call(this);var current=this.bonePose.current;var delta=this.bonePose.delta;var result=this.bonePose.result;this.bone._transformDirty=true;if(this._tweenState!==2){this._tweenState=0;}result.x=current.x+delta.x*this._tweenProgress;result.y=current.y+delta.y*this._tweenProgress;};return BoneTranslateTimelineState;}(dragonBones.BoneTimelineState);dragonBones.BoneTranslateTimelineState=BoneTranslateTimelineState;var BoneRotateTimelineState=function(_super){__extends$1(BoneRotateTimelineState,_super);function BoneRotateTimelineState(){return _super!==null&&_super.apply(this,arguments)||this;}BoneRotateTimelineState.toString=function(){return "[class dragonBones.BoneRotateTimelineState]";};BoneRotateTimelineState.prototype._onArriveAtFrame=function(){_super.prototype._onArriveAtFrame.call(this);if(this._timelineData!==null){var valueOffset=this._animationData.frameFloatOffset+this._frameValueOffset+this._frameIndex*2;var frameFloatArray=this._frameFloatArray;var current=this.bonePose.current;var delta=this.bonePose.delta;current.rotation=frameFloatArray[valueOffset++];current.skew=frameFloatArray[valueOffset++];if(this._tweenState===2){if(this._frameIndex===this._frameCount-1){valueOffset=this._animationData.frameFloatOffset+this._frameValueOffset;delta.rotation=dragonBones.Transform.normalizeRadian(frameFloatArray[valueOffset++]-current.rotation);}else {delta.rotation=frameFloatArray[valueOffset++]-current.rotation;}delta.skew=frameFloatArray[valueOffset++]-current.skew;}else {delta.rotation=0.0;delta.skew=0.0;}}else {var current=this.bonePose.current;var delta=this.bonePose.delta;current.rotation=0.0;current.skew=0.0;delta.rotation=0.0;delta.skew=0.0;}};BoneRotateTimelineState.prototype._onUpdateFrame=function(){_super.prototype._onUpdateFrame.call(this);var current=this.bonePose.current;var delta=this.bonePose.delta;var result=this.bonePose.result;this.bone._transformDirty=true;if(this._tweenState!==2){this._tweenState=0;}result.rotation=current.rotation+delta.rotation*this._tweenProgress;result.skew=current.skew+delta.skew*this._tweenProgress;};BoneRotateTimelineState.prototype.fadeOut=function(){var result=this.bonePose.result;result.rotation=dragonBones.Transform.normalizeRadian(result.rotation);result.skew=dragonBones.Transform.normalizeRadian(result.skew);};return BoneRotateTimelineState;}(dragonBones.BoneTimelineState);dragonBones.BoneRotateTimelineState=BoneRotateTimelineState;var BoneScaleTimelineState=function(_super){__extends$1(BoneScaleTimelineState,_super);function BoneScaleTimelineState(){return _super!==null&&_super.apply(this,arguments)||this;}BoneScaleTimelineState.toString=function(){return "[class dragonBones.BoneScaleTimelineState]";};BoneScaleTimelineState.prototype._onArriveAtFrame=function(){_super.prototype._onArriveAtFrame.call(this);if(this._timelineData!==null){var valueOffset=this._animationData.frameFloatOffset+this._frameValueOffset+this._frameIndex*2;var frameFloatArray=this._frameFloatArray;var current=this.bonePose.current;var delta=this.bonePose.delta;current.scaleX=frameFloatArray[valueOffset++];current.scaleY=frameFloatArray[valueOffset++];if(this._tweenState===2){if(this._frameIndex===this._frameCount-1){valueOffset=this._animationData.frameFloatOffset+this._frameValueOffset;}delta.scaleX=frameFloatArray[valueOffset++]-current.scaleX;delta.scaleY=frameFloatArray[valueOffset++]-current.scaleY;}else {delta.scaleX=0.0;delta.scaleY=0.0;}}else {var current=this.bonePose.current;var delta=this.bonePose.delta;current.scaleX=1.0;current.scaleY=1.0;delta.scaleX=0.0;delta.scaleY=0.0;}};BoneScaleTimelineState.prototype._onUpdateFrame=function(){_super.prototype._onUpdateFrame.call(this);var current=this.bonePose.current;var delta=this.bonePose.delta;var result=this.bonePose.result;this.bone._transformDirty=true;if(this._tweenState!==2){this._tweenState=0;}result.scaleX=current.scaleX+delta.scaleX*this._tweenProgress;result.scaleY=current.scaleY+delta.scaleY*this._tweenProgress;};return BoneScaleTimelineState;}(dragonBones.BoneTimelineState);dragonBones.BoneScaleTimelineState=BoneScaleTimelineState;var SurfaceTimelineState=function(_super){__extends$1(SurfaceTimelineState,_super);function SurfaceTimelineState(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this._current=[];_this._delta=[];_this._result=[];return _this;}SurfaceTimelineState.toString=function(){return "[class dragonBones.SurfaceTimelineState]";};SurfaceTimelineState.prototype._onClear=function(){_super.prototype._onClear.call(this);this.surface=null;this._frameFloatOffset=0;this._valueCount=0;this._deformCount=0;this._valueOffset=0;this._current.length=0;this._delta.length=0;this._result.length=0;};SurfaceTimelineState.prototype._onArriveAtFrame=function(){_super.prototype._onArriveAtFrame.call(this);if(this._timelineData!==null){var valueOffset=this._animationData.frameFloatOffset+this._frameValueOffset+this._frameIndex*this._valueCount;var scale=this._armature._armatureData.scale;var frameFloatArray=this._frameFloatArray;if(this._tweenState===2){var nextValueOffset=valueOffset+this._valueCount;if(this._frameIndex===this._frameCount-1){nextValueOffset=this._animationData.frameFloatOffset+this._frameValueOffset;}for(var i=0;i<this._valueCount;++i){this._delta[i]=frameFloatArray[nextValueOffset+i]*scale-(this._current[i]=frameFloatArray[valueOffset+i]*scale);}}else {for(var i=0;i<this._valueCount;++i){this._current[i]=frameFloatArray[valueOffset+i]*scale;}}}else {for(var i=0;i<this._valueCount;++i){this._current[i]=0.0;}}};SurfaceTimelineState.prototype._onUpdateFrame=function(){_super.prototype._onUpdateFrame.call(this);this.surface._transformDirty=true;if(this._tweenState!==2){this._tweenState=0;}for(var i=0;i<this._valueCount;++i){this._result[i]=this._current[i]+this._delta[i]*this._tweenProgress;}};SurfaceTimelineState.prototype.init=function(armature,animationState,timelineData){_super.prototype.init.call(this,armature,animationState,timelineData);if(this._timelineData!==null){var frameIntOffset=this._animationData.frameIntOffset+this._timelineArray[this._timelineData.offset+3];this._deformCount=this._frameIntArray[frameIntOffset+1];this._valueCount=this._frameIntArray[frameIntOffset+2];this._valueOffset=this._frameIntArray[frameIntOffset+3];this._frameFloatOffset=this._frameIntArray[frameIntOffset+4]+this._animationData.frameFloatOffset;}else {this._deformCount=this.surface._deformVertices.length;this._valueCount=this._deformCount;this._valueOffset=0;this._frameFloatOffset=0;}this._current.length=this._valueCount;this._delta.length=this._valueCount;this._result.length=this._valueCount;for(var i=0;i<this._valueCount;++i){this._delta[i]=0.0;}};SurfaceTimelineState.prototype.blend=function(state){var blendWeight=this.surface._blendState.blendWeight;var result=this.surface._deformVertices;for(var i=0;i<this._deformCount;++i){var value=0.0;if(i<this._valueOffset){value=this._frameFloatArray[this._frameFloatOffset+i];}else if(i<this._valueOffset+this._valueCount){value=this._result[i-this._valueOffset];}else {value=this._frameFloatArray[this._frameFloatOffset+i-this._valueCount];}if(state===2){result[i]+=value*blendWeight;}else if(blendWeight!==1.0){result[i]=value*blendWeight;}else {result[i]=value;}}if(this._animationState._fadeState!==0||this._animationState._subFadeState!==0){this.surface._transformDirty=true;}};return SurfaceTimelineState;}(dragonBones.TweenTimelineState);dragonBones.SurfaceTimelineState=SurfaceTimelineState;var SlotDislayTimelineState=function(_super){__extends$1(SlotDislayTimelineState,_super);function SlotDislayTimelineState(){return _super!==null&&_super.apply(this,arguments)||this;}SlotDislayTimelineState.toString=function(){return "[class dragonBones.SlotDislayTimelineState]";};SlotDislayTimelineState.prototype._onArriveAtFrame=function(){if(this.playState>=0){var displayIndex=this._timelineData!==null?this._frameArray[this._frameOffset+1]:this.slot._slotData.displayIndex;if(this.slot.displayIndex!==displayIndex){this.slot._setDisplayIndex(displayIndex,true);}}};return SlotDislayTimelineState;}(dragonBones.SlotTimelineState);dragonBones.SlotDislayTimelineState=SlotDislayTimelineState;var SlotColorTimelineState=function(_super){__extends$1(SlotColorTimelineState,_super);function SlotColorTimelineState(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this._current=[0,0,0,0,0,0,0,0];_this._delta=[0,0,0,0,0,0,0,0];_this._result=[0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0];return _this;}SlotColorTimelineState.toString=function(){return "[class dragonBones.SlotColorTimelineState]";};SlotColorTimelineState.prototype._onClear=function(){_super.prototype._onClear.call(this);this._dirty=false;};SlotColorTimelineState.prototype._onArriveAtFrame=function(){_super.prototype._onArriveAtFrame.call(this);if(this._timelineData!==null){var intArray=this._dragonBonesData.intArray;var frameIntArray=this._frameIntArray;var valueOffset=this._animationData.frameIntOffset+this._frameValueOffset+this._frameIndex*1;var colorOffset=frameIntArray[valueOffset];if(colorOffset<0){colorOffset+=65536;}this._current[0]=intArray[colorOffset++];this._current[1]=intArray[colorOffset++];this._current[2]=intArray[colorOffset++];this._current[3]=intArray[colorOffset++];this._current[4]=intArray[colorOffset++];this._current[5]=intArray[colorOffset++];this._current[6]=intArray[colorOffset++];this._current[7]=intArray[colorOffset++];if(this._tweenState===2){if(this._frameIndex===this._frameCount-1){colorOffset=frameIntArray[this._animationData.frameIntOffset+this._frameValueOffset];}else {colorOffset=frameIntArray[valueOffset+1*1];}if(colorOffset<0){colorOffset+=65536;}this._delta[0]=intArray[colorOffset++]-this._current[0];this._delta[1]=intArray[colorOffset++]-this._current[1];this._delta[2]=intArray[colorOffset++]-this._current[2];this._delta[3]=intArray[colorOffset++]-this._current[3];this._delta[4]=intArray[colorOffset++]-this._current[4];this._delta[5]=intArray[colorOffset++]-this._current[5];this._delta[6]=intArray[colorOffset++]-this._current[6];this._delta[7]=intArray[colorOffset++]-this._current[7];}}else {var color=this.slot._slotData.color;this._current[0]=color.alphaMultiplier*100.0;this._current[1]=color.redMultiplier*100.0;this._current[2]=color.greenMultiplier*100.0;this._current[3]=color.blueMultiplier*100.0;this._current[4]=color.alphaOffset;this._current[5]=color.redOffset;this._current[6]=color.greenOffset;this._current[7]=color.blueOffset;}};SlotColorTimelineState.prototype._onUpdateFrame=function(){_super.prototype._onUpdateFrame.call(this);this._dirty=true;if(this._tweenState!==2){this._tweenState=0;}this._result[0]=(this._current[0]+this._delta[0]*this._tweenProgress)*0.01;this._result[1]=(this._current[1]+this._delta[1]*this._tweenProgress)*0.01;this._result[2]=(this._current[2]+this._delta[2]*this._tweenProgress)*0.01;this._result[3]=(this._current[3]+this._delta[3]*this._tweenProgress)*0.01;this._result[4]=this._current[4]+this._delta[4]*this._tweenProgress;this._result[5]=this._current[5]+this._delta[5]*this._tweenProgress;this._result[6]=this._current[6]+this._delta[6]*this._tweenProgress;this._result[7]=this._current[7]+this._delta[7]*this._tweenProgress;};SlotColorTimelineState.prototype.fadeOut=function(){this._tweenState=0;this._dirty=false;};SlotColorTimelineState.prototype.update=function(passedTime){_super.prototype.update.call(this,passedTime);if(this._tweenState!==0||this._dirty){var result=this.slot._colorTransform;if(this._animationState._fadeState!==0||this._animationState._subFadeState!==0){if(result.alphaMultiplier!==this._result[0]||result.redMultiplier!==this._result[1]||result.greenMultiplier!==this._result[2]||result.blueMultiplier!==this._result[3]||result.alphaOffset!==this._result[4]||result.redOffset!==this._result[5]||result.greenOffset!==this._result[6]||result.blueOffset!==this._result[7]){var fadeProgress=Math.pow(this._animationState._fadeProgress,4);result.alphaMultiplier+=(this._result[0]-result.alphaMultiplier)*fadeProgress;result.redMultiplier+=(this._result[1]-result.redMultiplier)*fadeProgress;result.greenMultiplier+=(this._result[2]-result.greenMultiplier)*fadeProgress;result.blueMultiplier+=(this._result[3]-result.blueMultiplier)*fadeProgress;result.alphaOffset+=(this._result[4]-result.alphaOffset)*fadeProgress;result.redOffset+=(this._result[5]-result.redOffset)*fadeProgress;result.greenOffset+=(this._result[6]-result.greenOffset)*fadeProgress;result.blueOffset+=(this._result[7]-result.blueOffset)*fadeProgress;this.slot._colorDirty=true;}}else if(this._dirty){this._dirty=false;if(result.alphaMultiplier!==this._result[0]||result.redMultiplier!==this._result[1]||result.greenMultiplier!==this._result[2]||result.blueMultiplier!==this._result[3]||result.alphaOffset!==this._result[4]||result.redOffset!==this._result[5]||result.greenOffset!==this._result[6]||result.blueOffset!==this._result[7]){result.alphaMultiplier=this._result[0];result.redMultiplier=this._result[1];result.greenMultiplier=this._result[2];result.blueMultiplier=this._result[3];result.alphaOffset=this._result[4];result.redOffset=this._result[5];result.greenOffset=this._result[6];result.blueOffset=this._result[7];this.slot._colorDirty=true;}}}};return SlotColorTimelineState;}(dragonBones.SlotTimelineState);dragonBones.SlotColorTimelineState=SlotColorTimelineState;var DeformTimelineState=function(_super){__extends$1(DeformTimelineState,_super);function DeformTimelineState(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this._current=[];_this._delta=[];_this._result=[];return _this;}DeformTimelineState.toString=function(){return "[class dragonBones.DeformTimelineState]";};DeformTimelineState.prototype._onClear=function(){_super.prototype._onClear.call(this);this.vertexOffset=0;this._dirty=false;this._frameFloatOffset=0;this._valueCount=0;this._deformCount=0;this._valueOffset=0;this._current.length=0;this._delta.length=0;this._result.length=0;};DeformTimelineState.prototype._onArriveAtFrame=function(){_super.prototype._onArriveAtFrame.call(this);if(this._timelineData!==null){var valueOffset=this._animationData.frameFloatOffset+this._frameValueOffset+this._frameIndex*this._valueCount;var scale=this._armature._armatureData.scale;var frameFloatArray=this._frameFloatArray;if(this._tweenState===2){var nextValueOffset=valueOffset+this._valueCount;if(this._frameIndex===this._frameCount-1){nextValueOffset=this._animationData.frameFloatOffset+this._frameValueOffset;}for(var i=0;i<this._valueCount;++i){this._delta[i]=frameFloatArray[nextValueOffset+i]*scale-(this._current[i]=frameFloatArray[valueOffset+i]*scale);}}else {for(var i=0;i<this._valueCount;++i){this._current[i]=frameFloatArray[valueOffset+i]*scale;}}}else {for(var i=0;i<this._valueCount;++i){this._current[i]=0.0;}}};DeformTimelineState.prototype._onUpdateFrame=function(){_super.prototype._onUpdateFrame.call(this);this._dirty=true;if(this._tweenState!==2){this._tweenState=0;}for(var i=0;i<this._valueCount;++i){this._result[i]=this._current[i]+this._delta[i]*this._tweenProgress;}};DeformTimelineState.prototype.init=function(armature,animationState,timelineData){_super.prototype.init.call(this,armature,animationState,timelineData);if(this._timelineData!==null){var frameIntOffset=this._animationData.frameIntOffset+this._timelineArray[this._timelineData.offset+3];this.vertexOffset=this._frameIntArray[frameIntOffset+0];if(this.vertexOffset<0){this.vertexOffset+=65536;}this._deformCount=this._frameIntArray[frameIntOffset+1];this._valueCount=this._frameIntArray[frameIntOffset+2];this._valueOffset=this._frameIntArray[frameIntOffset+3];this._frameFloatOffset=this._frameIntArray[frameIntOffset+4]+this._animationData.frameFloatOffset;}else {var deformVertices=this.slot._deformVertices;this._deformCount=deformVertices!==null?deformVertices.vertices.length:0;this._valueCount=this._deformCount;this._valueOffset=0;this._frameFloatOffset=0;}this._current.length=this._valueCount;this._delta.length=this._valueCount;this._result.length=this._valueCount;for(var i=0;i<this._valueCount;++i){this._delta[i]=0.0;}};DeformTimelineState.prototype.fadeOut=function(){this._tweenState=0;this._dirty=false;};DeformTimelineState.prototype.update=function(passedTime){var deformVertices=this.slot._deformVertices;if(deformVertices===null||deformVertices.verticesData===null||deformVertices.verticesData.offset!==this.vertexOffset){return;}_super.prototype.update.call(this,passedTime);if(this._tweenState!==0||this._dirty){var result=deformVertices.vertices;if(this._animationState._fadeState!==0||this._animationState._subFadeState!==0){var fadeProgress=Math.pow(this._animationState._fadeProgress,2);for(var i=0;i<this._deformCount;++i){if(i<this._valueOffset){result[i]+=(this._frameFloatArray[this._frameFloatOffset+i]-result[i])*fadeProgress;}else if(i<this._valueOffset+this._valueCount){result[i]+=(this._result[i-this._valueOffset]-result[i])*fadeProgress;}else {result[i]+=(this._frameFloatArray[this._frameFloatOffset+i-this._valueCount]-result[i])*fadeProgress;}}deformVertices.verticesDirty=true;}else if(this._dirty){this._dirty=false;for(var i=0;i<this._deformCount;++i){if(i<this._valueOffset){result[i]=this._frameFloatArray[this._frameFloatOffset+i];}else if(i<this._valueOffset+this._valueCount){result[i]=this._result[i-this._valueOffset];}else {result[i]=this._frameFloatArray[this._frameFloatOffset+i-this._valueCount];}}deformVertices.verticesDirty=true;}}};return DeformTimelineState;}(dragonBones.SlotTimelineState);dragonBones.DeformTimelineState=DeformTimelineState;var IKConstraintTimelineState=function(_super){__extends$1(IKConstraintTimelineState,_super);function IKConstraintTimelineState(){return _super!==null&&_super.apply(this,arguments)||this;}IKConstraintTimelineState.toString=function(){return "[class dragonBones.IKConstraintTimelineState]";};IKConstraintTimelineState.prototype._onClear=function(){_super.prototype._onClear.call(this);this._current=0.0;this._delta=0.0;};IKConstraintTimelineState.prototype._onArriveAtFrame=function(){_super.prototype._onArriveAtFrame.call(this);var ikConstraint=this.constraint;if(this._timelineData!==null){var valueOffset=this._animationData.frameIntOffset+this._frameValueOffset+this._frameIndex*2;var frameIntArray=this._frameIntArray;var bendPositive=frameIntArray[valueOffset++]!==0;this._current=frameIntArray[valueOffset++]*0.01;if(this._tweenState===2){if(this._frameIndex===this._frameCount-1){valueOffset=this._animationData.frameIntOffset+this._frameValueOffset;}this._delta=frameIntArray[valueOffset+1]*0.01-this._current;}else {this._delta=0.0;}ikConstraint._bendPositive=bendPositive;}else {var ikConstraintData=ikConstraint._constraintData;this._current=ikConstraintData.weight;this._delta=0.0;ikConstraint._bendPositive=ikConstraintData.bendPositive;}ikConstraint.invalidUpdate();};IKConstraintTimelineState.prototype._onUpdateFrame=function(){_super.prototype._onUpdateFrame.call(this);if(this._tweenState!==2){this._tweenState=0;}var ikConstraint=this.constraint;ikConstraint._weight=this._current+this._delta*this._tweenProgress;ikConstraint.invalidUpdate();};return IKConstraintTimelineState;}(dragonBones.ConstraintTimelineState);dragonBones.IKConstraintTimelineState=IKConstraintTimelineState;var AnimationTimelineState=function(_super){__extends$1(AnimationTimelineState,_super);function AnimationTimelineState(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this._floats=[0.0,0.0,0.0,0.0,0.0,0.0];return _this;}AnimationTimelineState.toString=function(){return "[class dragonBones.AnimationTimelineState]";};AnimationTimelineState.prototype._onClear=function(){_super.prototype._onClear.call(this);this.animationState=null;};AnimationTimelineState.prototype._onArriveAtFrame=function(){_super.prototype._onArriveAtFrame.call(this);if(this._timelineData===null){return;}var valueOffset=this._animationData.frameIntOffset+this._frameValueOffset+this._frameIndex*2;var frameRateR=1.0/this.animationState._animationData.parent.frameRate;var frameIntArray=this._frameIntArray;this._floats[0]=frameIntArray[valueOffset++]*frameRateR;this._floats[3]=frameIntArray[valueOffset++]*0.01;if(this._tweenState===2){if(this._frameIndex===this._frameCount-1){valueOffset=this._animationData.frameIntOffset+this._frameValueOffset;}this._floats[1]=frameIntArray[valueOffset++]*frameRateR-this._floats[0];this._floats[4]=frameIntArray[valueOffset++]*0.01-this._floats[3];}else {this._floats[1]=0.0;this._floats[4]=0.0;}};AnimationTimelineState.prototype._onUpdateFrame=function(){_super.prototype._onUpdateFrame.call(this);if(this._tweenState!==2){this._tweenState=0;}if(this._floats[0]>=0.0){this._floats[2]=this._floats[0]+this._floats[1]*this._tweenProgress;}this._floats[5]=this._floats[3]+this._floats[4]*this._tweenProgress;};AnimationTimelineState.prototype.blend=function(state){var animationState=this.animationState;var blendWeight=animationState._blendState.blendWeight;if(state===2){animationState.weight+=this._floats[5]*blendWeight;animationState.currentTime+=this._floats[2]*blendWeight;}else {animationState.weight=this._floats[5]*blendWeight;animationState.currentTime=this._floats[2]*blendWeight;}};return AnimationTimelineState;}(dragonBones.TweenTimelineState);dragonBones.AnimationTimelineState=AnimationTimelineState;})(dragonBones||(dragonBones={}));(function(dragonBones){var EventObject=function(_super){__extends$1(EventObject,_super);function EventObject(){return _super!==null&&_super.apply(this,arguments)||this;}EventObject.actionDataToInstance=function(data,instance,armature){if(data.type===0){instance.type=EventObject.FRAME_EVENT;}else {instance.type=data.type===10?EventObject.FRAME_EVENT:EventObject.SOUND_EVENT;}instance.name=data.name;instance.armature=armature;instance.actionData=data;instance.data=data.data;if(data.bone!==null){instance.bone=armature.getBone(data.bone.name);}if(data.slot!==null){instance.slot=armature.getSlot(data.slot.name);}};EventObject.toString=function(){return "[class dragonBones.EventObject]";};EventObject.prototype._onClear=function(){this.time=0.0;this.type="";this.name="";this.armature=null;this.bone=null;this.slot=null;this.animationState=null;this.actionData=null;this.data=null;};EventObject.START="start";EventObject.LOOP_COMPLETE="loopComplete";EventObject.COMPLETE="complete";EventObject.FADE_IN="fadeIn";EventObject.FADE_IN_COMPLETE="fadeInComplete";EventObject.FADE_OUT="fadeOut";EventObject.FADE_OUT_COMPLETE="fadeOutComplete";EventObject.FRAME_EVENT="frameEvent";EventObject.SOUND_EVENT="soundEvent";return EventObject;}(dragonBones.BaseObject);dragonBones.EventObject=EventObject;})(dragonBones||(dragonBones={}));(function(dragonBones){var DataParser=function(){function DataParser(){}DataParser._getArmatureType=function(value){switch(value.toLowerCase()){case"stage":return 2;case"armature":return 0;case"movieclip":return 1;default:return 0;}};DataParser._getBoneType=function(value){switch(value.toLowerCase()){case"bone":return 0;case"surface":return 1;default:return 0;}};DataParser._getDisplayType=function(value){switch(value.toLowerCase()){case"image":return 0;case"mesh":return 2;case"armature":return 1;case"boundingbox":return 3;case"path":return 4;default:return 0;}};DataParser._getBoundingBoxType=function(value){switch(value.toLowerCase()){case"rectangle":return 0;case"ellipse":return 1;case"polygon":return 2;default:return 0;}};DataParser._getActionType=function(value){switch(value.toLowerCase()){case"play":return 0;case"frame":return 10;case"sound":return 11;default:return 0;}};DataParser._getBlendMode=function(value){switch(value.toLowerCase()){case"normal":return 0;case"add":return 1;case"alpha":return 2;case"darken":return 3;case"difference":return 4;case"erase":return 5;case"hardlight":return 6;case"invert":return 7;case"layer":return 8;case"lighten":return 9;case"multiply":return 10;case"overlay":return 11;case"screen":return 12;case"subtract":return 13;default:return 0;}};DataParser._getPositionMode=function(value){switch(value.toLocaleLowerCase()){case"percent":return 1;case"fixed":return 0;default:return 1;}};DataParser._getSpacingMode=function(value){switch(value.toLocaleLowerCase()){case"length":return 0;case"percent":return 2;case"fixed":return 1;default:return 0;}};DataParser._getRotateMode=function(value){switch(value.toLocaleLowerCase()){case"tangent":return 0;case"chain":return 1;case"chainscale":return 2;default:return 0;}};DataParser.parseDragonBonesData=function(rawData){console.warn("Deprecated.");if(rawData instanceof ArrayBuffer){return dragonBones.BinaryDataParser.getInstance().parseDragonBonesData(rawData);}else {return dragonBones.ObjectDataParser.getInstance().parseDragonBonesData(rawData);}};DataParser.parseTextureAtlasData=function(rawData,scale){if(scale===void 0){scale=1;}console.warn("");var textureAtlasData={};var subTextureList=rawData[DataParser.SUB_TEXTURE];for(var i=0,len=subTextureList.length;i<len;i++){var subTextureObject=subTextureList[i];var subTextureName=subTextureObject[DataParser.NAME];var subTextureRegion=new dragonBones.Rectangle();var subTextureFrame=null;subTextureRegion.x=subTextureObject[DataParser.X]/scale;subTextureRegion.y=subTextureObject[DataParser.Y]/scale;subTextureRegion.width=subTextureObject[DataParser.WIDTH]/scale;subTextureRegion.height=subTextureObject[DataParser.HEIGHT]/scale;if(DataParser.FRAME_WIDTH in subTextureObject){subTextureFrame=new dragonBones.Rectangle();subTextureFrame.x=subTextureObject[DataParser.FRAME_X]/scale;subTextureFrame.y=subTextureObject[DataParser.FRAME_Y]/scale;subTextureFrame.width=subTextureObject[DataParser.FRAME_WIDTH]/scale;subTextureFrame.height=subTextureObject[DataParser.FRAME_HEIGHT]/scale;}textureAtlasData[subTextureName]={region:subTextureRegion,frame:subTextureFrame,rotated:false};}return textureAtlasData;};DataParser.DATA_VERSION_2_3="2.3";DataParser.DATA_VERSION_3_0="3.0";DataParser.DATA_VERSION_4_0="4.0";DataParser.DATA_VERSION_4_5="4.5";DataParser.DATA_VERSION_5_0="5.0";DataParser.DATA_VERSION_5_5="5.5";DataParser.DATA_VERSION=DataParser.DATA_VERSION_5_5;DataParser.DATA_VERSIONS=[DataParser.DATA_VERSION_4_0,DataParser.DATA_VERSION_4_5,DataParser.DATA_VERSION_5_0,DataParser.DATA_VERSION_5_5];DataParser.TEXTURE_ATLAS="textureAtlas";DataParser.SUB_TEXTURE="SubTexture";DataParser.FORMAT="format";DataParser.IMAGE_PATH="imagePath";DataParser.WIDTH="width";DataParser.HEIGHT="height";DataParser.ROTATED="rotated";DataParser.FRAME_X="frameX";DataParser.FRAME_Y="frameY";DataParser.FRAME_WIDTH="frameWidth";DataParser.FRAME_HEIGHT="frameHeight";DataParser.DRADON_BONES="dragonBones";DataParser.USER_DATA="userData";DataParser.ARMATURE="armature";DataParser.BONE="bone";DataParser.SURFACE="surface";DataParser.SLOT="slot";DataParser.CONSTRAINT="constraint";DataParser.IK="ik";DataParser.PATH_CONSTRAINT="path";DataParser.SKIN="skin";DataParser.DISPLAY="display";DataParser.ANIMATION="animation";DataParser.Z_ORDER="zOrder";DataParser.FFD="ffd";DataParser.FRAME="frame";DataParser.TRANSLATE_FRAME="translateFrame";DataParser.ROTATE_FRAME="rotateFrame";DataParser.SCALE_FRAME="scaleFrame";DataParser.DISPLAY_FRAME="displayFrame";DataParser.COLOR_FRAME="colorFrame";DataParser.DEFAULT_ACTIONS="defaultActions";DataParser.ACTIONS="actions";DataParser.EVENTS="events";DataParser.INTS="ints";DataParser.FLOATS="floats";DataParser.STRINGS="strings";DataParser.CANVAS="canvas";DataParser.TRANSFORM="transform";DataParser.PIVOT="pivot";DataParser.AABB="aabb";DataParser.COLOR="color";DataParser.VERSION="version";DataParser.COMPATIBLE_VERSION="compatibleVersion";DataParser.FRAME_RATE="frameRate";DataParser.TYPE="type";DataParser.SUB_TYPE="subType";DataParser.NAME="name";DataParser.PARENT="parent";DataParser.TARGET="target";DataParser.STAGE="stage";DataParser.SHARE="share";DataParser.PATH="path";DataParser.LENGTH="length";DataParser.DISPLAY_INDEX="displayIndex";DataParser.BLEND_MODE="blendMode";DataParser.INHERIT_TRANSLATION="inheritTranslation";DataParser.INHERIT_ROTATION="inheritRotation";DataParser.INHERIT_SCALE="inheritScale";DataParser.INHERIT_REFLECTION="inheritReflection";DataParser.INHERIT_ANIMATION="inheritAnimation";DataParser.INHERIT_DEFORM="inheritDeform";DataParser.SEGMENT_X="segmentX";DataParser.SEGMENT_Y="segmentY";DataParser.BEND_POSITIVE="bendPositive";DataParser.CHAIN="chain";DataParser.WEIGHT="weight";DataParser.FADE_IN_TIME="fadeInTime";DataParser.PLAY_TIMES="playTimes";DataParser.SCALE="scale";DataParser.OFFSET="offset";DataParser.POSITION="position";DataParser.DURATION="duration";DataParser.TWEEN_EASING="tweenEasing";DataParser.TWEEN_ROTATE="tweenRotate";DataParser.TWEEN_SCALE="tweenScale";DataParser.CLOCK_WISE="clockwise";DataParser.CURVE="curve";DataParser.SOUND="sound";DataParser.EVENT="event";DataParser.ACTION="action";DataParser.X="x";DataParser.Y="y";DataParser.SKEW_X="skX";DataParser.SKEW_Y="skY";DataParser.SCALE_X="scX";DataParser.SCALE_Y="scY";DataParser.VALUE="value";DataParser.ROTATE="rotate";DataParser.SKEW="skew";DataParser.ALPHA_OFFSET="aO";DataParser.RED_OFFSET="rO";DataParser.GREEN_OFFSET="gO";DataParser.BLUE_OFFSET="bO";DataParser.ALPHA_MULTIPLIER="aM";DataParser.RED_MULTIPLIER="rM";DataParser.GREEN_MULTIPLIER="gM";DataParser.BLUE_MULTIPLIER="bM";DataParser.UVS="uvs";DataParser.VERTICES="vertices";DataParser.TRIANGLES="triangles";DataParser.WEIGHTS="weights";DataParser.SLOT_POSE="slotPose";DataParser.BONE_POSE="bonePose";DataParser.GLUE_WEIGHTS="glueWeights";DataParser.GLUE_MESHES="glueMeshes";DataParser.BONES="bones";DataParser.POSITION_MODE="positionMode";DataParser.SPACING_MODE="spacingMode";DataParser.ROTATE_MODE="rotateMode";DataParser.SPACING="spacing";DataParser.ROTATE_OFFSET="rotateOffset";DataParser.ROTATE_MIX="rotateMix";DataParser.TRANSLATE_MIX="translateMix";DataParser.TARGET_DISPLAY="targetDisplay";DataParser.CLOSED="closed";DataParser.CONSTANT_SPEED="constantSpeed";DataParser.VERTEX_COUNT="vertexCount";DataParser.LENGTHS="lengths";DataParser.GOTO_AND_PLAY="gotoAndPlay";DataParser.DEFAULT_NAME="default";return DataParser;}();dragonBones.DataParser=DataParser;})(dragonBones||(dragonBones={}));(function(dragonBones){var ObjectDataParser=function(_super){__extends$1(ObjectDataParser,_super);function ObjectDataParser(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this._rawTextureAtlasIndex=0;_this._rawBones=[];_this._data=null;_this._armature=null;_this._bone=null;_this._surface=null;_this._slot=null;_this._skin=null;_this._mesh=null;_this._animation=null;_this._timeline=null;_this._rawTextureAtlases=null;_this._defaultColorOffset=-1;_this._prevClockwise=0;_this._prevRotation=0.0;_this._helpMatrixA=new dragonBones.Matrix();_this._helpMatrixB=new dragonBones.Matrix();_this._helpTransform=new dragonBones.Transform();_this._helpColorTransform=new dragonBones.ColorTransform();_this._helpPoint=new dragonBones.Point();_this._helpArray=[];_this._intArray=[];_this._floatArray=[];_this._frameIntArray=[];_this._frameFloatArray=[];_this._frameArray=[];_this._timelineArray=[];_this._cacheRawMeshes=[];_this._cacheMeshes=[];_this._actionFrames=[];_this._weightSlotPose={};_this._weightBonePoses={};_this._cacheBones={};_this._slotChildActions={};return _this;}ObjectDataParser._getBoolean=function(rawData,key,defaultValue){if(key in rawData){var value=rawData[key];var type=typeof value;if(type==="boolean"){return value;}else if(type==="string"){switch(value){case"0":case"NaN":case"":case"false":case"null":case"undefined":return false;default:return true;}}else {return !!value;}}return defaultValue;};ObjectDataParser._getNumber=function(rawData,key,defaultValue){if(key in rawData){var value=rawData[key];if(value===null||value==="NaN"){return defaultValue;}return +value||0;}return defaultValue;};ObjectDataParser._getString=function(rawData,key,defaultValue){if(key in rawData){var value=rawData[key];var type=typeof value;if(type==="string"){if(dragonBones.DragonBones.webAssembly){for(var i=0,l=value.length;i<l;++i){if(value.charCodeAt(i)>255){return encodeURI(value);}}}return value;}return String(value);}return defaultValue;};ObjectDataParser.prototype._getCurvePoint=function(x1,y1,x2,y2,x3,y3,x4,y4,t,result){var l_t=1.0-t;var powA=l_t*l_t;var powB=t*t;var kA=l_t*powA;var kB=3.0*t*powA;var kC=3.0*l_t*powB;var kD=t*powB;result.x=kA*x1+kB*x2+kC*x3+kD*x4;result.y=kA*y1+kB*y2+kC*y3+kD*y4;};ObjectDataParser.prototype._samplingEasingCurve=function(curve,samples){var curveCount=curve.length;var stepIndex=-2;for(var i=0,l=samples.length;i<l;++i){var t=(i+1)/(l+1);while((stepIndex+6<curveCount?curve[stepIndex+6]:1)<t){stepIndex+=6;}var isInCurve=stepIndex>=0&&stepIndex+6<curveCount;var x1=isInCurve?curve[stepIndex]:0.0;var y1=isInCurve?curve[stepIndex+1]:0.0;var x2=curve[stepIndex+2];var y2=curve[stepIndex+3];var x3=curve[stepIndex+4];var y3=curve[stepIndex+5];var x4=isInCurve?curve[stepIndex+6]:1.0;var y4=isInCurve?curve[stepIndex+7]:1.0;var lower=0.0;var higher=1.0;while(higher-lower>0.0001){var percentage=(higher+lower)*0.5;this._getCurvePoint(x1,y1,x2,y2,x3,y3,x4,y4,percentage,this._helpPoint);if(t-this._helpPoint.x>0.0){lower=percentage;}else {higher=percentage;}}samples[i]=this._helpPoint.y;}};ObjectDataParser.prototype._parseActionDataInFrame=function(rawData,frameStart,bone,slot){if(dragonBones.DataParser.EVENT in rawData){this._mergeActionFrame(rawData[dragonBones.DataParser.EVENT],frameStart,10,bone,slot);}if(dragonBones.DataParser.SOUND in rawData){this._mergeActionFrame(rawData[dragonBones.DataParser.SOUND],frameStart,11,bone,slot);}if(dragonBones.DataParser.ACTION in rawData){this._mergeActionFrame(rawData[dragonBones.DataParser.ACTION],frameStart,0,bone,slot);}if(dragonBones.DataParser.EVENTS in rawData){this._mergeActionFrame(rawData[dragonBones.DataParser.EVENTS],frameStart,10,bone,slot);}if(dragonBones.DataParser.ACTIONS in rawData){this._mergeActionFrame(rawData[dragonBones.DataParser.ACTIONS],frameStart,0,bone,slot);}};ObjectDataParser.prototype._mergeActionFrame=function(rawData,frameStart,type,bone,slot){var actionOffset=dragonBones.DragonBones.webAssembly?this._armature.actions.size():this._armature.actions.length;var actions=this._parseActionData(rawData,type,bone,slot);var frameIndex=0;var frame=null;for(var _i=0,actions_2=actions;_i<actions_2.length;_i++){var action=actions_2[_i];this._armature.addAction(action,false);}if(this._actionFrames.length===0){frame=new ActionFrame();frame.frameStart=0;this._actionFrames.push(frame);frame=null;}for(var _a=0,_b=this._actionFrames;_a<_b.length;_a++){var eachFrame=_b[_a];if(eachFrame.frameStart===frameStart){frame=eachFrame;break;}else if(eachFrame.frameStart>frameStart){break;}frameIndex++;}if(frame===null){frame=new ActionFrame();frame.frameStart=frameStart;this._actionFrames.splice(frameIndex+1,0,frame);}for(var i=0;i<actions.length;++i){frame.actions.push(actionOffset+i);}};ObjectDataParser.prototype._parseArmature=function(rawData,scale){var armature=dragonBones.BaseObject.borrowObject(dragonBones.ArmatureData);armature.name=ObjectDataParser._getString(rawData,dragonBones.DataParser.NAME,"");armature.frameRate=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.FRAME_RATE,this._data.frameRate);armature.scale=scale;if(dragonBones.DataParser.TYPE in rawData&&typeof rawData[dragonBones.DataParser.TYPE]==="string"){armature.type=dragonBones.DataParser._getArmatureType(rawData[dragonBones.DataParser.TYPE]);}else {armature.type=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.TYPE,0);}if(armature.frameRate===0){armature.frameRate=24;}this._armature=armature;if(dragonBones.DataParser.CANVAS in rawData){var rawCanvas=rawData[dragonBones.DataParser.CANVAS];var canvas=dragonBones.BaseObject.borrowObject(dragonBones.CanvasData);if(dragonBones.DataParser.COLOR in rawCanvas){canvas.hasBackground=true;}else {canvas.hasBackground=false;}canvas.color=ObjectDataParser._getNumber(rawCanvas,dragonBones.DataParser.COLOR,0);canvas.x=ObjectDataParser._getNumber(rawCanvas,dragonBones.DataParser.X,0)*armature.scale;canvas.y=ObjectDataParser._getNumber(rawCanvas,dragonBones.DataParser.Y,0)*armature.scale;canvas.width=ObjectDataParser._getNumber(rawCanvas,dragonBones.DataParser.WIDTH,0)*armature.scale;canvas.height=ObjectDataParser._getNumber(rawCanvas,dragonBones.DataParser.HEIGHT,0)*armature.scale;armature.canvas=canvas;}if(dragonBones.DataParser.AABB in rawData){var rawAABB=rawData[dragonBones.DataParser.AABB];armature.aabb.x=ObjectDataParser._getNumber(rawAABB,dragonBones.DataParser.X,0.0)*armature.scale;armature.aabb.y=ObjectDataParser._getNumber(rawAABB,dragonBones.DataParser.Y,0.0)*armature.scale;armature.aabb.width=ObjectDataParser._getNumber(rawAABB,dragonBones.DataParser.WIDTH,0.0)*armature.scale;armature.aabb.height=ObjectDataParser._getNumber(rawAABB,dragonBones.DataParser.HEIGHT,0.0)*armature.scale;}if(dragonBones.DataParser.BONE in rawData){var rawBones=rawData[dragonBones.DataParser.BONE];for(var _i=0,rawBones_1=rawBones;_i<rawBones_1.length;_i++){var rawBone=rawBones_1[_i];var parentName=ObjectDataParser._getString(rawBone,dragonBones.DataParser.PARENT,"");var bone=this._parseBone(rawBone);if(parentName.length>0){var parent_1=armature.getBone(parentName);if(parent_1!==null){bone.parent=parent_1;}else {if(!(parentName in this._cacheBones)){this._cacheBones[parentName]=[];}this._cacheBones[parentName].push(bone);}}if(bone.name in this._cacheBones){for(var _a=0,_b=this._cacheBones[bone.name];_a<_b.length;_a++){var child=_b[_a];child.parent=bone;}delete this._cacheBones[bone.name];}armature.addBone(bone);this._rawBones.push(bone);}}if(dragonBones.DataParser.IK in rawData){var rawIKS=rawData[dragonBones.DataParser.IK];for(var _c=0,rawIKS_1=rawIKS;_c<rawIKS_1.length;_c++){var rawIK=rawIKS_1[_c];var constraint=this._parseIKConstraint(rawIK);if(constraint){armature.addConstraint(constraint);}}}armature.sortBones();if(dragonBones.DataParser.SLOT in rawData){var zOrder=0;var rawSlots=rawData[dragonBones.DataParser.SLOT];for(var _d=0,rawSlots_1=rawSlots;_d<rawSlots_1.length;_d++){var rawSlot=rawSlots_1[_d];armature.addSlot(this._parseSlot(rawSlot,zOrder++));}}if(dragonBones.DataParser.SKIN in rawData){var rawSkins=rawData[dragonBones.DataParser.SKIN];for(var _e=0,rawSkins_1=rawSkins;_e<rawSkins_1.length;_e++){var rawSkin=rawSkins_1[_e];armature.addSkin(this._parseSkin(rawSkin));}}if(dragonBones.DataParser.PATH_CONSTRAINT in rawData){var rawPaths=rawData[dragonBones.DataParser.PATH_CONSTRAINT];for(var _f=0,rawPaths_1=rawPaths;_f<rawPaths_1.length;_f++){var rawPath=rawPaths_1[_f];var constraint=this._parsePathConstraint(rawPath);if(constraint){armature.addConstraint(constraint);}}}for(var i=0,l=this._cacheRawMeshes.length;i<l;++i){var rawMeshData=this._cacheRawMeshes[i];if(!(dragonBones.DataParser.GLUE_WEIGHTS in rawMeshData)||!(dragonBones.DataParser.GLUE_MESHES in rawMeshData)){continue;}this._parseMeshGlue(rawMeshData,this._cacheMeshes[i]);}for(var i=0,l=this._cacheRawMeshes.length;i<l;++i){var rawData_1=this._cacheRawMeshes[i];var shareName=ObjectDataParser._getString(rawData_1,dragonBones.DataParser.SHARE,"");if(shareName.length===0){continue;}var skinName=ObjectDataParser._getString(rawData_1,dragonBones.DataParser.SKIN,dragonBones.DataParser.DEFAULT_NAME);if(skinName.length===0){skinName=dragonBones.DataParser.DEFAULT_NAME;}var shareMesh=armature.getMesh(skinName,"",shareName);if(shareMesh===null){continue;}var mesh=this._cacheMeshes[i];mesh.vertices.shareFrom(shareMesh.vertices);}if(dragonBones.DataParser.ANIMATION in rawData){var rawAnimations=rawData[dragonBones.DataParser.ANIMATION];for(var _g=0,rawAnimations_1=rawAnimations;_g<rawAnimations_1.length;_g++){var rawAnimation=rawAnimations_1[_g];var animation=this._parseAnimation(rawAnimation);armature.addAnimation(animation);}}if(dragonBones.DataParser.DEFAULT_ACTIONS in rawData){var actions=this._parseActionData(rawData[dragonBones.DataParser.DEFAULT_ACTIONS],0,null,null);for(var _h=0,actions_3=actions;_h<actions_3.length;_h++){var action=actions_3[_h];armature.addAction(action,true);if(action.type===0){var animation=armature.getAnimation(action.name);if(animation!==null){armature.defaultAnimation=animation;}}}}if(dragonBones.DataParser.ACTIONS in rawData){var actions=this._parseActionData(rawData[dragonBones.DataParser.ACTIONS],0,null,null);for(var _j=0,actions_4=actions;_j<actions_4.length;_j++){var action=actions_4[_j];armature.addAction(action,false);}}this._rawBones.length=0;this._cacheRawMeshes.length=0;this._cacheMeshes.length=0;this._armature=null;for(var k in this._weightSlotPose){delete this._weightSlotPose[k];}for(var k in this._weightBonePoses){delete this._weightBonePoses[k];}for(var k in this._cacheBones){delete this._cacheBones[k];}for(var k in this._slotChildActions){delete this._slotChildActions[k];}return armature;};ObjectDataParser.prototype._parseBone=function(rawData){var type=0;var scale=this._armature.scale;if(dragonBones.DataParser.TYPE in rawData&&typeof rawData[dragonBones.DataParser.TYPE]==="string"){type=dragonBones.DataParser._getBoneType(rawData[dragonBones.DataParser.TYPE]);}else {type=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.TYPE,0);}if(type===0){var bone=dragonBones.BaseObject.borrowObject(dragonBones.BoneData);bone.inheritTranslation=ObjectDataParser._getBoolean(rawData,dragonBones.DataParser.INHERIT_TRANSLATION,true);bone.inheritRotation=ObjectDataParser._getBoolean(rawData,dragonBones.DataParser.INHERIT_ROTATION,true);bone.inheritScale=ObjectDataParser._getBoolean(rawData,dragonBones.DataParser.INHERIT_SCALE,true);bone.inheritReflection=ObjectDataParser._getBoolean(rawData,dragonBones.DataParser.INHERIT_REFLECTION,true);bone.length=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.LENGTH,0)*scale;bone.name=ObjectDataParser._getString(rawData,dragonBones.DataParser.NAME,"");if(dragonBones.DataParser.TRANSFORM in rawData){this._parseTransform(rawData[dragonBones.DataParser.TRANSFORM],bone.transform,scale);}return bone;}var surface=dragonBones.BaseObject.borrowObject(dragonBones.SurfaceData);surface.name=ObjectDataParser._getString(rawData,dragonBones.DataParser.NAME,"");surface.segmentX=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.SEGMENT_X,0);surface.segmentY=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.SEGMENT_Y,0);surface.vertices.length=(surface.segmentX+1)*(surface.segmentY+1)*2;if(dragonBones.DataParser.VERTICES in rawData){var rawVertices=rawData[dragonBones.DataParser.VERTICES];for(var i=0,l=surface.vertices.length;i<l;++i){if(i<rawVertices.length){surface.vertices[i]=rawVertices[i]*scale;}else {surface.vertices[i]=0.0;}}}return surface;};ObjectDataParser.prototype._parseIKConstraint=function(rawData){var bone=this._armature.getBone(ObjectDataParser._getString(rawData,dragonBones.DataParser.BONE,""));if(bone===null){return null;}var target=this._armature.getBone(ObjectDataParser._getString(rawData,dragonBones.DataParser.TARGET,""));if(target===null){return null;}var constraint=dragonBones.BaseObject.borrowObject(dragonBones.IKConstraintData);constraint.scaleEnabled=ObjectDataParser._getBoolean(rawData,dragonBones.DataParser.SCALE,false);constraint.bendPositive=ObjectDataParser._getBoolean(rawData,dragonBones.DataParser.BEND_POSITIVE,true);constraint.weight=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.WEIGHT,1.0);constraint.name=ObjectDataParser._getString(rawData,dragonBones.DataParser.NAME,"");constraint.type=0;constraint.target=target;var chain=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.CHAIN,0);if(chain>0&&bone.parent!==null){constraint.root=bone.parent;constraint.bone=bone;}else {constraint.root=bone;constraint.bone=null;}return constraint;};ObjectDataParser.prototype._parsePathConstraint=function(rawData){var target=this._armature.getSlot(ObjectDataParser._getString(rawData,dragonBones.DataParser.TARGET,""));if(target===null){return null;}var defaultSkin=this._armature.defaultSkin;if(defaultSkin===null){return null;}var targetDisplay=defaultSkin.getDisplay(target.name,ObjectDataParser._getString(rawData,dragonBones.DataParser.TARGET_DISPLAY,target.name));if(targetDisplay===null||!(targetDisplay instanceof dragonBones.PathDisplayData)){return null;}var bones=rawData[dragonBones.DataParser.BONES];if(bones===null||bones.length===0){return null;}var constraint=dragonBones.BaseObject.borrowObject(dragonBones.PathConstraintData);constraint.name=ObjectDataParser._getString(rawData,dragonBones.DataParser.NAME,"");constraint.type=1;constraint.pathSlot=target;constraint.pathDisplayData=targetDisplay;constraint.target=target.parent;constraint.positionMode=dragonBones.DataParser._getPositionMode(ObjectDataParser._getString(rawData,dragonBones.DataParser.POSITION_MODE,""));constraint.spacingMode=dragonBones.DataParser._getSpacingMode(ObjectDataParser._getString(rawData,dragonBones.DataParser.SPACING_MODE,""));constraint.rotateMode=dragonBones.DataParser._getRotateMode(ObjectDataParser._getString(rawData,dragonBones.DataParser.ROTATE_MODE,""));constraint.position=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.POSITION,0);constraint.spacing=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.SPACING,0);constraint.rotateOffset=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.ROTATE_OFFSET,0);constraint.rotateMix=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.ROTATE_MIX,1);constraint.translateMix=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.TRANSLATE_MIX,1);for(var _i=0,bones_3=bones;_i<bones_3.length;_i++){var boneName=bones_3[_i];var bone=this._armature.getBone(boneName);if(bone!==null){constraint.AddBone(bone);if(constraint.root===null){constraint.root=bone;}}}return constraint;};ObjectDataParser.prototype._parseSlot=function(rawData,zOrder){var slot=dragonBones.BaseObject.borrowObject(dragonBones.SlotData);slot.displayIndex=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.DISPLAY_INDEX,0);slot.zOrder=zOrder;slot.name=ObjectDataParser._getString(rawData,dragonBones.DataParser.NAME,"");slot.parent=this._armature.getBone(ObjectDataParser._getString(rawData,dragonBones.DataParser.PARENT,""));if(dragonBones.DataParser.BLEND_MODE in rawData&&typeof rawData[dragonBones.DataParser.BLEND_MODE]==="string"){slot.blendMode=dragonBones.DataParser._getBlendMode(rawData[dragonBones.DataParser.BLEND_MODE]);}else {slot.blendMode=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.BLEND_MODE,0);}if(dragonBones.DataParser.COLOR in rawData){slot.color=dragonBones.SlotData.createColor();this._parseColorTransform(rawData[dragonBones.DataParser.COLOR],slot.color);}else {slot.color=dragonBones.SlotData.DEFAULT_COLOR;}if(dragonBones.DataParser.ACTIONS in rawData){this._slotChildActions[slot.name]=this._parseActionData(rawData[dragonBones.DataParser.ACTIONS],0,null,null);}return slot;};ObjectDataParser.prototype._parseSkin=function(rawData){var skin=dragonBones.BaseObject.borrowObject(dragonBones.SkinData);skin.name=ObjectDataParser._getString(rawData,dragonBones.DataParser.NAME,dragonBones.DataParser.DEFAULT_NAME);if(skin.name.length===0){skin.name=dragonBones.DataParser.DEFAULT_NAME;}if(dragonBones.DataParser.SLOT in rawData){var rawSlots=rawData[dragonBones.DataParser.SLOT];this._skin=skin;for(var _i=0,rawSlots_2=rawSlots;_i<rawSlots_2.length;_i++){var rawSlot=rawSlots_2[_i];var slotName=ObjectDataParser._getString(rawSlot,dragonBones.DataParser.NAME,"");var slot=this._armature.getSlot(slotName);if(slot!==null){this._slot=slot;if(dragonBones.DataParser.DISPLAY in rawSlot){var rawDisplays=rawSlot[dragonBones.DataParser.DISPLAY];for(var _a=0,rawDisplays_1=rawDisplays;_a<rawDisplays_1.length;_a++){var rawDisplay=rawDisplays_1[_a];if(rawDisplay){skin.addDisplay(slotName,this._parseDisplay(rawDisplay));}else {skin.addDisplay(slotName,null);}}}this._slot=null;}}this._skin=null;}return skin;};ObjectDataParser.prototype._parseDisplay=function(rawData){var name=ObjectDataParser._getString(rawData,dragonBones.DataParser.NAME,"");var path=ObjectDataParser._getString(rawData,dragonBones.DataParser.PATH,"");var type=0;var display=null;if(dragonBones.DataParser.TYPE in rawData&&typeof rawData[dragonBones.DataParser.TYPE]==="string"){type=dragonBones.DataParser._getDisplayType(rawData[dragonBones.DataParser.TYPE]);}else {type=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.TYPE,type);}switch(type){case 0:var imageDisplay=display=dragonBones.BaseObject.borrowObject(dragonBones.ImageDisplayData);imageDisplay.name=name;imageDisplay.path=path.length>0?path:name;this._parsePivot(rawData,imageDisplay);break;case 1:var armatureDisplay=display=dragonBones.BaseObject.borrowObject(dragonBones.ArmatureDisplayData);armatureDisplay.name=name;armatureDisplay.path=path.length>0?path:name;armatureDisplay.inheritAnimation=true;if(dragonBones.DataParser.ACTIONS in rawData){var actions=this._parseActionData(rawData[dragonBones.DataParser.ACTIONS],0,null,null);for(var _i=0,actions_5=actions;_i<actions_5.length;_i++){var action=actions_5[_i];armatureDisplay.addAction(action);}}else if(this._slot.name in this._slotChildActions){var displays=this._skin.getDisplays(this._slot.name);if(displays===null?this._slot.displayIndex===0:this._slot.displayIndex===displays.length){for(var _a=0,_b=this._slotChildActions[this._slot.name];_a<_b.length;_a++){var action=_b[_a];armatureDisplay.addAction(action);}delete this._slotChildActions[this._slot.name];}}break;case 2:var meshDisplay=display=dragonBones.BaseObject.borrowObject(dragonBones.MeshDisplayData);meshDisplay.vertices.inheritDeform=ObjectDataParser._getBoolean(rawData,dragonBones.DataParser.INHERIT_DEFORM,true);meshDisplay.name=name;meshDisplay.path=path.length>0?path:name;meshDisplay.vertices.data=this._data;if(dragonBones.DataParser.SHARE in rawData){this._cacheRawMeshes.push(rawData);this._cacheMeshes.push(meshDisplay);}else {this._parseMesh(rawData,meshDisplay);}if(dragonBones.DataParser.GLUE_WEIGHTS in rawData&&dragonBones.DataParser.GLUE_MESHES in rawData){this._cacheRawMeshes.push(rawData);this._cacheMeshes.push(meshDisplay);}break;case 3:var boundingBox=this._parseBoundingBox(rawData);if(boundingBox!==null){var boundingBoxDisplay=display=dragonBones.BaseObject.borrowObject(dragonBones.BoundingBoxDisplayData);boundingBoxDisplay.name=name;boundingBoxDisplay.path=path.length>0?path:name;boundingBoxDisplay.boundingBox=boundingBox;}break;case 4:var rawCurveLengths=rawData[dragonBones.DataParser.LENGTHS];var pathDisplay=display=dragonBones.BaseObject.borrowObject(dragonBones.PathDisplayData);pathDisplay.closed=ObjectDataParser._getBoolean(rawData,dragonBones.DataParser.CLOSED,false);pathDisplay.constantSpeed=ObjectDataParser._getBoolean(rawData,dragonBones.DataParser.CONSTANT_SPEED,false);pathDisplay.name=name;pathDisplay.path=path.length>0?path:name;pathDisplay.vertices.data=this._data;pathDisplay.curveLengths.length=rawCurveLengths.length;for(var i=0,l=rawCurveLengths.length;i<l;++i){pathDisplay.curveLengths[i]=rawCurveLengths[i];}this._parsePath(rawData,pathDisplay);break;}if(display!==null&&dragonBones.DataParser.TRANSFORM in rawData){this._parseTransform(rawData[dragonBones.DataParser.TRANSFORM],display.transform,this._armature.scale);}return display;};ObjectDataParser.prototype._parsePath=function(rawData,display){var rawVertices=rawData[dragonBones.DataParser.VERTICES];var vertexCount=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.VERTEX_COUNT,0);var vertexOffset=this._floatArray.length;var pathOffset=this._intArray.length;display.vertices.offset=pathOffset;this._intArray.length+=1+1;this._intArray[pathOffset+0]=vertexCount;this._intArray[pathOffset+2]=vertexOffset;if(!(dragonBones.DataParser.WEIGHTS in rawData)){this._floatArray.length+=rawVertices.length;for(var i=0,l=rawVertices.length;i<l;++i){this._floatArray[vertexOffset+i]=rawVertices[i];}}else {var rawWeights=rawData[dragonBones.DataParser.WEIGHTS];var rawBones=rawData[dragonBones.DataParser.BONES];var weightBoneCount=rawBones.length;var weightCount=Math.floor(rawWeights.length-vertexCount)/2;var weightOffset=this._intArray.length;var floatOffset=this._floatArray.length;var sortedBones=this._armature.sortedBones;var weight=dragonBones.BaseObject.borrowObject(dragonBones.WeightData);weight.count=weightCount;weight.offset=weightOffset;this._intArray.length+=1+1+weightBoneCount+vertexCount+weightCount;this._intArray[weightOffset+0]=weightBoneCount;this._intArray[weightOffset+1]=floatOffset;for(var i=0;i<weightBoneCount;i++){var rawBoneIndex=rawBones[i];var bone=this._rawBones[rawBoneIndex];weight.addBone(bone);this._intArray[weightOffset+2+i]=sortedBones.indexOf(bone);}this._floatArray.length+=weightCount*3;for(var i=0,iW=0,iV=0,iB=weightOffset+2+weightBoneCount,iF=floatOffset;i<weightCount;i++){var boneCount=rawWeights[iW++];this._intArray[iB++]=boneCount;for(var j=0;j<boneCount;j++){var boneIndex=rawWeights[iW++];var boneWeight=rawWeights[iW++];var x=rawVertices[iV++];var y=rawVertices[iV++];this._intArray[iB++]=rawBones.indexOf(boneIndex);this._floatArray[iF++]=boneWeight;this._floatArray[iF++]=x;this._floatArray[iF++]=y;}}display.vertices.weight=weight;}};ObjectDataParser.prototype._parsePivot=function(rawData,display){if(dragonBones.DataParser.PIVOT in rawData){var rawPivot=rawData[dragonBones.DataParser.PIVOT];display.pivot.x=ObjectDataParser._getNumber(rawPivot,dragonBones.DataParser.X,0.0);display.pivot.y=ObjectDataParser._getNumber(rawPivot,dragonBones.DataParser.Y,0.0);}else {display.pivot.x=0.5;display.pivot.y=0.5;}};ObjectDataParser.prototype._parseMesh=function(rawData,mesh){var rawVertices=rawData[dragonBones.DataParser.VERTICES];var rawUVs=rawData[dragonBones.DataParser.UVS];var rawTriangles=rawData[dragonBones.DataParser.TRIANGLES];var vertexCount=Math.floor(rawVertices.length/2);var triangleCount=Math.floor(rawTriangles.length/3);var vertexOffset=this._floatArray.length;var uvOffset=vertexOffset+vertexCount*2;var meshOffset=this._intArray.length;var meshName=this._skin.name+"_"+this._slot.name+"_"+mesh.name;mesh.vertices.offset=meshOffset;this._intArray.length+=1+1+1+1+triangleCount*3;this._intArray[meshOffset+0]=vertexCount;this._intArray[meshOffset+1]=triangleCount;this._intArray[meshOffset+2]=vertexOffset;for(var i=0,l=triangleCount*3;i<l;++i){this._intArray[meshOffset+4+i]=rawTriangles[i];}this._floatArray.length+=vertexCount*2+vertexCount*2;for(var i=0,l=vertexCount*2;i<l;++i){this._floatArray[vertexOffset+i]=rawVertices[i];this._floatArray[uvOffset+i]=rawUVs[i];}if(dragonBones.DataParser.WEIGHTS in rawData){var rawWeights=rawData[dragonBones.DataParser.WEIGHTS];var rawSlotPose=rawData[dragonBones.DataParser.SLOT_POSE];var rawBonePoses=rawData[dragonBones.DataParser.BONE_POSE];var sortedBones=this._armature.sortedBones;var weightBoneIndices=new Array();var weightBoneCount=Math.floor(rawBonePoses.length/7);var floatOffset=this._floatArray.length;var weightCount=Math.floor(rawWeights.length-vertexCount)/2;var weightOffset=this._intArray.length;var weight=dragonBones.BaseObject.borrowObject(dragonBones.WeightData);weight.count=weightCount;weight.offset=weightOffset;weightBoneIndices.length=weightBoneCount;this._intArray.length+=1+1+weightBoneCount+vertexCount+weightCount;this._intArray[weightOffset+1]=floatOffset;for(var i=0;i<weightBoneCount;++i){var rawBoneIndex=rawBonePoses[i*7];var bone=this._rawBones[rawBoneIndex];weight.addBone(bone);weightBoneIndices[i]=rawBoneIndex;this._intArray[weightOffset+2+i]=sortedBones.indexOf(bone);}this._floatArray.length+=weightCount*3;this._helpMatrixA.copyFromArray(rawSlotPose,0);for(var i=0,iW=0,iB=weightOffset+2+weightBoneCount,iV=floatOffset;i<vertexCount;++i){var iD=i*2;var vertexBoneCount=this._intArray[iB++]=rawWeights[iW++];var x=this._floatArray[vertexOffset+iD];var y=this._floatArray[vertexOffset+iD+1];this._helpMatrixA.transformPoint(x,y,this._helpPoint);x=this._helpPoint.x;y=this._helpPoint.y;for(var j=0;j<vertexBoneCount;++j){var rawBoneIndex=rawWeights[iW++];var boneIndex=weightBoneIndices.indexOf(rawBoneIndex);this._helpMatrixB.copyFromArray(rawBonePoses,boneIndex*7+1);this._helpMatrixB.invert();this._helpMatrixB.transformPoint(x,y,this._helpPoint);this._intArray[iB++]=boneIndex;this._floatArray[iV++]=rawWeights[iW++];this._floatArray[iV++]=this._helpPoint.x;this._floatArray[iV++]=this._helpPoint.y;}}mesh.vertices.weight=weight;this._weightSlotPose[meshName]=rawSlotPose;this._weightBonePoses[meshName]=rawBonePoses;}};ObjectDataParser.prototype._parseMeshGlue=function(rawData,mesh){};ObjectDataParser.prototype._parseBoundingBox=function(rawData){var boundingBox=null;var type=0;if(dragonBones.DataParser.SUB_TYPE in rawData&&typeof rawData[dragonBones.DataParser.SUB_TYPE]==="string"){type=dragonBones.DataParser._getBoundingBoxType(rawData[dragonBones.DataParser.SUB_TYPE]);}else {type=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.SUB_TYPE,type);}switch(type){case 0:boundingBox=dragonBones.BaseObject.borrowObject(dragonBones.RectangleBoundingBoxData);break;case 1:boundingBox=dragonBones.BaseObject.borrowObject(dragonBones.EllipseBoundingBoxData);break;case 2:boundingBox=this._parsePolygonBoundingBox(rawData);break;}if(boundingBox!==null){boundingBox.color=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.COLOR,0x000000);if(boundingBox.type===0||boundingBox.type===1){boundingBox.width=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.WIDTH,0.0);boundingBox.height=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.HEIGHT,0.0);}}return boundingBox;};ObjectDataParser.prototype._parsePolygonBoundingBox=function(rawData){var polygonBoundingBox=dragonBones.BaseObject.borrowObject(dragonBones.PolygonBoundingBoxData);if(dragonBones.DataParser.VERTICES in rawData){var scale=this._armature.scale;var rawVertices=rawData[dragonBones.DataParser.VERTICES];var vertices=polygonBoundingBox.vertices;if(dragonBones.DragonBones.webAssembly){vertices.resize(rawVertices.length,0.0);}else {vertices.length=rawVertices.length;}for(var i=0,l=rawVertices.length;i<l;i+=2){var x=rawVertices[i]*scale;var y=rawVertices[i+1]*scale;if(dragonBones.DragonBones.webAssembly){vertices.set(i,x);vertices.set(i+1,y);}else {vertices[i]=x;vertices[i+1]=y;}if(i===0){polygonBoundingBox.x=x;polygonBoundingBox.y=y;polygonBoundingBox.width=x;polygonBoundingBox.height=y;}else {if(x<polygonBoundingBox.x){polygonBoundingBox.x=x;}else if(x>polygonBoundingBox.width){polygonBoundingBox.width=x;}if(y<polygonBoundingBox.y){polygonBoundingBox.y=y;}else if(y>polygonBoundingBox.height){polygonBoundingBox.height=y;}}}polygonBoundingBox.width-=polygonBoundingBox.x;polygonBoundingBox.height-=polygonBoundingBox.y;}else {console.warn("Data error.\n Please reexport DragonBones Data to fixed the bug.");}return polygonBoundingBox;};ObjectDataParser.prototype._parseAnimation=function(rawData){var animation=dragonBones.BaseObject.borrowObject(dragonBones.AnimationData);animation.frameCount=Math.max(ObjectDataParser._getNumber(rawData,dragonBones.DataParser.DURATION,1),1);animation.playTimes=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.PLAY_TIMES,1);animation.duration=animation.frameCount/this._armature.frameRate;animation.fadeInTime=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.FADE_IN_TIME,0.0);animation.scale=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.SCALE,1.0);animation.name=ObjectDataParser._getString(rawData,dragonBones.DataParser.NAME,dragonBones.DataParser.DEFAULT_NAME);if(animation.name.length===0){animation.name=dragonBones.DataParser.DEFAULT_NAME;}animation.frameIntOffset=this._frameIntArray.length;animation.frameFloatOffset=this._frameFloatArray.length;animation.frameOffset=this._frameArray.length;this._animation=animation;if(dragonBones.DataParser.FRAME in rawData){var rawFrames=rawData[dragonBones.DataParser.FRAME];var keyFrameCount=rawFrames.length;if(keyFrameCount>0){for(var i=0,frameStart=0;i<keyFrameCount;++i){var rawFrame=rawFrames[i];this._parseActionDataInFrame(rawFrame,frameStart,null,null);frameStart+=ObjectDataParser._getNumber(rawFrame,dragonBones.DataParser.DURATION,1);}}}if(dragonBones.DataParser.Z_ORDER in rawData){this._animation.zOrderTimeline=this._parseTimeline(rawData[dragonBones.DataParser.Z_ORDER],null,dragonBones.DataParser.FRAME,1,false,false,0,this._parseZOrderFrame);}if(dragonBones.DataParser.BONE in rawData){var rawTimelines=rawData[dragonBones.DataParser.BONE];for(var _i=0,rawTimelines_1=rawTimelines;_i<rawTimelines_1.length;_i++){var rawTimeline=rawTimelines_1[_i];this._parseBoneTimeline(rawTimeline);}}if(dragonBones.DataParser.SURFACE in rawData){var rawTimelines=rawData[dragonBones.DataParser.SURFACE];for(var _a=0,rawTimelines_2=rawTimelines;_a<rawTimelines_2.length;_a++){var rawTimeline=rawTimelines_2[_a];var surfaceName=ObjectDataParser._getString(rawTimeline,dragonBones.DataParser.NAME,"");this._surface=this._armature.getBone(surfaceName);if(this._surface===null){continue;}var timeline=this._parseTimeline(rawTimeline,null,dragonBones.DataParser.FRAME,50,false,true,0,this._parseSurfaceFrame);if(timeline!==null){this._animation.addSurfaceTimeline(this._surface,timeline);}this._surface=null;}}if(dragonBones.DataParser.SLOT in rawData){var rawTimelines=rawData[dragonBones.DataParser.SLOT];for(var _b=0,rawTimelines_3=rawTimelines;_b<rawTimelines_3.length;_b++){var rawTimeline=rawTimelines_3[_b];this._parseSlotTimeline(rawTimeline);}}if(dragonBones.DataParser.FFD in rawData){var rawTimelines=rawData[dragonBones.DataParser.FFD];for(var _c=0,rawTimelines_4=rawTimelines;_c<rawTimelines_4.length;_c++){var rawTimeline=rawTimelines_4[_c];var skinName=ObjectDataParser._getString(rawTimeline,dragonBones.DataParser.SKIN,dragonBones.DataParser.DEFAULT_NAME);var slotName=ObjectDataParser._getString(rawTimeline,dragonBones.DataParser.SLOT,"");var displayName=ObjectDataParser._getString(rawTimeline,dragonBones.DataParser.NAME,"");if(skinName.length===0){skinName=dragonBones.DataParser.DEFAULT_NAME;}this._slot=this._armature.getSlot(slotName);this._mesh=this._armature.getMesh(skinName,slotName,displayName);if(this._slot===null||this._mesh===null){continue;}var timeline=this._parseTimeline(rawTimeline,null,dragonBones.DataParser.FRAME,22,false,true,0,this._parseSlotFFDFrame);if(timeline!==null){this._animation.addSlotTimeline(this._slot,timeline);}this._slot=null;this._mesh=null;}}if(dragonBones.DataParser.IK in rawData){var rawTimelines=rawData[dragonBones.DataParser.IK];for(var _d=0,rawTimelines_5=rawTimelines;_d<rawTimelines_5.length;_d++){var rawTimeline=rawTimelines_5[_d];var constraintName=ObjectDataParser._getString(rawTimeline,dragonBones.DataParser.NAME,"");var constraint=this._armature.getConstraint(constraintName);if(constraint===null){continue;}var timeline=this._parseTimeline(rawTimeline,null,dragonBones.DataParser.FRAME,30,true,false,2,this._parseIKConstraintFrame);if(timeline!==null){this._animation.addConstraintTimeline(constraint,timeline);}}}if(dragonBones.DataParser.ANIMATION in rawData){var rawTimelines=rawData[dragonBones.DataParser.ANIMATION];for(var _e=0,rawTimelines_6=rawTimelines;_e<rawTimelines_6.length;_e++){var rawTimeline=rawTimelines_6[_e];var animationName=ObjectDataParser._getString(rawTimeline,dragonBones.DataParser.NAME,"");var timeline=this._parseTimeline(rawTimeline,null,dragonBones.DataParser.FRAME,40,true,false,2,this._parseAnimationFrame);if(timeline!==null){this._animation.addAnimationTimeline(animationName,timeline);}}}if(this._actionFrames.length>0){this._animation.actionTimeline=this._parseTimeline(null,this._actionFrames,"",0,false,false,0,this._parseActionFrame);this._actionFrames.length=0;}this._animation=null;return animation;};ObjectDataParser.prototype._parseTimeline=function(rawData,rawFrames,framesKey,type,addIntOffset,addFloatOffset,frameValueCount,frameParser){if(rawData!==null&&framesKey.length>0&&framesKey in rawData){rawFrames=rawData[framesKey];}if(rawFrames===null){return null;}var keyFrameCount=rawFrames.length;if(keyFrameCount===0){return null;}var frameIntArrayLength=this._frameIntArray.length;var frameFloatArrayLength=this._frameFloatArray.length;var timeline=dragonBones.BaseObject.borrowObject(dragonBones.TimelineData);var timelineOffset=this._timelineArray.length;this._timelineArray.length+=1+1+1+1+1+keyFrameCount;if(rawData!==null){this._timelineArray[timelineOffset+0]=Math.round(ObjectDataParser._getNumber(rawData,dragonBones.DataParser.SCALE,1.0)*100);this._timelineArray[timelineOffset+1]=Math.round(ObjectDataParser._getNumber(rawData,dragonBones.DataParser.OFFSET,0.0)*100);}else {this._timelineArray[timelineOffset+0]=100;this._timelineArray[timelineOffset+1]=0;}this._timelineArray[timelineOffset+2]=keyFrameCount;this._timelineArray[timelineOffset+3]=frameValueCount;if(addIntOffset){this._timelineArray[timelineOffset+4]=frameIntArrayLength-this._animation.frameIntOffset;}else if(addFloatOffset){this._timelineArray[timelineOffset+4]=frameFloatArrayLength-this._animation.frameFloatOffset;}else {this._timelineArray[timelineOffset+4]=0;}this._timeline=timeline;timeline.type=type;timeline.offset=timelineOffset;if(keyFrameCount===1){timeline.frameIndicesOffset=-1;this._timelineArray[timelineOffset+5+0]=frameParser.call(this,rawFrames[0],0,0)-this._animation.frameOffset;}else {var totalFrameCount=this._animation.frameCount+1;var frameIndices=this._data.frameIndices;var frameIndicesOffset=0;if(dragonBones.DragonBones.webAssembly){frameIndicesOffset=frameIndices.size();frameIndices.resize(frameIndicesOffset+totalFrameCount,0);}else {frameIndicesOffset=frameIndices.length;frameIndices.length+=totalFrameCount;}timeline.frameIndicesOffset=frameIndicesOffset;for(var i=0,iK=0,frameStart=0,frameCount=0;i<totalFrameCount;++i){if(frameStart+frameCount<=i&&iK<keyFrameCount){var rawFrame=rawFrames[iK];frameStart=i;if(iK===keyFrameCount-1){frameCount=this._animation.frameCount-frameStart;}else {if(rawFrame instanceof ActionFrame){frameCount=this._actionFrames[iK+1].frameStart-frameStart;}else {frameCount=ObjectDataParser._getNumber(rawFrame,dragonBones.DataParser.DURATION,1);}}this._timelineArray[timelineOffset+5+iK]=frameParser.call(this,rawFrame,frameStart,frameCount)-this._animation.frameOffset;iK++;}if(dragonBones.DragonBones.webAssembly){frameIndices.set(frameIndicesOffset+i,iK-1);}else {frameIndices[frameIndicesOffset+i]=iK-1;}}}this._timeline=null;return timeline;};ObjectDataParser.prototype._parseBoneTimeline=function(rawData){var bone=this._armature.getBone(ObjectDataParser._getString(rawData,dragonBones.DataParser.NAME,""));if(bone===null){return;}this._bone=bone;this._slot=this._armature.getSlot(this._bone.name);if(dragonBones.DataParser.TRANSLATE_FRAME in rawData){var timeline=this._parseTimeline(rawData,null,dragonBones.DataParser.TRANSLATE_FRAME,11,false,true,2,this._parseBoneTranslateFrame);if(timeline!==null){this._animation.addBoneTimeline(bone,timeline);}}if(dragonBones.DataParser.ROTATE_FRAME in rawData){var timeline=this._parseTimeline(rawData,null,dragonBones.DataParser.ROTATE_FRAME,12,false,true,2,this._parseBoneRotateFrame);if(timeline!==null){this._animation.addBoneTimeline(bone,timeline);}}if(dragonBones.DataParser.SCALE_FRAME in rawData){var timeline=this._parseTimeline(rawData,null,dragonBones.DataParser.SCALE_FRAME,13,false,true,2,this._parseBoneScaleFrame);if(timeline!==null){this._animation.addBoneTimeline(bone,timeline);}}if(dragonBones.DataParser.FRAME in rawData){var timeline=this._parseTimeline(rawData,null,dragonBones.DataParser.FRAME,10,false,true,6,this._parseBoneAllFrame);if(timeline!==null){this._animation.addBoneTimeline(bone,timeline);}}this._bone=null;this._slot=null;};ObjectDataParser.prototype._parseSlotTimeline=function(rawData){var slot=this._armature.getSlot(ObjectDataParser._getString(rawData,dragonBones.DataParser.NAME,""));if(slot===null){return;}this._slot=slot;var displayTimeline=null;if(dragonBones.DataParser.DISPLAY_FRAME in rawData){displayTimeline=this._parseTimeline(rawData,null,dragonBones.DataParser.DISPLAY_FRAME,20,false,false,0,this._parseSlotDisplayFrame);}else {displayTimeline=this._parseTimeline(rawData,null,dragonBones.DataParser.FRAME,20,false,false,0,this._parseSlotDisplayFrame);}if(displayTimeline!==null){this._animation.addSlotTimeline(slot,displayTimeline);}var colorTimeline=null;if(dragonBones.DataParser.COLOR_FRAME in rawData){colorTimeline=this._parseTimeline(rawData,null,dragonBones.DataParser.COLOR_FRAME,21,true,false,1,this._parseSlotColorFrame);}else {colorTimeline=this._parseTimeline(rawData,null,dragonBones.DataParser.FRAME,21,true,false,1,this._parseSlotColorFrame);}if(colorTimeline!==null){this._animation.addSlotTimeline(slot,colorTimeline);}this._slot=null;};ObjectDataParser.prototype._parseFrame=function(rawData,frameStart,frameCount){var frameOffset=this._frameArray.length;this._frameArray.length+=1;this._frameArray[frameOffset+0]=frameStart;return frameOffset;};ObjectDataParser.prototype._parseTweenFrame=function(rawData,frameStart,frameCount){var frameOffset=this._parseFrame(rawData,frameStart,frameCount);if(frameCount>0){if(dragonBones.DataParser.CURVE in rawData){var sampleCount=frameCount+1;this._helpArray.length=sampleCount;this._samplingEasingCurve(rawData[dragonBones.DataParser.CURVE],this._helpArray);this._frameArray.length+=1+1+this._helpArray.length;this._frameArray[frameOffset+1]=2;this._frameArray[frameOffset+2]=sampleCount;for(var i=0;i<sampleCount;++i){this._frameArray[frameOffset+3+i]=Math.round(this._helpArray[i]*10000.0);}}else {var noTween=-2.0;var tweenEasing=noTween;if(dragonBones.DataParser.TWEEN_EASING in rawData){tweenEasing=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.TWEEN_EASING,noTween);}if(tweenEasing===noTween){this._frameArray.length+=1;this._frameArray[frameOffset+1]=0;}else if(tweenEasing===0.0){this._frameArray.length+=1;this._frameArray[frameOffset+1]=1;}else if(tweenEasing<0.0){this._frameArray.length+=1+1;this._frameArray[frameOffset+1]=3;this._frameArray[frameOffset+2]=Math.round(-tweenEasing*100.0);}else if(tweenEasing<=1.0){this._frameArray.length+=1+1;this._frameArray[frameOffset+1]=4;this._frameArray[frameOffset+2]=Math.round(tweenEasing*100.0);}else {this._frameArray.length+=1+1;this._frameArray[frameOffset+1]=5;this._frameArray[frameOffset+2]=Math.round(tweenEasing*100.0-100.0);}}}else {this._frameArray.length+=1;this._frameArray[frameOffset+1]=0;}return frameOffset;};ObjectDataParser.prototype._parseActionFrame=function(frame,frameStart,frameCount){var frameOffset=this._frameArray.length;var actionCount=frame.actions.length;this._frameArray.length+=1+1+actionCount;this._frameArray[frameOffset+0]=frameStart;this._frameArray[frameOffset+0+1]=actionCount;for(var i=0;i<actionCount;++i){this._frameArray[frameOffset+0+2+i]=frame.actions[i];}return frameOffset;};ObjectDataParser.prototype._parseZOrderFrame=function(rawData,frameStart,frameCount){var frameOffset=this._parseFrame(rawData,frameStart,frameCount);if(dragonBones.DataParser.Z_ORDER in rawData){var rawZOrder=rawData[dragonBones.DataParser.Z_ORDER];if(rawZOrder.length>0){var slotCount=this._armature.sortedSlots.length;var unchanged=new Array(slotCount-rawZOrder.length/2);var zOrders=new Array(slotCount);for(var i_1=0;i_1<unchanged.length;++i_1){unchanged[i_1]=0;}for(var i_2=0;i_2<slotCount;++i_2){zOrders[i_2]=-1;}var originalIndex=0;var unchangedIndex=0;for(var i_3=0,l=rawZOrder.length;i_3<l;i_3+=2){var slotIndex=rawZOrder[i_3];var zOrderOffset=rawZOrder[i_3+1];while(originalIndex!==slotIndex){unchanged[unchangedIndex++]=originalIndex++;}var index=originalIndex+zOrderOffset;zOrders[index]=originalIndex++;}while(originalIndex<slotCount){unchanged[unchangedIndex++]=originalIndex++;}this._frameArray.length+=1+slotCount;this._frameArray[frameOffset+1]=slotCount;var i=slotCount;while(i--){if(zOrders[i]===-1){this._frameArray[frameOffset+2+i]=unchanged[--unchangedIndex]||0;}else {this._frameArray[frameOffset+2+i]=zOrders[i]||0;}}return frameOffset;}}this._frameArray.length+=1;this._frameArray[frameOffset+1]=0;return frameOffset;};ObjectDataParser.prototype._parseBoneAllFrame=function(rawData,frameStart,frameCount){this._helpTransform.identity();if(dragonBones.DataParser.TRANSFORM in rawData){this._parseTransform(rawData[dragonBones.DataParser.TRANSFORM],this._helpTransform,1.0);}var rotation=this._helpTransform.rotation;if(frameStart!==0){if(this._prevClockwise===0){rotation=this._prevRotation+dragonBones.Transform.normalizeRadian(rotation-this._prevRotation);}else {if(this._prevClockwise>0?rotation>=this._prevRotation:rotation<=this._prevRotation){this._prevClockwise=this._prevClockwise>0?this._prevClockwise-1:this._prevClockwise+1;}rotation=this._prevRotation+rotation-this._prevRotation+dragonBones.Transform.PI_D*this._prevClockwise;}}this._prevClockwise=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.TWEEN_ROTATE,0.0);this._prevRotation=rotation;var frameOffset=this._parseTweenFrame(rawData,frameStart,frameCount);var frameFloatOffset=this._frameFloatArray.length;this._frameFloatArray.length+=6;this._frameFloatArray[frameFloatOffset++]=this._helpTransform.x;this._frameFloatArray[frameFloatOffset++]=this._helpTransform.y;this._frameFloatArray[frameFloatOffset++]=rotation;this._frameFloatArray[frameFloatOffset++]=this._helpTransform.skew;this._frameFloatArray[frameFloatOffset++]=this._helpTransform.scaleX;this._frameFloatArray[frameFloatOffset++]=this._helpTransform.scaleY;this._parseActionDataInFrame(rawData,frameStart,this._bone,this._slot);return frameOffset;};ObjectDataParser.prototype._parseBoneTranslateFrame=function(rawData,frameStart,frameCount){var frameOffset=this._parseTweenFrame(rawData,frameStart,frameCount);var frameFloatOffset=this._frameFloatArray.length;this._frameFloatArray.length+=2;this._frameFloatArray[frameFloatOffset++]=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.X,0.0);this._frameFloatArray[frameFloatOffset++]=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.Y,0.0);return frameOffset;};ObjectDataParser.prototype._parseBoneRotateFrame=function(rawData,frameStart,frameCount){var rotation=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.ROTATE,0.0)*dragonBones.Transform.DEG_RAD;if(frameStart!==0){if(this._prevClockwise===0){rotation=this._prevRotation+dragonBones.Transform.normalizeRadian(rotation-this._prevRotation);}else {if(this._prevClockwise>0?rotation>=this._prevRotation:rotation<=this._prevRotation){this._prevClockwise=this._prevClockwise>0?this._prevClockwise-1:this._prevClockwise+1;}rotation=this._prevRotation+rotation-this._prevRotation+dragonBones.Transform.PI_D*this._prevClockwise;}}this._prevClockwise=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.CLOCK_WISE,0);this._prevRotation=rotation;var frameOffset=this._parseTweenFrame(rawData,frameStart,frameCount);var frameFloatOffset=this._frameFloatArray.length;this._frameFloatArray.length+=2;this._frameFloatArray[frameFloatOffset++]=rotation;this._frameFloatArray[frameFloatOffset++]=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.SKEW,0.0)*dragonBones.Transform.DEG_RAD;return frameOffset;};ObjectDataParser.prototype._parseBoneScaleFrame=function(rawData,frameStart,frameCount){var frameOffset=this._parseTweenFrame(rawData,frameStart,frameCount);var frameFloatOffset=this._frameFloatArray.length;this._frameFloatArray.length+=2;this._frameFloatArray[frameFloatOffset++]=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.X,1.0);this._frameFloatArray[frameFloatOffset++]=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.Y,1.0);return frameOffset;};ObjectDataParser.prototype._parseSurfaceFrame=function(rawData,frameStart,frameCount){var frameFloatOffset=this._frameFloatArray.length;var frameOffset=this._parseTweenFrame(rawData,frameStart,frameCount);var rawVertices=rawData[dragonBones.DataParser.VERTICES];var offset=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.OFFSET,0);var vertexCount=this._surface.vertices.length/2;var x=0.0;var y=0.0;this._frameFloatArray.length+=vertexCount*2;for(var i=0;i<vertexCount*2;i+=2){if(i<offset||i-offset>=rawVertices.length){x=0.0;}else {x=rawVertices[i-offset];}if(i+1<offset||i+1-offset>=rawVertices.length){y=0.0;}else {y=rawVertices[i+1-offset];}this._frameFloatArray[frameFloatOffset+i]=x;this._frameFloatArray[frameFloatOffset+i+1]=y;}if(frameStart===0){var frameIntOffset=this._frameIntArray.length;this._frameIntArray.length+=1+1+1+1+1;this._frameIntArray[frameIntOffset+0]=0;this._frameIntArray[frameIntOffset+1]=this._frameFloatArray.length-frameFloatOffset;this._frameIntArray[frameIntOffset+2]=this._frameFloatArray.length-frameFloatOffset;this._frameIntArray[frameIntOffset+3]=0;this._frameIntArray[frameIntOffset+4]=frameFloatOffset-this._animation.frameFloatOffset;this._timelineArray[this._timeline.offset+3]=frameIntOffset-this._animation.frameIntOffset;}return frameOffset;};ObjectDataParser.prototype._parseSlotDisplayFrame=function(rawData,frameStart,frameCount){var frameOffset=this._parseFrame(rawData,frameStart,frameCount);this._frameArray.length+=1;if(dragonBones.DataParser.VALUE in rawData){this._frameArray[frameOffset+1]=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.VALUE,0);}else {this._frameArray[frameOffset+1]=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.DISPLAY_INDEX,0);}this._parseActionDataInFrame(rawData,frameStart,this._slot.parent,this._slot);return frameOffset;};ObjectDataParser.prototype._parseSlotColorFrame=function(rawData,frameStart,frameCount){var frameOffset=this._parseTweenFrame(rawData,frameStart,frameCount);var colorOffset=-1;if(dragonBones.DataParser.VALUE in rawData||dragonBones.DataParser.COLOR in rawData){var rawColor=dragonBones.DataParser.VALUE in rawData?rawData[dragonBones.DataParser.VALUE]:rawData[dragonBones.DataParser.COLOR];for(var k in rawColor){this._parseColorTransform(rawColor,this._helpColorTransform);colorOffset=this._intArray.length;this._intArray.length+=8;this._intArray[colorOffset++]=Math.round(this._helpColorTransform.alphaMultiplier*100);this._intArray[colorOffset++]=Math.round(this._helpColorTransform.redMultiplier*100);this._intArray[colorOffset++]=Math.round(this._helpColorTransform.greenMultiplier*100);this._intArray[colorOffset++]=Math.round(this._helpColorTransform.blueMultiplier*100);this._intArray[colorOffset++]=Math.round(this._helpColorTransform.alphaOffset);this._intArray[colorOffset++]=Math.round(this._helpColorTransform.redOffset);this._intArray[colorOffset++]=Math.round(this._helpColorTransform.greenOffset);this._intArray[colorOffset++]=Math.round(this._helpColorTransform.blueOffset);colorOffset-=8;break;}}if(colorOffset<0){if(this._defaultColorOffset<0){this._defaultColorOffset=colorOffset=this._intArray.length;this._intArray.length+=8;this._intArray[colorOffset++]=100;this._intArray[colorOffset++]=100;this._intArray[colorOffset++]=100;this._intArray[colorOffset++]=100;this._intArray[colorOffset++]=0;this._intArray[colorOffset++]=0;this._intArray[colorOffset++]=0;this._intArray[colorOffset++]=0;}colorOffset=this._defaultColorOffset;}var frameIntOffset=this._frameIntArray.length;this._frameIntArray.length+=1;this._frameIntArray[frameIntOffset]=colorOffset;return frameOffset;};ObjectDataParser.prototype._parseSlotFFDFrame=function(rawData,frameStart,frameCount){var frameFloatOffset=this._frameFloatArray.length;var frameOffset=this._parseTweenFrame(rawData,frameStart,frameCount);var rawVertices=dragonBones.DataParser.VERTICES in rawData?rawData[dragonBones.DataParser.VERTICES]:null;var offset=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.OFFSET,0);var vertexCount=this._intArray[this._mesh.vertices.offset+0];var meshName=this._mesh.parent.name+"_"+this._slot.name+"_"+this._mesh.name;var weight=this._mesh.vertices.weight;var x=0.0;var y=0.0;var iB=0;var iV=0;if(weight!==null){var rawSlotPose=this._weightSlotPose[meshName];this._helpMatrixA.copyFromArray(rawSlotPose,0);this._frameFloatArray.length+=weight.count*2;iB=weight.offset+2+weight.bones.length;}else {this._frameFloatArray.length+=vertexCount*2;}for(var i=0;i<vertexCount*2;i+=2){if(rawVertices===null){x=0.0;y=0.0;}else {if(i<offset||i-offset>=rawVertices.length){x=0.0;}else {x=rawVertices[i-offset];}if(i+1<offset||i+1-offset>=rawVertices.length){y=0.0;}else {y=rawVertices[i+1-offset];}}if(weight!==null){var rawBonePoses=this._weightBonePoses[meshName];var vertexBoneCount=this._intArray[iB++];this._helpMatrixA.transformPoint(x,y,this._helpPoint,true);x=this._helpPoint.x;y=this._helpPoint.y;for(var j=0;j<vertexBoneCount;++j){var boneIndex=this._intArray[iB++];this._helpMatrixB.copyFromArray(rawBonePoses,boneIndex*7+1);this._helpMatrixB.invert();this._helpMatrixB.transformPoint(x,y,this._helpPoint,true);this._frameFloatArray[frameFloatOffset+iV++]=this._helpPoint.x;this._frameFloatArray[frameFloatOffset+iV++]=this._helpPoint.y;}}else {this._frameFloatArray[frameFloatOffset+i]=x;this._frameFloatArray[frameFloatOffset+i+1]=y;}}if(frameStart===0){var frameIntOffset=this._frameIntArray.length;this._frameIntArray.length+=1+1+1+1+1;this._frameIntArray[frameIntOffset+0]=this._mesh.vertices.offset;this._frameIntArray[frameIntOffset+1]=this._frameFloatArray.length-frameFloatOffset;this._frameIntArray[frameIntOffset+2]=this._frameFloatArray.length-frameFloatOffset;this._frameIntArray[frameIntOffset+3]=0;this._frameIntArray[frameIntOffset+4]=frameFloatOffset-this._animation.frameFloatOffset;this._timelineArray[this._timeline.offset+3]=frameIntOffset-this._animation.frameIntOffset;}return frameOffset;};ObjectDataParser.prototype._parseIKConstraintFrame=function(rawData,frameStart,frameCount){var frameOffset=this._parseTweenFrame(rawData,frameStart,frameCount);var frameIntOffset=this._frameIntArray.length;this._frameIntArray.length+=2;this._frameIntArray[frameIntOffset++]=ObjectDataParser._getBoolean(rawData,dragonBones.DataParser.BEND_POSITIVE,true)?1:0;this._frameIntArray[frameIntOffset++]=Math.round(ObjectDataParser._getNumber(rawData,dragonBones.DataParser.WEIGHT,1.0)*100.0);return frameOffset;};ObjectDataParser.prototype._parseAnimationFrame=function(rawData,frameStart,frameCount){var frameOffset=this._parseTweenFrame(rawData,frameStart,frameCount);var frameIntOffset=this._frameIntArray.length;this._frameIntArray.length+=2;this._frameIntArray[frameIntOffset++]=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.VALUE,0);this._frameIntArray[frameIntOffset++]=Math.round(ObjectDataParser._getNumber(rawData,dragonBones.DataParser.WEIGHT,1.0)*100.0);return frameOffset;};ObjectDataParser.prototype._parseActionData=function(rawData,type,bone,slot){var actions=new Array();if(typeof rawData==="string"){var action=dragonBones.BaseObject.borrowObject(dragonBones.ActionData);action.type=type;action.name=rawData;action.bone=bone;action.slot=slot;actions.push(action);}else if(rawData instanceof Array){for(var _i=0,rawData_2=rawData;_i<rawData_2.length;_i++){var rawAction=rawData_2[_i];var action=dragonBones.BaseObject.borrowObject(dragonBones.ActionData);if(dragonBones.DataParser.GOTO_AND_PLAY in rawAction){action.type=0;action.name=ObjectDataParser._getString(rawAction,dragonBones.DataParser.GOTO_AND_PLAY,"");}else {if(dragonBones.DataParser.TYPE in rawAction&&typeof rawAction[dragonBones.DataParser.TYPE]==="string"){action.type=dragonBones.DataParser._getActionType(rawAction[dragonBones.DataParser.TYPE]);}else {action.type=ObjectDataParser._getNumber(rawAction,dragonBones.DataParser.TYPE,type);}action.name=ObjectDataParser._getString(rawAction,dragonBones.DataParser.NAME,"");}if(dragonBones.DataParser.BONE in rawAction){var boneName=ObjectDataParser._getString(rawAction,dragonBones.DataParser.BONE,"");action.bone=this._armature.getBone(boneName);}else {action.bone=bone;}if(dragonBones.DataParser.SLOT in rawAction){var slotName=ObjectDataParser._getString(rawAction,dragonBones.DataParser.SLOT,"");action.slot=this._armature.getSlot(slotName);}else {action.slot=slot;}var userData=null;if(dragonBones.DataParser.INTS in rawAction){if(userData===null){userData=dragonBones.BaseObject.borrowObject(dragonBones.UserData);}var rawInts=rawAction[dragonBones.DataParser.INTS];for(var _a=0,rawInts_1=rawInts;_a<rawInts_1.length;_a++){var rawValue=rawInts_1[_a];userData.addInt(rawValue);}}if(dragonBones.DataParser.FLOATS in rawAction){if(userData===null){userData=dragonBones.BaseObject.borrowObject(dragonBones.UserData);}var rawFloats=rawAction[dragonBones.DataParser.FLOATS];for(var _b=0,rawFloats_1=rawFloats;_b<rawFloats_1.length;_b++){var rawValue=rawFloats_1[_b];userData.addFloat(rawValue);}}if(dragonBones.DataParser.STRINGS in rawAction){if(userData===null){userData=dragonBones.BaseObject.borrowObject(dragonBones.UserData);}var rawStrings=rawAction[dragonBones.DataParser.STRINGS];for(var _c=0,rawStrings_1=rawStrings;_c<rawStrings_1.length;_c++){var rawValue=rawStrings_1[_c];userData.addString(rawValue);}}action.data=userData;actions.push(action);}}return actions;};ObjectDataParser.prototype._parseTransform=function(rawData,transform,scale){transform.x=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.X,0.0)*scale;transform.y=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.Y,0.0)*scale;if(dragonBones.DataParser.ROTATE in rawData||dragonBones.DataParser.SKEW in rawData){transform.rotation=dragonBones.Transform.normalizeRadian(ObjectDataParser._getNumber(rawData,dragonBones.DataParser.ROTATE,0.0)*dragonBones.Transform.DEG_RAD);transform.skew=dragonBones.Transform.normalizeRadian(ObjectDataParser._getNumber(rawData,dragonBones.DataParser.SKEW,0.0)*dragonBones.Transform.DEG_RAD);}else if(dragonBones.DataParser.SKEW_X in rawData||dragonBones.DataParser.SKEW_Y in rawData){transform.rotation=dragonBones.Transform.normalizeRadian(ObjectDataParser._getNumber(rawData,dragonBones.DataParser.SKEW_Y,0.0)*dragonBones.Transform.DEG_RAD);transform.skew=dragonBones.Transform.normalizeRadian(ObjectDataParser._getNumber(rawData,dragonBones.DataParser.SKEW_X,0.0)*dragonBones.Transform.DEG_RAD)-transform.rotation;}transform.scaleX=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.SCALE_X,1.0);transform.scaleY=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.SCALE_Y,1.0);};ObjectDataParser.prototype._parseColorTransform=function(rawData,color){color.alphaMultiplier=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.ALPHA_MULTIPLIER,100)*0.01;color.redMultiplier=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.RED_MULTIPLIER,100)*0.01;color.greenMultiplier=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.GREEN_MULTIPLIER,100)*0.01;color.blueMultiplier=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.BLUE_MULTIPLIER,100)*0.01;color.alphaOffset=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.ALPHA_OFFSET,0);color.redOffset=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.RED_OFFSET,0);color.greenOffset=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.GREEN_OFFSET,0);color.blueOffset=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.BLUE_OFFSET,0);};ObjectDataParser.prototype._parseArray=function(rawData){this._intArray.length=0;this._floatArray.length=0;this._frameIntArray.length=0;this._frameFloatArray.length=0;this._frameArray.length=0;this._timelineArray.length=0;};ObjectDataParser.prototype._modifyArray=function(){if(this._intArray.length%Int16Array.BYTES_PER_ELEMENT!==0){this._intArray.push(0);}if(this._frameIntArray.length%Int16Array.BYTES_PER_ELEMENT!==0){this._frameIntArray.push(0);}if(this._frameArray.length%Int16Array.BYTES_PER_ELEMENT!==0){this._frameArray.push(0);}if(this._timelineArray.length%Uint16Array.BYTES_PER_ELEMENT!==0){this._timelineArray.push(0);}var l1=this._intArray.length*Int16Array.BYTES_PER_ELEMENT;var l2=this._floatArray.length*Float32Array.BYTES_PER_ELEMENT;var l3=this._frameIntArray.length*Int16Array.BYTES_PER_ELEMENT;var l4=this._frameFloatArray.length*Float32Array.BYTES_PER_ELEMENT;var l5=this._frameArray.length*Int16Array.BYTES_PER_ELEMENT;var l6=this._timelineArray.length*Uint16Array.BYTES_PER_ELEMENT;var lTotal=l1+l2+l3+l4+l5+l6;if(dragonBones.DragonBones.webAssembly){var shareBuffer=dragonBones.webAssemblyModule.HEAP16.buffer;var bufferPointer=dragonBones.webAssemblyModule._malloc(lTotal);var intArray=new Int16Array(shareBuffer,bufferPointer,this._intArray.length);var floatArray=new Float32Array(shareBuffer,bufferPointer+l1,this._floatArray.length);var frameIntArray=new Int16Array(shareBuffer,bufferPointer+l1+l2,this._frameIntArray.length);var frameFloatArray=new Float32Array(shareBuffer,bufferPointer+l1+l2+l3,this._frameFloatArray.length);var frameArray=new Int16Array(shareBuffer,bufferPointer+l1+l2+l3+l4,this._frameArray.length);var timelineArray=new Uint16Array(shareBuffer,bufferPointer+l1+l2+l3+l4+l5,this._timelineArray.length);for(var i=0,l=this._intArray.length;i<l;++i){intArray[i]=this._intArray[i];}for(var i=0,l=this._floatArray.length;i<l;++i){floatArray[i]=this._floatArray[i];}for(var i=0,l=this._frameIntArray.length;i<l;++i){frameIntArray[i]=this._frameIntArray[i];}for(var i=0,l=this._frameFloatArray.length;i<l;++i){frameFloatArray[i]=this._frameFloatArray[i];}for(var i=0,l=this._frameArray.length;i<l;++i){frameArray[i]=this._frameArray[i];}for(var i=0,l=this._timelineArray.length;i<l;++i){timelineArray[i]=this._timelineArray[i];}dragonBones.webAssemblyModule.setDataBinary(this._data,bufferPointer,l1,l2,l3,l4,l5,l6);}else {var binary=new ArrayBuffer(lTotal);var intArray=new Int16Array(binary,0,this._intArray.length);var floatArray=new Float32Array(binary,l1,this._floatArray.length);var frameIntArray=new Int16Array(binary,l1+l2,this._frameIntArray.length);var frameFloatArray=new Float32Array(binary,l1+l2+l3,this._frameFloatArray.length);var frameArray=new Int16Array(binary,l1+l2+l3+l4,this._frameArray.length);var timelineArray=new Uint16Array(binary,l1+l2+l3+l4+l5,this._timelineArray.length);for(var i=0,l=this._intArray.length;i<l;++i){intArray[i]=this._intArray[i];}for(var i=0,l=this._floatArray.length;i<l;++i){floatArray[i]=this._floatArray[i];}for(var i=0,l=this._frameIntArray.length;i<l;++i){frameIntArray[i]=this._frameIntArray[i];}for(var i=0,l=this._frameFloatArray.length;i<l;++i){frameFloatArray[i]=this._frameFloatArray[i];}for(var i=0,l=this._frameArray.length;i<l;++i){frameArray[i]=this._frameArray[i];}for(var i=0,l=this._timelineArray.length;i<l;++i){timelineArray[i]=this._timelineArray[i];}this._data.binary=binary;this._data.intArray=intArray;this._data.floatArray=floatArray;this._data.frameIntArray=frameIntArray;this._data.frameFloatArray=frameFloatArray;this._data.frameArray=frameArray;this._data.timelineArray=timelineArray;}this._defaultColorOffset=-1;};ObjectDataParser.prototype.parseDragonBonesData=function(rawData,scale){if(scale===void 0){scale=1;}console.assert(rawData!==null&&rawData!==undefined,"Data error.");var version=ObjectDataParser._getString(rawData,dragonBones.DataParser.VERSION,"");var compatibleVersion=ObjectDataParser._getString(rawData,dragonBones.DataParser.COMPATIBLE_VERSION,"");if(dragonBones.DataParser.DATA_VERSIONS.indexOf(version)>=0||dragonBones.DataParser.DATA_VERSIONS.indexOf(compatibleVersion)>=0){var data=dragonBones.BaseObject.borrowObject(dragonBones.DragonBonesData);data.version=version;data.name=ObjectDataParser._getString(rawData,dragonBones.DataParser.NAME,"");data.frameRate=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.FRAME_RATE,24);if(data.frameRate===0){data.frameRate=24;}if(dragonBones.DataParser.ARMATURE in rawData){this._data=data;this._parseArray(rawData);var rawArmatures=rawData[dragonBones.DataParser.ARMATURE];for(var _i=0,rawArmatures_1=rawArmatures;_i<rawArmatures_1.length;_i++){var rawArmature=rawArmatures_1[_i];data.addArmature(this._parseArmature(rawArmature,scale));}if(!this._data.binary){this._modifyArray();}if(dragonBones.DataParser.STAGE in rawData){data.stage=data.getArmature(ObjectDataParser._getString(rawData,dragonBones.DataParser.STAGE,""));}else if(data.armatureNames.length>0){data.stage=data.getArmature(data.armatureNames[0]);}this._data=null;}if(dragonBones.DataParser.TEXTURE_ATLAS in rawData){this._rawTextureAtlases=rawData[dragonBones.DataParser.TEXTURE_ATLAS];}return data;}else {console.assert(false,"Nonsupport data version: "+version+"\n"+"Please convert DragonBones data to support version.\n"+"Read more: https://github.com/DragonBones/Tools/");}return null;};ObjectDataParser.prototype.parseTextureAtlasData=function(rawData,textureAtlasData,scale){if(scale===void 0){scale=1.0;}console.assert(rawData!==undefined);if(rawData===null){if(this._rawTextureAtlases===null||this._rawTextureAtlases.length===0){return false;}var rawTextureAtlas=this._rawTextureAtlases[this._rawTextureAtlasIndex++];this.parseTextureAtlasData(rawTextureAtlas,textureAtlasData,scale);if(this._rawTextureAtlasIndex>=this._rawTextureAtlases.length){this._rawTextureAtlasIndex=0;this._rawTextureAtlases=null;}return true;}textureAtlasData.width=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.WIDTH,0);textureAtlasData.height=ObjectDataParser._getNumber(rawData,dragonBones.DataParser.HEIGHT,0);textureAtlasData.scale=scale===1.0?1.0/ObjectDataParser._getNumber(rawData,dragonBones.DataParser.SCALE,1.0):scale;textureAtlasData.name=ObjectDataParser._getString(rawData,dragonBones.DataParser.NAME,"");textureAtlasData.imagePath=ObjectDataParser._getString(rawData,dragonBones.DataParser.IMAGE_PATH,"");if(dragonBones.DataParser.SUB_TEXTURE in rawData){var rawTextures=rawData[dragonBones.DataParser.SUB_TEXTURE];for(var i=0,l=rawTextures.length;i<l;++i){var rawTexture=rawTextures[i];var textureData=textureAtlasData.createTexture();textureData.rotated=ObjectDataParser._getBoolean(rawTexture,dragonBones.DataParser.ROTATED,false);textureData.name=ObjectDataParser._getString(rawTexture,dragonBones.DataParser.NAME,"");textureData.region.x=ObjectDataParser._getNumber(rawTexture,dragonBones.DataParser.X,0.0);textureData.region.y=ObjectDataParser._getNumber(rawTexture,dragonBones.DataParser.Y,0.0);textureData.region.width=ObjectDataParser._getNumber(rawTexture,dragonBones.DataParser.WIDTH,0.0);textureData.region.height=ObjectDataParser._getNumber(rawTexture,dragonBones.DataParser.HEIGHT,0.0);var frameWidth=ObjectDataParser._getNumber(rawTexture,dragonBones.DataParser.FRAME_WIDTH,-1.0);var frameHeight=ObjectDataParser._getNumber(rawTexture,dragonBones.DataParser.FRAME_HEIGHT,-1.0);if(frameWidth>0.0&&frameHeight>0.0){textureData.frame=dragonBones.TextureData.createRectangle();textureData.frame.x=ObjectDataParser._getNumber(rawTexture,dragonBones.DataParser.FRAME_X,0.0);textureData.frame.y=ObjectDataParser._getNumber(rawTexture,dragonBones.DataParser.FRAME_Y,0.0);textureData.frame.width=frameWidth;textureData.frame.height=frameHeight;}textureAtlasData.addTexture(textureData);}}return true;};ObjectDataParser.getInstance=function(){if(ObjectDataParser._objectDataParserInstance===null){ObjectDataParser._objectDataParserInstance=new ObjectDataParser();}return ObjectDataParser._objectDataParserInstance;};ObjectDataParser._objectDataParserInstance=null;return ObjectDataParser;}(dragonBones.DataParser);dragonBones.ObjectDataParser=ObjectDataParser;var ActionFrame=function(){function ActionFrame(){this.frameStart=0;this.actions=[];}return ActionFrame;}();dragonBones.ActionFrame=ActionFrame;})(dragonBones||(dragonBones={}));(function(dragonBones){var BinaryDataParser=function(_super){__extends$1(BinaryDataParser,_super);function BinaryDataParser(){return _super!==null&&_super.apply(this,arguments)||this;}BinaryDataParser.prototype._inRange=function(a,min,max){return min<=a&&a<=max;};BinaryDataParser.prototype._decodeUTF8=function(data){var EOF_byte=-1;var EOF_code_point=-1;var FATAL_POINT=0xFFFD;var pos=0;var result="";var code_point;var utf8_code_point=0;var utf8_bytes_needed=0;var utf8_bytes_seen=0;var utf8_lower_boundary=0;while(data.length>pos){var _byte=data[pos++];if(_byte===EOF_byte){if(utf8_bytes_needed!==0){code_point=FATAL_POINT;}else {code_point=EOF_code_point;}}else {if(utf8_bytes_needed===0){if(this._inRange(_byte,0x00,0x7F)){code_point=_byte;}else {if(this._inRange(_byte,0xC2,0xDF)){utf8_bytes_needed=1;utf8_lower_boundary=0x80;utf8_code_point=_byte-0xC0;}else if(this._inRange(_byte,0xE0,0xEF)){utf8_bytes_needed=2;utf8_lower_boundary=0x800;utf8_code_point=_byte-0xE0;}else if(this._inRange(_byte,0xF0,0xF4)){utf8_bytes_needed=3;utf8_lower_boundary=0x10000;utf8_code_point=_byte-0xF0;}else;utf8_code_point=utf8_code_point*Math.pow(64,utf8_bytes_needed);code_point=null;}}else if(!this._inRange(_byte,0x80,0xBF)){utf8_code_point=0;utf8_bytes_needed=0;utf8_bytes_seen=0;utf8_lower_boundary=0;pos--;code_point=_byte;}else {utf8_bytes_seen+=1;utf8_code_point=utf8_code_point+(_byte-0x80)*Math.pow(64,utf8_bytes_needed-utf8_bytes_seen);if(utf8_bytes_seen!==utf8_bytes_needed){code_point=null;}else {var cp=utf8_code_point;var lower_boundary=utf8_lower_boundary;utf8_code_point=0;utf8_bytes_needed=0;utf8_bytes_seen=0;utf8_lower_boundary=0;if(this._inRange(cp,lower_boundary,0x10FFFF)&&!this._inRange(cp,0xD800,0xDFFF)){code_point=cp;}else {code_point=_byte;}}}}if(code_point!==null&&code_point!==EOF_code_point){if(code_point<=0xFFFF){if(code_point>0)result+=String.fromCharCode(code_point);}else {code_point-=0x10000;result+=String.fromCharCode(0xD800+(code_point>>10&0x3ff));result+=String.fromCharCode(0xDC00+(code_point&0x3ff));}}}return result;};BinaryDataParser.prototype._getUTF16Key=function(value){for(var i=0,l=value.length;i<l;++i){if(value.charCodeAt(i)>255){return encodeURI(value);}}return value;};BinaryDataParser.prototype._parseBinaryTimeline=function(type,offset,timelineData){if(timelineData===void 0){timelineData=null;}var timeline=timelineData!==null?timelineData:dragonBones.BaseObject.borrowObject(dragonBones.TimelineData);timeline.type=type;timeline.offset=offset;this._timeline=timeline;var keyFrameCount=this._timelineArrayBuffer[timeline.offset+2];if(keyFrameCount===1){timeline.frameIndicesOffset=-1;}else {var frameIndicesOffset=0;var totalFrameCount=this._animation.frameCount+1;var frameIndices=this._data.frameIndices;if(dragonBones.DragonBones.webAssembly){frameIndicesOffset=frameIndices.size();frameIndices.resize(frameIndicesOffset+totalFrameCount,0);}else {frameIndicesOffset=frameIndices.length;frameIndices.length+=totalFrameCount;}timeline.frameIndicesOffset=frameIndicesOffset;for(var i=0,iK=0,frameStart=0,frameCount=0;i<totalFrameCount;++i){if(frameStart+frameCount<=i&&iK<keyFrameCount){frameStart=this._frameArrayBuffer[this._animation.frameOffset+this._timelineArrayBuffer[timeline.offset+5+iK]];if(iK===keyFrameCount-1){frameCount=this._animation.frameCount-frameStart;}else {frameCount=this._frameArrayBuffer[this._animation.frameOffset+this._timelineArrayBuffer[timeline.offset+5+iK+1]]-frameStart;}iK++;}if(dragonBones.DragonBones.webAssembly){frameIndices.set(frameIndicesOffset+i,iK-1);}else {frameIndices[frameIndicesOffset+i]=iK-1;}}}this._timeline=null;return timeline;};BinaryDataParser.prototype._parseVertices=function(rawData,vertices){vertices.offset=rawData[dragonBones.DataParser.OFFSET];var weightOffset=this._intArrayBuffer[vertices.offset+3];if(weightOffset>=0){var weight=dragonBones.BaseObject.borrowObject(dragonBones.WeightData);var vertexCount=this._intArrayBuffer[vertices.offset+0];var boneCount=this._intArrayBuffer[weightOffset+0];weight.offset=weightOffset;for(var i=0;i<boneCount;++i){var boneIndex=this._intArrayBuffer[weightOffset+2+i];weight.addBone(this._rawBones[boneIndex]);}var boneIndicesOffset=weightOffset+2+boneCount;var weightCount=0;for(var i=0,l=vertexCount;i<l;++i){var vertexBoneCount=this._intArrayBuffer[boneIndicesOffset++];weightCount+=vertexBoneCount;boneIndicesOffset+=vertexBoneCount;}weight.count=weightCount;vertices.weight=weight;}};BinaryDataParser.prototype._parseMesh=function(rawData,mesh){this._parseVertices(rawData,mesh.vertices);};BinaryDataParser.prototype._parsePath=function(rawData,path){this._parseVertices(rawData,path.vertices);};BinaryDataParser.prototype._parseAnimation=function(rawData){var animation=dragonBones.BaseObject.borrowObject(dragonBones.AnimationData);animation.frameCount=Math.max(dragonBones.ObjectDataParser._getNumber(rawData,dragonBones.DataParser.DURATION,1),1);animation.playTimes=dragonBones.ObjectDataParser._getNumber(rawData,dragonBones.DataParser.PLAY_TIMES,1);animation.duration=animation.frameCount/this._armature.frameRate;animation.fadeInTime=dragonBones.ObjectDataParser._getNumber(rawData,dragonBones.DataParser.FADE_IN_TIME,0.0);animation.scale=dragonBones.ObjectDataParser._getNumber(rawData,dragonBones.DataParser.SCALE,1.0);animation.name=dragonBones.ObjectDataParser._getString(rawData,dragonBones.DataParser.NAME,dragonBones.DataParser.DEFAULT_NAME);if(animation.name.length===0){animation.name=dragonBones.DataParser.DEFAULT_NAME;}var offsets=rawData[dragonBones.DataParser.OFFSET];animation.frameIntOffset=offsets[0];animation.frameFloatOffset=offsets[1];animation.frameOffset=offsets[2];this._animation=animation;if(dragonBones.DataParser.ACTION in rawData){animation.actionTimeline=this._parseBinaryTimeline(0,rawData[dragonBones.DataParser.ACTION]);}if(dragonBones.DataParser.Z_ORDER in rawData){animation.zOrderTimeline=this._parseBinaryTimeline(1,rawData[dragonBones.DataParser.Z_ORDER]);}if(dragonBones.DataParser.BONE in rawData){var rawTimeliness=rawData[dragonBones.DataParser.BONE];for(var k in rawTimeliness){var rawTimelines=rawTimeliness[k];if(dragonBones.DragonBones.webAssembly){k=this._getUTF16Key(k);}var bone=this._armature.getBone(k);if(bone===null){continue;}for(var i=0,l=rawTimelines.length;i<l;i+=2){var timelineType=rawTimelines[i];var timelineOffset=rawTimelines[i+1];var timeline=this._parseBinaryTimeline(timelineType,timelineOffset);this._animation.addBoneTimeline(bone,timeline);}}}if(dragonBones.DataParser.SURFACE in rawData){var rawTimeliness=rawData[dragonBones.DataParser.SURFACE];for(var k in rawTimeliness){var rawTimelines=rawTimeliness[k];if(dragonBones.DragonBones.webAssembly){k=this._getUTF16Key(k);}var surface=this._armature.getBone(k);if(surface===null){continue;}for(var i=0,l=rawTimelines.length;i<l;i+=2){var timelineType=rawTimelines[i];var timelineOffset=rawTimelines[i+1];var timeline=this._parseBinaryTimeline(timelineType,timelineOffset);this._animation.addSurfaceTimeline(surface,timeline);}}}if(dragonBones.DataParser.SLOT in rawData){var rawTimeliness=rawData[dragonBones.DataParser.SLOT];for(var k in rawTimeliness){var rawTimelines=rawTimeliness[k];if(dragonBones.DragonBones.webAssembly){k=this._getUTF16Key(k);}var slot=this._armature.getSlot(k);if(slot===null){continue;}for(var i=0,l=rawTimelines.length;i<l;i+=2){var timelineType=rawTimelines[i];var timelineOffset=rawTimelines[i+1];var timeline=this._parseBinaryTimeline(timelineType,timelineOffset);this._animation.addSlotTimeline(slot,timeline);}}}if(dragonBones.DataParser.CONSTRAINT in rawData){var rawTimeliness=rawData[dragonBones.DataParser.CONSTRAINT];for(var k in rawTimeliness){var rawTimelines=rawTimeliness[k];if(dragonBones.DragonBones.webAssembly){k=this._getUTF16Key(k);}var constraint=this._armature.getConstraint(k);if(constraint===null){continue;}for(var i=0,l=rawTimelines.length;i<l;i+=2){var timelineType=rawTimelines[i];var timelineOffset=rawTimelines[i+1];var timeline=this._parseBinaryTimeline(timelineType,timelineOffset);this._animation.addConstraintTimeline(constraint,timeline);}}}if(dragonBones.DataParser.ANIMATION in rawData){var rawTimeliness=rawData[dragonBones.DataParser.ANIMATION];for(var k in rawTimeliness){var rawTimelines=rawTimeliness[k];if(dragonBones.DragonBones.webAssembly){k=this._getUTF16Key(k);}for(var i=0,l=rawTimelines.length;i<l;i+=2){var timelineType=rawTimelines[i];var timelineOffset=rawTimelines[i+1];var timeline=this._parseBinaryTimeline(timelineType,timelineOffset);this._animation.addAnimationTimeline(k,timeline);}}}this._animation=null;return animation;};BinaryDataParser.prototype._parseArray=function(rawData){var offsets=rawData[dragonBones.DataParser.OFFSET];var l1=offsets[1];var l2=offsets[3];var l3=offsets[5];var l4=offsets[7];var l5=offsets[9];var l6=offsets[11];var intArray=new Int16Array(this._binary,this._binaryOffset+offsets[0],l1/Int16Array.BYTES_PER_ELEMENT);var floatArray=new Float32Array(this._binary,this._binaryOffset+offsets[2],l2/Float32Array.BYTES_PER_ELEMENT);var frameIntArray=new Int16Array(this._binary,this._binaryOffset+offsets[4],l3/Int16Array.BYTES_PER_ELEMENT);var frameFloatArray=new Float32Array(this._binary,this._binaryOffset+offsets[6],l4/Float32Array.BYTES_PER_ELEMENT);var frameArray=new Int16Array(this._binary,this._binaryOffset+offsets[8],l5/Int16Array.BYTES_PER_ELEMENT);var timelineArray=new Uint16Array(this._binary,this._binaryOffset+offsets[10],l6/Uint16Array.BYTES_PER_ELEMENT);if(dragonBones.DragonBones.webAssembly){var lTotal=l1+l2+l3+l4+l5+l6;var bufferPointer=dragonBones.webAssemblyModule._malloc(lTotal);var rawArray=new Uint8Array(this._binary,this._binaryOffset,lTotal/Uint8Array.BYTES_PER_ELEMENT);var copyArray=new Uint8Array(dragonBones.webAssemblyModule.HEAP16.buffer,bufferPointer,rawArray.length);for(var i=0,l=rawArray.length;i<l;++i){copyArray[i]=rawArray[i];}dragonBones.webAssemblyModule.setDataBinary(this._data,bufferPointer,l1,l2,l3,l4,l5,l6);this._intArrayBuffer=intArray;this._floatArrayBuffer=floatArray;this._frameIntArrayBuffer=frameIntArray;this._frameFloatArrayBuffer=frameFloatArray;this._frameArrayBuffer=frameArray;this._timelineArrayBuffer=timelineArray;}else {this._data.binary=this._binary;this._data.intArray=this._intArrayBuffer=intArray;this._data.floatArray=this._floatArrayBuffer=floatArray;this._data.frameIntArray=this._frameIntArrayBuffer=frameIntArray;this._data.frameFloatArray=this._frameFloatArrayBuffer=frameFloatArray;this._data.frameArray=this._frameArrayBuffer=frameArray;this._data.timelineArray=this._timelineArrayBuffer=timelineArray;}};BinaryDataParser.prototype.parseDragonBonesData=function(rawData,scale){if(scale===void 0){scale=1;}console.assert(rawData!==null&&rawData!==undefined&&rawData instanceof ArrayBuffer,"Data error.");var tag=new Uint8Array(rawData,0,8);if(tag[0]!=="D".charCodeAt(0)||tag[1]!=="B".charCodeAt(0)||tag[2]!=="D".charCodeAt(0)||tag[3]!=="T".charCodeAt(0)){console.assert(false,"Nonsupport data.");return null;}var headerLength=new Uint32Array(rawData,8,1)[0];var headerBytes=new Uint8Array(rawData,8+4,headerLength);var headerString=this._decodeUTF8(headerBytes);var header=JSON.parse(headerString);this._binaryOffset=8+4+headerLength;this._binary=rawData;return _super.prototype.parseDragonBonesData.call(this,header,scale);};BinaryDataParser.getInstance=function(){if(BinaryDataParser._binaryDataParserInstance===null){BinaryDataParser._binaryDataParserInstance=new BinaryDataParser();}return BinaryDataParser._binaryDataParserInstance;};BinaryDataParser._binaryDataParserInstance=null;return BinaryDataParser;}(dragonBones.ObjectDataParser);dragonBones.BinaryDataParser=BinaryDataParser;})(dragonBones||(dragonBones={}));(function(dragonBones){var BaseFactory=function(){function BaseFactory(dataParser){if(dataParser===void 0){dataParser=null;}this.autoSearch=false;this._dragonBonesDataMap={};this._textureAtlasDataMap={};this._dragonBones=null;this._dataParser=null;if(BaseFactory._objectParser===null){BaseFactory._objectParser=new dragonBones.ObjectDataParser();}if(BaseFactory._binaryParser===null){BaseFactory._binaryParser=new dragonBones.BinaryDataParser();}this._dataParser=dataParser!==null?dataParser:BaseFactory._objectParser;}BaseFactory.prototype._isSupportMesh=function(){return true;};BaseFactory.prototype._getTextureData=function(textureAtlasName,textureName){if(textureAtlasName in this._textureAtlasDataMap){for(var _i=0,_a=this._textureAtlasDataMap[textureAtlasName];_i<_a.length;_i++){var textureAtlasData=_a[_i];var textureData=textureAtlasData.getTexture(textureName);if(textureData!==null){return textureData;}}}if(this.autoSearch){for(var k in this._textureAtlasDataMap){for(var _b=0,_c=this._textureAtlasDataMap[k];_b<_c.length;_b++){var textureAtlasData=_c[_b];if(textureAtlasData.autoSearch){var textureData=textureAtlasData.getTexture(textureName);if(textureData!==null){return textureData;}}}}}return null;};BaseFactory.prototype._fillBuildArmaturePackage=function(dataPackage,dragonBonesName,armatureName,skinName,textureAtlasName){var dragonBonesData=null;var armatureData=null;if(dragonBonesName.length>0){if(dragonBonesName in this._dragonBonesDataMap){dragonBonesData=this._dragonBonesDataMap[dragonBonesName];armatureData=dragonBonesData.getArmature(armatureName);}}if(armatureData===null&&(dragonBonesName.length===0||this.autoSearch)){for(var k in this._dragonBonesDataMap){dragonBonesData=this._dragonBonesDataMap[k];if(dragonBonesName.length===0||dragonBonesData.autoSearch){armatureData=dragonBonesData.getArmature(armatureName);if(armatureData!==null){dragonBonesName=k;break;}}}}if(armatureData!==null){dataPackage.dataName=dragonBonesName;dataPackage.textureAtlasName=textureAtlasName;dataPackage.data=dragonBonesData;dataPackage.armature=armatureData;dataPackage.skin=null;if(skinName.length>0){dataPackage.skin=armatureData.getSkin(skinName);if(dataPackage.skin===null&&this.autoSearch){for(var k in this._dragonBonesDataMap){var skinDragonBonesData=this._dragonBonesDataMap[k];var skinArmatureData=skinDragonBonesData.getArmature(skinName);if(skinArmatureData!==null){dataPackage.skin=skinArmatureData.defaultSkin;break;}}}}if(dataPackage.skin===null){dataPackage.skin=armatureData.defaultSkin;}return true;}return false;};BaseFactory.prototype._buildBones=function(dataPackage,armature){for(var _i=0,_a=dataPackage.armature.sortedBones;_i<_a.length;_i++){var boneData=_a[_i];var bone=dragonBones.BaseObject.borrowObject(boneData.type===0?dragonBones.Bone:dragonBones.Surface);bone.init(boneData,armature);}};BaseFactory.prototype._buildSlots=function(dataPackage,armature){var currentSkin=dataPackage.skin;var defaultSkin=dataPackage.armature.defaultSkin;if(currentSkin===null||defaultSkin===null){return;}var skinSlots={};for(var k in defaultSkin.displays){var displays=defaultSkin.getDisplays(k);skinSlots[k]=displays;}if(currentSkin!==defaultSkin){for(var k in currentSkin.displays){var displays=currentSkin.getDisplays(k);skinSlots[k]=displays;}}for(var _i=0,_a=dataPackage.armature.sortedSlots;_i<_a.length;_i++){var slotData=_a[_i];var displayDatas=slotData.name in skinSlots?skinSlots[slotData.name]:null;var slot=this._buildSlot(dataPackage,slotData,armature);slot.rawDisplayDatas=displayDatas;if(displayDatas!==null){var displayList=new Array();for(var i=0,l=dragonBones.DragonBones.webAssembly?displayDatas.size():displayDatas.length;i<l;++i){var displayData=dragonBones.DragonBones.webAssembly?displayDatas.get(i):displayDatas[i];if(displayData!==null){displayList.push(this._getSlotDisplay(dataPackage,displayData,null,slot));}else {displayList.push(null);}}slot._setDisplayList(displayList);}slot._setDisplayIndex(slotData.displayIndex,true);}};BaseFactory.prototype._buildConstraints=function(dataPackage,armature){var constraints=dataPackage.armature.constraints;for(var k in constraints){var constraintData=constraints[k];switch(constraintData.type){case 0:var ikConstraint=dragonBones.BaseObject.borrowObject(dragonBones.IKConstraint);ikConstraint.init(constraintData,armature);armature._addConstraint(ikConstraint);break;case 1:var pathConstraint=dragonBones.BaseObject.borrowObject(dragonBones.PathConstraint);pathConstraint.init(constraintData,armature);armature._addConstraint(pathConstraint);break;default:var constraint=dragonBones.BaseObject.borrowObject(dragonBones.IKConstraint);constraint.init(constraintData,armature);armature._addConstraint(constraint);break;}}};BaseFactory.prototype._buildChildArmature=function(dataPackage,slot,displayData){return this.buildArmature(displayData.path,dataPackage!==null?dataPackage.dataName:"","",dataPackage!==null?dataPackage.textureAtlasName:"");};BaseFactory.prototype._getSlotDisplay=function(dataPackage,displayData,rawDisplayData,slot){var dataName=dataPackage!==null?dataPackage.dataName:displayData.parent.parent.parent.name;var display=null;switch(displayData.type){case 0:{var imageDisplayData=displayData;if(dataPackage!==null&&dataPackage.textureAtlasName.length>0){imageDisplayData.texture=this._getTextureData(dataPackage.textureAtlasName,displayData.path);}if(imageDisplayData.texture===null){imageDisplayData.texture=this._getTextureData(dataName,displayData.path);}if(rawDisplayData!==null&&rawDisplayData.type===2&&this._isSupportMesh()){display=slot.meshDisplay;}else {display=slot.rawDisplay;}break;}case 2:{var meshDisplayData=displayData;if(dataPackage!==null&&dataPackage.textureAtlasName.length>0){meshDisplayData.texture=this._getTextureData(dataPackage.textureAtlasName,meshDisplayData.path);}if(meshDisplayData.texture===null){meshDisplayData.texture=this._getTextureData(dataName,meshDisplayData.path);}if(this._isSupportMesh()){display=slot.meshDisplay;}else {display=slot.rawDisplay;}break;}case 1:{var armatureDisplayData=displayData;var childArmature=this._buildChildArmature(dataPackage,slot,displayData);if(childArmature!==null){childArmature.inheritAnimation=armatureDisplayData.inheritAnimation;if(!childArmature.inheritAnimation){var actions=armatureDisplayData.actions.length>0?armatureDisplayData.actions:childArmature.armatureData.defaultActions;if(actions.length>0){for(var _i=0,actions_6=actions;_i<actions_6.length;_i++){var action=actions_6[_i];var eventObject=dragonBones.BaseObject.borrowObject(dragonBones.EventObject);dragonBones.EventObject.actionDataToInstance(action,eventObject,slot.armature);eventObject.slot=slot;slot.armature._bufferAction(eventObject,false);}}else {childArmature.animation.play();}}armatureDisplayData.armature=childArmature.armatureData;}display=childArmature;break;}}return display;};BaseFactory.prototype.parseDragonBonesData=function(rawData,name,scale){if(name===void 0){name=null;}if(scale===void 0){scale=1.0;}var dataParser=rawData instanceof ArrayBuffer?BaseFactory._binaryParser:this._dataParser;var dragonBonesData=dataParser.parseDragonBonesData(rawData,scale);while(true){var textureAtlasData=this._buildTextureAtlasData(null,null);if(dataParser.parseTextureAtlasData(null,textureAtlasData,scale)){this.addTextureAtlasData(textureAtlasData,name);}else {textureAtlasData.returnToPool();break;}}if(dragonBonesData!==null){this.addDragonBonesData(dragonBonesData,name);}return dragonBonesData;};BaseFactory.prototype.parseTextureAtlasData=function(rawData,textureAtlas,name,scale){if(name===void 0){name=null;}if(scale===void 0){scale=1.0;}var textureAtlasData=this._buildTextureAtlasData(null,null);this._dataParser.parseTextureAtlasData(rawData,textureAtlasData,scale);this._buildTextureAtlasData(textureAtlasData,textureAtlas||null);this.addTextureAtlasData(textureAtlasData,name);return textureAtlasData;};BaseFactory.prototype.updateTextureAtlasData=function(name,textureAtlases){var textureAtlasDatas=this.getTextureAtlasData(name);if(textureAtlasDatas!==null){for(var i=0,l=textureAtlasDatas.length;i<l;++i){if(i<textureAtlases.length){this._buildTextureAtlasData(textureAtlasDatas[i],textureAtlases[i]);}}}};BaseFactory.prototype.getDragonBonesData=function(name){return name in this._dragonBonesDataMap?this._dragonBonesDataMap[name]:null;};BaseFactory.prototype.addDragonBonesData=function(data,name){if(name===void 0){name=null;}name=name!==null?name:data.name;if(name in this._dragonBonesDataMap){if(this._dragonBonesDataMap[name]===data){return;}console.warn("Can not add same name data: "+name);return;}this._dragonBonesDataMap[name]=data;};BaseFactory.prototype.removeDragonBonesData=function(name,disposeData){if(disposeData===void 0){disposeData=true;}if(name in this._dragonBonesDataMap){if(disposeData){this._dragonBones.bufferObject(this._dragonBonesDataMap[name]);}delete this._dragonBonesDataMap[name];}};BaseFactory.prototype.getTextureAtlasData=function(name){return name in this._textureAtlasDataMap?this._textureAtlasDataMap[name]:null;};BaseFactory.prototype.addTextureAtlasData=function(data,name){if(name===void 0){name=null;}name=name!==null?name:data.name;var textureAtlasList=name in this._textureAtlasDataMap?this._textureAtlasDataMap[name]:this._textureAtlasDataMap[name]=[];if(textureAtlasList.indexOf(data)<0){textureAtlasList.push(data);}};BaseFactory.prototype.removeTextureAtlasData=function(name,disposeData){if(disposeData===void 0){disposeData=true;}if(name in this._textureAtlasDataMap){var textureAtlasDataList=this._textureAtlasDataMap[name];if(disposeData){for(var _i=0,textureAtlasDataList_1=textureAtlasDataList;_i<textureAtlasDataList_1.length;_i++){var textureAtlasData=textureAtlasDataList_1[_i];this._dragonBones.bufferObject(textureAtlasData);}}delete this._textureAtlasDataMap[name];}};BaseFactory.prototype.getArmatureData=function(name,dragonBonesName){if(dragonBonesName===void 0){dragonBonesName="";}var dataPackage=new BuildArmaturePackage();if(!this._fillBuildArmaturePackage(dataPackage,dragonBonesName,name,"","")){return null;}return dataPackage.armature;};BaseFactory.prototype.clear=function(disposeData){if(disposeData===void 0){disposeData=true;}for(var k in this._dragonBonesDataMap){if(disposeData){this._dragonBones.bufferObject(this._dragonBonesDataMap[k]);}delete this._dragonBonesDataMap[k];}for(var k in this._textureAtlasDataMap){if(disposeData){var textureAtlasDataList=this._textureAtlasDataMap[k];for(var _i=0,textureAtlasDataList_2=textureAtlasDataList;_i<textureAtlasDataList_2.length;_i++){var textureAtlasData=textureAtlasDataList_2[_i];this._dragonBones.bufferObject(textureAtlasData);}}delete this._textureAtlasDataMap[k];}};BaseFactory.prototype.buildArmature=function(armatureName,dragonBonesName,skinName,textureAtlasName){if(dragonBonesName===void 0){dragonBonesName="";}if(skinName===void 0){skinName="";}if(textureAtlasName===void 0){textureAtlasName="";}var dataPackage=new BuildArmaturePackage();if(!this._fillBuildArmaturePackage(dataPackage,dragonBonesName||"",armatureName,skinName||"",textureAtlasName||"")){console.warn("No armature data: "+armatureName+", "+(dragonBonesName!==null?dragonBonesName:""));return null;}var armature=this._buildArmature(dataPackage);this._buildBones(dataPackage,armature);this._buildSlots(dataPackage,armature);this._buildConstraints(dataPackage,armature);armature.invalidUpdate(null,true);armature.advanceTime(0.0);return armature;};BaseFactory.prototype.replaceDisplay=function(slot,displayData,displayIndex){if(displayIndex===void 0){displayIndex=-1;}if(displayIndex<0){displayIndex=slot.displayIndex;}if(displayIndex<0){displayIndex=0;}slot.replaceDisplayData(displayData,displayIndex);var displayList=slot.displayList;if(displayList.length<=displayIndex){displayList.length=displayIndex+1;for(var i=0,l=displayList.length;i<l;++i){if(!displayList[i]){displayList[i]=null;}}}if(displayData!==null){var rawDisplayDatas=slot.rawDisplayDatas;var rawDisplayData=null;if(rawDisplayDatas){if(dragonBones.DragonBones.webAssembly){if(displayIndex<rawDisplayDatas.size()){rawDisplayData=rawDisplayDatas.get(displayIndex);}}else {if(displayIndex<rawDisplayDatas.length){rawDisplayData=rawDisplayDatas[displayIndex];}}}displayList[displayIndex]=this._getSlotDisplay(null,displayData,rawDisplayData,slot);}else {displayList[displayIndex]=null;}slot.displayList=displayList;};BaseFactory.prototype.replaceSlotDisplay=function(dragonBonesName,armatureName,slotName,displayName,slot,displayIndex){if(displayIndex===void 0){displayIndex=-1;}var armatureData=this.getArmatureData(armatureName,dragonBonesName||"");if(!armatureData||!armatureData.defaultSkin){return false;}var displayData=armatureData.defaultSkin.getDisplay(slotName,displayName);if(!displayData){return false;}this.replaceDisplay(slot,displayData,displayIndex);return true;};BaseFactory.prototype.replaceSlotDisplayList=function(dragonBonesName,armatureName,slotName,slot){var armatureData=this.getArmatureData(armatureName,dragonBonesName||"");if(!armatureData||!armatureData.defaultSkin){return false;}var displays=armatureData.defaultSkin.getDisplays(slotName);if(!displays){return false;}var displayIndex=0;for(var i=0,l=dragonBones.DragonBones.webAssembly?displays.size():displays.length;i<l;++i){var displayData=dragonBones.DragonBones.webAssembly?displays.get(i):displays[i];this.replaceDisplay(slot,displayData,displayIndex++);}return true;};BaseFactory.prototype.replaceSkin=function(armature,skin,isOverride,exclude){if(isOverride===void 0){isOverride=false;}if(exclude===void 0){exclude=null;}var success=false;var defaultSkin=skin.parent.defaultSkin;for(var _i=0,_a=armature.getSlots();_i<_a.length;_i++){var slot=_a[_i];if(exclude!==null&&exclude.indexOf(slot.name)>=0){continue;}var displays=skin.getDisplays(slot.name);if(!displays){if(defaultSkin!==null&&skin!==defaultSkin){displays=defaultSkin.getDisplays(slot.name);}if(!displays){if(isOverride){slot.rawDisplayDatas=null;slot.displayList=[];}continue;}}var displayCount=dragonBones.DragonBones.webAssembly?displays.size():displays.length;var displayList=slot.displayList;displayList.length=displayCount;for(var i=0,l=displayCount;i<l;++i){var displayData=dragonBones.DragonBones.webAssembly?displays.get(i):displays[i];if(displayData!==null){displayList[i]=this._getSlotDisplay(null,displayData,null,slot);}else {displayList[i]=null;}}success=true;slot.rawDisplayDatas=displays;slot.displayList=displayList;}return success;};BaseFactory.prototype.replaceAnimation=function(armature,armatureData,isOverride){if(isOverride===void 0){isOverride=true;}var skinData=armatureData.defaultSkin;if(skinData===null){return false;}if(isOverride){armature.animation.animations=armatureData.animations;}else {var rawAnimations=armature.animation.animations;var animations={};for(var k in rawAnimations){animations[k]=rawAnimations[k];}for(var k in armatureData.animations){animations[k]=armatureData.animations[k];}armature.animation.animations=animations;}for(var _i=0,_a=armature.getSlots();_i<_a.length;_i++){var slot=_a[_i];var index=0;for(var _b=0,_c=slot.displayList;_b<_c.length;_b++){var display=_c[_b];if(display instanceof dragonBones.Armature){var displayDatas=skinData.getDisplays(slot.name);if(displayDatas!==null&&index<(dragonBones.DragonBones.webAssembly?displayDatas.size():displayDatas.length)){var displayData=dragonBones.DragonBones.webAssembly?displayDatas.get(index):displayDatas[index];if(displayData!==null&&displayData.type===1){var childArmatureData=this.getArmatureData(displayData.path,displayData.parent.parent.parent.name);if(childArmatureData){this.replaceAnimation(display,childArmatureData,isOverride);}}}}index++;}}return true;};BaseFactory.prototype.getAllDragonBonesData=function(){return this._dragonBonesDataMap;};BaseFactory.prototype.getAllTextureAtlasData=function(){return this._textureAtlasDataMap;};Object.defineProperty(BaseFactory.prototype,"clock",{get:function(){return this._dragonBones.clock;},enumerable:true,configurable:true});Object.defineProperty(BaseFactory.prototype,"dragonBones",{get:function(){return this._dragonBones;},enumerable:true,configurable:true});BaseFactory.prototype.changeSkin=function(armature,skin,exclude){if(exclude===void 0){exclude=null;}return this.replaceSkin(armature,skin,false,exclude);};BaseFactory.prototype.copyAnimationsToArmature=function(toArmature,fromArmatreName,fromSkinName,fromDragonBonesDataName,replaceOriginalAnimation){if(fromDragonBonesDataName===void 0){fromDragonBonesDataName="";}if(replaceOriginalAnimation===void 0){replaceOriginalAnimation=true;}var armatureData=this.getArmatureData(fromArmatreName,fromDragonBonesDataName);if(!armatureData){return false;}return this.replaceAnimation(toArmature,armatureData,replaceOriginalAnimation);};BaseFactory._objectParser=null;BaseFactory._binaryParser=null;return BaseFactory;}();dragonBones.BaseFactory=BaseFactory;var BuildArmaturePackage=function(){function BuildArmaturePackage(){this.dataName="";this.textureAtlasName="";this.skin=null;}return BuildArmaturePackage;}();dragonBones.BuildArmaturePackage=BuildArmaturePackage;})(dragonBones||(dragonBones={}));(function(dragonBones){dragonBones.BinaryOffset={WeigthBoneCount:0,WeigthFloatOffset:1,WeigthBoneIndices:2,MeshVertexCount:0,MeshTriangleCount:1,MeshFloatOffset:2,MeshWeightOffset:3,MeshVertexIndices:4,TimelineScale:0,TimelineOffset:1,TimelineKeyFrameCount:2,TimelineFrameValueCount:3,TimelineFrameValueOffset:4,TimelineFrameOffset:5,FramePosition:0,FrameTweenType:1,FrameTweenEasingOrCurveSampleCount:2,FrameCurveSamples:3,DeformMeshOffset:0,DeformCount:1,DeformValueCount:2,DeformValueOffset:3,DeformFloatOffset:4};dragonBones.ArmatureType={Armature:0,MovieClip:1,Stage:2};dragonBones.BoneType={Bone:0,Surface:1};dragonBones.DisplayType={Image:0,Armature:1,Mesh:2,BoundingBox:3};dragonBones.BoundingBoxType={Rectangle:0,Ellipse:1,Polygon:2};dragonBones.ActionType={Play:0,Stop:1,GotoAndPlay:2,GotoAndStop:3,FadeIn:4,FadeOut:5,Frame:10,Sound:11};dragonBones.BlendMode={Normal:0,Add:1,Alpha:2,Darken:3,Difference:4,Erase:5,HardLight:6,Invert:7,Layer:8,Lighten:9,Multiply:10,Overlay:11,Screen:12,Subtract:13};dragonBones.TweenType={None:0,Line:1,Curve:2,QuadIn:3,QuadOut:4,QuadInOut:5};dragonBones.TimelineType={Action:0,ZOrder:1,BoneAll:10,BoneTranslate:11,BoneRotate:12,BoneScale:13,Surface:50,SlotDisplay:20,SlotColor:21,SlotFFD:22,IKConstraint:30,AnimationTime:40,AnimationWeight:41};})(dragonBones||(dragonBones={}));const DragonBones=dragonBones.DragonBones;const BaseObject=dragonBones.BaseObject;const Matrix=dragonBones.Matrix;const Transform=dragonBones.Transform;const ColorTransform=dragonBones.ColorTransform;const Point$2=dragonBones.Point;const Rectangle=dragonBones.Rectangle;const UserData=dragonBones.UserData;const ActionData=dragonBones.ActionData;const DragonBonesData=dragonBones.DragonBonesData;const ArmatureData=dragonBones.ArmatureData;const BoneData=dragonBones.BoneData;const SurfaceData=dragonBones.SurfaceData;const SlotData=dragonBones.SlotData;const ConstraintData=dragonBones.ConstraintData;const IKConstraintData=dragonBones.IKConstraintData;const PathConstraintData=dragonBones.PathConstraintData;const CanvasData=dragonBones.CanvasData;const SkinData=dragonBones.SkinData;const VerticesData=dragonBones.VerticesData;const DisplayData=dragonBones.DisplayData;const ImageDisplayData=dragonBones.ImageDisplayData;const ArmatureDisplayData=dragonBones.ArmatureDisplayData;const MeshDisplayData=dragonBones.MeshDisplayData;const BoundingBoxDisplayData=dragonBones.BoundingBoxDisplayData;const PathDisplayData=dragonBones.PathDisplayData;const WeightData=dragonBones.WeightData;const BoundingBoxData=dragonBones.BoundingBoxData;const RectangleBoundingBoxData=dragonBones.RectangleBoundingBoxData;const EllipseBoundingBoxData=dragonBones.EllipseBoundingBoxData;const PolygonBoundingBoxData=dragonBones.PolygonBoundingBoxData;const AnimationData=dragonBones.AnimationData;const TimelineData=dragonBones.TimelineData;const AnimationConfig=dragonBones.AnimationConfig;const TextureAtlasData=dragonBones.TextureAtlasData;const TextureData=dragonBones.TextureData;const DeformVertices=dragonBones.DeformVertices;const Armature=dragonBones.Armature;const TransformObject=dragonBones.TransformObject;const Bone=dragonBones.Bone;const Surface=dragonBones.Surface;const Slot=dragonBones.Slot;const Constraint$1=dragonBones.Constraint;const IKConstraint=dragonBones.IKConstraint;const PathConstraint=dragonBones.PathConstraint;const WorldClock=dragonBones.WorldClock;const Animation$1=dragonBones.Animation;const AnimationState=dragonBones.AnimationState;const BonePose=dragonBones.BonePose;const BlendState$1=dragonBones.BlendState;const TimelineState=dragonBones.TimelineState;const TweenTimelineState=dragonBones.TweenTimelineState;const BoneTimelineState=dragonBones.BoneTimelineState;const SlotTimelineState=dragonBones.SlotTimelineState;const ConstraintTimelineState=dragonBones.ConstraintTimelineState;const ActionTimelineState=dragonBones.ActionTimelineState;const ZOrderTimelineState=dragonBones.ZOrderTimelineState;const BoneAllTimelineState=dragonBones.BoneAllTimelineState;const BoneTranslateTimelineState=dragonBones.BoneTranslateTimelineState;const BoneRotateTimelineState=dragonBones.BoneRotateTimelineState;const BoneScaleTimelineState=dragonBones.BoneScaleTimelineState;const SurfaceTimelineState=dragonBones.SurfaceTimelineState;const SlotDislayTimelineState=dragonBones.SlotDislayTimelineState;const SlotColorTimelineState=dragonBones.SlotColorTimelineState;const DeformTimelineState=dragonBones.DeformTimelineState;const IKConstraintTimelineState=dragonBones.IKConstraintTimelineState;const AnimationTimelineState=dragonBones.AnimationTimelineState;const EventObject=dragonBones.EventObject;const DataParser=dragonBones.DataParser;const ObjectDataParser=dragonBones.ObjectDataParser;const ActionFrame=dragonBones.ActionFrame;const BinaryDataParser=dragonBones.BinaryDataParser;const BaseFactory=dragonBones.BaseFactory;const BuildArmaturePackage=dragonBones.BuildArmaturePackage;const BinaryOffset=dragonBones.BinaryOffset;const ArmatureType=dragonBones.ArmatureType;const BoneType=dragonBones.BoneType;const DisplayType=dragonBones.DisplayType;const BoundingBoxType=dragonBones.BoundingBoxType;const ActionType=dragonBones.ActionType;const BlendMode=dragonBones.BlendMode;const TweenType=dragonBones.TweenType;const TimelineType=dragonBones.TimelineType;

            var _dec$1w, _class$1x, _temp$1q, _dec2$1m, _class3$v, _temp2$8;
            let CCTextureAtlasData = (_dec$1w = ccclass('dragonBones.CCTextureAtlasData'), _dec$1w(_class$1x = (_temp$1q = class CCTextureAtlasData extends TextureAtlasData {
              constructor(...args) {
                super(...args);
                this._renderTexture = null;
              }

              get renderTexture() {
                return this._renderTexture;
              }

              set renderTexture(value) {
                this._renderTexture = value;

                if (value) {
                  for (const k in this.textures) {
                    const textureData = this.textures[k];

                    if (!textureData.spriteFrame) {
                      let rect = null;

                      if (textureData.rotated) {
                        rect = new Rect$1(textureData.region.x, textureData.region.y, textureData.region.height, textureData.region.width);
                      } else {
                        rect = new Rect$1(textureData.region.x, textureData.region.y, textureData.region.width, textureData.region.height);
                        textureData.spriteFrame = new SpriteFrame();
                        textureData.spriteFrame.texture = value;
                        textureData.spriteFrame.rect = rect;
                      }
                    }
                  }
                } else {
                  for (const k in this.textures) {
                    const textureData = this.textures[k];
                    textureData.spriteFrame = null;
                  }
                }
              }

              static toString() {
                return '[class dragonBones.CCTextureAtlasData]';
              }

              createTexture() {
                return BaseObject.borrowObject(CCTextureData);
              }

              _onClear() {
                super._onClear();

                this.renderTexture = null;
              }

            }, _temp$1q)) || _class$1x);
            let CCTextureData = (_dec2$1m = ccclass('dragonBones.CCTextureData'), _dec2$1m(_class3$v = (_temp2$8 = class CCTextureData extends TextureData {
              constructor(...args) {
                super(...args);
                this.spriteFrame = null;
              }

              static toString() {
                return '[class dragonBones.CCTextureData]';
              }

              _onClear() {
                super._onClear();

                this.spriteFrame = null;
              }

            }, _temp2$8)) || _class3$v);

            var _dec$1x, _class$1y, _temp$1r;
            let CCSlot = (_dec$1x = ccclass('dragonBones.CCSlot'), _dec$1x(_class$1y = (_temp$1r = class CCSlot extends Slot {
              static toString() {
                return '[class dragonBones.CCSlot]';
              }

              constructor() {
                super();
                this._localVertices = void 0;
                this._indices = void 0;
                this._matrix = void 0;
                this._worldMatrix = void 0;
                this._worldMatrixDirty = void 0;
                this._color = void 0;
                this._localVertices = [];
                this._indices = [];
                this._matrix = new Mat4();
                this._worldMatrix = new Mat4();
                this._worldMatrixDirty = true;
                this._visible = false;
                this._color = new Color$1();
              }

              getTexture() {
                if (this._textureData) {
                  const sp = this._textureData.spriteFrame;
                  const tex = sp.texture;
                  return tex;
                }

                return null;
              }

              calculWorldMatrix() {
                const parent = this._armature._parent;

                if (parent) {
                  this._mulMat(this._worldMatrix, parent._worldMatrix, this._matrix);
                } else {
                  Mat4.copy(this._worldMatrix, this._matrix);
                }

                this._worldMatrixDirty = false;
              }

              _onClear() {
                super._onClear();

                this._localVertices.length = 0;
                this._indices.length = 0;
                Mat4.identity(this._matrix);
                Mat4.identity(this._worldMatrix);
                this._worldMatrixDirty = true;
                this._color = new Color$1();
                this._visible = false;
              }

              _onUpdateDisplay() {}

              _initDisplay(value) {}

              _addDisplay() {
                this._visible = true;
              }

              _replaceDisplay(value) {}

              _removeDisplay() {
                this._visible = false;
              }

              _disposeDisplay(object) {}

              _updateVisible() {
                this._visible = this.parent.visible;
              }

              _updateGlueMesh() {}

              _updateZOrder() {}

              _updateBlendMode() {
                if (this._childArmature) {
                  const childSlots = this._childArmature.getSlots();

                  for (let i = 0, l = childSlots.length; i < l; i++) {
                    const slot = childSlots[i];
                    slot._blendMode = this._blendMode;

                    slot._updateBlendMode();
                  }
                }
              }

              _updateColor() {
                const c = this._color;
                c.r = this._colorTransform.redMultiplier * 255;
                c.g = this._colorTransform.greenMultiplier * 255;
                c.b = this._colorTransform.blueMultiplier * 255;
                c.a = this._colorTransform.alphaMultiplier * 255;
              }

              _updateFrame() {
                this._indices.length = 0;
                const indices = this._indices;
                const localVertices = this._localVertices;
                let indexOffset = 0;
                let vfOffset = 0;
                const currentTextureData = this._textureData;
                if (!this._display || this._displayIndex < 0 || !currentTextureData || !currentTextureData.spriteFrame) return;
                const texture = currentTextureData.spriteFrame.texture;
                const textureAtlasWidth = texture.width;
                const textureAtlasHeight = texture.height;
                const region = currentTextureData.region;

                if (textureAtlasWidth === 0 || textureAtlasHeight === 0) {
                  console.error(`SpriteFrame ${currentTextureData.spriteFrame.name} incorrect size ${textureAtlasWidth} x ${textureAtlasHeight}`);
                  return;
                }

                const currentVerticesData = this._deformVertices !== null && this._display === this._meshDisplay ? this._deformVertices.verticesData : null;

                if (currentVerticesData) {
                  const data = currentVerticesData.data;
                  const intArray = data.intArray;
                  const floatArray = data.floatArray;
                  const vertexCount = intArray[currentVerticesData.offset + BinaryOffset.MeshVertexCount];
                  const triangleCount = intArray[currentVerticesData.offset + BinaryOffset.MeshTriangleCount];
                  let vertexOffset = intArray[currentVerticesData.offset + BinaryOffset.MeshFloatOffset];

                  if (vertexOffset < 0) {
                    vertexOffset += 65536;
                  }

                  const uvOffset = vertexOffset + vertexCount * 2;
                  const scale = this._armature._armatureData.scale;

                  for (let i = 0, l = vertexCount * 2; i < l; i += 2) {
                    localVertices[vfOffset++] = floatArray[vertexOffset + i] * scale;
                    localVertices[vfOffset++] = -floatArray[vertexOffset + i + 1] * scale;

                    if (currentVerticesData.rotated) {
                      localVertices[vfOffset++] = (region.x + (1.0 - floatArray[uvOffset + i]) * region.width) / textureAtlasWidth;
                      localVertices[vfOffset++] = (region.y + floatArray[uvOffset + i + 1] * region.height) / textureAtlasHeight;
                    } else {
                      localVertices[vfOffset++] = (region.x + floatArray[uvOffset + i] * region.width) / textureAtlasWidth;
                      localVertices[vfOffset++] = (region.y + floatArray[uvOffset + i + 1] * region.height) / textureAtlasHeight;
                    }
                  }

                  for (let i = 0; i < triangleCount * 3; ++i) {
                    indices[indexOffset++] = intArray[currentVerticesData.offset + BinaryOffset.MeshVertexIndices + i];
                  }

                  localVertices.length = vfOffset;
                  indices.length = indexOffset;
                  const isSkinned = !!currentVerticesData.weight;

                  if (isSkinned) {
                    this._identityTransform();
                  }
                } else {
                  const l = region.x / textureAtlasWidth;
                  const b = (region.y + region.height) / textureAtlasHeight;
                  const r = (region.x + region.width) / textureAtlasWidth;
                  const t = region.y / textureAtlasHeight;
                  localVertices[vfOffset++] = 0;
                  localVertices[vfOffset++] = 0;
                  localVertices[vfOffset++] = l;
                  localVertices[vfOffset++] = b;
                  localVertices[vfOffset++] = region.width;
                  localVertices[vfOffset++] = 0;
                  localVertices[vfOffset++] = r;
                  localVertices[vfOffset++] = b;
                  localVertices[vfOffset++] = 0;
                  localVertices[vfOffset++] = region.height;
                  localVertices[vfOffset++] = l;
                  localVertices[vfOffset++] = t;
                  localVertices[vfOffset++] = region.width;
                  localVertices[vfOffset++] = region.height;
                  localVertices[vfOffset++] = r;
                  localVertices[vfOffset++] = t;
                  indices[0] = 0;
                  indices[1] = 1;
                  indices[2] = 2;
                  indices[3] = 1;
                  indices[4] = 3;
                  indices[5] = 2;
                  localVertices.length = vfOffset;
                  indices.length = 6;
                }

                this._visibleDirty = true;
                this._blendModeDirty = true;
                this._colorDirty = true;
              }

              _updateMesh() {
                const scale = this._armature._armatureData.scale;
                const deformVertices = this._deformVertices.vertices;
                const bones = this._deformVertices.bones;
                const verticesData = this._deformVertices.verticesData;
                const weightData = verticesData.weight;
                const hasDeform = deformVertices.length > 0 && verticesData.inheritDeform;
                const localVertices = this._localVertices;

                if (weightData) {
                  const data = verticesData.data;
                  const intArray = data.intArray;
                  const floatArray = data.floatArray;
                  const vertexCount = intArray[verticesData.offset + BinaryOffset.MeshVertexCount];
                  let weightFloatOffset = intArray[weightData.offset + BinaryOffset.WeigthFloatOffset];

                  if (weightFloatOffset < 0) {
                    weightFloatOffset += 65536;
                  }

                  for (let i = 0, iB = weightData.offset + BinaryOffset.WeigthBoneIndices + bones.length, iV = weightFloatOffset, iF = 0, lvi = 0; i < vertexCount; i++, lvi += 4) {
                    const boneCount = intArray[iB++];
                    let xG = 0.0;
                    let yG = 0.0;

                    for (let j = 0; j < boneCount; ++j) {
                      const boneIndex = intArray[iB++];
                      const bone = bones[boneIndex];

                      if (bone !== null) {
                        const matrix = bone.globalTransformMatrix;
                        const weight = floatArray[iV++];
                        let xL = floatArray[iV++] * scale;
                        let yL = floatArray[iV++] * scale;

                        if (hasDeform) {
                          xL += deformVertices[iF++];
                          yL += deformVertices[iF++];
                        }

                        xG += (matrix.a * xL + matrix.c * yL + matrix.tx) * weight;
                        yG += (matrix.b * xL + matrix.d * yL + matrix.ty) * weight;
                      }
                    }

                    localVertices[lvi] = xG;
                    localVertices[lvi + 1] = -yG;
                  }
                } else if (hasDeform) {
                  const isSurface = this._parent._boneData.type !== BoneType.Bone;
                  const data = verticesData.data;
                  const intArray = data.intArray;
                  const floatArray = data.floatArray;
                  const vertexCount = intArray[verticesData.offset + BinaryOffset.MeshVertexCount];
                  let vertexOffset = intArray[verticesData.offset + BinaryOffset.MeshFloatOffset];

                  if (vertexOffset < 0) {
                    vertexOffset += 65536;
                  }

                  for (let i = 0, l = vertexCount, lvi = 0; i < l; i++, lvi += 4) {
                    const x = floatArray[vertexOffset + i * 2] * scale + deformVertices[i * 2];
                    const y = floatArray[vertexOffset + i * 2 + 1] * scale + deformVertices[i * 2 + 1];

                    if (isSurface) {
                      const matrix = this._parent._getGlobalTransformMatrix(x, y);

                      localVertices[lvi] = matrix.a * x + matrix.c * y + matrix.tx;
                      localVertices[lvi + 1] = -matrix.b * x + matrix.d * y + matrix.ty;
                    } else {
                      localVertices[lvi] = x;
                      localVertices[lvi + 1] = -y;
                    }
                  }
                }

                if (weightData) {
                  this._identityTransform();
                }
              }

              _identityTransform() {
                const m = this._matrix;
                m.m00 = 1.0;
                m.m01 = 0.0;
                m.m04 = -0.0;
                m.m05 = -1.0;
                m.m12 = 0.0;
                m.m13 = 0.0;
                this._worldMatrixDirty = true;
              }

              _updateTransform() {
                const m = this._matrix;
                m.m00 = this.globalTransformMatrix.a;
                m.m01 = this.globalTransformMatrix.b;
                m.m04 = -this.globalTransformMatrix.c;
                m.m05 = -this.globalTransformMatrix.d;

                if (this._childArmature) {
                  m.m12 = this.globalTransformMatrix.tx;
                  m.m13 = this.globalTransformMatrix.ty;
                } else {
                  m.m12 = this.globalTransformMatrix.tx - (this.globalTransformMatrix.a * this._pivotX - this.globalTransformMatrix.c * this._pivotY);
                  m.m13 = this.globalTransformMatrix.ty - (this.globalTransformMatrix.b * this._pivotX - this.globalTransformMatrix.d * this._pivotY);
                }

                this._worldMatrixDirty = true;
              }

              updateWorldMatrix() {
                if (!this._armature) return;
                const parentSlot = this._armature._parent;

                if (parentSlot) {
                  parentSlot.updateWorldMatrix();
                }

                if (this._worldMatrixDirty) {
                  this.calculWorldMatrix();
                  const childArmature = this.childArmature;
                  if (!childArmature) return;
                  const slots = childArmature.getSlots();

                  for (let i = 0, n = slots.length; i < n; i++) {
                    const slot = slots[i];

                    if (slot) {
                      slot._worldMatrixDirty = true;
                    }
                  }
                }
              }

              _mulMat(out, a, b) {
                const aa = a.m00;
                const ab = a.m01;
                const ac = a.m04;
                const ad = a.m05;
                const atx = a.m12;
                const aty = a.m13;
                const ba = b.m00;
                const bb = b.m01;
                const bc = b.m04;
                const bd = b.m05;
                const btx = b.m12;
                const bty = b.m13;

                if (ab !== 0 || ac !== 0) {
                  out.m00 = ba * aa + bb * ac;
                  out.m01 = ba * ab + bb * ad;
                  out.m04 = bc * aa + bd * ac;
                  out.m05 = bc * ab + bd * ad;
                  out.m12 = aa * btx + ac * bty + atx;
                  out.m13 = ab * btx + ad * bty + aty;
                } else {
                  out.m00 = ba * aa;
                  out.m01 = bb * ad;
                  out.m04 = bc * aa;
                  out.m05 = bd * ad;
                  out.m12 = aa * btx + atx;
                  out.m13 = ad * bty + aty;
                }
              }

            }, _temp$1r)) || _class$1y);

            var _dec$1y, _class$1z, _temp$1s;
            let CCArmatureDisplay = (_dec$1y = ccclass('dragonBones.CCArmatureDisplay'), _dec$1y(_class$1z = (_temp$1s = class CCArmatureDisplay extends DisplayData {
              get node() {
                return this;
              }

              constructor() {
                super();
                this.shouldAdvanced = false;
                this._ccNode = null;
                this._ccComponent = null;
                this._eventTarget = void 0;
                this._armature = null;
                this._eventTarget = new EventTarget();
              }

              hasEvent(type) {
                console.warn('Method not implemented.');
                return false;
              }

              addEvent(type, listener, thisObject) {
                console.warn('Method not implemented.');
              }

              removeEvent(type, listener, thisObject) {
                console.warn('Method not implemented.');
              }

              setEventTarget(eventTarget) {
                this._eventTarget = eventTarget;
              }

              getRootDisplay() {
                let parentSlot = this._armature._parent;

                if (!parentSlot) {
                  return this;
                }

                let slot;

                while (parentSlot) {
                  slot = parentSlot;
                  parentSlot = parentSlot._armature._parent;
                }

                return slot._armature.display;
              }

              convertToRootSpace(pos) {
                const slot = this._armature._parent;

                if (!slot) {
                  return pos;
                }

                slot.updateWorldMatrix();
                const worldMatrix = slot._worldMatrix;
                const newPos = new Vec3(0, 0);
                newPos.x = pos.x * worldMatrix.m00 + pos.y * worldMatrix.m04 + worldMatrix.m12;
                newPos.y = pos.x * worldMatrix.m01 + pos.y * worldMatrix.m05 + worldMatrix.m13;
                return newPos;
              }

              convertToWorldSpace(point) {
                var _ccNode$_uiProps$uiTr;

                const newPos = this.convertToRootSpace(point);
                const ccNode = this.getRootNode();
                return ccNode === null || ccNode === void 0 ? void 0 : (_ccNode$_uiProps$uiTr = ccNode._uiProps.uiTransformComp) === null || _ccNode$_uiProps$uiTr === void 0 ? void 0 : _ccNode$_uiProps$uiTr.convertToWorldSpaceAR(newPos);
              }

              getRootNode() {
                const rootDisplay = this.getRootDisplay();
                return rootDisplay && rootDisplay._ccNode;
              }

              dbInit(armature) {
                this._armature = armature;
              }

              dbClear() {
                this._armature = null;
              }

              dbUpdate() {
                if (this._ccComponent) {
                  this._ccComponent.markForUpdateRenderData();
                }
              }

              advanceTimeBySelf(on) {
                this.shouldAdvanced = !!on;
              }

              hasDBEventListener(type) {
                return this._eventTarget.hasEventListener(type);
              }

              addDBEventListener(type, listener, target) {
                this._eventTarget.on(type, listener, target);
              }

              removeDBEventListener(type, listener, target) {
                this._eventTarget.off(type, listener, target);
              }

              dispatchDBEvent(type, eventObject) {
                this._eventTarget.emit(type, eventObject);
              }

            }, _temp$1s)) || _class$1z);

            var _dec$1z, _class$1A, _class2$1l, _temp$1t;
            let CCFactory = (_dec$1z = ccclass('CCFactory'), _dec$1z(_class$1A = (_temp$1t = _class2$1l = class CCFactory extends BaseFactory {
              static getInstance() {
                if (!CCFactory._factory) {
                  CCFactory._factory = new CCFactory();
                }

                return CCFactory._factory;
              }

              constructor() {
                super();
                this.id = void 0;
                this.uuid = void 0;
                this._slots = void 0;
                const eventManager = new CCArmatureDisplay();
                this._dragonBones = new DragonBones(eventManager);

                if ( director.getScheduler()) {
                  game.on(Game.EVENT_RESTART, this.onRestart, this);
                  this.initUpdate();
                }

                this.id = this.uuid = 'CCFactory';
              }

              onRestart() {
                CCFactory._factory = null;
              }

              initUpdate(dt) {
                Scheduler.enableForTarget(this);
                director.getScheduler().scheduleUpdate(this, System.Priority.HIGH, false);
              }

              update(dt) {
                this._dragonBones.advanceTime(dt);
              }

              getDragonBonesDataByRawData(rawData) {
                const dataParser = rawData instanceof ArrayBuffer ? BaseFactory._binaryParser : this._dataParser;
                return dataParser.parseDragonBonesData(rawData, 1.0);
              }

              buildArmatureDisplay(armatureName, dragonBonesName, skinName, textureAtlasName) {
                const armature = this.buildArmature(armatureName, dragonBonesName, skinName, textureAtlasName);
                return armature ? armature._display : null;
              }

              createArmatureNode(comp, armatureName, node) {
                node = node || new Node();
                let display = node.getComponent('dragonBones.ArmatureDisplay');

                if (!display) {
                  display = node.addComponent('dragonBones.ArmatureDisplay');
                }

                node.name = armatureName;
                display._armatureName = armatureName;
                display._dragonAsset = comp.dragonAsset;
                display._dragonAtlasAsset = comp.dragonAtlasAsset;

                display._init();

                return display;
              }

              _buildTextureAtlasData(textureAtlasData, textureAtlas) {
                if (textureAtlasData) {
                  textureAtlasData.renderTexture = textureAtlas;
                } else {
                  textureAtlasData = BaseObject.borrowObject(CCTextureAtlasData);
                }

                return textureAtlasData;
              }

              _sortSlots() {
                const slots = this._slots;
                const sortedSlots = [];

                for (let i = 0, l = slots.length; i < l; i++) {
                  const slot = slots[i];
                  const zOrder = slot._zOrder;
                  let inserted = false;

                  for (let j = sortedSlots.length - 1; j >= 0; j--) {
                    if (zOrder >= sortedSlots[j]._zOrder) {
                      sortedSlots.splice(j + 1, 0, slot);
                      inserted = true;
                      break;
                    }
                  }

                  if (!inserted) {
                    sortedSlots.unshift(slot);
                  }
                }

                this._slots = sortedSlots;
              }

              _buildArmature(dataPackage) {
                const armature = BaseObject.borrowObject(Armature);
                armature._skinData = dataPackage.skin;
                armature._animation = BaseObject.borrowObject(Animation$1);
                armature._animation._armature = armature;
                armature._animation.animations = dataPackage.armature.animations;
                armature._isChildArmature = false;
                const display = new CCArmatureDisplay();
                armature.init(dataPackage.armature, display, display, this._dragonBones);
                return armature;
              }

              _buildSlot(dataPackage, slotData, displays) {
                const slot = BaseObject.borrowObject(CCSlot);
                const display = slot;
                slot.init(slotData, displays, display, display);
                return slot;
              }

              getDragonBonesDataByUUID(uuid) {
                for (const name in this._dragonBonesDataMap) {
                  if (name.indexOf(uuid) !== -1) {
                    return this._dragonBonesDataMap[name];
                  }
                }

                return null;
              }

              removeDragonBonesDataByUUID(uuid, disposeData) {
                if (disposeData === undefined) {
                  disposeData = true;
                }

                for (const name in this._dragonBonesDataMap) {
                  if (name.indexOf(uuid) === -1) continue;

                  if (disposeData) {
                    this._dragonBones.bufferObject(this._dragonBonesDataMap[name]);
                  }

                  delete this._dragonBonesDataMap[name];
                }
              }

            }, _class2$1l._factory = null, _temp$1t)) || _class$1A);

            const MaxCacheTime$1 = 30;
            const FrameTime$1 = 1 / 60;
            const _vertices$2 = [];
            const _indices$1 = [];
            let _boneInfoOffset$1 = 0;
            let _indexOffset$2 = 0;
            let _vfOffset$3 = 0;
            let _preTexUrl = null;
            let _preBlendMode$1 = null;
            let _segVCount$1 = 0;
            let _segICount$1 = 0;
            let _segOffset$1 = 0;
            let _colorOffset$1 = 0;
            let _preColor = 0;

            let _x$1;

            let _y$1;

            class AnimationCache$1 {
              constructor() {
                this._privateMode = false;
                this._inited = false;
                this._invalid = true;
                this._enableCacheAttachedInfo = false;
                this.frames = [];
                this.totalTime = 0;
                this.isCompleted = false;
                this._frameIdx = -1;
                this._armatureInfo = null;
                this._animationName = null;
                this._tempSegments = null;
                this._tempColors = null;
                this._tempBoneInfos = null;
              }

              init(armatureInfo, animationName) {
                this._inited = true;
                this._armatureInfo = armatureInfo;
                this._animationName = animationName;
              }

              clear() {
                this._inited = false;

                for (let i = 0, n = this.frames.length; i < n; i++) {
                  const frame = this.frames[i];
                  frame.segments.length = 0;
                }

                this.invalidAllFrame();
              }

              begin() {
                if (!this._invalid) return;
                const armatureInfo = this._armatureInfo;
                const curAnimationCache = armatureInfo.curAnimationCache;

                if (curAnimationCache && curAnimationCache !== this) {
                  if (this._privateMode) {
                    curAnimationCache.invalidAllFrame();
                  } else {
                    curAnimationCache.updateToFrame();
                  }
                }

                const armature = armatureInfo.armature;
                const animation = armature.animation;
                animation.play(this._animationName, 1);
                armatureInfo.curAnimationCache = this;
                this._invalid = false;
                this._frameIdx = -1;
                this.totalTime = 0;
                this.isCompleted = false;
              }

              end() {
                if (!this._needToUpdate()) {
                  this._armatureInfo.curAnimationCache = null;
                  this.frames.length = this._frameIdx + 1;
                  this.isCompleted = true;
                }
              }

              _needToUpdate(toFrameIdx) {
                const armatureInfo = this._armatureInfo;
                const armature = armatureInfo.armature;
                const animation = armature.animation;
                return !animation.isCompleted && this.totalTime < MaxCacheTime$1 && (toFrameIdx === undefined || this._frameIdx < toFrameIdx);
              }

              updateToFrame(toFrameIdx) {
                if (!this._inited) return;
                this.begin();
                if (!this._needToUpdate(toFrameIdx)) return;
                const armatureInfo = this._armatureInfo;
                const armature = armatureInfo.armature;

                do {
                  armature.advanceTime(FrameTime$1);
                  this._frameIdx++;

                  this._updateFrame(armature, this._frameIdx);

                  this.totalTime += FrameTime$1;
                } while (this._needToUpdate(toFrameIdx));

                this.end();
              }

              isInited() {
                return this._inited;
              }

              isInvalid() {
                return this._invalid;
              }

              invalidAllFrame() {
                this.isCompleted = false;
                this._invalid = true;
              }

              updateAllFrame() {
                this.invalidAllFrame();
                this.updateToFrame();
              }

              enableCacheAttachedInfo() {
                if (!this._enableCacheAttachedInfo) {
                  this._enableCacheAttachedInfo = true;
                  this.invalidAllFrame();
                }
              }

              _updateFrame(armature, index) {
                _vfOffset$3 = 0;
                _boneInfoOffset$1 = 0;
                _indexOffset$2 = 0;
                _preTexUrl = null;
                _preBlendMode$1 = null;
                _segVCount$1 = 0;
                _segICount$1 = 0;
                _segOffset$1 = 0;
                _colorOffset$1 = 0;
                _preColor = 0;
                this.frames[index] = this.frames[index] || {
                  segments: [],
                  colors: [],
                  boneInfos: [],
                  vertices: null,
                  uintVert: null,
                  indices: null
                };
                const frame = this.frames[index];
                const segments = this._tempSegments = frame.segments;
                const colors = this._tempColors = frame.colors;
                const boneInfos = this._tempBoneInfos = frame.boneInfos;

                this._traverseArmature(armature, 1.0);

                if (_colorOffset$1 > 0) {
                  colors[_colorOffset$1 - 1].vfOffset = _vfOffset$3;
                }

                colors.length = _colorOffset$1;
                boneInfos.length = _boneInfoOffset$1;
                const preSegOffset = _segOffset$1 - 1;

                if (preSegOffset >= 0) {
                  if (_segICount$1 > 0) {
                    const preSegInfo = segments[preSegOffset];
                    preSegInfo.indexCount = _segICount$1;
                    preSegInfo.vfCount = _segVCount$1 * 5;
                    preSegInfo.vertexCount = _segVCount$1;
                    segments.length = _segOffset$1;
                  } else {
                    segments.length = _segOffset$1 - 1;
                  }
                }

                if (segments.length === 0) return;
                let vertices = frame.vertices;
                let uintVert = frame.uintVert;

                if (!vertices || vertices.length < _vfOffset$3) {
                  vertices = frame.vertices = new Float32Array(_vfOffset$3);
                  uintVert = frame.uintVert = new Uint32Array(vertices.buffer);
                }

                for (let i = 0, j = 0; i < _vfOffset$3;) {
                  vertices[i++] = _vertices$2[j++];
                  vertices[i++] = _vertices$2[j++];
                  vertices[i++] = _vertices$2[j++];
                  vertices[i++] = _vertices$2[j++];
                  uintVert[i++] = _vertices$2[j++];
                }

                let indices = frame.indices;

                if (!indices || indices.length < _indexOffset$2) {
                  indices = frame.indices = new Uint16Array(_indexOffset$2);
                }

                for (let i = 0; i < _indexOffset$2; i++) {
                  indices[i] = _indices$1[i];
                }

                frame.vertices = vertices;
                frame.uintVert = uintVert;
                frame.indices = indices;
              }

              _traverseArmature(armature, parentOpacity) {
                const colors = this._tempColors;
                const segments = this._tempSegments;
                const boneInfos = this._tempBoneInfos;
                const gVertices = _vertices$2;
                const gIndices = _indices$1;
                const slots = armature._slots;
                let slotVertices;
                let slotIndices;
                let slot;
                let slotMatrix;
                let slotColor;
                let colorVal;
                let texture;
                let preSegOffset;
                let preSegInfo;
                const bones = armature._bones;

                if (this._enableCacheAttachedInfo) {
                  for (let i = 0, l = bones.length; i < l; i++, _boneInfoOffset$1++) {
                    const bone = bones[i];
                    let boneInfo = boneInfos[_boneInfoOffset$1];

                    if (!boneInfo) {
                      boneInfo = boneInfos[_boneInfoOffset$1] = {
                        globalTransformMatrix: new Matrix()
                      };
                    }

                    const boneMat = bone.globalTransformMatrix;
                    const cacheBoneMat = boneInfo.globalTransformMatrix;
                    cacheBoneMat.copyFrom(boneMat);
                  }
                }

                for (let i = 0, l = slots.length; i < l; i++) {
                  slot = slots[i];
                  if (!slot._visible || !slot._displayData) continue;
                  slot.updateWorldMatrix();
                  slotColor = slot._color;

                  if (slot.childArmature) {
                    this._traverseArmature(slot.childArmature, parentOpacity * slotColor.a / 255);

                    continue;
                  }

                  texture = slot.getTexture();
                  if (!texture) continue;

                  if (_preTexUrl !== texture.nativeUrl || _preBlendMode$1 !== slot._blendMode) {
                    _preTexUrl = texture.nativeUrl;
                    _preBlendMode$1 = slot._blendMode;
                    preSegOffset = _segOffset$1 - 1;

                    if (preSegOffset >= 0) {
                      if (_segICount$1 > 0) {
                        preSegInfo = segments[preSegOffset];
                        preSegInfo.indexCount = _segICount$1;
                        preSegInfo.vertexCount = _segVCount$1;
                        preSegInfo.vfCount = _segVCount$1 * 5;
                      } else {
                        _segOffset$1--;
                      }
                    }

                    segments[_segOffset$1] = {
                      tex: texture,
                      blendMode: slot._blendMode,
                      indexCount: 0,
                      vertexCount: 0,
                      vfCount: 0
                    };
                    _segOffset$1++;
                    _segICount$1 = 0;
                    _segVCount$1 = 0;
                  }

                  colorVal = (slotColor.a * parentOpacity << 24 >>> 0) + (slotColor.b << 16) + (slotColor.g << 8) + slotColor.r;

                  if (_preColor !== colorVal) {
                    _preColor = colorVal;

                    if (_colorOffset$1 > 0) {
                      colors[_colorOffset$1 - 1].vfOffset = _vfOffset$3;
                    }

                    colors[_colorOffset$1++] = {
                      r: slotColor.r,
                      g: slotColor.g,
                      b: slotColor.b,
                      a: slotColor.a * parentOpacity,
                      vfOffset: 0
                    };
                  }

                  slotVertices = slot._localVertices;
                  slotIndices = slot._indices;
                  slotMatrix = slot._worldMatrix;

                  for (let j = 0, vl = slotVertices.length; j < vl;) {
                    _x$1 = slotVertices[j++];
                    _y$1 = slotVertices[j++];
                    gVertices[_vfOffset$3++] = _x$1 * slotMatrix.m00 + _y$1 * slotMatrix.m04 + slotMatrix.m12;
                    gVertices[_vfOffset$3++] = _x$1 * slotMatrix.m01 + _y$1 * slotMatrix.m05 + slotMatrix.m13;
                    gVertices[_vfOffset$3++] = slotVertices[j++];
                    gVertices[_vfOffset$3++] = slotVertices[j++];
                    gVertices[_vfOffset$3++] = colorVal;
                  }

                  for (let ii = 0, il = slotIndices.length; ii < il; ii++) {
                    gIndices[_indexOffset$2++] = _segVCount$1 + slotIndices[ii];
                  }
                  _segICount$1 += slotIndices.length;
                  _segVCount$1 += slotVertices.length / 4;
                }
              }

            }
            class ArmatureCache {
              constructor() {
                this._privateMode = false;
                this._animationPool = {};
                this._armatureCache = {};
              }

              enablePrivateMode() {
                this._privateMode = true;
              }

              dispose() {
                for (const key in this._armatureCache) {
                  const armatureInfo = this._armatureCache[key];

                  if (armatureInfo) {
                    const armature = armatureInfo.armature;
                    if (armature) armature.dispose();
                  }
                }

                this._armatureCache = {};
                this._animationPool = {};
              }

              _removeArmature(armatureKey) {
                const armatureInfo = this._armatureCache[armatureKey];
                const animationsCache = armatureInfo.animationsCache;

                for (const aniKey in animationsCache) {
                  const animationCache = animationsCache[aniKey];
                  if (!animationCache) continue;
                  this._animationPool[`${armatureKey}#${aniKey}`] = animationCache;
                  animationCache.clear();
                }

                const armature = armatureInfo.armature;
                if (armature) armature.dispose();
                delete this._armatureCache[armatureKey];
              }

              resetArmature(uuid) {
                for (const armatureKey in this._armatureCache) {
                  if (armatureKey.indexOf(uuid) === -1) continue;

                  this._removeArmature(armatureKey);
                }
              }

              getArmatureCache(armatureName, armatureKey, atlasUUID) {
                const armatureInfo = this._armatureCache[armatureKey];
                let armature;

                if (!armatureInfo) {
                  const factory = CCFactory.getInstance();
                  const proxy = factory.buildArmatureDisplay(armatureName, armatureKey, '', atlasUUID);
                  if (!proxy || !proxy._armature) return null;
                  armature = proxy._armature;

                  if (!ArmatureCache.canCache(armature)) {
                    armature.dispose();
                    return null;
                  }

                  this._armatureCache[armatureKey] = {
                    armature,
                    animationsCache: {},
                    curAnimationCache: null
                  };
                } else {
                  armature = armatureInfo.armature;
                }

                return armature;
              }

              getAnimationCache(armatureKey, animationName) {
                const armatureInfo = this._armatureCache[armatureKey];
                if (!armatureInfo) return null;
                const animationsCache = armatureInfo.animationsCache;
                return animationsCache[animationName];
              }

              initAnimationCache(armatureKey, animationName) {
                if (!animationName) return null;
                const armatureInfo = this._armatureCache[armatureKey];
                const armature = armatureInfo && armatureInfo.armature;
                if (!armature) return null;
                const animation = armature.animation;
                const hasAni = animation.hasAnimation(animationName);
                if (!hasAni) return null;
                const animationsCache = armatureInfo.animationsCache;
                let animationCache = animationsCache[animationName];

                if (!animationCache) {
                  const poolKey = `${armatureKey}#${animationName}`;
                  animationCache = this._animationPool[poolKey];

                  if (animationCache) {
                    delete this._animationPool[poolKey];
                  } else {
                    animationCache = new AnimationCache$1();
                    animationCache._privateMode = this._privateMode;
                  }

                  animationCache.init(armatureInfo, animationName);
                  animationsCache[animationName] = animationCache;
                }

                return animationCache;
              }

              invalidAnimationCache(armatureKey) {
                const armatureInfo = this._armatureCache[armatureKey];
                const armature = armatureInfo && armatureInfo.armature;
                if (!armature) return;
                const animationsCache = armatureInfo.animationsCache;

                for (const aniKey in animationsCache) {
                  const animationCache = animationsCache[aniKey];
                  animationCache.invalidAllFrame();
                }
              }

              updateAnimationCache(armatureKey, animationName) {
                if (animationName) {
                  const animationCache = this.initAnimationCache(armatureKey, animationName);
                  if (!animationCache) return;
                  animationCache.updateAllFrame();
                } else {
                  const armatureInfo = this._armatureCache[armatureKey];
                  const armature = armatureInfo && armatureInfo.armature;
                  if (!armature) return;
                  const animationsCache = armatureInfo.animationsCache;

                  for (const aniKey in animationsCache) {
                    const animationCache = animationsCache[aniKey];
                    animationCache.updateAllFrame();
                  }
                }
              }

              static canCache(armature) {
                const slots = armature._slots;

                for (let i = 0, l = slots.length; i < l; i++) {
                  const slot = slots[i];

                  if (slot.childArmature) {
                    return false;
                  }
                }

                return true;
              }

            }
            ArmatureCache.FrameTime = FrameTime$1;
            ArmatureCache.sharedCache = new ArmatureCache();

            var _dec$1A, _class$1B, _class2$1m, _descriptor$1i, _temp$1u;
            let DragonBonesAsset = (_dec$1A = ccclass('dragonBones.DragonBonesAsset'), _dec$1A(_class$1B = (_class2$1m = (_temp$1u = class DragonBonesAsset extends Asset {
              constructor(...args) {
                super(...args);

                _initializerDefineProperty(this, "_dragonBonesJson", _descriptor$1i, this);

                this._factory = null;
                this._dragonBonesJsonData = void 0;
                this._armaturesEnum = null;
              }

              get dragonBonesJson() {
                return this._dragonBonesJson;
              }

              set dragonBonesJson(value) {
                this._dragonBonesJson = value;
                this._dragonBonesJsonData = JSON.parse(value);
                this.reset();
              }

              constructctor() {
                this.reset();
              }

              createNode(callback) {
                const node = new Node(this.name);
                const armatureDisplay = node.addComponent('dragonBones.ArmatureDisplay');
                armatureDisplay.dragonAsset = this;
                return callback(null, node);
              }

              reset() {
                this._clear();
              }

              init(factory, atlasUUID) {
                {
                  this._factory = factory;
                }

                if (!this._dragonBonesJsonData && this.dragonBonesJson) {
                  this._dragonBonesJsonData = JSON.parse(this.dragonBonesJson);
                }

                let rawData = null;

                if (this._dragonBonesJsonData) {
                  rawData = this._dragonBonesJsonData;
                } else {
                  rawData = this._nativeAsset;
                }

                if (!this._uuid) {
                  const dbData = this._factory.getDragonBonesDataByRawData(rawData);

                  if (dbData) {
                    this._uuid = dbData.name;
                  } else {
                    console.warn('dragonbones name is empty');
                  }
                }

                const armatureKey = `${this._uuid}#${atlasUUID}`;

                const dragonBonesData = this._factory.getDragonBonesData(armatureKey);

                if (dragonBonesData) return armatureKey;

                this._factory.parseDragonBonesData(rawData instanceof ArrayBuffer ? rawData : rawData.buffer instanceof ArrayBuffer ? rawData.buffer : rawData, armatureKey);

                return armatureKey;
              }

              getArmatureEnum() {
                if (this._armaturesEnum) {
                  return this._armaturesEnum;
                }

                this.init();

                const dragonBonesData = this._factory.getDragonBonesDataByUUID(this._uuid);

                if (dragonBonesData) {
                  const armatureNames = dragonBonesData.armatureNames;
                  const enumDef = {};

                  for (let i = 0; i < armatureNames.length; i++) {
                    const name = armatureNames[i];
                    enumDef[name] = i;
                  }

                  return this._armaturesEnum = Enum(enumDef);
                }

                return null;
              }

              getAnimsEnum(armatureName) {
                this.init();

                const dragonBonesData = this._factory.getDragonBonesDataByUUID(this._uuid);

                if (dragonBonesData) {
                  const armature = dragonBonesData.getArmature(armatureName);

                  if (!armature) {
                    return null;
                  }

                  const enumDef = {
                    '<None>': 0
                  };
                  const anims = armature.animations;
                  let i = 0;

                  for (const animName in anims) {
                    if (anims.hasOwnProperty(animName)) {
                      enumDef[animName] = i + 1;
                      i++;
                    }
                  }

                  return Enum(enumDef);
                }

                return null;
              }

              destroy() {
                this._clear();

                return super.destroy();
              }

              _clear() {
                if (this._factory) {
                  ArmatureCache.sharedCache.resetArmature(this._uuid);

                  this._factory.removeDragonBonesDataByUUID(this._uuid, true);
                }
              }

            }, _temp$1u), (_descriptor$1i = _applyDecoratedDescriptor(_class2$1m.prototype, "_dragonBonesJson", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            })), _class2$1m)) || _class$1B);
            legacyCC.internal.DragonBonesAsset = DragonBonesAsset;

            var _dec$1B, _dec2$1n, _class$1C, _class2$1n, _descriptor$1j, _descriptor2$1a, _descriptor3$Y, _descriptor4$U, _temp$1v;
            let DragonBonesAtlasAsset = (_dec$1B = ccclass('dragonBones.DragonBonesAtlasAsset'), _dec2$1n = type$1(Texture2D), _dec$1B(_class$1C = (_class2$1n = (_temp$1v = class DragonBonesAtlasAsset extends Asset {
              constructor() {
                super();

                _initializerDefineProperty(this, "_atlasJson", _descriptor$1j, this);

                _initializerDefineProperty(this, "_texture", _descriptor2$1a, this);

                _initializerDefineProperty(this, "_atlasJsonData", _descriptor3$Y, this);

                this._factory = null;

                _initializerDefineProperty(this, "_textureAtlasData", _descriptor4$U, this);

                this._clear();
              }

              get atlasJson() {
                return this._atlasJson;
              }

              set atlasJson(value) {
                this._atlasJson = value;
                this._atlasJsonData = JSON.parse(this.atlasJson);

                this._clear();
              }

              get texture() {
                return this._texture;
              }

              set texture(value) {
                this._texture = value;

                this._clear();
              }

              createNode(callback) {
                const node = new Node(this.name);
                const armatureDisplay = node.addComponent('dragonBones.ArmatureDisplay');
                armatureDisplay.dragonAtlasAsset = this;
                return callback(null, node);
              }

              init(factory) {
                this._factory = factory;

                if (!this._atlasJsonData) {
                  this._atlasJsonData = JSON.parse(this.atlasJson);
                }

                const atlasJsonObj = this._atlasJsonData;
                this._uuid = this._uuid || atlasJsonObj.name;

                if (this._textureAtlasData) {
                  factory.addTextureAtlasData(this._textureAtlasData, this._uuid);
                } else {
                  this._textureAtlasData = factory.parseTextureAtlasData(atlasJsonObj, this.texture, this._uuid);
                }
              }

              destroy() {
                this._clear();

                return super.destroy();
              }

              _clear() {
                return;
              }

            }, _temp$1v), (_descriptor$1j = _applyDecoratedDescriptor(_class2$1n.prototype, "_atlasJson", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            }), _descriptor2$1a = _applyDecoratedDescriptor(_class2$1n.prototype, "_texture", [serializable, _dec2$1n], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor3$Y = _applyDecoratedDescriptor(_class2$1n.prototype, "_atlasJsonData", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return {};
              }
            }), _descriptor4$U = _applyDecoratedDescriptor(_class2$1n.prototype, "_textureAtlasData", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            })), _class2$1n)) || _class$1C);
            legacyCC.internal.DragonBonesAtlasAsset = DragonBonesAtlasAsset;

            var _dec$1C, _class$1D, _temp$1w;

            const _tempMat4 = new Mat4();

            let AttachUtil$1 = (_dec$1C = ccclass('dragonBones.AttachUtil'), _dec$1C(_class$1D = (_temp$1w = class AttachUtil {
              constructor() {
                this._inited = false;
                this._armature = null;
                this._armatureNode = null;
                this._armatureDisplay = null;
              }

              init(armatureDisplay) {
                this._inited = true;
                this._armature = armatureDisplay._armature;
                this._armatureNode = armatureDisplay.node;
                this._armatureDisplay = armatureDisplay;
              }

              reset() {
                this._inited = false;
                this._armature = null;
                this._armatureNode = null;
                this._armatureDisplay = null;
              }

              _syncAttachedNode() {
                if (!this._inited) return;
                const rootMatrix = this._armatureNode.worldMatrix;
                let boneInfos = null;

                const isCached = this._armatureDisplay.isAnimationCached();

                if (isCached && this._armatureDisplay) {
                  boneInfos = this._armatureDisplay._curFrame && this._armatureDisplay._curFrame.boneInfos;
                  if (!boneInfos) return;
                }

                const sockets = this._armatureDisplay.sockets;
                const socketNodes = this._armatureDisplay.socketNodes;
                const scale = new Vec3();

                const matrixHandle = (node, boneMat) => {
                  const tm = _tempMat4;
                  tm.m00 = boneMat.a;
                  tm.m01 = boneMat.b;
                  tm.m04 = -boneMat.c;
                  tm.m05 = -boneMat.d;
                  tm.m12 = boneMat.tx;
                  tm.m13 = boneMat.ty;

                  if (!node._oldScale) {
                    node._oldScale = node.scale.clone();
                  }

                  scale.set(node._oldScale);
                  node.matrix = _tempMat4;
                  node.scale = scale.multiply(this._armatureNode.scale);
                };

                const bones = this._armature.getBones();

                for (let l = sockets.length - 1; l >= 0; l--) {
                  const sock = sockets[l];
                  const boneNode = sock.target;
                  if (!boneNode) continue;

                  if (!boneNode.isValid) {
                    socketNodes.delete(sock.path);
                    sockets.splice(l, 1);
                    continue;
                  }

                  const bone = isCached ? boneInfos[sock.boneIndex] : bones[sock.boneIndex];
                  if (!bone) continue;
                  matrixHandle(boneNode, bone.globalTransformMatrix);
                }
              }

            }, _temp$1w)) || _class$1D);

            class ArmatureSystem extends System {
              constructor() {
                super();
                this._armatures = new Set();
              }

              static getInstance() {
                if (!ArmatureSystem._instance) {
                  ArmatureSystem._instance = new ArmatureSystem();
                  director.registerSystem(ArmatureSystem.ID, ArmatureSystem._instance, System.Priority.HIGH);
                }

                return ArmatureSystem._instance;
              }

              add(armature) {
                if (!armature) return;

                if (!this._armatures.has(armature)) {
                  this._armatures.add(armature);
                }
              }

              remove(armature) {
                if (!armature) return;

                if (this._armatures.has(armature)) {
                  this._armatures.delete(armature);
                }
              }

              postUpdate(dt) {
                if (!this._armatures) {
                  return;
                }

                this._armatures.forEach(armature => {
                  armature.updateAnimation(dt);
                });
              }

            }
            ArmatureSystem.ID = 'ARMATURE';
            ArmatureSystem._instance = void 0;
            legacyCC.internal.ArmatureSystem = ArmatureSystem;

            var _dec$1D, _dec2$1o, _class$1E, _class2$1o, _descriptor$1k, _descriptor2$1b, _temp$1x, _dec3$16, _dec4$11, _dec5$W, _dec6$R, _dec7$P, _dec8$L, _dec9$G, _dec10$D, _dec11$z, _dec12$y, _dec13$v, _dec14$r, _dec15$r, _dec16$q, _dec17$n, _dec18$m, _dec19$m, _dec20$k, _dec21$j, _dec22$i, _dec23$i, _dec24$f, _dec25$f, _class4$7, _class5$7, _descriptor3$Z, _descriptor4$V, _descriptor5$L, _descriptor6$C, _descriptor7$u, _descriptor8$q, _descriptor9$k, _descriptor10$j, _descriptor11$i, _descriptor12$g, _descriptor13$c, _descriptor14$9, _descriptor15$8, _descriptor16$8, _class6$4, _temp2$9;
            var DefaultArmaturesEnum;

            (function (DefaultArmaturesEnum) {
              DefaultArmaturesEnum[DefaultArmaturesEnum["default"] = -1] = "default";
            })(DefaultArmaturesEnum || (DefaultArmaturesEnum = {}));

            ccenum(DefaultArmaturesEnum);
            var DefaultAnimsEnum$1;

            (function (DefaultAnimsEnum) {
              DefaultAnimsEnum[DefaultAnimsEnum["<None>"] = 0] = "<None>";
            })(DefaultAnimsEnum$1 || (DefaultAnimsEnum$1 = {}));

            ccenum(DefaultAnimsEnum$1);
            var DefaultCacheMode;

            (function (DefaultCacheMode) {
              DefaultCacheMode[DefaultCacheMode["REALTIME"] = 0] = "REALTIME";
            })(DefaultCacheMode || (DefaultCacheMode = {}));

            ccenum(DefaultAnimsEnum$1);
            let timeScale$1 = 1;
            let AnimationCacheMode$1;

            (function (AnimationCacheMode) {
              AnimationCacheMode[AnimationCacheMode["REALTIME"] = 0] = "REALTIME";
              AnimationCacheMode[AnimationCacheMode["SHARED_CACHE"] = 1] = "SHARED_CACHE";
              AnimationCacheMode[AnimationCacheMode["PRIVATE_CACHE"] = 2] = "PRIVATE_CACHE";
            })(AnimationCacheMode$1 || (AnimationCacheMode$1 = {}));

            ccenum(AnimationCacheMode$1);

            function setEnumAttr$1(obj, propName, enumDef) {
              CCClass.Attr.setClassAttr(obj, propName, 'type', 'Enum');
              CCClass.Attr.setClassAttr(obj, propName, 'enumList', Enum.getList(enumDef));
            }

            let DragonBoneSocket = (_dec$1D = ccclass('dragonBones.ArmatureDisplay.DragonBoneSocket'), _dec2$1o = type$1(Node), _dec$1D(_class$1E = (_class2$1o = (_temp$1x = class DragonBoneSocket {
              constructor(path = '', target = null) {
                _initializerDefineProperty(this, "path", _descriptor$1k, this);

                _initializerDefineProperty(this, "target", _descriptor2$1b, this);

                this.boneIndex = null;
                this.path = path;
                this.target = target;
              }

            }, _temp$1x), (_descriptor$1k = _applyDecoratedDescriptor(_class2$1o.prototype, "path", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            }), _descriptor2$1b = _applyDecoratedDescriptor(_class2$1o.prototype, "target", [_dec2$1o, editable, serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            })), _class2$1o)) || _class$1E);
            setClassAlias(DragonBoneSocket, 'dragonBones.ArmatureDisplay.DragonBoneSocket');
            let ArmatureDisplay = (_dec3$16 = ccclass('dragonBones.ArmatureDisplay'), _dec4$11 = help(), _dec5$W = menu$1(), _dec6$R = type$1(DragonBonesAsset), _dec7$P = tooltip(), _dec8$L = type$1(DragonBonesAtlasAsset), _dec9$G = tooltip(), _dec10$D = visible(), _dec11$z = visible(), _dec12$y = displayName(), _dec13$v = type$1(DefaultArmaturesEnum), _dec14$r = tooltip(), _dec15$r = type$1(DefaultAnimsEnum$1), _dec16$q = displayName(), _dec17$n = tooltip(), _dec18$m = displayName(), _dec19$m = tooltip(), _dec20$k = tooltip(), _dec21$j = tooltip(), _dec22$i = tooltip(), _dec23$i = tooltip(), _dec24$f = type$1([DragonBoneSocket]), _dec25$f = tooltip(), _dec3$16(_class4$7 = _dec4$11(_class4$7 = _dec5$W(_class4$7 = executeInEditMode(_class4$7 = (_class5$7 = (_temp2$9 = _class6$4 = class ArmatureDisplay extends Renderable2D {
              get dragonAsset() {
                return this._dragonAsset;
              }

              set dragonAsset(value) {
                this._dragonAsset = value;

                this._refresh();
              }

              get dragonAtlasAsset() {
                return this._dragonAtlasAsset;
              }

              set dragonAtlasAsset(value) {
                this._dragonAtlasAsset = value;

                this._parseDragonAtlasAsset();

                this._refresh();
              }

              get armatureName() {
                return this._armatureName;
              }

              set armatureName(name) {
                this._armatureName = name;
                const animNames = this.getAnimationNames(this._armatureName);

                if (!this.animationName || animNames.indexOf(this.animationName) < 0) {
                  {
                    this.animationName = '';
                  }
                }

                if (this._armature && !this.isAnimationCached()) {
                  this._factory._dragonBones.clock.remove(this._armature);
                }

                this._refresh();

                if (this._armature && !this.isAnimationCached()) {
                  this._factory._dragonBones.clock.add(this._armature);
                }
              }

              get animationName() {
                return this._animationName;
              }

              set animationName(value) {
                this._animationName = value;
              }

              get _defaultArmatureIndex() {
                return this._defaultArmatureIndexValue;
              }

              set _defaultArmatureIndex(value) {
                this._defaultArmatureIndexValue = value;
                let armatureName = '';

                if (this.dragonAsset) {
                  let armaturesEnum;

                  if (this.dragonAsset) {
                    armaturesEnum = this.dragonAsset.getArmatureEnum();
                  }

                  if (!armaturesEnum) {
                    errorID(7400, this.name);
                    return;
                  }

                  armatureName = armaturesEnum[this._defaultArmatureIndex];
                }

                if (armatureName !== undefined) {
                  this.armatureName = armatureName;
                } else {
                  errorID(7401, this.name);
                }

                this.resetRenderData();
                this.markForUpdateRenderData();
              }

              get _animationIndex() {
                return this._animationIndexValue;
              }

              set _animationIndex(value) {
                this._animationIndexValue = value;

                if (this._animationIndex === 0) {
                  this.animationName = '';
                  return;
                }

                let animsEnum;

                if (this.dragonAsset) {
                  animsEnum = this.dragonAsset.getAnimsEnum(this.armatureName);
                }

                if (!animsEnum) {
                  return;
                }

                const animName = animsEnum[this._animationIndex];

                if (animName !== undefined) {
                  this.playAnimation(animName, this.playTimes);
                } else {
                  errorID(7402, this.name);
                }
              }

              get _defaultCacheMode() {
                return this._defaultCacheModeValue;
              }

              set _defaultCacheMode(value) {
                this._defaultCacheModeValue = value;

                if (this._defaultCacheMode !== AnimationCacheMode$1.REALTIME) {
                  if (this._armature && !ArmatureCache.canCache(this._armature)) {
                    this._defaultCacheMode = AnimationCacheMode$1.REALTIME;
                    console.warn('Animation cache mode doesn\'t support skeletal nesting');
                    return;
                  }
                }

                this.setAnimationCacheMode(this._defaultCacheMode);
              }

              get timeScale() {
                return this._timeScale;
              }

              set timeScale(value) {
                this._timeScale = value;

                if (this._armature && !this.isAnimationCached()) {
                  this._armature.animation.timeScale = this.timeScale;
                }
              }

              get debugBones() {
                return this._debugBones;
              }

              set debugBones(value) {
                this._debugBones = value;

                this._updateDebugDraw();
              }

              get sockets() {
                return this._sockets;
              }

              set sockets(val) {
                this._verifySockets(val);

                this._sockets = val;

                this._updateSocketBindings();

                if (val.length > 0 && this._frameCache) {
                  this._frameCache.enableCacheAttachedInfo();
                }
              }

              get socketNodes() {
                return this._socketNodes;
              }

              get meshRenderDataArray() {
                return this._meshRenderDataArray;
              }

              constructor() {
                super();

                _initializerDefineProperty(this, "playTimes", _descriptor3$Z, this);

                _initializerDefineProperty(this, "premultipliedAlpha", _descriptor4$V, this);

                this._armature = null;
                this.attachUtil = void 0;

                _initializerDefineProperty(this, "_defaultArmatureIndexValue", _descriptor5$L, this);

                _initializerDefineProperty(this, "_dragonAsset", _descriptor6$C, this);

                _initializerDefineProperty(this, "_dragonAtlasAsset", _descriptor7$u, this);

                _initializerDefineProperty(this, "_armatureName", _descriptor8$q, this);

                _initializerDefineProperty(this, "_animationName", _descriptor9$k, this);

                _initializerDefineProperty(this, "_animationIndexValue", _descriptor10$j, this);

                this._preCacheMode = -1;
                this._cacheMode = AnimationCacheMode$1.REALTIME;

                _initializerDefineProperty(this, "_defaultCacheModeValue", _descriptor11$i, this);

                _initializerDefineProperty(this, "_timeScale", _descriptor12$g, this);

                _initializerDefineProperty(this, "_playTimes", _descriptor13$c, this);

                _initializerDefineProperty(this, "_debugBones", _descriptor14$9, this);

                this._debugDraw = null;

                _initializerDefineProperty(this, "_enableBatch", _descriptor15$8, this);

                this._armatureKey = '';
                this._accTime = 0;
                this._playCount = 0;
                this._frameCache = null;
                this._curFrame = null;
                this._playing = false;
                this._armatureCache = null;
                this._eventTarget = void 0;
                this._factory = null;
                this._displayProxy = null;
                this._meshRenderDataArray = [];
                this._materialCache = {};
                this._enumArmatures = Enum({});
                this._enumAnimations = Enum({});
                this._socketNodes = new Map();
                this._cachedSockets = new Map();

                _initializerDefineProperty(this, "_sockets", _descriptor16$8, this);

                this._inited = void 0;
                this._meshRenderDataArrayIdx = 0;
                this._cacheModeEnum = void 0;
                this._eventTarget = new EventTarget();
                this._inited = false;
                this.attachUtil = new AttachUtil$1();
                this.initFactory();
                setEnumAttr$1(this, '_animationIndex', this._enumAnimations);
                setEnumAttr$1(this, '_defaultArmatureIndex', this._enumArmatures);
              }

              initFactory() {
                this._factory = CCFactory.getInstance();
              }

              onLoad() {
                const children = this.node.children;

                for (let i = 0, n = children.length; i < n; i++) {
                  const child = children[i];
                  const pos = child.name && child.name.search('CHILD_ARMATURE-');

                  if (pos === 0) {
                    child.destroy();
                  }
                }
              }

              requestMeshRenderData() {
                const arr = this._meshRenderDataArray;

                if (arr.length > 0 && arr[arr.length - 1].renderData.vertexCount === 0) {
                  return arr[arr.length - 1];
                }

                const renderData = new MeshRenderData();
                const comb = {
                  renderData,
                  texture: null
                };
                arr.push(comb);
                return comb;
              }

              destroyRenderData() {
                if (this._meshRenderDataArray) {
                  this._meshRenderDataArray.forEach(rd => {
                    rd.renderData.reset();
                  });

                  this._meshRenderDataArray.length = 0;
                }
              }

              resetRenderData() {
                if (this._meshRenderDataArray) {
                  this._meshRenderDataArray.forEach(rd => {
                    rd.renderData.reset();
                  });
                }
              }

              getMaterialForBlend(src, dst) {
                const key = `${src}/${dst}`;
                let inst = this._materialCache[key];

                if (inst) {
                  return inst;
                }

                const material = this.getMaterial(0);
                const matInfo = {
                  parent: material,
                  subModelIdx: 0,
                  owner: this
                };
                inst = new MaterialInstance(matInfo);
                inst.recompileShaders({
                  USE_LOCAL: false
                }, 0);
                this._materialCache[key] = inst;
                inst.overridePipelineStates({
                  blendState: {
                    targets: [{
                      blendSrc: src,
                      blendDst: dst
                    }]
                  }
                });
                return inst;
              }

              _render(ui) {
                if (this._meshRenderDataArray) {
                  for (let i = 0; i < this._meshRenderDataArray.length; i++) {
                    const mat = this.material;
                    this._meshRenderDataArrayIdx = i;
                    const m = this._meshRenderDataArray[i];

                    if (m.renderData.material) {
                      this.material = m.renderData.material;
                    }

                    if (m.texture) {
                      ui.commitComp(this, m.texture, this._assembler, null);
                    }

                    this.material = mat;
                  }
                }
              }

              _updateBatch() {
                this._materialCache = {};
                this.destroyRenderData();
                this.markForUpdateRenderData();
              }

              _updateMaterial() {
                this.markForUpdateRenderData();
              }

              disableRender() {}

              _validateRender() {
                const texture = this.dragonAtlasAsset && this.dragonAtlasAsset.texture;

                if (!texture) {
                  this.disableRender();
                  return false;
                }

                return true;
              }

              __preload() {
                super.__preload();

                this._init();
              }

              _init() {

                this._cacheMode = this._defaultCacheMode;
                if (this._inited) return;
                this._inited = true;

                this._parseDragonAtlasAsset();

                this._refresh();

                const children = this.node.children;

                for (let i = 0, n = children.length; i < n; i++) {
                  const child = children[i];

                  if (child && child.name === 'DEBUG_DRAW_NODE') {
                    child.destroy();
                  }
                }

                this._updateDebugDraw();

                this._indexBoneSockets();

                this._updateSocketBindings();
              }

              getArmatureKey() {
                return this._armatureKey;
              }

              setAnimationCacheMode(cacheMode) {
                if (this._preCacheMode !== cacheMode) {
                  this._cacheMode = cacheMode;

                  this._buildArmature();

                  if (this._armature && !this.isAnimationCached()) {
                    this._factory._dragonBones.clock.add(this._armature);
                  }

                  this._updateSocketBindings();

                  this.markForUpdateRenderData();
                }
              }

              isAnimationCached() {
                return this._cacheMode !== AnimationCacheMode$1.REALTIME;
              }

              onEnable() {
                super.onEnable();

                if (this._armature && !this.isAnimationCached()) {
                  this._factory._dragonBones.clock.add(this._armature);
                }

                this._flushAssembler();

                ArmatureSystem.getInstance().add(this);
              }

              onDisable() {
                super.onDisable();

                if (this._armature && !this.isAnimationCached()) {
                  this._factory._dragonBones.clock.remove(this._armature);
                }

                ArmatureSystem.getInstance().remove(this);
              }

              _emitCacheCompleteEvent() {
                this._eventTarget.emit(EventObject.LOOP_COMPLETE);

                this._eventTarget.emit(EventObject.COMPLETE);
              }

              updateAnimation(dt) {
                if (!this.isAnimationCached()) return;
                if (!this._frameCache) return;
                this.markForUpdateRenderData();
                const frameCache = this._frameCache;

                if (!frameCache.isInited()) {
                  return;
                }

                const frames = frameCache.frames;

                if (!this._playing) {
                  if (frameCache.isInvalid()) {
                    frameCache.updateToFrame();
                    this._curFrame = frames[frames.length - 1];
                  }

                  return;
                }

                const frameTime = ArmatureCache.FrameTime;

                if (this._accTime === 0 && this._playCount === 0) {
                  this._eventTarget.emit(EventObject.START);
                }

                const globalTimeScale = timeScale$1;
                this._accTime += dt * this.timeScale * globalTimeScale;
                let frameIdx = Math.floor(this._accTime / frameTime);

                if (!frameCache.isCompleted) {
                  frameCache.updateToFrame(frameIdx);
                }

                if (frameCache.isCompleted && frameIdx >= frames.length) {
                  this._playCount++;

                  if (this.playTimes > 0 && this._playCount >= this.playTimes) {
                    this._curFrame = frames[frames.length - 1];
                    this._accTime = 0;
                    this._playing = false;
                    this._playCount = 0;

                    this._emitCacheCompleteEvent();

                    this.attachUtil._syncAttachedNode();

                    return;
                  }

                  this._accTime = 0;
                  frameIdx = 0;

                  this._emitCacheCompleteEvent();
                }

                this._curFrame = frames[frameIdx];

                this.attachUtil._syncAttachedNode();
              }

              onDestroy() {
                this._materialInstances = this._materialInstances.filter(instance => !!instance);
                super.onDestroy();
                this._inited = false;

                {
                  if (this._cacheMode === AnimationCacheMode$1.PRIVATE_CACHE) {
                    this._armatureCache.dispose();

                    this._armatureCache = null;
                    this._armature = null;
                  } else if (this._cacheMode === AnimationCacheMode$1.SHARED_CACHE) {
                    this._armatureCache = null;
                    this._armature = null;
                  } else if (this._armature) {
                    this._armature.dispose();

                    this._armature = null;
                  }
                }

                this.destroyRenderData();
              }

              _updateDebugDraw() {
                if (this.debugBones) {
                  if (!this._debugDraw) {
                    const debugDrawNode = new Node('DEBUG_DRAW_NODE');
                    debugDrawNode.hideFlags |= CCObject.Flags.DontSave | CCObject.Flags.HideInHierarchy;
                    const debugDraw = debugDrawNode.addComponent(Graphics);
                    debugDraw.lineWidth = 1;
                    debugDraw.strokeColor = new Color$1(255, 0, 0, 255);
                    this._debugDraw = debugDraw;
                  }

                  this._debugDraw.node.parent = this.node;
                } else if (this._debugDraw) {
                  this._debugDraw.node.parent = null;
                }

                this.destroyRenderData();
                this.markForUpdateRenderData();
              }

              _buildArmature() {
                if (!this.dragonAsset || !this.dragonAtlasAsset || !this.armatureName) return;

                if (this._armature) {
                  {
                    if (this._preCacheMode === AnimationCacheMode$1.PRIVATE_CACHE) {
                      this._armatureCache.dispose();
                    } else if (this._preCacheMode === AnimationCacheMode$1.REALTIME) {
                      this._armature.dispose();
                    }
                  }

                  this._armatureCache = null;
                  this._armature = null;
                  this._displayProxy = null;
                  this._frameCache = null;
                  this._curFrame = null;
                  this._playing = false;
                  this._preCacheMode = -1;
                }

                {
                  if (this._cacheMode === AnimationCacheMode$1.SHARED_CACHE) {
                    this._armatureCache = ArmatureCache.sharedCache;
                  } else if (this._cacheMode === AnimationCacheMode$1.PRIVATE_CACHE) {
                    this._armatureCache = new ArmatureCache();

                    this._armatureCache.enablePrivateMode();
                  }
                }

                const atlasUUID = this.dragonAtlasAsset._uuid;
                this._armatureKey = this.dragonAsset.init(this._factory, atlasUUID);

                if (this.isAnimationCached()) {
                  this._armature = this._armatureCache.getArmatureCache(this.armatureName, this._armatureKey, atlasUUID);

                  if (!this._armature) {
                    this._cacheMode = AnimationCacheMode$1.REALTIME;
                  }
                }

                this._preCacheMode = this._cacheMode;

                if ( this._cacheMode === AnimationCacheMode$1.REALTIME) {
                  this._displayProxy = this._factory.buildArmatureDisplay(this.armatureName, this._armatureKey, '', atlasUUID);
                  if (!this._displayProxy) return;
                  this._displayProxy._ccNode = this.node;
                  this._displayProxy._ccComponent = this;

                  this._displayProxy.setEventTarget(this._eventTarget);

                  this._armature = this._displayProxy._armature;
                  this._armature.animation.timeScale = this.timeScale;
                }

                if (this._cacheMode !== AnimationCacheMode$1.REALTIME && this.debugBones) {
                  console.warn('Debug bones is invalid in cached mode');
                }

                if (this._armature) {
                  const armatureData = this._armature.armatureData;
                  const aabb = armatureData.aabb;

                  this.node._uiProps.uiTransformComp.setContentSize(aabb.width, aabb.height);
                }

                this._updateBatch();

                this.attachUtil.init(this);

                if (this.animationName) {
                  this.playAnimation(this.animationName, this.playTimes);
                }

                this.destroyRenderData();
                this.markForUpdateRenderData();
              }

              querySockets() {
                if (!this._armature) {
                  return [];
                }

                if (this._cachedSockets.size === 0) {
                  this._indexBoneSockets();
                }

                return Array.from(this._cachedSockets.keys()).sort();
              }

              setBlendHash() {
                if (this._blendHash !== -1) this._blendHash = -1;
              }

              querySocketPathByName(name) {
                const ret = [];

                for (const key of this._cachedSockets.keys()) {
                  if (key.endsWith(name)) {
                    ret.push(key);
                  }
                }

                return ret;
              }

              _parseDragonAtlasAsset() {
                if (this.dragonAtlasAsset) {
                  this.dragonAtlasAsset.init(this._factory);
                }
              }

              _refresh() {
                this._buildArmature();

                this._indexBoneSockets();

                this.markForUpdateRenderData();
              }

              _updateCacheModeEnum() {
                this._cacheModeEnum = Enum({});

                if (this._armature) {
                  Object.assign(this._cacheModeEnum, AnimationCacheMode$1);
                } else {
                  Object.assign(this._cacheModeEnum, DefaultCacheMode);
                }

                setEnumAttr$1(this, '_defaultCacheMode', this._cacheModeEnum);
              }

              _updateAnimEnum() {
                let animEnum;

                if (this.dragonAsset) {
                  animEnum = this.dragonAsset.getAnimsEnum(this.armatureName);
                } else {
                  animEnum = DefaultAnimsEnum$1;
                }

                this._enumAnimations = Enum({});
                Object.assign(this._enumAnimations, animEnum || DefaultAnimsEnum$1);
                Enum.update(this._enumAnimations);
                setEnumAttr$1(this, '_animationIndex', this._enumAnimations);
              }

              _updateArmatureEnum() {
                let armatureEnum;

                if (this.dragonAsset) {
                  armatureEnum = this.dragonAsset.getArmatureEnum();
                } else {
                  armatureEnum = DefaultArmaturesEnum;
                }

                this._enumArmatures = Enum({});
                Object.assign(this._enumArmatures, armatureEnum || DefaultArmaturesEnum);
                Enum.update(this._enumArmatures);
                setEnumAttr$1(this, '_defaultArmatureIndex', this._enumArmatures);
              }

              _indexBoneSockets() {
                if (!this._armature) {
                  return;
                }

                this._cachedSockets.clear();

                const nameToBone = this._cachedSockets;

                const cacheBoneName = (bi, bones, cache) => {
                  if (cache.has(bi)) {
                    return cache.get(bi);
                  }

                  const bone = bones[bi];

                  if (!bone.parent) {
                    cache.set(bi, bone.name);
                    bone.path = bone.name;
                    return bone.name;
                  }

                  const name = `${cacheBoneName(bone.parent._boneIndex, bones, cache)}/${bone.name}`;
                  cache.set(bi, name);
                  bone.path = name;
                  return name;
                };

                const walkArmature = (prefix, armature) => {
                  const bones = armature.getBones();
                  const boneToName = new Map();

                  for (let i = 0; i < bones.length; i++) {
                    bones[i]._boneIndex = i;
                  }

                  for (let i = 0; i < bones.length; i++) {
                    cacheBoneName(i, bones, boneToName);
                  }

                  for (const bone of boneToName.keys()) {
                    nameToBone.set(`${prefix}${boneToName.get(bone)}`, bone);
                  }

                  const slots = armature.getSlots();

                  for (let i = 0; i < slots.length; i++) {
                    if (slots[i].childArmature) {
                      walkArmature(slots[i].name, slots[i].childArmature);
                    }
                  }
                };

                walkArmature('', this._armature);
              }

              playAnimation(animName, playTimes) {
                this.playTimes = playTimes === undefined ? -1 : playTimes;
                this.animationName = animName;

                if (this.isAnimationCached()) {
                  let cache = this._armatureCache.getAnimationCache(this._armatureKey, animName);

                  if (!cache) {
                    cache = this._armatureCache.initAnimationCache(this._armatureKey, animName);
                  }

                  if (cache) {
                    this._accTime = 0;
                    this._playCount = 0;
                    this._frameCache = cache;

                    if (this._sockets.length > 0) {
                      this._frameCache.enableCacheAttachedInfo();
                    }

                    this._frameCache.updateToFrame(0);

                    this._playing = true;
                    this._curFrame = this._frameCache.frames[0];
                  }
                } else if (this._armature) {
                  return this._armature.animation.play(animName, this.playTimes);
                }

                this.markForUpdateRenderData();
                return null;
              }

              updateAnimationCache(animName) {
                if (!this.isAnimationCached()) return;

                this._armatureCache.updateAnimationCache(this._armatureKey, animName);
              }

              invalidAnimationCache() {
                if (!this.isAnimationCached()) return;

                this._armatureCache.invalidAnimationCache(this._armatureKey);
              }

              getArmatureNames() {
                const dragonBonesData = this._factory.getDragonBonesData(this._armatureKey);

                return dragonBonesData && dragonBonesData.armatureNames || [];
              }

              getAnimationNames(armatureName) {
                const ret = [];

                const dragonBonesData = this._factory.getDragonBonesData(this._armatureKey);

                if (dragonBonesData) {
                  const armatureData = dragonBonesData.getArmature(armatureName);

                  if (armatureData) {
                    for (const animName in armatureData.animations) {
                      if (armatureData.animations.hasOwnProperty(animName)) {
                        ret.push(animName);
                      }
                    }
                  }
                }

                return ret;
              }

              on(eventType, listener, target) {
                this.addEventListener(eventType, listener, target);
              }

              off(eventType, listener, target) {
                this.removeEventListener(eventType, listener, target);
              }

              once(eventType, listener, target) {
                this._eventTarget.once(eventType, listener, target);
              }

              addEventListener(eventType, listener, target) {
                this._eventTarget.on(eventType, listener, target);
              }

              removeEventListener(eventType, listener, target) {
                this._eventTarget.off(eventType, listener, target);
              }

              buildArmature(armatureName, node) {
                return this._factory.createArmatureNode(this, armatureName, node);
              }

              armature() {
                return this._armature;
              }

              _flushAssembler() {
                const assembler = ArmatureDisplay.Assembler.getAssembler(this);

                if (this._assembler !== assembler) {
                  this._assembler = assembler;
                }

                if (this._meshRenderDataArray.length === 0) {
                  if (this._assembler && this._assembler.createData) {
                    this._assembler.createData(this);

                    this.markForUpdateRenderData();
                    this._colorDirty = true;

                    this._updateColor();
                  }
                }
              }

              _updateSocketBindings() {
                if (!this._armature) return;

                this._socketNodes.clear();

                for (let i = 0, l = this._sockets.length; i < l; i++) {
                  const socket = this._sockets[i];

                  if (socket.path && socket.target) {
                    const bone = this._cachedSockets.get(socket.path);

                    if (!bone) {
                      console.error(`Skeleton data does not contain path ${socket.path}`);
                      continue;
                    }

                    socket.boneIndex = bone;

                    this._socketNodes.set(socket.path, socket.target);
                  }
                }
              }

              _verifySockets(sockets) {
                for (let i = 0, l = sockets.length; i < l; i++) {
                  const target = sockets[i].target;

                  if (target) {
                    if (!target.parent || target.parent !== this.node) {
                      console.error(`Target node ${target.name} is expected to be a direct child of ${this.node.name}`);
                      continue;
                    }
                  }
                }
              }

            }, _class6$4.AnimationCacheMode = AnimationCacheMode$1, _temp2$9), (_applyDecoratedDescriptor(_class5$7.prototype, "dragonAsset", [editable, _dec6$R, _dec7$P], Object.getOwnPropertyDescriptor(_class5$7.prototype, "dragonAsset"), _class5$7.prototype), _applyDecoratedDescriptor(_class5$7.prototype, "dragonAtlasAsset", [editable, _dec8$L, _dec9$G], Object.getOwnPropertyDescriptor(_class5$7.prototype, "dragonAtlasAsset"), _class5$7.prototype), _applyDecoratedDescriptor(_class5$7.prototype, "armatureName", [_dec10$D], Object.getOwnPropertyDescriptor(_class5$7.prototype, "armatureName"), _class5$7.prototype), _applyDecoratedDescriptor(_class5$7.prototype, "animationName", [_dec11$z], Object.getOwnPropertyDescriptor(_class5$7.prototype, "animationName"), _class5$7.prototype), _applyDecoratedDescriptor(_class5$7.prototype, "_defaultArmatureIndex", [_dec12$y, editable, _dec13$v, _dec14$r], Object.getOwnPropertyDescriptor(_class5$7.prototype, "_defaultArmatureIndex"), _class5$7.prototype), _applyDecoratedDescriptor(_class5$7.prototype, "_animationIndex", [editable, _dec15$r, _dec16$q, _dec17$n], Object.getOwnPropertyDescriptor(_class5$7.prototype, "_animationIndex"), _class5$7.prototype), _applyDecoratedDescriptor(_class5$7.prototype, "_defaultCacheMode", [editable, _dec18$m, _dec19$m], Object.getOwnPropertyDescriptor(_class5$7.prototype, "_defaultCacheMode"), _class5$7.prototype), _applyDecoratedDescriptor(_class5$7.prototype, "timeScale", [editable, _dec20$k, serializable], Object.getOwnPropertyDescriptor(_class5$7.prototype, "timeScale"), _class5$7.prototype), _descriptor3$Z = _applyDecoratedDescriptor(_class5$7.prototype, "playTimes", [_dec21$j, editable, serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return -1;
              }
            }), _descriptor4$V = _applyDecoratedDescriptor(_class5$7.prototype, "premultipliedAlpha", [serializable, editable, _dec22$i], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _applyDecoratedDescriptor(_class5$7.prototype, "debugBones", [_dec23$i, editable], Object.getOwnPropertyDescriptor(_class5$7.prototype, "debugBones"), _class5$7.prototype), _applyDecoratedDescriptor(_class5$7.prototype, "sockets", [_dec24$f, _dec25$f], Object.getOwnPropertyDescriptor(_class5$7.prototype, "sockets"), _class5$7.prototype), _descriptor5$L = _applyDecoratedDescriptor(_class5$7.prototype, "_defaultArmatureIndexValue", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return DefaultArmaturesEnum.default;
              }
            }), _descriptor6$C = _applyDecoratedDescriptor(_class5$7.prototype, "_dragonAsset", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor7$u = _applyDecoratedDescriptor(_class5$7.prototype, "_dragonAtlasAsset", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return null;
              }
            }), _descriptor8$q = _applyDecoratedDescriptor(_class5$7.prototype, "_armatureName", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            }), _descriptor9$k = _applyDecoratedDescriptor(_class5$7.prototype, "_animationName", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return '';
              }
            }), _descriptor10$j = _applyDecoratedDescriptor(_class5$7.prototype, "_animationIndexValue", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 0;
              }
            }), _descriptor11$i = _applyDecoratedDescriptor(_class5$7.prototype, "_defaultCacheModeValue", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return AnimationCacheMode$1.REALTIME;
              }
            }), _descriptor12$g = _applyDecoratedDescriptor(_class5$7.prototype, "_timeScale", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 1;
              }
            }), _descriptor13$c = _applyDecoratedDescriptor(_class5$7.prototype, "_playTimes", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return -1;
              }
            }), _descriptor14$9 = _applyDecoratedDescriptor(_class5$7.prototype, "_debugBones", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor15$8 = _applyDecoratedDescriptor(_class5$7.prototype, "_enableBatch", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return false;
              }
            }), _descriptor16$8 = _applyDecoratedDescriptor(_class5$7.prototype, "_sockets", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return [];
              }
            })), _class5$7)) || _class4$7) || _class4$7) || _class4$7) || _class4$7);
            legacyCC.internal.ArmatureDisplay = ArmatureDisplay;

            const NEED_COLOR = 0x01;
            const NEED_BATCH = 0x10;
            const STRIDE_FLOAT = 9;

            const _boneColor$1 = new Color$1(255, 0, 0, 255);

            const _slotColor$1 = new Color$1(0, 0, 255, 255);

            const _originColor$1 = new Color$1(0, 255, 0, 255);

            let _nodeR$1;

            let _nodeG$1;

            let _nodeB$1;

            let _nodeA$1;

            let _premultipliedAlpha$1;

            let _mustFlush$1;

            let _buffer$1;

            let _node$1;

            let _comp$2;

            let _vfOffset$4;

            let _indexOffset$3;

            let _vertexOffset$1;

            let _vertexCount$1;

            let _indexCount$2;

            let _x$2;

            let _y$2;

            const _c = new Float32Array(4);

            let _handleVal$1;

            let _m00$1;

            let _m04$1;

            let _m12$1;

            let _m01$1;

            let _m05$1;

            let _m13$1;

            const _vec3u_temp$2 = new Vec3();

            function _getSlotMaterial$1(tex, blendMode) {
              if (!tex) return null;
              let src;
              let dst;

              switch (blendMode) {
                case 1:
                  src = _premultipliedAlpha$1 ? BlendFactor.ONE : BlendFactor.SRC_ALPHA;
                  dst = BlendFactor.ONE;
                  break;

                case 10:
                  src = BlendFactor.DST_COLOR;
                  dst = BlendFactor.ONE_MINUS_SRC_ALPHA;
                  break;

                case 12:
                  src = BlendFactor.ONE;
                  dst = BlendFactor.ONE_MINUS_SRC_COLOR;
                  break;

                case 0:
                default:
                  src = _premultipliedAlpha$1 ? BlendFactor.ONE : BlendFactor.SRC_ALPHA;
                  dst = BlendFactor.ONE_MINUS_SRC_ALPHA;
                  break;
              }

              _comp$2.setBlendHash();

              return _comp$2.getMaterialForBlend(src, dst);
            }

            function _handleColor$1(color, parentOpacity) {
              const _a = color.a * parentOpacity * _nodeA$1;

              const _multiply = _premultipliedAlpha$1 ? _a / 255.0 : 1.0;

              const _r = color.r * _nodeR$1 * _multiply / 255.0;

              const _g = color.g * _nodeG$1 * _multiply / 255.0;

              const _b = color.b * _nodeB$1 * _multiply / 255.0;

              _c[0] = _r;
              _c[1] = _g;
              _c[2] = _b;
              _c[3] = _premultipliedAlpha$1 ? 1.0 : _a / 255.0;
            }

            function _intToColor(v) {
              _c[0] = (0xFF & v >>> 24) / 255.0;
              _c[1] = (0xFF & v >>> 16) / 255.0;
              _c[2] = (0xFF & v >>> 8) / 255.0;
              _c[3] = (0xFF & v >>> 0) / 255.0;
            }

            const simple$3 = {
              createData() {},

              updateRenderData(comp, ui) {
                _comp$2 = comp;
                updateComponentRenderData$1(comp);
              },

              updateColor(comp) {
                if (!comp) return;
                _comp$2 = comp;

                _comp$2.markForUpdateRenderData();
              },

              fillBuffers(comp, renderer) {
                if (!comp || comp.meshRenderDataArray.length === 0) return;
                const dataArray = comp.meshRenderDataArray;
                const node = comp.node;
                let buffer = renderer.acquireBufferBatch();
                let floatOffset = buffer.byteOffset >> 2;
                let indicesOffset = buffer.indicesOffset;
                let vertexOffset = buffer.vertexOffset;
                const data = dataArray[comp._meshRenderDataArrayIdx];
                const renderData = data.renderData;
                const isRecreate = buffer.request(renderData.vertexCount, renderData.indicesCount);

                if (!isRecreate) {
                  buffer = renderer.currBufferBatch;
                  floatOffset = 0;
                  indicesOffset = 0;
                  vertexOffset = 0;
                }

                const vBuf = buffer.vData;
                const iBuf = buffer.iData;
                const matrix = node.worldMatrix;
                const srcVBuf = renderData.vData;
                const srcVIdx = renderData.vertexStart;
                const srcIBuf = renderData.iData;
                vBuf.set(srcVBuf.slice(srcVIdx, srcVIdx + renderData.vertexCount * STRIDE_FLOAT), floatOffset);

                if (!comp._enableBatch) {
                  for (let i = 0; i < renderData.vertexCount; i++) {
                    const pOffset = floatOffset + i * STRIDE_FLOAT;

                    _vec3u_temp$2.set(vBuf[pOffset], vBuf[pOffset + 1], vBuf[pOffset + 2]);

                    _vec3u_temp$2.transformMat4(matrix);

                    vBuf[pOffset] = _vec3u_temp$2.x;
                    vBuf[pOffset + 1] = _vec3u_temp$2.y;
                    vBuf[pOffset + 2] = _vec3u_temp$2.z;
                  }
                }

                const srcIOffset = renderData.indicesStart;

                for (let i = 0; i < renderData.indicesCount; i += 1) {
                  iBuf[i + indicesOffset] = srcIBuf[i + srcIOffset] + vertexOffset;
                }
              }

            };

            function realTimeTraverse$1(armature, parentMat, parentOpacity) {
              const slots = armature._slots;
              let vbuf;
              let ibuf;
              let material;
              let vertices;
              let indices;
              let slotColor;
              let slot;
              const slotMat = new Mat4();

              for (let i = 0, l = slots.length; i < l; i++) {
                slot = slots[i];
                slotColor = slot._color;
                if (!slot._visible || !slot._displayData) continue;

                if (parentMat) {
                  slot._mulMat(slot._worldMatrix, parentMat, slot._matrix);
                } else {
                  Mat4.copy(slot._worldMatrix, slot._matrix);
                }

                if (slot.childArmature) {
                  realTimeTraverse$1(slot.childArmature, slot._worldMatrix, parentOpacity * slotColor.a / 255);
                  continue;
                }

                material = _getSlotMaterial$1(slot.getTexture(), slot._blendMode);

                if (!material) {
                  continue;
                }

                if (!_buffer$1.renderData.material) {
                  _buffer$1.renderData.material = material;
                }

                if (!_buffer$1.texture) {
                  _buffer$1.texture = slot.getTexture();
                }

                if (_mustFlush$1 || material !== _buffer$1.renderData.material || _buffer$1.texture !== slot.getTexture()) {
                  _mustFlush$1 = false;
                  _buffer$1 = _comp$2.requestMeshRenderData();
                  _buffer$1.renderData.material = material;
                  _buffer$1.texture = slot.getTexture();
                }

                _handleColor$1(slotColor, parentOpacity);

                slotMat.set(slot._worldMatrix);
                vertices = slot._localVertices;
                _vertexCount$1 = vertices.length >> 2;
                indices = slot._indices;
                _indexCount$2 = indices.length;
                const rd = _buffer$1.renderData;
                rd.reserve(_vertexCount$1, _indexCount$2);
                _indexOffset$3 = rd.indicesCount;
                _vfOffset$4 = rd.vDataOffset;
                _vertexOffset$1 = rd.vertexCount;
                vbuf = _buffer$1.renderData.vData;
                ibuf = _buffer$1.renderData.iData;
                _m00$1 = slotMat.m00;
                _m04$1 = slotMat.m04;
                _m12$1 = slotMat.m12;
                _m01$1 = slotMat.m01;
                _m05$1 = slotMat.m05;
                _m13$1 = slotMat.m13;

                for (let vi = 0, vl = vertices.length; vi < vl;) {
                  _x$2 = vertices[vi++];
                  _y$2 = vertices[vi++];
                  vbuf[_vfOffset$4] = _x$2 * _m00$1 + _y$2 * _m04$1 + _m12$1;
                  vbuf[_vfOffset$4 + 1] = _x$2 * _m01$1 + _y$2 * _m05$1 + _m13$1;
                  vbuf[_vfOffset$4 + 3] = vertices[vi++];
                  vbuf[_vfOffset$4 + 4] = vertices[vi++];
                  vbuf.set(_c, _vfOffset$4 + 5);
                  _vfOffset$4 += STRIDE_FLOAT;
                }

                for (let ii = 0, il = indices.length; ii < il; ii++) {
                  ibuf[_indexOffset$3++] = _vertexOffset$1 + indices[ii];
                }

                _buffer$1.renderData.advance(_vertexCount$1, _indexCount$2);
              }
            }

            function cacheTraverse$1(frame, parentMat) {
              if (!frame) return;
              const segments = frame.segments;
              if (segments.length === 0) return;
              let vbuf;
              let ibuf;
              let material;
              const vertices = frame.vertices;
              const colorArray = new Uint32Array(vertices.buffer);
              const indices = frame.indices;
              let frameVFOffset = 0;
              let frameIndexOffset = 0;
              let segVFCount = 0;

              if (parentMat) {
                _m00$1 = parentMat.m00;
                _m01$1 = parentMat.m01;
                _m04$1 = parentMat.m04;
                _m05$1 = parentMat.m05;
                _m12$1 = parentMat.m12;
                _m13$1 = parentMat.m13;
              }

              const justTranslate = _m00$1 === 1 && _m01$1 === 0 && _m04$1 === 0 && _m05$1 === 1;
              const needBatch = _handleVal$1 & NEED_BATCH;
              const calcTranslate = needBatch && justTranslate;
              let colorOffset = 0;
              const colors = frame.colors;
              let nowColor = colors[colorOffset++];
              let maxVFOffset = nowColor.vfOffset;

              _handleColor$1(nowColor, 1.0);

              for (let i = 0, n = segments.length; i < n; i++) {
                const segInfo = segments[i];
                material = _getSlotMaterial$1(segInfo.tex, segInfo.blendMode);

                if (!_buffer$1.renderData.material) {
                  _buffer$1.renderData.material = material;
                }

                if (!_buffer$1.texture) {
                  _buffer$1.texture = segInfo.tex;
                }

                if (_mustFlush$1 || _buffer$1.renderData.material !== material || _buffer$1.texture !== segInfo.tex) {
                  _mustFlush$1 = false;
                  _buffer$1 = _comp$2.requestMeshRenderData();
                  _buffer$1.renderData.material = material;
                  _buffer$1.texture = segInfo.tex;
                }

                _vertexCount$1 = segInfo.vertexCount;
                _indexCount$2 = segInfo.indexCount;
                const rd = _buffer$1.renderData;
                rd.reserve(_vertexCount$1, _indexCount$2);
                _indexOffset$3 = rd.indicesCount;
                _vfOffset$4 = rd.vDataOffset;
                _vertexOffset$1 = rd.vertexCount;
                vbuf = _buffer$1.renderData.vData;
                ibuf = _buffer$1.renderData.iData;

                for (let ii = _indexOffset$3, il = _indexOffset$3 + _indexCount$2; ii < il; ii++) {
                  ibuf[ii] = _vertexOffset$1 + indices[frameIndexOffset++];
                }

                segVFCount = segInfo.vfCount;

                for (let ii = frameVFOffset, jj = _vfOffset$4; ii < frameVFOffset + segVFCount;) {
                  vbuf[jj] = vertices[ii++];
                  vbuf[jj + 1] = vertices[ii++];
                  vbuf[jj + 3] = vertices[ii++];
                  vbuf[jj + 4] = vertices[ii++];

                  _intToColor(colorArray[ii++]);

                  vbuf.set(_c, jj + 5);
                  jj += STRIDE_FLOAT;
                }

                frameVFOffset += segVFCount;

                if (calcTranslate) {
                  for (let ii = _vfOffset$4, il = _vfOffset$4 + segVFCount; ii < il; ii += STRIDE_FLOAT) {
                    vbuf[ii] += _m12$1;
                    vbuf[ii + 1] += _m13$1;
                  }
                } else if (needBatch) {
                  for (let ii = _vfOffset$4, il = _vfOffset$4 + segVFCount; ii < il; ii += STRIDE_FLOAT) {
                    _x$2 = vbuf[ii];
                    _y$2 = vbuf[ii + 1];
                    vbuf[ii] = _x$2 * _m00$1 + _y$2 * _m04$1 + _m12$1;
                    vbuf[ii + 1] = _x$2 * _m01$1 + _y$2 * _m05$1 + _m13$1;
                  }
                }

                _buffer$1.renderData.advance(_vertexCount$1, _indexCount$2);

                if (!(_handleVal$1 & NEED_COLOR)) continue;
                let frameColorOffset = frameVFOffset - segVFCount;

                for (let ii = _vfOffset$4 + 5, il = _vfOffset$4 + 4 + segVFCount; ii < il; ii += STRIDE_FLOAT, frameColorOffset += STRIDE_FLOAT) {
                  if (frameColorOffset >= maxVFOffset) {
                    nowColor = colors[colorOffset++];

                    _handleColor$1(nowColor, 1.0);

                    maxVFOffset = nowColor.vfOffset;
                  }

                  vbuf.set(_c, ii);
                }
              }
            }

            function updateComponentRenderData$1(comp, batcher) {
              const armature = comp._armature;
              if (!armature) return;
              comp.markForUpdateRenderData();
              comp.destroyRenderData();
              _mustFlush$1 = true;
              _premultipliedAlpha$1 = comp.premultipliedAlpha;
              _node$1 = comp.node;
              _buffer$1 = comp.requestMeshRenderData();
              _comp$2 = comp;
              _handleVal$1 = 0;
              const nodeColor = comp.color;
              _nodeR$1 = nodeColor.r / 255;
              _nodeG$1 = nodeColor.g / 255;
              _nodeB$1 = nodeColor.b / 255;
              _nodeA$1 = nodeColor.a / 255;

              if (nodeColor._val !== 0xffffffff) {
                _handleVal$1 |= NEED_COLOR;
              }

              let worldMat;

              if (_comp$2._enableBatch) {
                worldMat = _node$1.worldMatrix;
                _mustFlush$1 = false;
                _handleVal$1 |= NEED_BATCH;
              }

              if (comp.isAnimationCached()) {
                cacheTraverse$1(comp._curFrame, worldMat);
              } else {
                realTimeTraverse$1(armature, worldMat, 1.0);
                const graphics = comp._debugDraw;

                if (comp.debugBones && graphics) {
                  graphics.clear();
                  graphics.lineWidth = 5;
                  graphics.strokeColor = _boneColor$1;
                  graphics.fillColor = _slotColor$1;
                  const bones = armature.getBones();

                  for (let i = 0, l = bones.length; i < l; i++) {
                    const bone = bones[i];
                    const boneLength = Math.max(bone.boneData.length, 5);
                    const startX = bone.globalTransformMatrix.tx;
                    const startY = bone.globalTransformMatrix.ty;
                    const endX = startX + bone.globalTransformMatrix.a * boneLength;
                    const endY = startY + bone.globalTransformMatrix.b * boneLength;
                    graphics.moveTo(startX, startY);
                    graphics.lineTo(endX, endY);
                    graphics.stroke();
                    graphics.circle(startX, startY, Math.PI * 2);
                    graphics.fill();

                    if (i === 0) {
                      graphics.fillColor = _originColor$1;
                    }
                  }
                }
              }

              comp.attachUtil._syncAttachedNode();

              _node$1 = undefined;
              _buffer$1 = undefined;
              _comp$2 = undefined;
            }

            legacyCC.internal.DragonBonesAssembler = simple$3;

            const simpleDragonBoneAssembler = {
              getAssembler() {
                return simple$3;
              }

            };
            ArmatureDisplay.Assembler = simpleDragonBoneAssembler;

            let ExtensionType;

            (function (ExtensionType) {
              ExtensionType[ExtensionType["FFD"] = 0] = "FFD";
              ExtensionType[ExtensionType["AdjustColor"] = 10] = "AdjustColor";
              ExtensionType[ExtensionType["BevelFilter"] = 11] = "BevelFilter";
              ExtensionType[ExtensionType["BlurFilter"] = 12] = "BlurFilter";
              ExtensionType[ExtensionType["DropShadowFilter"] = 13] = "DropShadowFilter";
              ExtensionType[ExtensionType["GlowFilter"] = 14] = "GlowFilter";
              ExtensionType[ExtensionType["GradientBevelFilter"] = 15] = "GradientBevelFilter";
              ExtensionType[ExtensionType["GradientGlowFilter"] = 16] = "GradientGlowFilter";
            })(ExtensionType || (ExtensionType = {}));

            let EventType$8;

            (function (EventType) {
              EventType[EventType["Frame"] = 0] = "Frame";
              EventType[EventType["Sound"] = 1] = "Sound";
            })(EventType$8 || (EventType$8 = {}));

            let AnimationFadeOutMode;

            (function (AnimationFadeOutMode) {
              AnimationFadeOutMode[AnimationFadeOutMode["None"] = 0] = "None";
              AnimationFadeOutMode[AnimationFadeOutMode["SameLayer"] = 1] = "SameLayer";
              AnimationFadeOutMode[AnimationFadeOutMode["SameGroup"] = 2] = "SameGroup";
              AnimationFadeOutMode[AnimationFadeOutMode["SameLayerAndGroup"] = 3] = "SameLayerAndGroup";
              AnimationFadeOutMode[AnimationFadeOutMode["All"] = 4] = "All";
            })(AnimationFadeOutMode || (AnimationFadeOutMode = {}));
            const dragonBones$1 = window.dragonBones;
            const Slot$1 = dragonBones$1.Slot;
            const Matrix$1 = dragonBones$1.Matrix;
            const BaseObject$1 = dragonBones$1.BaseObject;
            const BoundingBoxData$1 = dragonBones$1.BoundingBoxData;
            const PolygonBoundingBoxData$1 = dragonBones$1.PolygonBoundingBoxData;
            const Transform$1 = dragonBones$1.Transform;
            const Animation$2 = dragonBones$1.Animation;
            const TextureData$1 = dragonBones$1.TextureData;
            const CCTextureData$1 = dragonBones$1.CCTextureData;
            const BaseFactory$1 = dragonBones$1.BaseFactory;
            const CCFactory$1 = dragonBones$1.CCFactory;
            const WorldClock$1 = dragonBones$1.WorldClock;
            const TextureAtlasData$1 = dragonBones$1.TextureAtlasData;
            const CCArmatureDisplay$1 = dragonBones$1.CCArmatureDisplay;
            const AnimationState$1 = dragonBones$1.AnimationState;
            const BoneData$1 = dragonBones$1.BoneData;
            const EllipseBoundingBoxData$1 = dragonBones$1.EllipseBoundingBoxData;
            const ArmatureData$1 = dragonBones$1.ArmatureData;
            const CCTextureAtlasData$1 = dragonBones$1.CCTextureAtlasData;
            const TransformObject$1 = dragonBones$1.TransformObject;
            const CCSlot$1 = dragonBones$1.CCSlot;
            const Armature$1 = dragonBones$1.Armature;
            const Bone$1 = dragonBones$1.Bone;
            const RectangleBoundingBoxData$1 = dragonBones$1.RectangleBoundingBoxData;
            const ArmatureCacheMgr = dragonBones$1.ArmatureCacheMgr;
            const SkinData$1 = dragonBones$1.SkinData;
            const EventObject$1 = dragonBones$1.EventObject;
            const SlotData$1 = dragonBones$1.SlotData;
            const DragonBonesData$1 = dragonBones$1.DragonBonesData;
            const AnimationData$1 = dragonBones$1.AnimationData;
            const CCArmatureCacheDisplay = dragonBones$1.CCArmatureCacheDisplay;

            var index$3 = /*#__PURE__*/Object.freeze({
                __proto__: null,
                DragonBonesAsset: DragonBonesAsset,
                DragonBonesAtlasAsset: DragonBonesAtlasAsset,
                timeScale: timeScale$1,
                get AnimationCacheMode () { return AnimationCacheMode$1; },
                DragonBoneSocket: DragonBoneSocket,
                ArmatureDisplay: ArmatureDisplay,
                AttachUtil: AttachUtil$1,
                simpleDragonBoneAssembler: simpleDragonBoneAssembler,
                get ExtensionType () { return ExtensionType; },
                get EventType () { return EventType$8; },
                get AnimationFadeOutMode () { return AnimationFadeOutMode; },
                Slot: Slot$1,
                Matrix: Matrix$1,
                BaseObject: BaseObject$1,
                BoundingBoxData: BoundingBoxData$1,
                PolygonBoundingBoxData: PolygonBoundingBoxData$1,
                Transform: Transform$1,
                Animation: Animation$2,
                TextureData: TextureData$1,
                CCTextureData: CCTextureData$1,
                BaseFactory: BaseFactory$1,
                CCFactory: CCFactory$1,
                WorldClock: WorldClock$1,
                TextureAtlasData: TextureAtlasData$1,
                CCArmatureDisplay: CCArmatureDisplay$1,
                AnimationState: AnimationState$1,
                BoneData: BoneData$1,
                EllipseBoundingBoxData: EllipseBoundingBoxData$1,
                ArmatureData: ArmatureData$1,
                CCTextureAtlasData: CCTextureAtlasData$1,
                TransformObject: TransformObject$1,
                CCSlot: CCSlot$1,
                Armature: Armature$1,
                Bone: Bone$1,
                RectangleBoundingBoxData: RectangleBoundingBoxData$1,
                ArmatureCacheMgr: ArmatureCacheMgr,
                SkinData: SkinData$1,
                EventObject: EventObject$1,
                SlotData: SlotData$1,
                DragonBonesData: DragonBonesData$1,
                AnimationData: AnimationData$1,
                CCArmatureCacheDisplay: CCArmatureCacheDisplay
            });
            exports('dragonBones', index$3);

            console.log('pptest importing cc 4');
        }
    };
});
